{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/Staticfile","path":"Staticfile","modified":1,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/love.js","path":"js/src/love.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1644304181224},{"_id":"source/CNAME","hash":"eafaa21db3eefb48b97d539754dfa68fd4e9492d","modified":1644304181224},{"_id":"source/.DS_Store","hash":"6988bd4264d7bc1f2212dd2425b96dae251e58ba","modified":1688980986854},{"_id":"source/robots.txt","hash":"1f80141df2980941e75ed9708494d9c906d29839","modified":1644304181229},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1556422112000},{"_id":"themes/next/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1648553864355},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1556422112000},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1556422112000},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1556422112000},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1556422112000},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1556422112000},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1556422112000},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1556422112000},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1556422112000},{"_id":"themes/next/README.md","hash":"efcdc4b0ca791c3fc64afa28c8721e137f2d11ea","modified":1556422112000},{"_id":"themes/next/README.cn.md","hash":"b878b73f3fcdef47849453c94420871903d487b3","modified":1556422112000},{"_id":"themes/next/_layout.swig","hash":"417bf8ba467721f02790566ddbf45fffcc32fbb2","modified":1545624198000},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1556422112000},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1556422112000},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1556422112000},{"_id":"themes/next/_config.yml","hash":"16cee0b55e4750fab01798d86ee986a6c682c765","modified":1644243378000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1659521533833},{"_id":"source/_posts/AQS.md","hash":"4b454f7ce41f299d59aaea76267cd04d829227c8","modified":1644304181225},{"_id":"source/_posts/CAS.md","hash":"e20ec1f08229de1b7cabeda5778ad91bdb8c3deb","modified":1644304181225},{"_id":"source/_posts/Fast-fail与Fast-safe.md","hash":"bd1b0749bcc664b382715aac41fe7f0646175d0b","modified":1644304181225},{"_id":"source/_posts/HashMap.md","hash":"893e4faf2f10dfa0dc684058737af847cc465767","modified":1644304181225},{"_id":"source/_posts/Hibernate.md","hash":"77490d450477cbf37d7b36a4b76bb37a4a5f71c7","modified":1644304181225},{"_id":"source/_posts/LRU.md","hash":"d87cea407fab56b8f75266332a85fde624d6e918","modified":1644304181226},{"_id":"source/_posts/ThreadLocal.md","hash":"24ae5544234003cf184bdff74544ab92de03859e","modified":1644304181226},{"_id":"source/_posts/RateLimiter.md","hash":"6082430aacb93b59b281ddc887800f78165d9173","modified":1644304181226},{"_id":"source/_posts/css.md","hash":"5891c9b6a5ed33b6cb8fc60be6890a814d0c4716","modified":1644304181226},{"_id":"source/_posts/javaSE上.md","hash":"06d0ed2403572c8aa0ac7b674a6cf87f22c97de7","modified":1644304181226},{"_id":"source/_posts/implementing-bitcask-a-log-structured-hash-table.md","hash":"f88b9b7523bb60be9334490c888d648bb6b53e2d","modified":1670495072333},{"_id":"source/_posts/DDD.md","hash":"adb32e012054432983c8f02453dfe664ca3a3318","modified":1657196588897},{"_id":"source/_posts/javaSE下.md","hash":"d55e37100980c8317318e77beb2b50bb2c621700","modified":1644304181226},{"_id":"source/_posts/javaweb.md","hash":"ad14ccd9c83fefe5d932c3b9046642efb5182348","modified":1644304181227},{"_id":"source/_posts/Raft协议解读与实践.md","hash":"eb79e9aadf2d8b9649530ad6bb7ff06ddb78ef77","modified":1662021915160},{"_id":"source/_posts/synchronized与volatile.md","hash":"408e94ff09d9923aa1497eeb821a139b3c32a96b","modified":1644304181227},{"_id":"source/_posts/《java web开发与应用》笔记.md","hash":"6babe779353d7bdc2b9a5dfeba474730566b18ac","modified":1644304181227},{"_id":"source/_posts/一刷剑指offer.md","hash":"b1c7c420b320992e94d2392f0161d5967c34a6f6","modified":1644304181228},{"_id":"source/_posts/verifying-distributed-systems-isabelle.md","hash":"0166c40c5087b9f19f5f3b74cd4013342d57e732","modified":1670604935379},{"_id":"source/_posts/redis.md","hash":"6088dc6f0a667238a05676cba83de1792c01a02f","modified":1657289479295},{"_id":"source/_posts/代理模式.md","hash":"3d0ff8fdfc59bb0d897fad423427dfdcc81d41af","modified":1644304181228},{"_id":"source/_posts/retries.md","hash":"4269e8903b0ef42e98c8916e8102fc90982b1392","modified":1670495184585},{"_id":"source/_posts/单例模式.md","hash":"2309de973cb3e00d66df2d8e5edb257fca75e12d","modified":1646035322477},{"_id":"source/_posts/布隆过滤器.md","hash":"0fbed9a87be181d618a18668d64326697067a537","modified":1644304181228},{"_id":"source/_posts/循环依赖.md","hash":"e6163a55474aaace9fae78f8ecec19990475dec2","modified":1644304181228},{"_id":"source/_posts/手写http服务器.md","hash":"16ed93f544d13472f9a3f3c8691e2ac0fbe50867","modified":1644304181228},{"_id":"source/_posts/我的第一个博文.md","hash":"33c1c52de1be9a6be7b614194188a95e1d23037f","modified":1644304181228},{"_id":"source/_posts/数据库系统工程师（软考）.md","hash":"48c8f8ad5f1e201f7b0c85d2f318e63f49972722","modified":1644304181229},{"_id":"source/_posts/实习笔记——开发技巧.md","hash":"6692c9a7a1abfdcd25c9f355415a69df11b60aa6","modified":1657195271254},{"_id":"source/_posts/线程池详解.md","hash":"177ceec1f9f2d00829f5bb9fcab1dfa86e281b59","modified":1644304181229},{"_id":"source/_posts/自实现线程池（下）.md","hash":"0c9ab974e66bac022b36ab4b705ada005b5c0f47","modified":1644304181229},{"_id":"source/_posts/自英-redis的zset可以做哪些有趣的事？.md","hash":"7776bc2b1543a25217aa83707d2d43ac865e7947","modified":1658765929725},{"_id":"source/_posts/我的编程之路1.md","hash":"0c8690a55a581df6fa904c597d78e5fcff598f25","modified":1661851891807},{"_id":"source/_posts/数据结构读书笔记.md","hash":"22d9942320546ebc1bec30a83ec4d81055e9e6a0","modified":1648886393724},{"_id":"source/_posts/英文-redis的zset可以做哪些有趣的事？.md","hash":"7776bc2b1543a25217aa83707d2d43ac865e7947","modified":1691582087731},{"_id":"source/_posts/逃逸分析.md","hash":"8165b6a89dd22b8f4992887b982b30dd66ef344f","modified":1644304181229},{"_id":"source/about/index.md","hash":"f4bd276461845f1407082745dfed5f5d56040776","modified":1657196349369},{"_id":"source/categories/index.md","hash":"114faa3da1baa72630f9e75ee72e59a501dfdbfe","modified":1644304181229},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1556422112000},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1556422112000},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1556422112000},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1556422112000},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1556422112000},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1556422112000},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1556422112000},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1556422112000},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1556422112000},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1556422112000},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1556422112000},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1556422112000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1556422112000},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1556422112000},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1556422112000},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1556422112000},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1556422112000},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1556422112000},{"_id":"themes/next/layout/_layout.swig","hash":"588ad96ad379cfa5ea90374ceded7dd7bb7995c7","modified":1556608158000},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1545624198000},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1545624198000},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1545624198000},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1545624198000},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1545624198000},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1545624198000},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1545624198000},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1556422114000},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1556422114000},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1556422114000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545624198000},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1556422112000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1556422112000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1556422112000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1556422112000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1556422112000},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1556422112000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1556422112000},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1556422112000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1556422112000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1648554761085},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1545624198000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1545624198000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1545624198000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1545624198000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1545624198000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1545624198000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1545624198000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1545624198000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1545624198000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1545624198000},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1545624198000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1545624198000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1545624198000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1545624198000},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1545624198000},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1545624198000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1545624198000},{"_id":"themes/next/layout/_custom/header.swig","hash":"f3d163510e8bf8084a1f68c88aaf9040e865a10e","modified":1545624198000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1545624198000},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1545624198000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1545624198000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1545624198000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1545624198000},{"_id":"themes/next/layout/_macro/post.swig","hash":"e0c1cc31da4584caa5538f265fdc91ac8ceae7d8","modified":1545624198000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"81bcdb9fe4df90e789a5c4759df5a94ff4d1fc9a","modified":1556437756000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1545624198000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1545624198000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"a063a349ce21c10e487e676b71b70d809814fb16","modified":1545624198000},{"_id":"themes/next/layout/_partials/head.swig","hash":"dfa630c8a0392db7c2eb84c60d10c835b59be3d3","modified":1545624198000},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1545624198000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1545624198000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1545624198000},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1545624198000},{"_id":"themes/next/layout/_scripts/baidu_push.swig","hash":"13cedacb4de07500bef2e40d7048c0b24c9c07b9","modified":1572411164000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1545624198000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1545624198000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1545624198000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1545624198000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1545624198000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1545624198000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1545624198000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1545624198000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1545624198000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1545624198000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545624198000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545624198000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545624198000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545624198000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545624198000},{"_id":"themes/next/source/images/avatar.jpg","hash":"6dae7823dc2a664322d276e0d047eff7dfaadc4d","modified":1556426570000},{"_id":"themes/next/source/images/favicon.ico","hash":"f9510cbe989871c2b763737b6a0b4586d62cd588","modified":1545624198000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545624198000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545624198000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1545624198000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1545624198000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1545624198000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1545624198000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1545624198000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1545624198000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1545624198000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1545624198000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1545624198000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1545624198000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1545624198000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1545624198000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1545624198000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1545624198000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1545624198000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1545624198000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1545624198000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1545624198000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1545624198000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1545624198000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1545624198000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1545624198000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1545624198000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1545624198000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1545624198000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1545624198000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1545624198000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1545624198000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1545624198000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1545624198000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"c51fd5cbf5ee42952b972ea523555bca995e05aa","modified":1648553926348},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1545624198000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1545624198000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1545624198000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1545624198000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1545624198000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1545624198000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1545624198000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1545624198000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1545624198000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1545624198000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1545624198000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1545624198000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1545624198000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1545624198000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1545624198000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1545624198000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1545624198000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1545624198000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1545624198000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1545624198000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1545624198000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1545624198000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1545624198000},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1545624198000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1545624198000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1545624198000},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1545624198000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1545624198000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1545624198000},{"_id":"themes/next/source/js/src/love.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1545624198000},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1545624198000},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1545624198000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1545624198000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1545624198000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1545624198000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1545624198000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1545624198000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1545624198000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1545624198000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1545624198000},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1545624198000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1545624198000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1545624198000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1545624198000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1545624198000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1545624198000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1545624198000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1545624198000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1545624198000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1545624198000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1545624198000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1545624198000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1545624198000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1545624198000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1545624198000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1545624198000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1545624198000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1545624198000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1545624198000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1545624198000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1545624198000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1545624198000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1545624198000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1545624198000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1545624198000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1545624198000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1545624198000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fb161e87f3942f35edf7d194566f9517dc854aa1","modified":1561724298000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1545624198000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1545624198000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1545624198000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1545624198000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1545624198000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1545624198000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1545624198000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1545624198000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1545624198000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1545624198000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1545624198000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1545624198000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1545624198000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1545624198000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"1a56727edb931dc51958b1b9925518ccf7751a23","modified":1648553926351},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1545624198000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1545624198000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1545624198000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1545624198000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1545624198000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1545624198000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1545624198000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1545624198000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1545624198000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1545624198000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1545624198000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1545624198000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1545624198000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1545624198000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1545624198000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1545624198000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1545624198000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1545624198000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1545624198000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1545624198000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1545624198000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1545624198000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1545624198000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1545624198000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"64fcb902601b18cd75197e920e0de3267bcd643e","modified":1556426686000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"bbcd2cf17869e1b4dcdd3162e45992b2aec0f20b","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1545624198000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1545624198000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1545624198000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1545624198000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1545624198000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1545624198000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1545624198000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1545624198000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1545624198000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1545624198000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1545624198000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1545624198000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1545624198000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1545624198000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1545624198000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1545624198000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1545624198000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1545624198000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1545624198000},{"_id":"public/baidusitemap.xml","hash":"0090ffbe40dd97e348e39bb471abeba2f590b463","modified":1691583394902},{"_id":"public/search.xml","hash":"c6f44bc2ef9f5676d80fd5eea8bfaa4048b24901","modified":1691583395031},{"_id":"public/sitemap.xml","hash":"7b787d1d7ea6e0fa7ee35745c33e71aed5980acf","modified":1691583395032},{"_id":"public/about/index.html","hash":"29e35bab0c06a2c57599cbaa891b79ca4564ce60","modified":1691583395119},{"_id":"public/categories/index.html","hash":"2b220a7ab33764fe671050f00d3d731ab8bc83a0","modified":1691583395119},{"_id":"public/2022/12/01/implementing-bitcask-a-log-structured-hash-table/index.html","hash":"94d9833ee2f9c5cb969c8dc6ee1ef467bde6c83d","modified":1691583395119},{"_id":"public/2022/11/15/verifying-distributed-systems-isabelle/index.html","hash":"84141dd0986d101e74c0666b4c0ab1373482ed69","modified":1691583395120},{"_id":"public/2022/10/01/retries/index.html","hash":"81ff8da96aeeaf04785690cc342be96aaf1e9054","modified":1691583395120},{"_id":"public/2022/07/26/自英-redis的zset可以做哪些有趣的事？/index.html","hash":"ee39451e569b5ad6e64ecaaa4076e37c55ca913c","modified":1691583395120},{"_id":"public/2022/07/26/英文-redis的zset可以做哪些有趣的事？/index.html","hash":"9fb42dd5e6a2b9e73108fe6ccf5f0ace9879fd1c","modified":1691583395120},{"_id":"public/2022/07/07/Raft协议解读与实践/index.html","hash":"cb592daeb4d0dbd5836e9d707cb93302ebcde04f","modified":1691583395120},{"_id":"public/2021/07/02/DDD/index.html","hash":"a98fd5173700a2e7f5067249e62359e6e337f8cc","modified":1691583395120},{"_id":"public/2020/06/04/我的编程之路1/index.html","hash":"a44ff64851dc92afb9640c0de6acca0a0ec9ea81","modified":1691583395120},{"_id":"public/2020/04/17/RateLimiter/index.html","hash":"d4e1ce0dbb51034a041b41df211af646dda7cff3","modified":1691583395120},{"_id":"public/2019/11/25/实习笔记——开发技巧/index.html","hash":"d82b3de77f0859c59bcf7a974372fc9058fbbade","modified":1691583395120},{"_id":"public/2019/11/01/redis/index.html","hash":"87d7a8873c85f2fa7dee2fd8ea465d57e233c6ad","modified":1691583395120},{"_id":"public/2019/10/09/循环依赖/index.html","hash":"0df1dbb0d0ddb50c05d061c57153631d155264a3","modified":1691583395120},{"_id":"public/2019/10/01/synchronized与volatile/index.html","hash":"e6367e25b49af713dfd37c82b4d99fb647743fc7","modified":1691583395120},{"_id":"public/2019/08/25/CAS/index.html","hash":"1e85bc83711e8272850034b15ee3fd697e02cabd","modified":1691583395120},{"_id":"public/2019/08/14/AQS/index.html","hash":"dda473141101ad6afedac9d7dced9cc0230419ae","modified":1691583395120},{"_id":"public/2019/08/12/逃逸分析/index.html","hash":"4b09667563e2b27089ab1ce2314eb0e85ce1bdef","modified":1691583395120},{"_id":"public/2019/08/10/ThreadLocal/index.html","hash":"38aacbfb744515ebc89c4808ac6f99659347c307","modified":1691583395120},{"_id":"public/2019/08/01/Fast-fail与Fast-safe/index.html","hash":"d17040fff8102b554717ce03d169a8ff95ba4b0b","modified":1691583395120},{"_id":"public/2019/07/25/LRU/index.html","hash":"6ab4aaa45f6e21ab13b3d2d8b2ec33e048c64e94","modified":1691583395120},{"_id":"public/2019/07/23/HashMap/index.html","hash":"58fd8919cd0a05b5bc78693ae803a5872a2cdab3","modified":1691583395120},{"_id":"public/2019/07/01/自实现线程池（下）/index.html","hash":"b98f01981c9abe91112316b1d6020422e7997b7a","modified":1691583395120},{"_id":"public/2019/06/26/一刷剑指offer/index.html","hash":"08258fc0e0c5f773e26f4539465f1f0bd4bcad8d","modified":1691583395120},{"_id":"public/2019/05/29/手写http服务器/index.html","hash":"58f280d5834195c15fbcbb3ef5adbbd659eb6bd2","modified":1691583395120},{"_id":"public/2019/05/26/线程池详解/index.html","hash":"133d82760a9a5d4299a8fcb68ae6131e5d1ca67f","modified":1691583395120},{"_id":"public/2019/04/16/布隆过滤器/index.html","hash":"6f02f72b8bdabb4cf0d313e393cdc09e22604170","modified":1691583395120},{"_id":"public/2019/01/21/单例模式/index.html","hash":"8cc8547a9b4f90b356954b5be2a579eb6c4f8bc8","modified":1691583395120},{"_id":"public/2019/01/20/代理模式/index.html","hash":"c20cdad0e1a2b4da3589c7a410848b3feaf64e81","modified":1691583395120},{"_id":"public/2018/12/17/《java web开发与应用》笔记/index.html","hash":"70201c29b078c60b06ea9236055db77f2ed2640b","modified":1691583395120},{"_id":"public/2018/10/10/javaSE下/index.html","hash":"1b1c3fd0a514e807e8fd62b934fa574a1544bf47","modified":1691583395121},{"_id":"public/2018/10/06/javaSE上/index.html","hash":"ade6d5ccf400c14dbca66a0d8d34c5e7309ce9ec","modified":1691583395121},{"_id":"public/2018/10/04/javaweb/index.html","hash":"0a8145d92d351a6ef50800ca03684a54456bd240","modified":1691583395121},{"_id":"public/2018/09/27/Hibernate/index.html","hash":"caec119893affe2fd5ebc657f700939ec69424d3","modified":1691583395121},{"_id":"public/2018/09/18/css/index.html","hash":"d818fd95ec47c579afc24b5e3e87a1ae913fc890","modified":1691583395121},{"_id":"public/2018/09/08/数据库系统工程师（软考）/index.html","hash":"4c8926792dcb0a6936f937056d40e770fc212bca","modified":1691583395121},{"_id":"public/2018/09/08/数据结构读书笔记/index.html","hash":"f5e0cee121609e98d274dd8cabcd8d82b8969bcc","modified":1691583395121},{"_id":"public/2018/09/06/我的第一个博文/index.html","hash":"2708003c839b74f74a8b4511ab3afa0ddeabdd18","modified":1691583395121},{"_id":"public/categories/并发/index.html","hash":"d8f3a6fe766f02f155c913ce0dcd479ac1449650","modified":1691583395121},{"_id":"public/categories/java/index.html","hash":"16fde20e37874c8a3b4d5a769f6660c60ecadf96","modified":1691583395121},{"_id":"public/categories/算法/index.html","hash":"d6a9de4b646e3218d0bb7b2028c10419cc2d339a","modified":1691583395121},{"_id":"public/categories/前端/index.html","hash":"bb9f94ab0068ff068639a5feb7ab471e2a8371da","modified":1691583395121},{"_id":"public/categories/翻译/index.html","hash":"9159cf3531837c8dca3b0a186502f235999f4fea","modified":1691583395121},{"_id":"public/categories/设计模式/index.html","hash":"d9cb627562c17c2c5a81b8b296ba1792aeaf9cd4","modified":1691583395121},{"_id":"public/categories/分布式/index.html","hash":"eb6189b891144ce38c43d658097276cb4ff84e5b","modified":1691583395121},{"_id":"public/categories/读书笔记/index.html","hash":"57681b39d9320631d930b234ee8b6b62d422d2fa","modified":1691583395121},{"_id":"public/categories/生活/index.html","hash":"af67a83ff3f46d1d84bee6f05249fef460de9db5","modified":1691583395122},{"_id":"public/categories/秋招/index.html","hash":"68a7be3cac51491fa0498c0f1fd687dbf0e0bb27","modified":1691583395122},{"_id":"public/categories/spring/index.html","hash":"8a8c79728c17d550da34189892b4ce5bd15685bf","modified":1691583395122},{"_id":"public/categories/数据库/index.html","hash":"315e282a433d2ea5ffec7f113305826e5920d60d","modified":1691583395122},{"_id":"public/categories/mytomcat/index.html","hash":"3783581dfefe3d579902e398dde8731436e860f6","modified":1691583395122},{"_id":"public/categories/工程技巧/index.html","hash":"bd37fd9a69e6277e15538faf3d43710a33ea8855","modified":1691583395122},{"_id":"public/categories/redis/index.html","hash":"f32b40d24b09cb44dcd29aee7a94a7e7c124374c","modified":1691583395122},{"_id":"public/categories/jvm/index.html","hash":"08cac75e892f60edbf478c404c2c2bcda872abdc","modified":1691583395122},{"_id":"public/index.html","hash":"0c03682ed3cb1c2e1ca2fb00b89a111b90026b0f","modified":1691583395122},{"_id":"public/page/2/index.html","hash":"8e3ab8f84757a2534be439d368671d7a3124f98a","modified":1691583395122},{"_id":"public/page/3/index.html","hash":"185619773e0662158650dad99d890a4f422953c6","modified":1691583395123},{"_id":"public/page/4/index.html","hash":"5595838d0776fc4fe06eadc392a2aff7ccec5486","modified":1691583395123},{"_id":"public/archives/index.html","hash":"175a9560e560af68194dbc520a85a125ce42ebe7","modified":1691583395123},{"_id":"public/archives/page/2/index.html","hash":"12c9ba6857553222fc5d9a44af8c484a75a4f1e3","modified":1691583395123},{"_id":"public/archives/page/3/index.html","hash":"7248657a11c053578bd8e055a0e2015789831865","modified":1691583395123},{"_id":"public/archives/page/4/index.html","hash":"0e181b3f148fc47ea95d9ec499d9192bf267d6b2","modified":1691583395123},{"_id":"public/archives/2018/index.html","hash":"c33d205a7a886b803d294df41001c450b0a3daf5","modified":1691583395123},{"_id":"public/archives/2018/09/index.html","hash":"d44ed7e65cd8cb95523753956e6c6ddf6a0479cf","modified":1691583395123},{"_id":"public/archives/2018/10/index.html","hash":"e1d774e4beabf283fb7549315d71272f2909f372","modified":1691583395123},{"_id":"public/archives/2018/12/index.html","hash":"77338ea9e7a2788e8641384874c41f7c414106a3","modified":1691583395123},{"_id":"public/archives/2019/index.html","hash":"ce75e7e7c57cb9d4d46cad2bb4ae503a15d20ce1","modified":1691583395123},{"_id":"public/archives/2019/page/2/index.html","hash":"63077cd81decf8853b8d22c26b498be45b347f0c","modified":1691583395123},{"_id":"public/archives/2019/01/index.html","hash":"7c42973062dc7c30e24830c2d09e42be274fc1ea","modified":1691583395123},{"_id":"public/archives/2019/04/index.html","hash":"f477b945fac841caaf025e8cd47b77824588477a","modified":1691583395123},{"_id":"public/archives/2019/05/index.html","hash":"a94fdcef634b355861f76dde28fc257812f707ab","modified":1691583395123},{"_id":"public/archives/2019/06/index.html","hash":"3d49364e99633563241912de0c540eb8e01dffa5","modified":1691583395123},{"_id":"public/archives/2019/07/index.html","hash":"be063d9d0a56f817c678ca5893bbe576db549ade","modified":1691583395124},{"_id":"public/archives/2019/08/index.html","hash":"5a7de83f125296081541dc014aeed59b34aa2725","modified":1691583395124},{"_id":"public/archives/2019/10/index.html","hash":"43e3caceeafd46f2d24efb63292c7c4f9094cb36","modified":1691583395124},{"_id":"public/archives/2019/11/index.html","hash":"e471dc440488d73f267af74947bc0dc0dd07977d","modified":1691583395124},{"_id":"public/archives/2020/index.html","hash":"883c64fb8f4010549660b2a53db664f4ae83aefb","modified":1691583395124},{"_id":"public/archives/2020/04/index.html","hash":"f6c82b2ce218360e43ad930af1c0ae7328b3f130","modified":1691583395124},{"_id":"public/archives/2020/06/index.html","hash":"acd28d67d0f01d8ee69aa2a5df219801690b4cb5","modified":1691583395124},{"_id":"public/archives/2021/index.html","hash":"32011c7eef0ee21bd0123780ec7ff09876a7b8ed","modified":1691583395124},{"_id":"public/archives/2021/07/index.html","hash":"0a4f20ad138cf419d985a8aa1a0c39ea6f113209","modified":1691583395124},{"_id":"public/archives/2022/index.html","hash":"6ce22829997dd06177d40ae54cff3401f9543c70","modified":1691583395124},{"_id":"public/archives/2022/07/index.html","hash":"35b7cfa3d448f18626efae7b0400640d49d33225","modified":1691583395124},{"_id":"public/archives/2022/10/index.html","hash":"84835e9a705c666e16ddc75f84cb71208001e7cd","modified":1691583395124},{"_id":"public/archives/2022/11/index.html","hash":"ee7336b4832ea2bfd0d561025447dbfaf4700cd0","modified":1691583395124},{"_id":"public/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1691583395124},{"_id":"public/archives/2022/12/index.html","hash":"b1273d84ef4f738569c78222b9194a1027ae4802","modified":1691583395130},{"_id":"public/CNAME","hash":"eafaa21db3eefb48b97d539754dfa68fd4e9492d","modified":1691583395130},{"_id":"public/robots.txt","hash":"1f80141df2980941e75ed9708494d9c906d29839","modified":1691583395130},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1691583395130},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1691583395130},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1691583395130},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1691583395130},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1691583395130},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1691583395130},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1691583395130},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1691583395130},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1691583395130},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1691583395130},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1691583395130},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1691583395130},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1691583395130},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1691583395130},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1691583395130},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1691583395130},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1691583395130},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1691583395130},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1691583395130},{"_id":"public/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1691583395130},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1691583395130},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1691583395130},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1691583395130},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1691583395130},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1691583395130},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1691583395130},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1691583395130},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1691583395130},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1691583395130},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1691583395131},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1691583395131},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1691583395131},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1691583395131},{"_id":"public/live2dw/assets/hijiki.model.json","hash":"feff43bf7498d213982c3736c2c029664e4bcbd2","modified":1691583395131},{"_id":"public/live2dw/assets/hijiki.pose.json","hash":"81438bf69b32c7c11e311b4fe043730cdc7b7ec2","modified":1691583395131},{"_id":"public/live2dw/assets/mtn/02.mtn","hash":"7eafc52edc73b7cb80ae70d34b43c6ac778fa47b","modified":1691583395131},{"_id":"public/live2dw/assets/mtn/00_idle.mtn","hash":"b224c60e463b9f71ddbfc0c720e430496c175f4f","modified":1691583395131},{"_id":"public/live2dw/assets/mtn/01.mtn","hash":"fb550833ae22c9954c3e01df37ed29b2d61700f2","modified":1691583395131},{"_id":"public/live2dw/assets/mtn/04.mtn","hash":"c7a25d3c5d783639bae18db2f3cd284b819c3c85","modified":1691583395131},{"_id":"public/live2dw/assets/mtn/03.mtn","hash":"f900737c7a98441cbb2e05255427e6260e19ae68","modified":1691583395131},{"_id":"public/live2dw/assets/mtn/06.mtn","hash":"ad404bd852d276cdd3d054c953e23f90e4e45ae1","modified":1691583395131},{"_id":"public/live2dw/assets/mtn/07.mtn","hash":"b7f2e3a9fa4f3ffbb6e64a08f8d9f45ca1868ffb","modified":1691583395131},{"_id":"public/live2dw/assets/mtn/05.mtn","hash":"dd20ad24b5d1830a5d44b9bccb28f922eea5e0e5","modified":1691583395131},{"_id":"public/live2dw/assets/mtn/08.mtn","hash":"4411c7651ff65195b113d95e7d5ebef8a59a37d9","modified":1691583395131},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1691583395131},{"_id":"public/images/favicon.ico","hash":"f9510cbe989871c2b763737b6a0b4586d62cd588","modified":1691583395637},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1691583395643},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1691583395657},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1691583395657},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1691583395657},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1691583395657},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1691583395657},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1691583395657},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1691583395657},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1691583395657},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1691583395657},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1691583395657},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1691583395657},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1691583395657},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1691583395657},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1691583395657},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1691583395657},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1691583395657},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1691583395657},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1691583395657},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1691583395657},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1691583395657},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1691583395658},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1691583395658},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1691583395658},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1691583395658},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1691583395658},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1691583395658},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1691583395658},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1691583395658},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1691583395658},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1691583395658},{"_id":"public/js/src/love.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1691583395658},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1691583395658},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1691583395658},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1691583395658},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1691583395658},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1691583395658},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1691583395658},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1691583395658},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1691583395658},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1691583395658},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1691583395658},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1691583395658},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1691583395658},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1691583395658},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1691583395658},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1691583395658},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1691583395658},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1691583395658},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1691583395658},{"_id":"public/lib/jquery_lazyload/README.html","hash":"4f049ffa89c8eb5d072041733515a8cd6d33095f","modified":1691583395658},{"_id":"public/css/main.css","hash":"92c6ce9dc53132839f73967d6d26a2ff48f60fc2","modified":1691583395658},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1691583395658},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1691583395658},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1691583395658},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1691583395658},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1691583395658},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1691583395658},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1691583395658},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1691583395658},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1691583395658},{"_id":"public/lib/Han/dist/han.css","hash":"1a56727edb931dc51958b1b9925518ccf7751a23","modified":1691583395658},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1691583395659},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1691583395659},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1691583395659},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1691583395659},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1691583395659},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1691583395659},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1691583395659},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1691583395659},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1691583395659},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1691583395659},{"_id":"public/images/avatar.jpg","hash":"6dae7823dc2a664322d276e0d047eff7dfaadc4d","modified":1691583395659},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1691583395660},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1691583395660},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1691583395665},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1691583395665},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1691583395665},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1691583395667},{"_id":"public/live2dw/assets/moc/hijiki.2048/texture_00.png","hash":"66464e0d96439695b5542c5e2f5be60739c29999","modified":1691583395667},{"_id":"public/live2dw/assets/moc/hijiki.moc","hash":"44289e62545a7046e0f5231103a851750b78524e","modified":1691583395668},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1691583395985},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1691583395985}],"Category":[{"name":"并发","_id":"cll3p2qjr0002w9rpr0fhp1j3"},{"name":"java","_id":"cll3p2qjz0009w9rpy6th2hqf"},{"name":"算法","_id":"cll3p2qk8000ow9rpfmxl4xt4"},{"name":"前端","_id":"cll3p2qkd000tw9rpol9uuqtn"},{"name":"翻译","_id":"cll3p2qkh000yw9rp2t27v8fn"},{"name":"设计模式","_id":"cll3p2qkj0014w9rp8pjkqjty"},{"name":"分布式","_id":"cll3p2qkk0019w9rp8pfmd1dr"},{"name":"读书笔记","_id":"cll3p2qkl001ew9rpgjrzq8nv"},{"name":"生活","_id":"cll3p2qkm001jw9rpyfe5pd9g"},{"name":"秋招","_id":"cll3p2qkq001qw9rpl348pyss"},{"name":"spring","_id":"cll3p2qkr001vw9rpv10tbnbg"},{"name":"数据库","_id":"cll3p2qks001yw9rphhz79am3"},{"name":"mytomcat","_id":"cll3p2qks0021w9rphckzsyj8"},{"name":"工程技巧","_id":"cll3p2qkt0024w9rp1k516199"},{"name":"redis","_id":"cll3p2qkt0026w9rpc9iuxhe3"},{"name":"jvm","_id":"cll3p2qqc002hw9rpao3ca1lq"}],"Data":[],"Page":[{"title":"about","date":"2018-09-09T01:19:32.000Z","_content":"\n### 关于我\n20届毕业，现居杭州\n20年7月~至今，就职于蘑菇街\n服务端攻城狮\n典型的INTJ,无时不刻在思考\n\n\n\n### 联系我\n我的邮箱：wangxuanni98@qq.com\n\n\n\n\n\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-09-09 09:19:32\n---\n\n### 关于我\n20届毕业，现居杭州\n20年7月~至今，就职于蘑菇街\n服务端攻城狮\n典型的INTJ,无时不刻在思考\n\n\n\n### 联系我\n我的邮箱：wangxuanni98@qq.com\n\n\n\n\n\n\n","updated":"2022-07-07T12:19:09.369Z","path":"about/index.html","comments":1,"layout":"page","_id":"cll3p2qq2002aw9rpxsniz6a7","content":"<h3 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h3><p>20届毕业，现居杭州<br>20年7月~至今，就职于蘑菇街<br>服务端攻城狮<br>典型的INTJ,无时不刻在思考</p>\n<h3 id=\"联系我\"><a href=\"#联系我\" class=\"headerlink\" title=\"联系我\"></a>联系我</h3><p>我的邮箱：<a href=\"mailto:wangxuanni98@qq.com\" target=\"_blank\" rel=\"noopener\">wangxuanni98@qq.com</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h3><p>20届毕业，现居杭州<br>20年7月~至今，就职于蘑菇街<br>服务端攻城狮<br>典型的INTJ,无时不刻在思考</p>\n<h3 id=\"联系我\"><a href=\"#联系我\" class=\"headerlink\" title=\"联系我\"></a>联系我</h3><p>我的邮箱：<a href=\"mailto:wangxuanni98@qq.com\" target=\"_blank\" rel=\"noopener\">wangxuanni98@qq.com</a></p>\n"},{"title":"categories","date":"2018-09-09T00:49:21.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-09-09 08:49:21\ntype: \"categories\"\n---\n","updated":"2022-02-08T07:09:41.229Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cll3p2qq6002cw9rpx9scl5a9","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"AQS源码解析","date":"2019-08-14T12:09:50.000Z","description":"AQS源码解析","_content":"\n# AQS\n\nAbstractQueuedSynchronizer 类（简称 AQS）。它是一个**抽象类**，定义一套多线程访问共享资源的同步器框架，是抽象的队列式的同步器。\n\n同步器是基于**模板方法模式**的，同步器的子类可以通过继承同步器并实现它的抽象方法来管理同步状态，子类推荐被定义为自定义同步组件的**静态内部类**。\n\n[TOC]\n\n\n\n## 两个核心\n\n### volatile int state\n\n同步的核心其实就一个用volatile修饰的int成员变量，**锁的状态就是这个值的更改**。0就是当前没有线程获取锁，1是有。可重入锁可以多次加锁，即把state值加一，当然也需要同样次数的解锁，因为0才代表当前没有线程获取锁。\n\n```\n    private volatile int state;\n```\n\n\n\n### FIFO队列\n\n一个先进先出的双向链表。*这个队列的操作有一点复杂，我建议您可以先跳下去看重要方法后，再回头看Node类。*\n\n```java\nstatic final class Node {\n    static final Node SHARED = new Node();//标识等待节点处于共享模式\n    static final Node EXCLUSIVE = null;//标识等待节点处于独占模式\n\n    static final int CANCELLED =  1;//由于超时或中断，节点已被取消\n    static final int SIGNAL    = -1;//表示下一个节点是通过park堵塞的，需要通过unpark唤醒\n    static final int CONDITION = -2;//表示线程在等待条件变量（先获取锁，加入到条件等待队列，然后释放锁，等待条件变量满足条件；只有重新获取锁之后才能返回）\n    static final int PROPAGATE = -3;//表示后续结点会传播唤醒的操作，共享模式下起作用\n\n    //等待状态：对于condition节点，初始化为CONDITION；其它情况，默认为0，通过CAS操作原子更新\n    volatile int waitStatus;\n    //前节点\n    volatile Node prev;\n    //后节点\n    volatile Node next;\n    //线程对象\n    volatile Thread thread;\n    //对于Condtion表示下一个等待条件变量的节点；其它情况下用于区分共享模式和独占模式；\n    Node nextWaiter;\n\n    final boolean isShared() {\n        return nextWaiter == SHARED;//判断是否共享模式\n    }\n    //获取前节点，如果为null，抛出异常\n    final Node predecessor() throws NullPointerException {\n        Node p = prev;\n        if (p == null)\n            throw new NullPointerException();\n        else\n            return p;\n    }\n    \n    Node() {    // Used to establish initial head or SHARED marker\n    }\n    Node(Thread thread, Node mode) {     //addWaiter方法使用\n        this.nextWaiter = mode;\n        this.thread = thread;\n    }\n    Node(Thread thread, int waitStatus) { //Condition使用\n        this.waitStatus = waitStatus;\n        this.thread = thread;\n    }\n}\n```\n\n\n\n## 重要方法\n\nisHeldExclusively() 该线程是否正在独占资源。只有用到 condition 才需要去实现它。\ntryAcquire(int)/tryRelease(int)独占方式，尝试获取/释放资源。\ntryAcquireShared(int)/tryReleaseShared(int)共享方式，尝试获取/释放资源。\n\n这篇本博文只介绍独占方式，尝试获取/释放资源的方法。\n\n### acquire()获取同步状态\n\n不要小看这一行判断，这一句代码其实就是获取许可的核心操作了。\n\n- tryAcquire**尝试获取同步状态**，成功就没必要加入队列。\n- 如果获取同步状态失败，把线程构造成结点（Node.EXCLUSIVE，独占式）addWaiter把**结点加入队列尾部**。\n- 加入之后acquireQueued()死循环去**轮询前一个结点看是否轮到自己了**。\n- 如果轮到自己了，把自己的线程状态设置为**打断等待**\n\n```java\n   public final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n    }\n```\n\n\n\n### tryAcquire()尝试获取同步状态\n\n注意：这里的tryAcquire我是把**可重入锁的公平锁对tryAcquire()的实现**贴过来了！因为AQS抽象类并没有实现这个方法，而是留给子类去实现。\n\n```java\n protected final boolean tryAcquire(int acquires) {\n     //获取当前线程\n            final Thread current = Thread.currentThread();\n            int c = getState();\n     //c等于0，说明锁没有被线程占有，可以试图获取锁\n            if (c == 0) {\n                //如果前面没有线程排队，就用CAS把state从0更新为1\n                if (!hasQueuedPredecessors() &&\n                    compareAndSetState(0, acquires)) {\n                    //获取到锁了，标记一下，告诉大家，现在是本线程占用了锁\n                    setExclusiveOwnerThread(current);\n                    //锁获取成功，直接返回\n                    return true;\n                }\n            }\n      //c不等于0或者上面CAS操作失败了，说明锁被某线程占有\n     //重入就在下面这段代码实现的\n     //由于ReentrantLock是可重入，如果获取锁的线程是当前线程，那还是可以再操作一波的\n            else if (current == getExclusiveOwnerThread()) {\n                //重入了就对state再加1，别忘了acquires是写死为1的\n                int nextc = c + acquires;\n                if (nextc < 0)\n                    throw new Error(\"Maximum lock count exceeded\");\n                //注意：可重入锁加了几次就要释放几次\n                setState(nextc);\n                return true;\n            }\n            return false;\n        }\n    }\n```\n\n\n\n\n\n### addWaiter()线程构造成结点尾部入队和enq()自旋入队\n\n用CAS结点加入队列\n\n> 不过当结点被**并发**地被添加到 LinkedList时, LinkedList将难以保证Node的正确添加,最终的结果可能是节点的数量有偏差,而且顺序也是混乱的。\n>  所以在enq( final Node node)方法中,同步器通过“死循环”来保证节点的正确添加,在“死循环”中只有通过CAS将节点设置成为尾节点之后,当前线程才能从该方法返回,否则当前线程不断地尝试设置。可以看出,enq( final Node node)方法将并发添加节点的请求通过CAS变得“**串行化**”了。\n>\n> ——以上出自《java并发编程的艺术》\n\n\n\n```java\n    private Node addWaiter(Node mode) {\n        Node node = new Node(Thread.currentThread(), mode);\n        Node pred = tail;\n        if (pred != null) {\n             // 将自己的前驱指向尾节点 \n            node.prev = pred;\n            //用CAS把自己加到尾部\n            if (compareAndSetTail(pred, node)) {\n           // 设置尾结点的后继为自己，双向链表嘛\n                pred.next = node;\n                //线程成功添加到尾部，可以返回了\n                return node;\n            }\n        }\n        //但是添加尾结点的操作在并发的情况下可能失败，于是有了enq方法\n        //如果到这里，说明 pred==null队列是空的，或者 CAS把自己探究到尾结点失败(有线程在竞争入队)\n        enq(node);\n        return node;\n    }\n```\n\nenq()因为addWaiter中首次添加到队列尾部失败了，自旋加入队列尾部\n\n```java\n private Node enq(final Node node) {\n     //死循环添加，我就不信加不进去了哼\n        for (;;) {\n            Node t = tail;\n            if (t == null) { // Must initialize\n                // 初始化head节点\n                if (compareAndSetHead(new Node()))\n                    // 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return\n                    // 所以，设置完了以后，继续for循环，下次就到下面的else分支了\n                    tail = head;\n            } else {\n                 //还是加入队列尾部，不过是写在循环里的，加进去了才跳出循环。\n                node.prev = t;\n                if (compareAndSetTail(t, node)) {\n                    t.next = node;\n                    return t;\n                }\n            }\n        }\n    }\n```\n\n### acquireQueued()自旋询问是否到我了\n\n进入一个自旋的过程，不断轮询前面结点的状态，看啥时候到我了。\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n        boolean failed = true;\n        try {\n            boolean interrupted = false;\n            //一直空轮询判断自己是不是\n            for (;;) {\n                final Node p = node.predecessor();\n                //当前节点如果前驱是头结点，就tryAcquire用CAS尝试操作一下state\n                if (p == head && tryAcquire(arg)) {\n                //获取许可了，就把自己设置为头结点\n                    setHead(node);\n                    //把前驱的后继指针设置为null，帮助GC回收\n                    p.next = null; // help GC\n                    //标记设置成功\n                    failed = false;\n                    //没有被其他线程打断\n                    return interrupted;\n                } \n                // 前驱不是头结点，或者上面的if分支没有成功，tryAcquire(arg)没有抢赢别人\n                //\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    interrupted = true;\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n\n```\n\n### shouldParkAfterFailedAcquire抢锁失败，判断是否需要挂起当前线程\n\n在获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态。该方法主要靠前驱节点判断当前线程是否应该被阻塞。\n\n1. 如果当前线程的前驱节点状态为SINNAL（ws=-1），则表明当前线程需要被阻塞，调用unpark()方法唤醒，直接返回true，当前线程阻塞.\n2. 如果当前线程的前驱节点状态为CANCELLED（ws > 0），则表明该线程的前驱节点已经等待超时或者被中断了，则需要从CLH队列中将该前驱节点删除掉，直到回溯到前驱节点状态 <= 0 ，返回false\n3. 如果前驱节点非SINNAL，非CANCELLED，则通过CAS的方式将其前驱节点设置为SINNAL，返回false\n\n```java\n \n    // 第一个参数是前驱节点，第二个参数是当前线程的节点\n    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n        int ws = pred.waitStatus;\n        if (ws == Node.SIGNAL)\n         //前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true\n            return true;\n        // 前驱节点 waitStatus大于0 ，说明前驱节点取消了排队。往前遍历找一个前驱\n        if (ws > 0) {\n            do {\n                node.prev = pred = pred.prev;\n            } while (pred.waitStatus > 0);\n            pred.next = node;\n        } else {\n            // 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)\n            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n        }\n        // 这个方法返回 false，那么会再走一次 for 循序，\n        // 直到ws=-1，进入第一个if分支\n        return false;\n    }\n```\n\n\n\n如果 shouldParkAfterFailedAcquire(Node pred, Node node) 方法返回true，则调用parkAndCheckInterrupt()方法阻塞当前线程：\n\n```java\n    private final boolean parkAndCheckInterrupt() {\n        LockSupport.park(this);\n        return Thread.interrupted();\n    }\n```\n\n接下来以ReentrantLock的源码来分析AQS的具体实现。\n\n# ReentrantLock\n\n最核心的成员变量final Sync sync，这是一个继承AQS的抽象类，它有两个实现，一个是公平锁一个是非公平锁。\n\n获取当前占用锁的线程，如果State为0表示当前没有线程获取锁返回null，如果有就getExclusiveOwnerThread获取线程。\n\n```\nfinal Thread getOwner() {  \nreturn getState() == 0 ? null : getExclusiveOwnerThread();}\n```\n\n\n\n## 公平锁\n\n### lock\n\n这里直接**把值写死了**，每次加锁，acquire方法传入1.\n\n```\nfinal void lock() {    acquire(1);}\n```\n\n### AQS的acquire\n\n*点进acquire方法发现它跳到 AQS的acquire方法里去了，而点进AQS的tryAcquire发现它只抛出一个不支持操作的异常。也就是说在公平锁里，加锁这个操作用的AQS的**acquire**（和非公平锁**共用**），而**tryAcquire**是公平锁和非公平锁**各自**实现的。*\n\n```java\n    public final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n    }\n```\n\n### tryAcquire\n\n这个方法在上文的AQS中已经分析过了，为了方便顺着看，再贴过来。\n\n```java\n  protected final boolean tryAcquire(int acquires) {\n     //获取当前线程\n            final Thread current = Thread.currentThread();\n            int c = getState();\n     //c等于0，说明锁没有被线程占有，可以试图获取锁\n            if (c == 0) {\n                //如果前面没有线程排队，就用CAS把state从0更新为1\n                if (!hasQueuedPredecessors() &&\n                    compareAndSetState(0, acquires)) {\n                    //获取到锁了，标记一下，告诉大家，现在是本线程占用了锁\n                    setExclusiveOwnerThread(current);\n                    //锁获取成功，直接返回\n                    return true;\n                }\n            }\n      //c不等于0或者上面CAS操作失败了，说明锁被某线程占有\n     //重入就在下面这段代码实现的\n     //由于ReentrantLock是可重入，如果获取锁的线程是当前线程，那还是可以再操作一波的\n            else if (current == getExclusiveOwnerThread()) {\n                //重入了就对state再加1，别忘了acquires是写死为1的\n                int nextc = c + acquires;\n                if (nextc < 0)\n                    throw new Error(\"Maximum lock count exceeded\");\n                //注意：可重入锁加了几次就要释放几次\n                setState(nextc);\n                return true;\n            }\n            return false;\n        }\n    }\n```\n\n\n\n\n\n## 非公平锁\n\n非公平锁就两方法lock和tryAcquire\n\n### lock\n\n第一次不加队列，直接先CAS试图获取锁。没有成功在走AQS的acquire方法\n\n```java\n   final void lock() {\n            if (compareAndSetState(0, 1))\n                setExclusiveOwnerThread(Thread.currentThread());\n            else\n                //没有成功在走AQS的acquire方法,去排队。\n                acquire(1);\n        }\n```\n\n### AQS的acquire\n\n*点进acquire方法发现它跳到 AQS的acquire方法里去了，而点进AQS的tryAcquire发现它只抛出一个不支持操作的异常。也就是说在公平锁里，加锁这个操作用的AQS的**acquire**（和非公平锁**共用**），而**tryAcquire**是公平锁和非公平锁**各自**实现的。*\n\n```java\n    public final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n    }\n```\n\n### \n\n\n\n### tryAcquire\n\n```java\n     protected final boolean tryAcquire(int acquires) {\n            final Thread current = Thread.currentThread();\n            int c = getState();\n            if (c == 0) {\n                if (!hasQueuedPredecessors() &&\n                    compareAndSetState(0, acquires)) {\n                    setExclusiveOwnerThread(current);\n                    return true;\n                }\n            }\n            else if (current == getExclusiveOwnerThread()) {\n                int nextc = c + acquires;\n                if (nextc < 0)\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);\n                return true;\n            }\n            return false;\n        }\n```\n\n\n\n## tryRelease()\n\n可重入方式的释放锁\n\n```java\n     protected final boolean tryRelease(int releases) {\n     //只是State减1，还未更新\n            int c = getState() - releases;\n         //如果获取锁的线程不是当前线程，释放失败\n            if (Thread.currentThread() != getExclusiveOwnerThread())\n                throw new IllegalMonitorStateException();\n         \n            boolean free = false;\n         //State等于0，锁被释放了\n         //也有可能减1后不等于0，因为可重入锁的State的可以一直加的\n            if (c == 0) {\n                free = true;\n                setExclusiveOwnerThread(null);\n            }//更新\n            setState(c);\n            return free;\n        }\n```\n\n## Synchronized与ReentrantLock的区别\n\n1）互斥锁\n2）可重入\n3）都保证了可见性和互斥性\n两者的不同点：\n1）ReentrantLock显示获得、释放锁，synchronized隐式获得释放锁\n2）ReentrantLock可响应中断、可轮回，synchronized是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性\n3）ReentrantLock是API级别的，synchronized是JVM级别的\n4）ReentrantLock可以实现公平锁\n5）ReentrantLock通过Condition可以绑定多个条件\n6）底层实现不一样， synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略\n\n\n","source":"_posts/AQS.md","raw":"---\ntitle: AQS源码解析\ndate: 2019-08-14 20:09:50\ncategories: 并发\ndescription: AQS源码解析\n---\n\n# AQS\n\nAbstractQueuedSynchronizer 类（简称 AQS）。它是一个**抽象类**，定义一套多线程访问共享资源的同步器框架，是抽象的队列式的同步器。\n\n同步器是基于**模板方法模式**的，同步器的子类可以通过继承同步器并实现它的抽象方法来管理同步状态，子类推荐被定义为自定义同步组件的**静态内部类**。\n\n[TOC]\n\n\n\n## 两个核心\n\n### volatile int state\n\n同步的核心其实就一个用volatile修饰的int成员变量，**锁的状态就是这个值的更改**。0就是当前没有线程获取锁，1是有。可重入锁可以多次加锁，即把state值加一，当然也需要同样次数的解锁，因为0才代表当前没有线程获取锁。\n\n```\n    private volatile int state;\n```\n\n\n\n### FIFO队列\n\n一个先进先出的双向链表。*这个队列的操作有一点复杂，我建议您可以先跳下去看重要方法后，再回头看Node类。*\n\n```java\nstatic final class Node {\n    static final Node SHARED = new Node();//标识等待节点处于共享模式\n    static final Node EXCLUSIVE = null;//标识等待节点处于独占模式\n\n    static final int CANCELLED =  1;//由于超时或中断，节点已被取消\n    static final int SIGNAL    = -1;//表示下一个节点是通过park堵塞的，需要通过unpark唤醒\n    static final int CONDITION = -2;//表示线程在等待条件变量（先获取锁，加入到条件等待队列，然后释放锁，等待条件变量满足条件；只有重新获取锁之后才能返回）\n    static final int PROPAGATE = -3;//表示后续结点会传播唤醒的操作，共享模式下起作用\n\n    //等待状态：对于condition节点，初始化为CONDITION；其它情况，默认为0，通过CAS操作原子更新\n    volatile int waitStatus;\n    //前节点\n    volatile Node prev;\n    //后节点\n    volatile Node next;\n    //线程对象\n    volatile Thread thread;\n    //对于Condtion表示下一个等待条件变量的节点；其它情况下用于区分共享模式和独占模式；\n    Node nextWaiter;\n\n    final boolean isShared() {\n        return nextWaiter == SHARED;//判断是否共享模式\n    }\n    //获取前节点，如果为null，抛出异常\n    final Node predecessor() throws NullPointerException {\n        Node p = prev;\n        if (p == null)\n            throw new NullPointerException();\n        else\n            return p;\n    }\n    \n    Node() {    // Used to establish initial head or SHARED marker\n    }\n    Node(Thread thread, Node mode) {     //addWaiter方法使用\n        this.nextWaiter = mode;\n        this.thread = thread;\n    }\n    Node(Thread thread, int waitStatus) { //Condition使用\n        this.waitStatus = waitStatus;\n        this.thread = thread;\n    }\n}\n```\n\n\n\n## 重要方法\n\nisHeldExclusively() 该线程是否正在独占资源。只有用到 condition 才需要去实现它。\ntryAcquire(int)/tryRelease(int)独占方式，尝试获取/释放资源。\ntryAcquireShared(int)/tryReleaseShared(int)共享方式，尝试获取/释放资源。\n\n这篇本博文只介绍独占方式，尝试获取/释放资源的方法。\n\n### acquire()获取同步状态\n\n不要小看这一行判断，这一句代码其实就是获取许可的核心操作了。\n\n- tryAcquire**尝试获取同步状态**，成功就没必要加入队列。\n- 如果获取同步状态失败，把线程构造成结点（Node.EXCLUSIVE，独占式）addWaiter把**结点加入队列尾部**。\n- 加入之后acquireQueued()死循环去**轮询前一个结点看是否轮到自己了**。\n- 如果轮到自己了，把自己的线程状态设置为**打断等待**\n\n```java\n   public final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n    }\n```\n\n\n\n### tryAcquire()尝试获取同步状态\n\n注意：这里的tryAcquire我是把**可重入锁的公平锁对tryAcquire()的实现**贴过来了！因为AQS抽象类并没有实现这个方法，而是留给子类去实现。\n\n```java\n protected final boolean tryAcquire(int acquires) {\n     //获取当前线程\n            final Thread current = Thread.currentThread();\n            int c = getState();\n     //c等于0，说明锁没有被线程占有，可以试图获取锁\n            if (c == 0) {\n                //如果前面没有线程排队，就用CAS把state从0更新为1\n                if (!hasQueuedPredecessors() &&\n                    compareAndSetState(0, acquires)) {\n                    //获取到锁了，标记一下，告诉大家，现在是本线程占用了锁\n                    setExclusiveOwnerThread(current);\n                    //锁获取成功，直接返回\n                    return true;\n                }\n            }\n      //c不等于0或者上面CAS操作失败了，说明锁被某线程占有\n     //重入就在下面这段代码实现的\n     //由于ReentrantLock是可重入，如果获取锁的线程是当前线程，那还是可以再操作一波的\n            else if (current == getExclusiveOwnerThread()) {\n                //重入了就对state再加1，别忘了acquires是写死为1的\n                int nextc = c + acquires;\n                if (nextc < 0)\n                    throw new Error(\"Maximum lock count exceeded\");\n                //注意：可重入锁加了几次就要释放几次\n                setState(nextc);\n                return true;\n            }\n            return false;\n        }\n    }\n```\n\n\n\n\n\n### addWaiter()线程构造成结点尾部入队和enq()自旋入队\n\n用CAS结点加入队列\n\n> 不过当结点被**并发**地被添加到 LinkedList时, LinkedList将难以保证Node的正确添加,最终的结果可能是节点的数量有偏差,而且顺序也是混乱的。\n>  所以在enq( final Node node)方法中,同步器通过“死循环”来保证节点的正确添加,在“死循环”中只有通过CAS将节点设置成为尾节点之后,当前线程才能从该方法返回,否则当前线程不断地尝试设置。可以看出,enq( final Node node)方法将并发添加节点的请求通过CAS变得“**串行化**”了。\n>\n> ——以上出自《java并发编程的艺术》\n\n\n\n```java\n    private Node addWaiter(Node mode) {\n        Node node = new Node(Thread.currentThread(), mode);\n        Node pred = tail;\n        if (pred != null) {\n             // 将自己的前驱指向尾节点 \n            node.prev = pred;\n            //用CAS把自己加到尾部\n            if (compareAndSetTail(pred, node)) {\n           // 设置尾结点的后继为自己，双向链表嘛\n                pred.next = node;\n                //线程成功添加到尾部，可以返回了\n                return node;\n            }\n        }\n        //但是添加尾结点的操作在并发的情况下可能失败，于是有了enq方法\n        //如果到这里，说明 pred==null队列是空的，或者 CAS把自己探究到尾结点失败(有线程在竞争入队)\n        enq(node);\n        return node;\n    }\n```\n\nenq()因为addWaiter中首次添加到队列尾部失败了，自旋加入队列尾部\n\n```java\n private Node enq(final Node node) {\n     //死循环添加，我就不信加不进去了哼\n        for (;;) {\n            Node t = tail;\n            if (t == null) { // Must initialize\n                // 初始化head节点\n                if (compareAndSetHead(new Node()))\n                    // 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return\n                    // 所以，设置完了以后，继续for循环，下次就到下面的else分支了\n                    tail = head;\n            } else {\n                 //还是加入队列尾部，不过是写在循环里的，加进去了才跳出循环。\n                node.prev = t;\n                if (compareAndSetTail(t, node)) {\n                    t.next = node;\n                    return t;\n                }\n            }\n        }\n    }\n```\n\n### acquireQueued()自旋询问是否到我了\n\n进入一个自旋的过程，不断轮询前面结点的状态，看啥时候到我了。\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n        boolean failed = true;\n        try {\n            boolean interrupted = false;\n            //一直空轮询判断自己是不是\n            for (;;) {\n                final Node p = node.predecessor();\n                //当前节点如果前驱是头结点，就tryAcquire用CAS尝试操作一下state\n                if (p == head && tryAcquire(arg)) {\n                //获取许可了，就把自己设置为头结点\n                    setHead(node);\n                    //把前驱的后继指针设置为null，帮助GC回收\n                    p.next = null; // help GC\n                    //标记设置成功\n                    failed = false;\n                    //没有被其他线程打断\n                    return interrupted;\n                } \n                // 前驱不是头结点，或者上面的if分支没有成功，tryAcquire(arg)没有抢赢别人\n                //\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    interrupted = true;\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n\n```\n\n### shouldParkAfterFailedAcquire抢锁失败，判断是否需要挂起当前线程\n\n在获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态。该方法主要靠前驱节点判断当前线程是否应该被阻塞。\n\n1. 如果当前线程的前驱节点状态为SINNAL（ws=-1），则表明当前线程需要被阻塞，调用unpark()方法唤醒，直接返回true，当前线程阻塞.\n2. 如果当前线程的前驱节点状态为CANCELLED（ws > 0），则表明该线程的前驱节点已经等待超时或者被中断了，则需要从CLH队列中将该前驱节点删除掉，直到回溯到前驱节点状态 <= 0 ，返回false\n3. 如果前驱节点非SINNAL，非CANCELLED，则通过CAS的方式将其前驱节点设置为SINNAL，返回false\n\n```java\n \n    // 第一个参数是前驱节点，第二个参数是当前线程的节点\n    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n        int ws = pred.waitStatus;\n        if (ws == Node.SIGNAL)\n         //前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true\n            return true;\n        // 前驱节点 waitStatus大于0 ，说明前驱节点取消了排队。往前遍历找一个前驱\n        if (ws > 0) {\n            do {\n                node.prev = pred = pred.prev;\n            } while (pred.waitStatus > 0);\n            pred.next = node;\n        } else {\n            // 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)\n            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n        }\n        // 这个方法返回 false，那么会再走一次 for 循序，\n        // 直到ws=-1，进入第一个if分支\n        return false;\n    }\n```\n\n\n\n如果 shouldParkAfterFailedAcquire(Node pred, Node node) 方法返回true，则调用parkAndCheckInterrupt()方法阻塞当前线程：\n\n```java\n    private final boolean parkAndCheckInterrupt() {\n        LockSupport.park(this);\n        return Thread.interrupted();\n    }\n```\n\n接下来以ReentrantLock的源码来分析AQS的具体实现。\n\n# ReentrantLock\n\n最核心的成员变量final Sync sync，这是一个继承AQS的抽象类，它有两个实现，一个是公平锁一个是非公平锁。\n\n获取当前占用锁的线程，如果State为0表示当前没有线程获取锁返回null，如果有就getExclusiveOwnerThread获取线程。\n\n```\nfinal Thread getOwner() {  \nreturn getState() == 0 ? null : getExclusiveOwnerThread();}\n```\n\n\n\n## 公平锁\n\n### lock\n\n这里直接**把值写死了**，每次加锁，acquire方法传入1.\n\n```\nfinal void lock() {    acquire(1);}\n```\n\n### AQS的acquire\n\n*点进acquire方法发现它跳到 AQS的acquire方法里去了，而点进AQS的tryAcquire发现它只抛出一个不支持操作的异常。也就是说在公平锁里，加锁这个操作用的AQS的**acquire**（和非公平锁**共用**），而**tryAcquire**是公平锁和非公平锁**各自**实现的。*\n\n```java\n    public final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n    }\n```\n\n### tryAcquire\n\n这个方法在上文的AQS中已经分析过了，为了方便顺着看，再贴过来。\n\n```java\n  protected final boolean tryAcquire(int acquires) {\n     //获取当前线程\n            final Thread current = Thread.currentThread();\n            int c = getState();\n     //c等于0，说明锁没有被线程占有，可以试图获取锁\n            if (c == 0) {\n                //如果前面没有线程排队，就用CAS把state从0更新为1\n                if (!hasQueuedPredecessors() &&\n                    compareAndSetState(0, acquires)) {\n                    //获取到锁了，标记一下，告诉大家，现在是本线程占用了锁\n                    setExclusiveOwnerThread(current);\n                    //锁获取成功，直接返回\n                    return true;\n                }\n            }\n      //c不等于0或者上面CAS操作失败了，说明锁被某线程占有\n     //重入就在下面这段代码实现的\n     //由于ReentrantLock是可重入，如果获取锁的线程是当前线程，那还是可以再操作一波的\n            else if (current == getExclusiveOwnerThread()) {\n                //重入了就对state再加1，别忘了acquires是写死为1的\n                int nextc = c + acquires;\n                if (nextc < 0)\n                    throw new Error(\"Maximum lock count exceeded\");\n                //注意：可重入锁加了几次就要释放几次\n                setState(nextc);\n                return true;\n            }\n            return false;\n        }\n    }\n```\n\n\n\n\n\n## 非公平锁\n\n非公平锁就两方法lock和tryAcquire\n\n### lock\n\n第一次不加队列，直接先CAS试图获取锁。没有成功在走AQS的acquire方法\n\n```java\n   final void lock() {\n            if (compareAndSetState(0, 1))\n                setExclusiveOwnerThread(Thread.currentThread());\n            else\n                //没有成功在走AQS的acquire方法,去排队。\n                acquire(1);\n        }\n```\n\n### AQS的acquire\n\n*点进acquire方法发现它跳到 AQS的acquire方法里去了，而点进AQS的tryAcquire发现它只抛出一个不支持操作的异常。也就是说在公平锁里，加锁这个操作用的AQS的**acquire**（和非公平锁**共用**），而**tryAcquire**是公平锁和非公平锁**各自**实现的。*\n\n```java\n    public final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n    }\n```\n\n### \n\n\n\n### tryAcquire\n\n```java\n     protected final boolean tryAcquire(int acquires) {\n            final Thread current = Thread.currentThread();\n            int c = getState();\n            if (c == 0) {\n                if (!hasQueuedPredecessors() &&\n                    compareAndSetState(0, acquires)) {\n                    setExclusiveOwnerThread(current);\n                    return true;\n                }\n            }\n            else if (current == getExclusiveOwnerThread()) {\n                int nextc = c + acquires;\n                if (nextc < 0)\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);\n                return true;\n            }\n            return false;\n        }\n```\n\n\n\n## tryRelease()\n\n可重入方式的释放锁\n\n```java\n     protected final boolean tryRelease(int releases) {\n     //只是State减1，还未更新\n            int c = getState() - releases;\n         //如果获取锁的线程不是当前线程，释放失败\n            if (Thread.currentThread() != getExclusiveOwnerThread())\n                throw new IllegalMonitorStateException();\n         \n            boolean free = false;\n         //State等于0，锁被释放了\n         //也有可能减1后不等于0，因为可重入锁的State的可以一直加的\n            if (c == 0) {\n                free = true;\n                setExclusiveOwnerThread(null);\n            }//更新\n            setState(c);\n            return free;\n        }\n```\n\n## Synchronized与ReentrantLock的区别\n\n1）互斥锁\n2）可重入\n3）都保证了可见性和互斥性\n两者的不同点：\n1）ReentrantLock显示获得、释放锁，synchronized隐式获得释放锁\n2）ReentrantLock可响应中断、可轮回，synchronized是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性\n3）ReentrantLock是API级别的，synchronized是JVM级别的\n4）ReentrantLock可以实现公平锁\n5）ReentrantLock通过Condition可以绑定多个条件\n6）底层实现不一样， synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略\n\n\n","slug":"AQS","published":1,"updated":"2022-02-08T07:09:41.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qjj0000w9rpzl518f67","content":"<h1 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h1><p>AbstractQueuedSynchronizer 类（简称 AQS）。它是一个<strong>抽象类</strong>，定义一套多线程访问共享资源的同步器框架，是抽象的队列式的同步器。</p>\n<p>同步器是基于<strong>模板方法模式</strong>的，同步器的子类可以通过继承同步器并实现它的抽象方法来管理同步状态，子类推荐被定义为自定义同步组件的<strong>静态内部类</strong>。</p>\n<p>[TOC]</p>\n<h2 id=\"两个核心\"><a href=\"#两个核心\" class=\"headerlink\" title=\"两个核心\"></a>两个核心</h2><h3 id=\"volatile-int-state\"><a href=\"#volatile-int-state\" class=\"headerlink\" title=\"volatile int state\"></a>volatile int state</h3><p>同步的核心其实就一个用volatile修饰的int成员变量，<strong>锁的状态就是这个值的更改</strong>。0就是当前没有线程获取锁，1是有。可重入锁可以多次加锁，即把state值加一，当然也需要同样次数的解锁，因为0才代表当前没有线程获取锁。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private volatile int state;</span><br></pre></td></tr></table></figure>\n<h3 id=\"FIFO队列\"><a href=\"#FIFO队列\" class=\"headerlink\" title=\"FIFO队列\"></a>FIFO队列</h3><p>一个先进先出的双向链表。<em>这个队列的操作有一点复杂，我建议您可以先跳下去看重要方法后，再回头看Node类。</em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node SHARED = <span class=\"keyword\">new</span> Node();<span class=\"comment\">//标识等待节点处于共享模式</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node EXCLUSIVE = <span class=\"keyword\">null</span>;<span class=\"comment\">//标识等待节点处于独占模式</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CANCELLED =  <span class=\"number\">1</span>;<span class=\"comment\">//由于超时或中断，节点已被取消</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIGNAL    = -<span class=\"number\">1</span>;<span class=\"comment\">//表示下一个节点是通过park堵塞的，需要通过unpark唤醒</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CONDITION = -<span class=\"number\">2</span>;<span class=\"comment\">//表示线程在等待条件变量（先获取锁，加入到条件等待队列，然后释放锁，等待条件变量满足条件；只有重新获取锁之后才能返回）</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PROPAGATE = -<span class=\"number\">3</span>;<span class=\"comment\">//表示后续结点会传播唤醒的操作，共享模式下起作用</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//等待状态：对于condition节点，初始化为CONDITION；其它情况，默认为0，通过CAS操作原子更新</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> waitStatus;</span><br><span class=\"line\">    <span class=\"comment\">//前节点</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Node prev;</span><br><span class=\"line\">    <span class=\"comment\">//后节点</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Node next;</span><br><span class=\"line\">    <span class=\"comment\">//线程对象</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Thread thread;</span><br><span class=\"line\">    <span class=\"comment\">//对于Condtion表示下一个等待条件变量的节点；其它情况下用于区分共享模式和独占模式；</span></span><br><span class=\"line\">    Node nextWaiter;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isShared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextWaiter == SHARED;<span class=\"comment\">//判断是否共享模式</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取前节点，如果为null，抛出异常</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> Node <span class=\"title\">predecessor</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NullPointerException </span>&#123;</span><br><span class=\"line\">        Node p = prev;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Node() &#123;    <span class=\"comment\">// Used to establish initial head or SHARED marker</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node(Thread thread, Node mode) &#123;     <span class=\"comment\">//addWaiter方法使用</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.nextWaiter = mode;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.thread = thread;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node(Thread thread, <span class=\"keyword\">int</span> waitStatus) &#123; <span class=\"comment\">//Condition使用</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.waitStatus = waitStatus;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.thread = thread;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"重要方法\"><a href=\"#重要方法\" class=\"headerlink\" title=\"重要方法\"></a>重要方法</h2><p>isHeldExclusively() 该线程是否正在独占资源。只有用到 condition 才需要去实现它。<br>tryAcquire(int)/tryRelease(int)独占方式，尝试获取/释放资源。<br>tryAcquireShared(int)/tryReleaseShared(int)共享方式，尝试获取/释放资源。</p>\n<p>这篇本博文只介绍独占方式，尝试获取/释放资源的方法。</p>\n<h3 id=\"acquire-获取同步状态\"><a href=\"#acquire-获取同步状态\" class=\"headerlink\" title=\"acquire()获取同步状态\"></a>acquire()获取同步状态</h3><p>不要小看这一行判断，这一句代码其实就是获取许可的核心操作了。</p>\n<ul>\n<li>tryAcquire<strong>尝试获取同步状态</strong>，成功就没必要加入队列。</li>\n<li>如果获取同步状态失败，把线程构造成结点（Node.EXCLUSIVE，独占式）addWaiter把<strong>结点加入队列尾部</strong>。</li>\n<li>加入之后acquireQueued()死循环去<strong>轮询前一个结点看是否轮到自己了</strong>。</li>\n<li>如果轮到自己了，把自己的线程状态设置为<strong>打断等待</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">         selfInterrupt();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"tryAcquire-尝试获取同步状态\"><a href=\"#tryAcquire-尝试获取同步状态\" class=\"headerlink\" title=\"tryAcquire()尝试获取同步状态\"></a>tryAcquire()尝试获取同步状态</h3><p>注意：这里的tryAcquire我是把<strong>可重入锁的公平锁对tryAcquire()的实现</strong>贴过来了！因为AQS抽象类并没有实现这个方法，而是留给子类去实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取当前线程</span></span><br><span class=\"line\">           <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">           <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"comment\">//c等于0，说明锁没有被线程占有，可以试图获取锁</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">//如果前面没有线程排队，就用CAS把state从0更新为1</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class=\"line\">                   compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">                   <span class=\"comment\">//获取到锁了，标记一下，告诉大家，现在是本线程占用了锁</span></span><br><span class=\"line\">                   setExclusiveOwnerThread(current);</span><br><span class=\"line\">                   <span class=\"comment\">//锁获取成功，直接返回</span></span><br><span class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">     <span class=\"comment\">//c不等于0或者上面CAS操作失败了，说明锁被某线程占有</span></span><br><span class=\"line\">    <span class=\"comment\">//重入就在下面这段代码实现的</span></span><br><span class=\"line\">    <span class=\"comment\">//由于ReentrantLock是可重入，如果获取锁的线程是当前线程，那还是可以再操作一波的</span></span><br><span class=\"line\">           <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">               <span class=\"comment\">//重入了就对state再加1，别忘了acquires是写死为1的</span></span><br><span class=\"line\">               <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                   <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">               <span class=\"comment\">//注意：可重入锁加了几次就要释放几次</span></span><br><span class=\"line\">               setState(nextc);</span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"addWaiter-线程构造成结点尾部入队和enq-自旋入队\"><a href=\"#addWaiter-线程构造成结点尾部入队和enq-自旋入队\" class=\"headerlink\" title=\"addWaiter()线程构造成结点尾部入队和enq()自旋入队\"></a>addWaiter()线程构造成结点尾部入队和enq()自旋入队</h3><p>用CAS结点加入队列</p>\n<blockquote>\n<p>不过当结点被<strong>并发</strong>地被添加到 LinkedList时, LinkedList将难以保证Node的正确添加,最终的结果可能是节点的数量有偏差,而且顺序也是混乱的。<br> 所以在enq( final Node node)方法中,同步器通过“死循环”来保证节点的正确添加,在“死循环”中只有通过CAS将节点设置成为尾节点之后,当前线程才能从该方法返回,否则当前线程不断地尝试设置。可以看出,enq( final Node node)方法将并发添加节点的请求通过CAS变得“<strong>串行化</strong>”了。</p>\n<p>——以上出自《java并发编程的艺术》</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode);</span><br><span class=\"line\">    Node pred = tail;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 将自己的前驱指向尾节点 </span></span><br><span class=\"line\">        node.prev = pred;</span><br><span class=\"line\">        <span class=\"comment\">//用CAS把自己加到尾部</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 设置尾结点的后继为自己，双向链表嘛</span></span><br><span class=\"line\">            pred.next = node;</span><br><span class=\"line\">            <span class=\"comment\">//线程成功添加到尾部，可以返回了</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//但是添加尾结点的操作在并发的情况下可能失败，于是有了enq方法</span></span><br><span class=\"line\">    <span class=\"comment\">//如果到这里，说明 pred==null队列是空的，或者 CAS把自己探究到尾结点失败(有线程在竞争入队)</span></span><br><span class=\"line\">    enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>enq()因为addWaiter中首次添加到队列尾部失败了，自旋加入队列尾部</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//死循环添加，我就不信加不进去了哼</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">           Node t = tail;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// Must initialize</span></span><br><span class=\"line\">               <span class=\"comment\">// 初始化head节点</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> Node()))</span><br><span class=\"line\">                   <span class=\"comment\">// 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return</span></span><br><span class=\"line\">                   <span class=\"comment\">// 所以，设置完了以后，继续for循环，下次就到下面的else分支了</span></span><br><span class=\"line\">                   tail = head;</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//还是加入队列尾部，不过是写在循环里的，加进去了才跳出循环。</span></span><br><span class=\"line\">               node.prev = t;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">                   t.next = node;</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"acquireQueued-自旋询问是否到我了\"><a href=\"#acquireQueued-自旋询问是否到我了\" class=\"headerlink\" title=\"acquireQueued()自旋询问是否到我了\"></a>acquireQueued()自旋询问是否到我了</h3><p>进入一个自旋的过程，不断轮询前面结点的状态，看啥时候到我了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">//一直空轮询判断自己是不是</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">                <span class=\"comment\">//当前节点如果前驱是头结点，就tryAcquire用CAS尝试操作一下state</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//获取许可了，就把自己设置为头结点</span></span><br><span class=\"line\">                    setHead(node);</span><br><span class=\"line\">                    <span class=\"comment\">//把前驱的后继指针设置为null，帮助GC回收</span></span><br><span class=\"line\">                    p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                    <span class=\"comment\">//标记设置成功</span></span><br><span class=\"line\">                    failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"comment\">//没有被其他线程打断</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">                <span class=\"comment\">// 前驱不是头结点，或者上面的if分支没有成功，tryAcquire(arg)没有抢赢别人</span></span><br><span class=\"line\">                <span class=\"comment\">//</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                    parkAndCheckInterrupt())</span><br><span class=\"line\">                    interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">                cancelAcquire(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"shouldParkAfterFailedAcquire抢锁失败，判断是否需要挂起当前线程\"><a href=\"#shouldParkAfterFailedAcquire抢锁失败，判断是否需要挂起当前线程\" class=\"headerlink\" title=\"shouldParkAfterFailedAcquire抢锁失败，判断是否需要挂起当前线程\"></a>shouldParkAfterFailedAcquire抢锁失败，判断是否需要挂起当前线程</h3><p>在获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态。该方法主要靠前驱节点判断当前线程是否应该被阻塞。</p>\n<ol>\n<li>如果当前线程的前驱节点状态为SINNAL（ws=-1），则表明当前线程需要被阻塞，调用unpark()方法唤醒，直接返回true，当前线程阻塞.</li>\n<li>如果当前线程的前驱节点状态为CANCELLED（ws &gt; 0），则表明该线程的前驱节点已经等待超时或者被中断了，则需要从CLH队列中将该前驱节点删除掉，直到回溯到前驱节点状态 &lt;= 0 ，返回false</li>\n<li>如果前驱节点非SINNAL，非CANCELLED，则通过CAS的方式将其前驱节点设置为SINNAL，返回false</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 第一个参数是前驱节点，第二个参数是当前线程的节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = pred.waitStatus;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws == Node.SIGNAL)</span><br><span class=\"line\">     <span class=\"comment\">//前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 前驱节点 waitStatus大于0 ，说明前驱节点取消了排队。往前遍历找一个前驱</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            node.prev = pred = pred.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        pred.next = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span></span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这个方法返回 false，那么会再走一次 for 循序，</span></span><br><span class=\"line\">    <span class=\"comment\">// 直到ws=-1，进入第一个if分支</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果 shouldParkAfterFailedAcquire(Node pred, Node node) 方法返回true，则调用parkAndCheckInterrupt()方法阻塞当前线程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parkAndCheckInterrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Thread.interrupted();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来以ReentrantLock的源码来分析AQS的具体实现。</p>\n<h1 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h1><p>最核心的成员变量final Sync sync，这是一个继承AQS的抽象类，它有两个实现，一个是公平锁一个是非公平锁。</p>\n<p>获取当前占用锁的线程，如果State为0表示当前没有线程获取锁返回null，如果有就getExclusiveOwnerThread获取线程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final Thread getOwner() &#123;  </span><br><span class=\"line\">return getState() == 0 ? null : getExclusiveOwnerThread();&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"公平锁\"><a href=\"#公平锁\" class=\"headerlink\" title=\"公平锁\"></a>公平锁</h2><h3 id=\"lock\"><a href=\"#lock\" class=\"headerlink\" title=\"lock\"></a>lock</h3><p>这里直接<strong>把值写死了</strong>，每次加锁，acquire方法传入1.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final void lock() &#123;    acquire(1);&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AQS的acquire\"><a href=\"#AQS的acquire\" class=\"headerlink\" title=\"AQS的acquire\"></a>AQS的acquire</h3><p><em>点进acquire方法发现它跳到 AQS的acquire方法里去了，而点进AQS的tryAcquire发现它只抛出一个不支持操作的异常。也就是说在公平锁里，加锁这个操作用的AQS的<strong>acquire</strong>（和非公平锁<strong>共用</strong>），而<strong>tryAcquire</strong>是公平锁和非公平锁<strong>各自</strong>实现的。</em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"tryAcquire\"><a href=\"#tryAcquire\" class=\"headerlink\" title=\"tryAcquire\"></a>tryAcquire</h3><p>这个方法在上文的AQS中已经分析过了，为了方便顺着看，再贴过来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">//获取当前线程</span></span><br><span class=\"line\">          <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">          <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">   <span class=\"comment\">//c等于0，说明锁没有被线程占有，可以试图获取锁</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              <span class=\"comment\">//如果前面没有线程排队，就用CAS把state从0更新为1</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class=\"line\">                  compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">//获取到锁了，标记一下，告诉大家，现在是本线程占用了锁</span></span><br><span class=\"line\">                  setExclusiveOwnerThread(current);</span><br><span class=\"line\">                  <span class=\"comment\">//锁获取成功，直接返回</span></span><br><span class=\"line\">                  <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">    <span class=\"comment\">//c不等于0或者上面CAS操作失败了，说明锁被某线程占有</span></span><br><span class=\"line\">   <span class=\"comment\">//重入就在下面这段代码实现的</span></span><br><span class=\"line\">   <span class=\"comment\">//由于ReentrantLock是可重入，如果获取锁的线程是当前线程，那还是可以再操作一波的</span></span><br><span class=\"line\">          <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">              <span class=\"comment\">//重入了就对state再加1，别忘了acquires是写死为1的</span></span><br><span class=\"line\">              <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">              <span class=\"comment\">//注意：可重入锁加了几次就要释放几次</span></span><br><span class=\"line\">              setState(nextc);</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"非公平锁\"><a href=\"#非公平锁\" class=\"headerlink\" title=\"非公平锁\"></a>非公平锁</h2><p>非公平锁就两方法lock和tryAcquire</p>\n<h3 id=\"lock-1\"><a href=\"#lock-1\" class=\"headerlink\" title=\"lock\"></a>lock</h3><p>第一次不加队列，直接先CAS试图获取锁。没有成功在走AQS的acquire方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">             setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">         <span class=\"keyword\">else</span></span><br><span class=\"line\">             <span class=\"comment\">//没有成功在走AQS的acquire方法,去排队。</span></span><br><span class=\"line\">             acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AQS的acquire-1\"><a href=\"#AQS的acquire-1\" class=\"headerlink\" title=\"AQS的acquire\"></a>AQS的acquire</h3><p><em>点进acquire方法发现它跳到 AQS的acquire方法里去了，而点进AQS的tryAcquire发现它只抛出一个不支持操作的异常。也就是说在公平锁里，加锁这个操作用的AQS的<strong>acquire</strong>（和非公平锁<strong>共用</strong>），而<strong>tryAcquire</strong>是公平锁和非公平锁<strong>各自</strong>实现的。</em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>### </p>\n<h3 id=\"tryAcquire-1\"><a href=\"#tryAcquire-1\" class=\"headerlink\" title=\"tryAcquire\"></a>tryAcquire</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">       <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class=\"line\">               compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">               setExclusiveOwnerThread(current);</span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">           setState(nextc);</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"tryRelease\"><a href=\"#tryRelease\" class=\"headerlink\" title=\"tryRelease()\"></a>tryRelease()</h2><p>可重入方式的释放锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//只是State减1，还未更新</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\">    <span class=\"comment\">//如果获取锁的线程不是当前线程，释放失败</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    </span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//State等于0，锁被释放了</span></span><br><span class=\"line\">    <span class=\"comment\">//也有可能减1后不等于0，因为可重入锁的State的可以一直加的</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">           free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">       &#125;<span class=\"comment\">//更新</span></span><br><span class=\"line\">       setState(c);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Synchronized与ReentrantLock的区别\"><a href=\"#Synchronized与ReentrantLock的区别\" class=\"headerlink\" title=\"Synchronized与ReentrantLock的区别\"></a>Synchronized与ReentrantLock的区别</h2><p>1）互斥锁<br>2）可重入<br>3）都保证了可见性和互斥性<br>两者的不同点：<br>1）ReentrantLock显示获得、释放锁，synchronized隐式获得释放锁<br>2）ReentrantLock可响应中断、可轮回，synchronized是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性<br>3）ReentrantLock是API级别的，synchronized是JVM级别的<br>4）ReentrantLock可以实现公平锁<br>5）ReentrantLock通过Condition可以绑定多个条件<br>6）底层实现不一样， synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h1><p>AbstractQueuedSynchronizer 类（简称 AQS）。它是一个<strong>抽象类</strong>，定义一套多线程访问共享资源的同步器框架，是抽象的队列式的同步器。</p>\n<p>同步器是基于<strong>模板方法模式</strong>的，同步器的子类可以通过继承同步器并实现它的抽象方法来管理同步状态，子类推荐被定义为自定义同步组件的<strong>静态内部类</strong>。</p>\n<p>[TOC]</p>\n<h2 id=\"两个核心\"><a href=\"#两个核心\" class=\"headerlink\" title=\"两个核心\"></a>两个核心</h2><h3 id=\"volatile-int-state\"><a href=\"#volatile-int-state\" class=\"headerlink\" title=\"volatile int state\"></a>volatile int state</h3><p>同步的核心其实就一个用volatile修饰的int成员变量，<strong>锁的状态就是这个值的更改</strong>。0就是当前没有线程获取锁，1是有。可重入锁可以多次加锁，即把state值加一，当然也需要同样次数的解锁，因为0才代表当前没有线程获取锁。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private volatile int state;</span><br></pre></td></tr></table></figure>\n<h3 id=\"FIFO队列\"><a href=\"#FIFO队列\" class=\"headerlink\" title=\"FIFO队列\"></a>FIFO队列</h3><p>一个先进先出的双向链表。<em>这个队列的操作有一点复杂，我建议您可以先跳下去看重要方法后，再回头看Node类。</em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node SHARED = <span class=\"keyword\">new</span> Node();<span class=\"comment\">//标识等待节点处于共享模式</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node EXCLUSIVE = <span class=\"keyword\">null</span>;<span class=\"comment\">//标识等待节点处于独占模式</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CANCELLED =  <span class=\"number\">1</span>;<span class=\"comment\">//由于超时或中断，节点已被取消</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIGNAL    = -<span class=\"number\">1</span>;<span class=\"comment\">//表示下一个节点是通过park堵塞的，需要通过unpark唤醒</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CONDITION = -<span class=\"number\">2</span>;<span class=\"comment\">//表示线程在等待条件变量（先获取锁，加入到条件等待队列，然后释放锁，等待条件变量满足条件；只有重新获取锁之后才能返回）</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PROPAGATE = -<span class=\"number\">3</span>;<span class=\"comment\">//表示后续结点会传播唤醒的操作，共享模式下起作用</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//等待状态：对于condition节点，初始化为CONDITION；其它情况，默认为0，通过CAS操作原子更新</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> waitStatus;</span><br><span class=\"line\">    <span class=\"comment\">//前节点</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Node prev;</span><br><span class=\"line\">    <span class=\"comment\">//后节点</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Node next;</span><br><span class=\"line\">    <span class=\"comment\">//线程对象</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Thread thread;</span><br><span class=\"line\">    <span class=\"comment\">//对于Condtion表示下一个等待条件变量的节点；其它情况下用于区分共享模式和独占模式；</span></span><br><span class=\"line\">    Node nextWaiter;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isShared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextWaiter == SHARED;<span class=\"comment\">//判断是否共享模式</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取前节点，如果为null，抛出异常</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> Node <span class=\"title\">predecessor</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NullPointerException </span>&#123;</span><br><span class=\"line\">        Node p = prev;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Node() &#123;    <span class=\"comment\">// Used to establish initial head or SHARED marker</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node(Thread thread, Node mode) &#123;     <span class=\"comment\">//addWaiter方法使用</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.nextWaiter = mode;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.thread = thread;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node(Thread thread, <span class=\"keyword\">int</span> waitStatus) &#123; <span class=\"comment\">//Condition使用</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.waitStatus = waitStatus;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.thread = thread;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"重要方法\"><a href=\"#重要方法\" class=\"headerlink\" title=\"重要方法\"></a>重要方法</h2><p>isHeldExclusively() 该线程是否正在独占资源。只有用到 condition 才需要去实现它。<br>tryAcquire(int)/tryRelease(int)独占方式，尝试获取/释放资源。<br>tryAcquireShared(int)/tryReleaseShared(int)共享方式，尝试获取/释放资源。</p>\n<p>这篇本博文只介绍独占方式，尝试获取/释放资源的方法。</p>\n<h3 id=\"acquire-获取同步状态\"><a href=\"#acquire-获取同步状态\" class=\"headerlink\" title=\"acquire()获取同步状态\"></a>acquire()获取同步状态</h3><p>不要小看这一行判断，这一句代码其实就是获取许可的核心操作了。</p>\n<ul>\n<li>tryAcquire<strong>尝试获取同步状态</strong>，成功就没必要加入队列。</li>\n<li>如果获取同步状态失败，把线程构造成结点（Node.EXCLUSIVE，独占式）addWaiter把<strong>结点加入队列尾部</strong>。</li>\n<li>加入之后acquireQueued()死循环去<strong>轮询前一个结点看是否轮到自己了</strong>。</li>\n<li>如果轮到自己了，把自己的线程状态设置为<strong>打断等待</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">         selfInterrupt();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"tryAcquire-尝试获取同步状态\"><a href=\"#tryAcquire-尝试获取同步状态\" class=\"headerlink\" title=\"tryAcquire()尝试获取同步状态\"></a>tryAcquire()尝试获取同步状态</h3><p>注意：这里的tryAcquire我是把<strong>可重入锁的公平锁对tryAcquire()的实现</strong>贴过来了！因为AQS抽象类并没有实现这个方法，而是留给子类去实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取当前线程</span></span><br><span class=\"line\">           <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">           <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"comment\">//c等于0，说明锁没有被线程占有，可以试图获取锁</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">//如果前面没有线程排队，就用CAS把state从0更新为1</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class=\"line\">                   compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">                   <span class=\"comment\">//获取到锁了，标记一下，告诉大家，现在是本线程占用了锁</span></span><br><span class=\"line\">                   setExclusiveOwnerThread(current);</span><br><span class=\"line\">                   <span class=\"comment\">//锁获取成功，直接返回</span></span><br><span class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">     <span class=\"comment\">//c不等于0或者上面CAS操作失败了，说明锁被某线程占有</span></span><br><span class=\"line\">    <span class=\"comment\">//重入就在下面这段代码实现的</span></span><br><span class=\"line\">    <span class=\"comment\">//由于ReentrantLock是可重入，如果获取锁的线程是当前线程，那还是可以再操作一波的</span></span><br><span class=\"line\">           <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">               <span class=\"comment\">//重入了就对state再加1，别忘了acquires是写死为1的</span></span><br><span class=\"line\">               <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                   <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">               <span class=\"comment\">//注意：可重入锁加了几次就要释放几次</span></span><br><span class=\"line\">               setState(nextc);</span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"addWaiter-线程构造成结点尾部入队和enq-自旋入队\"><a href=\"#addWaiter-线程构造成结点尾部入队和enq-自旋入队\" class=\"headerlink\" title=\"addWaiter()线程构造成结点尾部入队和enq()自旋入队\"></a>addWaiter()线程构造成结点尾部入队和enq()自旋入队</h3><p>用CAS结点加入队列</p>\n<blockquote>\n<p>不过当结点被<strong>并发</strong>地被添加到 LinkedList时, LinkedList将难以保证Node的正确添加,最终的结果可能是节点的数量有偏差,而且顺序也是混乱的。<br> 所以在enq( final Node node)方法中,同步器通过“死循环”来保证节点的正确添加,在“死循环”中只有通过CAS将节点设置成为尾节点之后,当前线程才能从该方法返回,否则当前线程不断地尝试设置。可以看出,enq( final Node node)方法将并发添加节点的请求通过CAS变得“<strong>串行化</strong>”了。</p>\n<p>——以上出自《java并发编程的艺术》</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode);</span><br><span class=\"line\">    Node pred = tail;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 将自己的前驱指向尾节点 </span></span><br><span class=\"line\">        node.prev = pred;</span><br><span class=\"line\">        <span class=\"comment\">//用CAS把自己加到尾部</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 设置尾结点的后继为自己，双向链表嘛</span></span><br><span class=\"line\">            pred.next = node;</span><br><span class=\"line\">            <span class=\"comment\">//线程成功添加到尾部，可以返回了</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//但是添加尾结点的操作在并发的情况下可能失败，于是有了enq方法</span></span><br><span class=\"line\">    <span class=\"comment\">//如果到这里，说明 pred==null队列是空的，或者 CAS把自己探究到尾结点失败(有线程在竞争入队)</span></span><br><span class=\"line\">    enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>enq()因为addWaiter中首次添加到队列尾部失败了，自旋加入队列尾部</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//死循环添加，我就不信加不进去了哼</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">           Node t = tail;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// Must initialize</span></span><br><span class=\"line\">               <span class=\"comment\">// 初始化head节点</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> Node()))</span><br><span class=\"line\">                   <span class=\"comment\">// 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return</span></span><br><span class=\"line\">                   <span class=\"comment\">// 所以，设置完了以后，继续for循环，下次就到下面的else分支了</span></span><br><span class=\"line\">                   tail = head;</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//还是加入队列尾部，不过是写在循环里的，加进去了才跳出循环。</span></span><br><span class=\"line\">               node.prev = t;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">                   t.next = node;</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"acquireQueued-自旋询问是否到我了\"><a href=\"#acquireQueued-自旋询问是否到我了\" class=\"headerlink\" title=\"acquireQueued()自旋询问是否到我了\"></a>acquireQueued()自旋询问是否到我了</h3><p>进入一个自旋的过程，不断轮询前面结点的状态，看啥时候到我了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">//一直空轮询判断自己是不是</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">                <span class=\"comment\">//当前节点如果前驱是头结点，就tryAcquire用CAS尝试操作一下state</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//获取许可了，就把自己设置为头结点</span></span><br><span class=\"line\">                    setHead(node);</span><br><span class=\"line\">                    <span class=\"comment\">//把前驱的后继指针设置为null，帮助GC回收</span></span><br><span class=\"line\">                    p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                    <span class=\"comment\">//标记设置成功</span></span><br><span class=\"line\">                    failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"comment\">//没有被其他线程打断</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">                <span class=\"comment\">// 前驱不是头结点，或者上面的if分支没有成功，tryAcquire(arg)没有抢赢别人</span></span><br><span class=\"line\">                <span class=\"comment\">//</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                    parkAndCheckInterrupt())</span><br><span class=\"line\">                    interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">                cancelAcquire(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"shouldParkAfterFailedAcquire抢锁失败，判断是否需要挂起当前线程\"><a href=\"#shouldParkAfterFailedAcquire抢锁失败，判断是否需要挂起当前线程\" class=\"headerlink\" title=\"shouldParkAfterFailedAcquire抢锁失败，判断是否需要挂起当前线程\"></a>shouldParkAfterFailedAcquire抢锁失败，判断是否需要挂起当前线程</h3><p>在获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态。该方法主要靠前驱节点判断当前线程是否应该被阻塞。</p>\n<ol>\n<li>如果当前线程的前驱节点状态为SINNAL（ws=-1），则表明当前线程需要被阻塞，调用unpark()方法唤醒，直接返回true，当前线程阻塞.</li>\n<li>如果当前线程的前驱节点状态为CANCELLED（ws &gt; 0），则表明该线程的前驱节点已经等待超时或者被中断了，则需要从CLH队列中将该前驱节点删除掉，直到回溯到前驱节点状态 &lt;= 0 ，返回false</li>\n<li>如果前驱节点非SINNAL，非CANCELLED，则通过CAS的方式将其前驱节点设置为SINNAL，返回false</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 第一个参数是前驱节点，第二个参数是当前线程的节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = pred.waitStatus;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws == Node.SIGNAL)</span><br><span class=\"line\">     <span class=\"comment\">//前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 前驱节点 waitStatus大于0 ，说明前驱节点取消了排队。往前遍历找一个前驱</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            node.prev = pred = pred.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        pred.next = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span></span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这个方法返回 false，那么会再走一次 for 循序，</span></span><br><span class=\"line\">    <span class=\"comment\">// 直到ws=-1，进入第一个if分支</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果 shouldParkAfterFailedAcquire(Node pred, Node node) 方法返回true，则调用parkAndCheckInterrupt()方法阻塞当前线程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parkAndCheckInterrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Thread.interrupted();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来以ReentrantLock的源码来分析AQS的具体实现。</p>\n<h1 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h1><p>最核心的成员变量final Sync sync，这是一个继承AQS的抽象类，它有两个实现，一个是公平锁一个是非公平锁。</p>\n<p>获取当前占用锁的线程，如果State为0表示当前没有线程获取锁返回null，如果有就getExclusiveOwnerThread获取线程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final Thread getOwner() &#123;  </span><br><span class=\"line\">return getState() == 0 ? null : getExclusiveOwnerThread();&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"公平锁\"><a href=\"#公平锁\" class=\"headerlink\" title=\"公平锁\"></a>公平锁</h2><h3 id=\"lock\"><a href=\"#lock\" class=\"headerlink\" title=\"lock\"></a>lock</h3><p>这里直接<strong>把值写死了</strong>，每次加锁，acquire方法传入1.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final void lock() &#123;    acquire(1);&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AQS的acquire\"><a href=\"#AQS的acquire\" class=\"headerlink\" title=\"AQS的acquire\"></a>AQS的acquire</h3><p><em>点进acquire方法发现它跳到 AQS的acquire方法里去了，而点进AQS的tryAcquire发现它只抛出一个不支持操作的异常。也就是说在公平锁里，加锁这个操作用的AQS的<strong>acquire</strong>（和非公平锁<strong>共用</strong>），而<strong>tryAcquire</strong>是公平锁和非公平锁<strong>各自</strong>实现的。</em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"tryAcquire\"><a href=\"#tryAcquire\" class=\"headerlink\" title=\"tryAcquire\"></a>tryAcquire</h3><p>这个方法在上文的AQS中已经分析过了，为了方便顺着看，再贴过来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">//获取当前线程</span></span><br><span class=\"line\">          <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">          <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">   <span class=\"comment\">//c等于0，说明锁没有被线程占有，可以试图获取锁</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              <span class=\"comment\">//如果前面没有线程排队，就用CAS把state从0更新为1</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class=\"line\">                  compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">//获取到锁了，标记一下，告诉大家，现在是本线程占用了锁</span></span><br><span class=\"line\">                  setExclusiveOwnerThread(current);</span><br><span class=\"line\">                  <span class=\"comment\">//锁获取成功，直接返回</span></span><br><span class=\"line\">                  <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">    <span class=\"comment\">//c不等于0或者上面CAS操作失败了，说明锁被某线程占有</span></span><br><span class=\"line\">   <span class=\"comment\">//重入就在下面这段代码实现的</span></span><br><span class=\"line\">   <span class=\"comment\">//由于ReentrantLock是可重入，如果获取锁的线程是当前线程，那还是可以再操作一波的</span></span><br><span class=\"line\">          <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">              <span class=\"comment\">//重入了就对state再加1，别忘了acquires是写死为1的</span></span><br><span class=\"line\">              <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">              <span class=\"comment\">//注意：可重入锁加了几次就要释放几次</span></span><br><span class=\"line\">              setState(nextc);</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"非公平锁\"><a href=\"#非公平锁\" class=\"headerlink\" title=\"非公平锁\"></a>非公平锁</h2><p>非公平锁就两方法lock和tryAcquire</p>\n<h3 id=\"lock-1\"><a href=\"#lock-1\" class=\"headerlink\" title=\"lock\"></a>lock</h3><p>第一次不加队列，直接先CAS试图获取锁。没有成功在走AQS的acquire方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">             setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">         <span class=\"keyword\">else</span></span><br><span class=\"line\">             <span class=\"comment\">//没有成功在走AQS的acquire方法,去排队。</span></span><br><span class=\"line\">             acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AQS的acquire-1\"><a href=\"#AQS的acquire-1\" class=\"headerlink\" title=\"AQS的acquire\"></a>AQS的acquire</h3><p><em>点进acquire方法发现它跳到 AQS的acquire方法里去了，而点进AQS的tryAcquire发现它只抛出一个不支持操作的异常。也就是说在公平锁里，加锁这个操作用的AQS的<strong>acquire</strong>（和非公平锁<strong>共用</strong>），而<strong>tryAcquire</strong>是公平锁和非公平锁<strong>各自</strong>实现的。</em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>### </p>\n<h3 id=\"tryAcquire-1\"><a href=\"#tryAcquire-1\" class=\"headerlink\" title=\"tryAcquire\"></a>tryAcquire</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">       <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class=\"line\">               compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">               setExclusiveOwnerThread(current);</span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">           setState(nextc);</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"tryRelease\"><a href=\"#tryRelease\" class=\"headerlink\" title=\"tryRelease()\"></a>tryRelease()</h2><p>可重入方式的释放锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//只是State减1，还未更新</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\">    <span class=\"comment\">//如果获取锁的线程不是当前线程，释放失败</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    </span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//State等于0，锁被释放了</span></span><br><span class=\"line\">    <span class=\"comment\">//也有可能减1后不等于0，因为可重入锁的State的可以一直加的</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">           free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">       &#125;<span class=\"comment\">//更新</span></span><br><span class=\"line\">       setState(c);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Synchronized与ReentrantLock的区别\"><a href=\"#Synchronized与ReentrantLock的区别\" class=\"headerlink\" title=\"Synchronized与ReentrantLock的区别\"></a>Synchronized与ReentrantLock的区别</h2><p>1）互斥锁<br>2）可重入<br>3）都保证了可见性和互斥性<br>两者的不同点：<br>1）ReentrantLock显示获得、释放锁，synchronized隐式获得释放锁<br>2）ReentrantLock可响应中断、可轮回，synchronized是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性<br>3）ReentrantLock是API级别的，synchronized是JVM级别的<br>4）ReentrantLock可以实现公平锁<br>5）ReentrantLock通过Condition可以绑定多个条件<br>6）底层实现不一样， synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略</p>\n"},{"title":"CAS核心原理","date":"2019-08-25T12:09:50.000Z","description":"一文搞懂CAS核心原理","_content":"\n\n\n[TOC]\n\n# CAS介绍\n\n\n\n## 什么是乐观锁和悲观锁？\n\n众所周知，悲观锁的先加锁在操作，因为悲观锁悲观的认为一定会有别的线程来修改数据。而乐观锁不同，它先操作，在判断数据是否被修改，修改就重试或者抛出异常，因为乐观锁乐观的认为不会有别的线程来修改数据（有句谚语：原谅比准许更容易得到。）。它两的**关键区别在于是先加锁还是先操作**。\n\n## cas是怎么解决线程不安全的问题？\n\n在多线程更新一个变量的情况下，可能会出现这样的问题，当a线程拷贝了一份主内存的变量到工作内存进行计算的时候，这个变量已经其他线程改变了，a做完了计算，此时的结果的错误的，如果刷新到主内存会覆盖中间其他线程的改变，因此我们希望出现这种情况的时候，**a能检测到此时的数据已经变脏，并把这个计算结果丢弃，重新计算，这就是cas。**\n\n\n\nCAS全称 Compare And Swap（比较与交换），CAS更新的值是原值算出来的，**如果原值已经被更改了，那么自增的更新值肯定也不对了。**最后一步要赋值的时候，把主内存的值与之前没计算的值做比较，相等一步到位把值更新了，不相等就放弃计算出来的值。\n\n\n\n# CAS关键\n\n关键在于，比较与交换这个**两个步骤**，在操作系统中对应的是**一条处理器指令**——CMPXCHG指令，而它是原子的！\n\n两个步骤是怎么做到原子的呢？当然是加锁啦，CAS通过LOCK CMPXCHG`（带`LOCK`前缀）来加锁。是不是有点晕了，说好的CAS是无锁的呢！其实，无锁算法的并不是完全消除同步、完全不加锁，只是它将同步减少到**CPU本身提供的单个指令原子操作**。\n\n无锁指的是不加high-level locks。high-level locks指可以保证任何时间只有一个线程操作数据的那种锁，想做到这个地步，它必须将其他线程挂起，将一个线程挂起大概花费**8万个时钟周期**，而且它还需要维护一个线程的等待队列（就像AQS所做的一样）。这与CPU 的LOCK前缀功能完全不同，LOCK前缀仅保护**单个指令原子性**，因此可能仅在该单个指令的持续时间内保留其他线程。这是由CPU本身实现的，一条指令大概花费**3个时钟周期**。当然CAS失败之后需要重试，但不论如何都比直接挂起线程效率高。\n\n可以想想，悲观锁在操作的过程一直持有锁。而乐观锁操作的过程是没有加锁的，其他线程也可以修改这个数据，乐观锁只有在最后的比较交换这条cpu指令加锁检查是否出现不一致。\n\n[如果还不理解可以看看stackoverflow的这个回答](https://stackoverflow.com/questions/27837731/is-x86-cmpxchg-atomic-if-so-why-does-it-need-lock)\n\n\n\n\n\nCAS的问题\n\n1. ABA问题\n\n   CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。**ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。**\n\n   *JDK从1.5开始提供了**AtomicStampedReference**类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。*\n\n2. **循环时间长开销大**。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。\n\n## volatile+Unsafe\n\nvalue是一个volatile变量，因此JVM可以保证任何时刻任何线程都能拿到该变量的最新值。\n\n```\nprivate volatile int value;\n```\n\n\n\n整个atomic都是基于`Unsafe`实现的，这个类里都是native本地方法。Unsafe通过通过单例模式来提供实例对象。\n\n```java\npublic final native boolean compareAndSwapInt(\n            Object o, long offset, int expected, int x);\n```\n\n这个方法可以在获得对象o的**内存偏移量**offset后与期望值比较，如果等于期望值，就更新为x。\n\n一个对象的属性=该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。这直接操作内存的。\n\n**为什么要直接操作内存呢？因为快呀。尤其当被修改的属性是一个对象的时候。**\n\n*插一嘴题外话，为什么它叫unsafe类？因为它封装了一些计算指针偏移量的操作，这种指针操作是很危险的，指针操作不当有可能覆盖别人的内存导致系统崩溃。Java抛弃了指针，jdk是不许用户应用程序获取Unsafe这个类的实例。在获得唯一可以Unsafe类实例的工厂方法里，它会检查调用类的类加载器如果不为null，就抛出异常拒绝工作。而只有Bootstrap类加载器会返回null。也就是说我们自己写的java类是无法直接使用Unsafe类（除非用反射）*\n\n这里我们主要关注它提供的几个方法：\n\n# CAS实现\n\nJDK中juc并发包里有12个原子类，原子类顾名思义是为了使操作是原子的，而实现的原理正是CAS。\n\n### 12个类\n\n#### 原子更新基本类型3个\n\n- AtomicBoolean\n- AtomicInteger\n- AtomicLong\n\n1.7,1.8 的实现方式有一丝丝的不同，1.7看似更好理解，这里以1.7为例。\n\n```java\n    public final int getAndIncrement() {\n        for (;;) {\n            int current = get();\n            int next = current + 1;\n            if (compareAndSet(current, next))\n                return current;\n        }\n    }\n```\n\n这是我们熟悉的CAS算法套路：\n\n- 循环重试，如果下一步的CAS更新失败，说明有线程修改了当前值。没关系。舍弃失败的操作，再次循环直达成功\n- 获取当前值进行加1 操作\n- 调用compareAndSet方法原子更新操作\n\ncompareAndSet调用unsafe类的compareAndSwapInt**本地方法**\n\n- unsafe： 获取并操作内存的数据。\n- valueOffset： 存储value在AtomicInteger中的偏移量。\n- value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。\n\n```java\npublic final boolean compareAndSet(int expect, int update) {\n//unsafe.compareAndSwapInt为native方法\n        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n    }\n```\n\ncompareAndSwapInt本地方法\n\n```java\n public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);\n```\n\n#### 原子更新数组3个\n\n- AtomicIntegerArray\n- AtomicLongArray\n- AtomicReferenceArray\n\n#### 原子更新引用类型3个\n\n- AtomicReference：原子更新引用类型\n- AtomicMarkableReference：原子更新带有标记位的引用类型。\n- AtomicStampedReference：原子更新带有**版本号**的引用类型。\n\n特别说一下AtomicStampedReference，它与原子引用不一样的地方在于，它使用版本号解决ABA问题。它调用比较交换方法时除了传入原值和要更新的值，还需要传入原版本号和版本号加一。这样每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。\n\n#### 原子更新器3个\n\n可以让普通的变量也享受CAS操作。\n\n- AtomicIntegerFieldUpdater：原子更新整型字段\n\n- AtomicLongFieldUpdater：原子更新长整型字段\n\n- AtomicReferenceFieldUpdater：原子更新引用类型里的字段\n\n  \n\n实例代码\n\n```java\n   //创建一个原子更新器\n    private static AtomicIntegerFieldUpdater<User> atomicIntegerFieldUpdater =\n            AtomicIntegerFieldUpdater.newUpdater(User.class,\"old\");\n\n    public static void main(String[] args){\n      \tvolatile  User user = new User(\"Tom\",15);\n        //原来的年龄\n        System.out.println(atomicIntegerFieldUpdater.getAndIncrement(user));\n        //现在的年龄\n        System.out.println(atomicIntegerFieldUpdater.get(user));\n    }\n\n```\n\n","source":"_posts/CAS.md","raw":"---\ntitle: CAS核心原理\ndate: 2019-08-25 20:09:50\ncategories: 并发\ndescription: 一文搞懂CAS核心原理\n\n---\n\n\n\n[TOC]\n\n# CAS介绍\n\n\n\n## 什么是乐观锁和悲观锁？\n\n众所周知，悲观锁的先加锁在操作，因为悲观锁悲观的认为一定会有别的线程来修改数据。而乐观锁不同，它先操作，在判断数据是否被修改，修改就重试或者抛出异常，因为乐观锁乐观的认为不会有别的线程来修改数据（有句谚语：原谅比准许更容易得到。）。它两的**关键区别在于是先加锁还是先操作**。\n\n## cas是怎么解决线程不安全的问题？\n\n在多线程更新一个变量的情况下，可能会出现这样的问题，当a线程拷贝了一份主内存的变量到工作内存进行计算的时候，这个变量已经其他线程改变了，a做完了计算，此时的结果的错误的，如果刷新到主内存会覆盖中间其他线程的改变，因此我们希望出现这种情况的时候，**a能检测到此时的数据已经变脏，并把这个计算结果丢弃，重新计算，这就是cas。**\n\n\n\nCAS全称 Compare And Swap（比较与交换），CAS更新的值是原值算出来的，**如果原值已经被更改了，那么自增的更新值肯定也不对了。**最后一步要赋值的时候，把主内存的值与之前没计算的值做比较，相等一步到位把值更新了，不相等就放弃计算出来的值。\n\n\n\n# CAS关键\n\n关键在于，比较与交换这个**两个步骤**，在操作系统中对应的是**一条处理器指令**——CMPXCHG指令，而它是原子的！\n\n两个步骤是怎么做到原子的呢？当然是加锁啦，CAS通过LOCK CMPXCHG`（带`LOCK`前缀）来加锁。是不是有点晕了，说好的CAS是无锁的呢！其实，无锁算法的并不是完全消除同步、完全不加锁，只是它将同步减少到**CPU本身提供的单个指令原子操作**。\n\n无锁指的是不加high-level locks。high-level locks指可以保证任何时间只有一个线程操作数据的那种锁，想做到这个地步，它必须将其他线程挂起，将一个线程挂起大概花费**8万个时钟周期**，而且它还需要维护一个线程的等待队列（就像AQS所做的一样）。这与CPU 的LOCK前缀功能完全不同，LOCK前缀仅保护**单个指令原子性**，因此可能仅在该单个指令的持续时间内保留其他线程。这是由CPU本身实现的，一条指令大概花费**3个时钟周期**。当然CAS失败之后需要重试，但不论如何都比直接挂起线程效率高。\n\n可以想想，悲观锁在操作的过程一直持有锁。而乐观锁操作的过程是没有加锁的，其他线程也可以修改这个数据，乐观锁只有在最后的比较交换这条cpu指令加锁检查是否出现不一致。\n\n[如果还不理解可以看看stackoverflow的这个回答](https://stackoverflow.com/questions/27837731/is-x86-cmpxchg-atomic-if-so-why-does-it-need-lock)\n\n\n\n\n\nCAS的问题\n\n1. ABA问题\n\n   CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。**ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。**\n\n   *JDK从1.5开始提供了**AtomicStampedReference**类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。*\n\n2. **循环时间长开销大**。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。\n\n## volatile+Unsafe\n\nvalue是一个volatile变量，因此JVM可以保证任何时刻任何线程都能拿到该变量的最新值。\n\n```\nprivate volatile int value;\n```\n\n\n\n整个atomic都是基于`Unsafe`实现的，这个类里都是native本地方法。Unsafe通过通过单例模式来提供实例对象。\n\n```java\npublic final native boolean compareAndSwapInt(\n            Object o, long offset, int expected, int x);\n```\n\n这个方法可以在获得对象o的**内存偏移量**offset后与期望值比较，如果等于期望值，就更新为x。\n\n一个对象的属性=该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。这直接操作内存的。\n\n**为什么要直接操作内存呢？因为快呀。尤其当被修改的属性是一个对象的时候。**\n\n*插一嘴题外话，为什么它叫unsafe类？因为它封装了一些计算指针偏移量的操作，这种指针操作是很危险的，指针操作不当有可能覆盖别人的内存导致系统崩溃。Java抛弃了指针，jdk是不许用户应用程序获取Unsafe这个类的实例。在获得唯一可以Unsafe类实例的工厂方法里，它会检查调用类的类加载器如果不为null，就抛出异常拒绝工作。而只有Bootstrap类加载器会返回null。也就是说我们自己写的java类是无法直接使用Unsafe类（除非用反射）*\n\n这里我们主要关注它提供的几个方法：\n\n# CAS实现\n\nJDK中juc并发包里有12个原子类，原子类顾名思义是为了使操作是原子的，而实现的原理正是CAS。\n\n### 12个类\n\n#### 原子更新基本类型3个\n\n- AtomicBoolean\n- AtomicInteger\n- AtomicLong\n\n1.7,1.8 的实现方式有一丝丝的不同，1.7看似更好理解，这里以1.7为例。\n\n```java\n    public final int getAndIncrement() {\n        for (;;) {\n            int current = get();\n            int next = current + 1;\n            if (compareAndSet(current, next))\n                return current;\n        }\n    }\n```\n\n这是我们熟悉的CAS算法套路：\n\n- 循环重试，如果下一步的CAS更新失败，说明有线程修改了当前值。没关系。舍弃失败的操作，再次循环直达成功\n- 获取当前值进行加1 操作\n- 调用compareAndSet方法原子更新操作\n\ncompareAndSet调用unsafe类的compareAndSwapInt**本地方法**\n\n- unsafe： 获取并操作内存的数据。\n- valueOffset： 存储value在AtomicInteger中的偏移量。\n- value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。\n\n```java\npublic final boolean compareAndSet(int expect, int update) {\n//unsafe.compareAndSwapInt为native方法\n        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n    }\n```\n\ncompareAndSwapInt本地方法\n\n```java\n public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);\n```\n\n#### 原子更新数组3个\n\n- AtomicIntegerArray\n- AtomicLongArray\n- AtomicReferenceArray\n\n#### 原子更新引用类型3个\n\n- AtomicReference：原子更新引用类型\n- AtomicMarkableReference：原子更新带有标记位的引用类型。\n- AtomicStampedReference：原子更新带有**版本号**的引用类型。\n\n特别说一下AtomicStampedReference，它与原子引用不一样的地方在于，它使用版本号解决ABA问题。它调用比较交换方法时除了传入原值和要更新的值，还需要传入原版本号和版本号加一。这样每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。\n\n#### 原子更新器3个\n\n可以让普通的变量也享受CAS操作。\n\n- AtomicIntegerFieldUpdater：原子更新整型字段\n\n- AtomicLongFieldUpdater：原子更新长整型字段\n\n- AtomicReferenceFieldUpdater：原子更新引用类型里的字段\n\n  \n\n实例代码\n\n```java\n   //创建一个原子更新器\n    private static AtomicIntegerFieldUpdater<User> atomicIntegerFieldUpdater =\n            AtomicIntegerFieldUpdater.newUpdater(User.class,\"old\");\n\n    public static void main(String[] args){\n      \tvolatile  User user = new User(\"Tom\",15);\n        //原来的年龄\n        System.out.println(atomicIntegerFieldUpdater.getAndIncrement(user));\n        //现在的年龄\n        System.out.println(atomicIntegerFieldUpdater.get(user));\n    }\n\n```\n\n","slug":"CAS","published":1,"updated":"2022-02-08T07:09:41.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qjp0001w9rpuwhq8iaf","content":"<p>[TOC]</p>\n<h1 id=\"CAS介绍\"><a href=\"#CAS介绍\" class=\"headerlink\" title=\"CAS介绍\"></a>CAS介绍</h1><h2 id=\"什么是乐观锁和悲观锁？\"><a href=\"#什么是乐观锁和悲观锁？\" class=\"headerlink\" title=\"什么是乐观锁和悲观锁？\"></a>什么是乐观锁和悲观锁？</h2><p>众所周知，悲观锁的先加锁在操作，因为悲观锁悲观的认为一定会有别的线程来修改数据。而乐观锁不同，它先操作，在判断数据是否被修改，修改就重试或者抛出异常，因为乐观锁乐观的认为不会有别的线程来修改数据（有句谚语：原谅比准许更容易得到。）。它两的<strong>关键区别在于是先加锁还是先操作</strong>。</p>\n<h2 id=\"cas是怎么解决线程不安全的问题？\"><a href=\"#cas是怎么解决线程不安全的问题？\" class=\"headerlink\" title=\"cas是怎么解决线程不安全的问题？\"></a>cas是怎么解决线程不安全的问题？</h2><p>在多线程更新一个变量的情况下，可能会出现这样的问题，当a线程拷贝了一份主内存的变量到工作内存进行计算的时候，这个变量已经其他线程改变了，a做完了计算，此时的结果的错误的，如果刷新到主内存会覆盖中间其他线程的改变，因此我们希望出现这种情况的时候，<strong>a能检测到此时的数据已经变脏，并把这个计算结果丢弃，重新计算，这就是cas。</strong></p>\n<p>CAS全称 Compare And Swap（比较与交换），CAS更新的值是原值算出来的，<strong>如果原值已经被更改了，那么自增的更新值肯定也不对了。</strong>最后一步要赋值的时候，把主内存的值与之前没计算的值做比较，相等一步到位把值更新了，不相等就放弃计算出来的值。</p>\n<h1 id=\"CAS关键\"><a href=\"#CAS关键\" class=\"headerlink\" title=\"CAS关键\"></a>CAS关键</h1><p>关键在于，比较与交换这个<strong>两个步骤</strong>，在操作系统中对应的是<strong>一条处理器指令</strong>——CMPXCHG指令，而它是原子的！</p>\n<p>两个步骤是怎么做到原子的呢？当然是加锁啦，CAS通过LOCK CMPXCHG<code>（带</code>LOCK`前缀）来加锁。是不是有点晕了，说好的CAS是无锁的呢！其实，无锁算法的并不是完全消除同步、完全不加锁，只是它将同步减少到<strong>CPU本身提供的单个指令原子操作</strong>。</p>\n<p>无锁指的是不加high-level locks。high-level locks指可以保证任何时间只有一个线程操作数据的那种锁，想做到这个地步，它必须将其他线程挂起，将一个线程挂起大概花费<strong>8万个时钟周期</strong>，而且它还需要维护一个线程的等待队列（就像AQS所做的一样）。这与CPU 的LOCK前缀功能完全不同，LOCK前缀仅保护<strong>单个指令原子性</strong>，因此可能仅在该单个指令的持续时间内保留其他线程。这是由CPU本身实现的，一条指令大概花费<strong>3个时钟周期</strong>。当然CAS失败之后需要重试，但不论如何都比直接挂起线程效率高。</p>\n<p>可以想想，悲观锁在操作的过程一直持有锁。而乐观锁操作的过程是没有加锁的，其他线程也可以修改这个数据，乐观锁只有在最后的比较交换这条cpu指令加锁检查是否出现不一致。</p>\n<p><a href=\"https://stackoverflow.com/questions/27837731/is-x86-cmpxchg-atomic-if-so-why-does-it-need-lock\" target=\"_blank\" rel=\"noopener\">如果还不理解可以看看stackoverflow的这个回答</a></p>\n<p>CAS的问题</p>\n<ol>\n<li><p>ABA问题</p>\n<p>CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。<strong>ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</strong></p>\n<p><em>JDK从1.5开始提供了<strong>AtomicStampedReference</strong>类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</em></p>\n</li>\n<li><p><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p>\n</li>\n</ol>\n<h2 id=\"volatile-Unsafe\"><a href=\"#volatile-Unsafe\" class=\"headerlink\" title=\"volatile+Unsafe\"></a>volatile+Unsafe</h2><p>value是一个volatile变量，因此JVM可以保证任何时刻任何线程都能拿到该变量的最新值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private volatile int value;</span><br></pre></td></tr></table></figure>\n<p>整个atomic都是基于<code>Unsafe</code>实现的，这个类里都是native本地方法。Unsafe通过通过单例模式来提供实例对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSwapInt</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Object o, <span class=\"keyword\">long</span> offset, <span class=\"keyword\">int</span> expected, <span class=\"keyword\">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>这个方法可以在获得对象o的<strong>内存偏移量</strong>offset后与期望值比较，如果等于期望值，就更新为x。</p>\n<p>一个对象的属性=该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。这直接操作内存的。</p>\n<p><strong>为什么要直接操作内存呢？因为快呀。尤其当被修改的属性是一个对象的时候。</strong></p>\n<p><em>插一嘴题外话，为什么它叫unsafe类？因为它封装了一些计算指针偏移量的操作，这种指针操作是很危险的，指针操作不当有可能覆盖别人的内存导致系统崩溃。Java抛弃了指针，jdk是不许用户应用程序获取Unsafe这个类的实例。在获得唯一可以Unsafe类实例的工厂方法里，它会检查调用类的类加载器如果不为null，就抛出异常拒绝工作。而只有Bootstrap类加载器会返回null。也就是说我们自己写的java类是无法直接使用Unsafe类（除非用反射）</em></p>\n<p>这里我们主要关注它提供的几个方法：</p>\n<h1 id=\"CAS实现\"><a href=\"#CAS实现\" class=\"headerlink\" title=\"CAS实现\"></a>CAS实现</h1><p>JDK中juc并发包里有12个原子类，原子类顾名思义是为了使操作是原子的，而实现的原理正是CAS。</p>\n<h3 id=\"12个类\"><a href=\"#12个类\" class=\"headerlink\" title=\"12个类\"></a>12个类</h3><h4 id=\"原子更新基本类型3个\"><a href=\"#原子更新基本类型3个\" class=\"headerlink\" title=\"原子更新基本类型3个\"></a>原子更新基本类型3个</h4><ul>\n<li>AtomicBoolean</li>\n<li>AtomicInteger</li>\n<li>AtomicLong</li>\n</ul>\n<p>1.7,1.8 的实现方式有一丝丝的不同，1.7看似更好理解，这里以1.7为例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndIncrement</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> current = get();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> next = current + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSet(current, next))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是我们熟悉的CAS算法套路：</p>\n<ul>\n<li>循环重试，如果下一步的CAS更新失败，说明有线程修改了当前值。没关系。舍弃失败的操作，再次循环直达成功</li>\n<li>获取当前值进行加1 操作</li>\n<li>调用compareAndSet方法原子更新操作</li>\n</ul>\n<p>compareAndSet调用unsafe类的compareAndSwapInt<strong>本地方法</strong></p>\n<ul>\n<li>unsafe： 获取并操作内存的数据。</li>\n<li>valueOffset： 存储value在AtomicInteger中的偏移量。</li>\n<li>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSet</span><span class=\"params\">(<span class=\"keyword\">int</span> expect, <span class=\"keyword\">int</span> update)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//unsafe.compareAndSwapInt为native方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"keyword\">this</span>, valueOffset, expect, update);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>compareAndSwapInt本地方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSwapInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4, <span class=\"keyword\">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"原子更新数组3个\"><a href=\"#原子更新数组3个\" class=\"headerlink\" title=\"原子更新数组3个\"></a>原子更新数组3个</h4><ul>\n<li>AtomicIntegerArray</li>\n<li>AtomicLongArray</li>\n<li>AtomicReferenceArray</li>\n</ul>\n<h4 id=\"原子更新引用类型3个\"><a href=\"#原子更新引用类型3个\" class=\"headerlink\" title=\"原子更新引用类型3个\"></a>原子更新引用类型3个</h4><ul>\n<li>AtomicReference：原子更新引用类型</li>\n<li>AtomicMarkableReference：原子更新带有标记位的引用类型。</li>\n<li>AtomicStampedReference：原子更新带有<strong>版本号</strong>的引用类型。</li>\n</ul>\n<p>特别说一下AtomicStampedReference，它与原子引用不一样的地方在于，它使用版本号解决ABA问题。它调用比较交换方法时除了传入原值和要更新的值，还需要传入原版本号和版本号加一。这样每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p>\n<h4 id=\"原子更新器3个\"><a href=\"#原子更新器3个\" class=\"headerlink\" title=\"原子更新器3个\"></a>原子更新器3个</h4><p>可以让普通的变量也享受CAS操作。</p>\n<ul>\n<li><p>AtomicIntegerFieldUpdater：原子更新整型字段</p>\n</li>\n<li><p>AtomicLongFieldUpdater：原子更新长整型字段</p>\n</li>\n<li><p>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</p>\n</li>\n</ul>\n<p>实例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建一个原子更新器</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicIntegerFieldUpdater&lt;User&gt; atomicIntegerFieldUpdater =</span><br><span class=\"line\">         AtomicIntegerFieldUpdater.newUpdater(User.class,<span class=\"string\">\"old\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">volatile</span>  User user = <span class=\"keyword\">new</span> User(<span class=\"string\">\"Tom\"</span>,<span class=\"number\">15</span>);</span><br><span class=\"line\">     <span class=\"comment\">//原来的年龄</span></span><br><span class=\"line\">     System.out.println(atomicIntegerFieldUpdater.getAndIncrement(user));</span><br><span class=\"line\">     <span class=\"comment\">//现在的年龄</span></span><br><span class=\"line\">     System.out.println(atomicIntegerFieldUpdater.get(user));</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"CAS介绍\"><a href=\"#CAS介绍\" class=\"headerlink\" title=\"CAS介绍\"></a>CAS介绍</h1><h2 id=\"什么是乐观锁和悲观锁？\"><a href=\"#什么是乐观锁和悲观锁？\" class=\"headerlink\" title=\"什么是乐观锁和悲观锁？\"></a>什么是乐观锁和悲观锁？</h2><p>众所周知，悲观锁的先加锁在操作，因为悲观锁悲观的认为一定会有别的线程来修改数据。而乐观锁不同，它先操作，在判断数据是否被修改，修改就重试或者抛出异常，因为乐观锁乐观的认为不会有别的线程来修改数据（有句谚语：原谅比准许更容易得到。）。它两的<strong>关键区别在于是先加锁还是先操作</strong>。</p>\n<h2 id=\"cas是怎么解决线程不安全的问题？\"><a href=\"#cas是怎么解决线程不安全的问题？\" class=\"headerlink\" title=\"cas是怎么解决线程不安全的问题？\"></a>cas是怎么解决线程不安全的问题？</h2><p>在多线程更新一个变量的情况下，可能会出现这样的问题，当a线程拷贝了一份主内存的变量到工作内存进行计算的时候，这个变量已经其他线程改变了，a做完了计算，此时的结果的错误的，如果刷新到主内存会覆盖中间其他线程的改变，因此我们希望出现这种情况的时候，<strong>a能检测到此时的数据已经变脏，并把这个计算结果丢弃，重新计算，这就是cas。</strong></p>\n<p>CAS全称 Compare And Swap（比较与交换），CAS更新的值是原值算出来的，<strong>如果原值已经被更改了，那么自增的更新值肯定也不对了。</strong>最后一步要赋值的时候，把主内存的值与之前没计算的值做比较，相等一步到位把值更新了，不相等就放弃计算出来的值。</p>\n<h1 id=\"CAS关键\"><a href=\"#CAS关键\" class=\"headerlink\" title=\"CAS关键\"></a>CAS关键</h1><p>关键在于，比较与交换这个<strong>两个步骤</strong>，在操作系统中对应的是<strong>一条处理器指令</strong>——CMPXCHG指令，而它是原子的！</p>\n<p>两个步骤是怎么做到原子的呢？当然是加锁啦，CAS通过LOCK CMPXCHG<code>（带</code>LOCK`前缀）来加锁。是不是有点晕了，说好的CAS是无锁的呢！其实，无锁算法的并不是完全消除同步、完全不加锁，只是它将同步减少到<strong>CPU本身提供的单个指令原子操作</strong>。</p>\n<p>无锁指的是不加high-level locks。high-level locks指可以保证任何时间只有一个线程操作数据的那种锁，想做到这个地步，它必须将其他线程挂起，将一个线程挂起大概花费<strong>8万个时钟周期</strong>，而且它还需要维护一个线程的等待队列（就像AQS所做的一样）。这与CPU 的LOCK前缀功能完全不同，LOCK前缀仅保护<strong>单个指令原子性</strong>，因此可能仅在该单个指令的持续时间内保留其他线程。这是由CPU本身实现的，一条指令大概花费<strong>3个时钟周期</strong>。当然CAS失败之后需要重试，但不论如何都比直接挂起线程效率高。</p>\n<p>可以想想，悲观锁在操作的过程一直持有锁。而乐观锁操作的过程是没有加锁的，其他线程也可以修改这个数据，乐观锁只有在最后的比较交换这条cpu指令加锁检查是否出现不一致。</p>\n<p><a href=\"https://stackoverflow.com/questions/27837731/is-x86-cmpxchg-atomic-if-so-why-does-it-need-lock\" target=\"_blank\" rel=\"noopener\">如果还不理解可以看看stackoverflow的这个回答</a></p>\n<p>CAS的问题</p>\n<ol>\n<li><p>ABA问题</p>\n<p>CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。<strong>ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</strong></p>\n<p><em>JDK从1.5开始提供了<strong>AtomicStampedReference</strong>类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</em></p>\n</li>\n<li><p><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p>\n</li>\n</ol>\n<h2 id=\"volatile-Unsafe\"><a href=\"#volatile-Unsafe\" class=\"headerlink\" title=\"volatile+Unsafe\"></a>volatile+Unsafe</h2><p>value是一个volatile变量，因此JVM可以保证任何时刻任何线程都能拿到该变量的最新值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private volatile int value;</span><br></pre></td></tr></table></figure>\n<p>整个atomic都是基于<code>Unsafe</code>实现的，这个类里都是native本地方法。Unsafe通过通过单例模式来提供实例对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSwapInt</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Object o, <span class=\"keyword\">long</span> offset, <span class=\"keyword\">int</span> expected, <span class=\"keyword\">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>这个方法可以在获得对象o的<strong>内存偏移量</strong>offset后与期望值比较，如果等于期望值，就更新为x。</p>\n<p>一个对象的属性=该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。这直接操作内存的。</p>\n<p><strong>为什么要直接操作内存呢？因为快呀。尤其当被修改的属性是一个对象的时候。</strong></p>\n<p><em>插一嘴题外话，为什么它叫unsafe类？因为它封装了一些计算指针偏移量的操作，这种指针操作是很危险的，指针操作不当有可能覆盖别人的内存导致系统崩溃。Java抛弃了指针，jdk是不许用户应用程序获取Unsafe这个类的实例。在获得唯一可以Unsafe类实例的工厂方法里，它会检查调用类的类加载器如果不为null，就抛出异常拒绝工作。而只有Bootstrap类加载器会返回null。也就是说我们自己写的java类是无法直接使用Unsafe类（除非用反射）</em></p>\n<p>这里我们主要关注它提供的几个方法：</p>\n<h1 id=\"CAS实现\"><a href=\"#CAS实现\" class=\"headerlink\" title=\"CAS实现\"></a>CAS实现</h1><p>JDK中juc并发包里有12个原子类，原子类顾名思义是为了使操作是原子的，而实现的原理正是CAS。</p>\n<h3 id=\"12个类\"><a href=\"#12个类\" class=\"headerlink\" title=\"12个类\"></a>12个类</h3><h4 id=\"原子更新基本类型3个\"><a href=\"#原子更新基本类型3个\" class=\"headerlink\" title=\"原子更新基本类型3个\"></a>原子更新基本类型3个</h4><ul>\n<li>AtomicBoolean</li>\n<li>AtomicInteger</li>\n<li>AtomicLong</li>\n</ul>\n<p>1.7,1.8 的实现方式有一丝丝的不同，1.7看似更好理解，这里以1.7为例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndIncrement</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> current = get();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> next = current + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSet(current, next))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是我们熟悉的CAS算法套路：</p>\n<ul>\n<li>循环重试，如果下一步的CAS更新失败，说明有线程修改了当前值。没关系。舍弃失败的操作，再次循环直达成功</li>\n<li>获取当前值进行加1 操作</li>\n<li>调用compareAndSet方法原子更新操作</li>\n</ul>\n<p>compareAndSet调用unsafe类的compareAndSwapInt<strong>本地方法</strong></p>\n<ul>\n<li>unsafe： 获取并操作内存的数据。</li>\n<li>valueOffset： 存储value在AtomicInteger中的偏移量。</li>\n<li>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSet</span><span class=\"params\">(<span class=\"keyword\">int</span> expect, <span class=\"keyword\">int</span> update)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//unsafe.compareAndSwapInt为native方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"keyword\">this</span>, valueOffset, expect, update);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>compareAndSwapInt本地方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSwapInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4, <span class=\"keyword\">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"原子更新数组3个\"><a href=\"#原子更新数组3个\" class=\"headerlink\" title=\"原子更新数组3个\"></a>原子更新数组3个</h4><ul>\n<li>AtomicIntegerArray</li>\n<li>AtomicLongArray</li>\n<li>AtomicReferenceArray</li>\n</ul>\n<h4 id=\"原子更新引用类型3个\"><a href=\"#原子更新引用类型3个\" class=\"headerlink\" title=\"原子更新引用类型3个\"></a>原子更新引用类型3个</h4><ul>\n<li>AtomicReference：原子更新引用类型</li>\n<li>AtomicMarkableReference：原子更新带有标记位的引用类型。</li>\n<li>AtomicStampedReference：原子更新带有<strong>版本号</strong>的引用类型。</li>\n</ul>\n<p>特别说一下AtomicStampedReference，它与原子引用不一样的地方在于，它使用版本号解决ABA问题。它调用比较交换方法时除了传入原值和要更新的值，还需要传入原版本号和版本号加一。这样每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p>\n<h4 id=\"原子更新器3个\"><a href=\"#原子更新器3个\" class=\"headerlink\" title=\"原子更新器3个\"></a>原子更新器3个</h4><p>可以让普通的变量也享受CAS操作。</p>\n<ul>\n<li><p>AtomicIntegerFieldUpdater：原子更新整型字段</p>\n</li>\n<li><p>AtomicLongFieldUpdater：原子更新长整型字段</p>\n</li>\n<li><p>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</p>\n</li>\n</ul>\n<p>实例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建一个原子更新器</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicIntegerFieldUpdater&lt;User&gt; atomicIntegerFieldUpdater =</span><br><span class=\"line\">         AtomicIntegerFieldUpdater.newUpdater(User.class,<span class=\"string\">\"old\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">volatile</span>  User user = <span class=\"keyword\">new</span> User(<span class=\"string\">\"Tom\"</span>,<span class=\"number\">15</span>);</span><br><span class=\"line\">     <span class=\"comment\">//原来的年龄</span></span><br><span class=\"line\">     System.out.println(atomicIntegerFieldUpdater.getAndIncrement(user));</span><br><span class=\"line\">     <span class=\"comment\">//现在的年龄</span></span><br><span class=\"line\">     System.out.println(atomicIntegerFieldUpdater.get(user));</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Fast-fail与Fast-safe","date":"2019-08-01T12:12:50.000Z","description":"Fast-fail与Fast-safe","_content":"\n\n\n## Fast-fail\n\n#### 是什么\n\n**fail-fast,即快速失败机制，它是java集合中的一种错误检测机制，当多个线程或者单个线程,在结构上对集合进行改变时，就有可能会产生fail-fast机制。**\n\n*注意：结构上的改变的意思是，例如集合上的**插入和删除**就是结构上的改变，但是，如果是对集合中某个元素进行**修改**的话，并不是结构上的改变。* \n\n\n\n#### 为什么\n\n为什么要有快速失败？为什么用for(int i=0;i<list.size();i++)这种形式就能一边遍历一边修改集合？\n\n其实答案很简单，普通for循环时，当一个元素结结构被改变时，集合大小和下标也会随之变化，**size是可以随着你改变变换的**。\n\n但使用了迭代器就不行了。迭代器（Iterator）是工作在一个独立的线程中，并且拥有一个 mutex 锁。 迭代器被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，**这个索引表的内容不会同步改变**，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 迭代器会马上抛出 java.util.ConcurrentModificationException。\n\n最后说一嘴，如果非要在用迭代器的时候删除，可以用迭代器的remove方法。如下\n\n```java\n  if (s.equals(\"a\")) {\n        iter.remove();\n    }\n```\n\n#### 原理\n\n迭代器在执行next()等方法的时候，都会调用**checkForComodification()**这个方法，查看modCount==expectedModCount如果不相等则抛出异常。\n\nexpectedModcount:这个值在对象被创建的时候就被赋予了一个固定的值modCount。也就是说这个值是不变的。也就是说，如果在迭代器遍历元素的时候，如果modCount这个值发生了改变，那么再次遍历时就会抛出异常。 \n\n什么时候modCount会发生改变呢？就是对集合的元素的个数做出改变的时候，modCount的值就会被改变，如果删除，插入。但修改则不会。\n\n\n\n```java\nprivate class Itr implements Iterator<E> {\n  \n        int expectedModCount = modCount;\n        \n         public E next() {\n            checkForComodification();\n            ...省略...\n       }\n            final void checkForComodification() {\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n        }\n}\n```\n\n\n\n## Fast-safe\n\n### 是什么\n\n采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是**先复制原有集合内容**，在拷贝的集合上进行遍历。主要是为了在多线程下可以并发的对集合进行更改。\n\n### 原理\n\n由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。\n\n###  缺点\n\n基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，**迭代器并不能访问到修改后的内容**，即迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。\n\n## 两者区别\n\nFast-fail场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。\n\nFast-fail场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。\n\n> [fail_fast和fail_safe的介绍及区别](https://blog.csdn.net/mlym521/article/details/82465126)\n\n","source":"_posts/Fast-fail与Fast-safe.md","raw":"---\ntitle: Fast-fail与Fast-safe\ndate: 2019-08-01 20:12:50\ncategories: java\ndescription: Fast-fail与Fast-safe\n---\n\n\n\n## Fast-fail\n\n#### 是什么\n\n**fail-fast,即快速失败机制，它是java集合中的一种错误检测机制，当多个线程或者单个线程,在结构上对集合进行改变时，就有可能会产生fail-fast机制。**\n\n*注意：结构上的改变的意思是，例如集合上的**插入和删除**就是结构上的改变，但是，如果是对集合中某个元素进行**修改**的话，并不是结构上的改变。* \n\n\n\n#### 为什么\n\n为什么要有快速失败？为什么用for(int i=0;i<list.size();i++)这种形式就能一边遍历一边修改集合？\n\n其实答案很简单，普通for循环时，当一个元素结结构被改变时，集合大小和下标也会随之变化，**size是可以随着你改变变换的**。\n\n但使用了迭代器就不行了。迭代器（Iterator）是工作在一个独立的线程中，并且拥有一个 mutex 锁。 迭代器被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，**这个索引表的内容不会同步改变**，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 迭代器会马上抛出 java.util.ConcurrentModificationException。\n\n最后说一嘴，如果非要在用迭代器的时候删除，可以用迭代器的remove方法。如下\n\n```java\n  if (s.equals(\"a\")) {\n        iter.remove();\n    }\n```\n\n#### 原理\n\n迭代器在执行next()等方法的时候，都会调用**checkForComodification()**这个方法，查看modCount==expectedModCount如果不相等则抛出异常。\n\nexpectedModcount:这个值在对象被创建的时候就被赋予了一个固定的值modCount。也就是说这个值是不变的。也就是说，如果在迭代器遍历元素的时候，如果modCount这个值发生了改变，那么再次遍历时就会抛出异常。 \n\n什么时候modCount会发生改变呢？就是对集合的元素的个数做出改变的时候，modCount的值就会被改变，如果删除，插入。但修改则不会。\n\n\n\n```java\nprivate class Itr implements Iterator<E> {\n  \n        int expectedModCount = modCount;\n        \n         public E next() {\n            checkForComodification();\n            ...省略...\n       }\n            final void checkForComodification() {\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n        }\n}\n```\n\n\n\n## Fast-safe\n\n### 是什么\n\n采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是**先复制原有集合内容**，在拷贝的集合上进行遍历。主要是为了在多线程下可以并发的对集合进行更改。\n\n### 原理\n\n由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。\n\n###  缺点\n\n基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，**迭代器并不能访问到修改后的内容**，即迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。\n\n## 两者区别\n\nFast-fail场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。\n\nFast-fail场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。\n\n> [fail_fast和fail_safe的介绍及区别](https://blog.csdn.net/mlym521/article/details/82465126)\n\n","slug":"Fast-fail与Fast-safe","published":1,"updated":"2022-02-08T07:09:41.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qjs0003w9rpt5kzsujp","content":"<h2 id=\"Fast-fail\"><a href=\"#Fast-fail\" class=\"headerlink\" title=\"Fast-fail\"></a>Fast-fail</h2><h4 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h4><p><strong>fail-fast,即快速失败机制，它是java集合中的一种错误检测机制，当多个线程或者单个线程,在结构上对集合进行改变时，就有可能会产生fail-fast机制。</strong></p>\n<p><em>注意：结构上的改变的意思是，例如集合上的<strong>插入和删除</strong>就是结构上的改变，但是，如果是对集合中某个元素进行<strong>修改</strong>的话，并不是结构上的改变。</em> </p>\n<h4 id=\"为什么\"><a href=\"#为什么\" class=\"headerlink\" title=\"为什么\"></a>为什么</h4><p>为什么要有快速失败？为什么用for(int i=0;i&lt;list.size();i++)这种形式就能一边遍历一边修改集合？</p>\n<p>其实答案很简单，普通for循环时，当一个元素结结构被改变时，集合大小和下标也会随之变化，<strong>size是可以随着你改变变换的</strong>。</p>\n<p>但使用了迭代器就不行了。迭代器（Iterator）是工作在一个独立的线程中，并且拥有一个 mutex 锁。 迭代器被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，<strong>这个索引表的内容不会同步改变</strong>，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 迭代器会马上抛出 java.util.ConcurrentModificationException。</p>\n<p>最后说一嘴，如果非要在用迭代器的时候删除，可以用迭代器的remove方法。如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (s.equals(<span class=\"string\">\"a\"</span>)) &#123;</span><br><span class=\"line\">      iter.remove();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>迭代器在执行next()等方法的时候，都会调用<strong>checkForComodification()</strong>这个方法，查看modCount==expectedModCount如果不相等则抛出异常。</p>\n<p>expectedModcount:这个值在对象被创建的时候就被赋予了一个固定的值modCount。也就是说这个值是不变的。也就是说，如果在迭代器遍历元素的时候，如果modCount这个值发生了改变，那么再次遍历时就会抛出异常。 </p>\n<p>什么时候modCount会发生改变呢？就是对集合的元素的个数做出改变的时候，modCount的值就会被改变，如果删除，插入。但修改则不会。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> expectedModCount = modCount;</span><br><span class=\"line\">        </span><br><span class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            checkForComodification();</span><br><span class=\"line\">            ...省略...</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForComodification</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (modCount != expectedModCount)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Fast-safe\"><a href=\"#Fast-safe\" class=\"headerlink\" title=\"Fast-safe\"></a>Fast-safe</h2><h3 id=\"是什么-1\"><a href=\"#是什么-1\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是<strong>先复制原有集合内容</strong>，在拷贝的集合上进行遍历。主要是为了在多线程下可以并发的对集合进行更改。</p>\n<h3 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，<strong>迭代器并不能访问到修改后的内容</strong>，即迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p>\n<h2 id=\"两者区别\"><a href=\"#两者区别\" class=\"headerlink\" title=\"两者区别\"></a>两者区别</h2><p>Fast-fail场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p>\n<p>Fast-fail场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/mlym521/article/details/82465126\" target=\"_blank\" rel=\"noopener\">fail_fast和fail_safe的介绍及区别</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Fast-fail\"><a href=\"#Fast-fail\" class=\"headerlink\" title=\"Fast-fail\"></a>Fast-fail</h2><h4 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h4><p><strong>fail-fast,即快速失败机制，它是java集合中的一种错误检测机制，当多个线程或者单个线程,在结构上对集合进行改变时，就有可能会产生fail-fast机制。</strong></p>\n<p><em>注意：结构上的改变的意思是，例如集合上的<strong>插入和删除</strong>就是结构上的改变，但是，如果是对集合中某个元素进行<strong>修改</strong>的话，并不是结构上的改变。</em> </p>\n<h4 id=\"为什么\"><a href=\"#为什么\" class=\"headerlink\" title=\"为什么\"></a>为什么</h4><p>为什么要有快速失败？为什么用for(int i=0;i&lt;list.size();i++)这种形式就能一边遍历一边修改集合？</p>\n<p>其实答案很简单，普通for循环时，当一个元素结结构被改变时，集合大小和下标也会随之变化，<strong>size是可以随着你改变变换的</strong>。</p>\n<p>但使用了迭代器就不行了。迭代器（Iterator）是工作在一个独立的线程中，并且拥有一个 mutex 锁。 迭代器被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，<strong>这个索引表的内容不会同步改变</strong>，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 迭代器会马上抛出 java.util.ConcurrentModificationException。</p>\n<p>最后说一嘴，如果非要在用迭代器的时候删除，可以用迭代器的remove方法。如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (s.equals(<span class=\"string\">\"a\"</span>)) &#123;</span><br><span class=\"line\">      iter.remove();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>迭代器在执行next()等方法的时候，都会调用<strong>checkForComodification()</strong>这个方法，查看modCount==expectedModCount如果不相等则抛出异常。</p>\n<p>expectedModcount:这个值在对象被创建的时候就被赋予了一个固定的值modCount。也就是说这个值是不变的。也就是说，如果在迭代器遍历元素的时候，如果modCount这个值发生了改变，那么再次遍历时就会抛出异常。 </p>\n<p>什么时候modCount会发生改变呢？就是对集合的元素的个数做出改变的时候，modCount的值就会被改变，如果删除，插入。但修改则不会。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> expectedModCount = modCount;</span><br><span class=\"line\">        </span><br><span class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            checkForComodification();</span><br><span class=\"line\">            ...省略...</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForComodification</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (modCount != expectedModCount)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Fast-safe\"><a href=\"#Fast-safe\" class=\"headerlink\" title=\"Fast-safe\"></a>Fast-safe</h2><h3 id=\"是什么-1\"><a href=\"#是什么-1\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是<strong>先复制原有集合内容</strong>，在拷贝的集合上进行遍历。主要是为了在多线程下可以并发的对集合进行更改。</p>\n<h3 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，<strong>迭代器并不能访问到修改后的内容</strong>，即迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p>\n<h2 id=\"两者区别\"><a href=\"#两者区别\" class=\"headerlink\" title=\"两者区别\"></a>两者区别</h2><p>Fast-fail场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p>\n<p>Fast-fail场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/mlym521/article/details/82465126\" target=\"_blank\" rel=\"noopener\">fail_fast和fail_safe的介绍及区别</a></p>\n</blockquote>\n"},{"title":"HashMap深度探索","date":"2019-07-23T12:12:50.000Z","description":"HashMap是java使用频率最高的集合类之一。本文将从定义、重要方法源码分析、与其他集合的比较来探索**JDK1.8**版本的HashMap。","_content":"\nHashMap是java使用频率最高的集合类之一。本文将从重要知识点、主要方法源码分析、与其他集合的比较三个方面来探索**JDK1.8**版本的HashMap。本文目录如下\n\n[TOC]\n\n# 重要知识点\n\n\n\n## 继承关系\n\n```java\npublic class HashMap<K,V> extends AbstractMap<K,V>implements Map<K,V>, Cloneable, Serializable\n```\n\n可以看到HashMap继承了AbstractMap实现了三个接口Map<K,V>, Cloneable, Serializable。我的理解是继承一个类是将HashMap**分为map类**，而实现接口是表明HashMap有可复制、可序列化的**能力**。\n\n*顺便说一句，不知道大家有没有想过为什么HashMap既然继承了AbstractMap为什么还要实现Map？并且AbstractMap也实现了Map？ 我看的时候好奇就去网上搜了搜，据java集合框架的创始人Josh Bloch描述，这样的写法其实是一个失误。在java集合框架中，类似这样的写法很多。最开始写java集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，JDK的维护者，后来不认为这个小小的失误值得去修改。所以就这样存在下来了。[stack overflow上的回答](https://stackoverflow.com/questions/2165204/why-does-linkedhashsete-extend-hashsete-and-implement-sete)*\n\n## 重要参数\n\n### 静态常量\n\n```java\n// 初始容量为2^4=16\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4;\n\n// 最大容量=2^30,传入容量过大将被这个值替换\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\n\n// 负载因子=0.75，当键值对个数达到>=容量* 负载因子（0.75）会触发resize扩容 \nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n// 树化的阀值=8，当链表长度大于8，且数组长度大于MIN_TREEIFY_CAPACITY，就会转为红黑树\nstatic final int TREEIFY_THRESHOLD = 8;\n\n// 非树化的阀值=6，当resize时候发现链表长度小于6时，从红黑树退化为链表\nstatic final int UNTREEIFY_THRESHOLD = 6;\n\n//最小的树化容量=64， 在要将链表转为红黑树之前，再进行一次判断，若数组容量小于该值，则用resize扩容，放弃转为红黑树\n// 意图：在建立Map的初期，放置过多键值对进入同一个数组下标中，而导致不必要的链表->红黑树的转化，此时扩容即可，可有效减少冲突\nstatic final int MIN_TREEIFY_CAPACITY = 64;\n```\n\n重点解释一下负载因子，HashMap不是在容量等于size的时候才扩容，而是在快接近size时候就提前扩容。负载因子就是决定提前到多大。负载因子越大表示散列表的装填程度越高，反之越小。\n它默认是0.75，也可以在构造函数里自定义。\n负载因子越大，散列表的数据越密集，空间利用率越大，key也越容易冲突化为链表/红黑树，查找效率低；\n负载因子越小，散列表的数据越稀疏，对空间的利用越浪费，但key也越不容易冲突，查找效率高。系统默认负载因子为0.75，一般情况下我们是无需修改的。\n\n## 数据结构\n\nHashMap是一个映射散列表，它存储的数据是键值对(key-value)。\nJDK1.8前采用数组+链表/红黑树， Node<K,V>[] table数组中的每一个Node元素是一个链表的头结点。这样结合数组和链表的优点，查询效率是大O(1)。\n\n构造函数如下：\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {{\n        final int hash;\n        final K key;\n        V value;\n        Node<K,V> next;\n}\n```\n\n## 位运算\n\nHashMap的位运算可以说是老*猪带胸罩，一套接一套的。\n\n### 第一套：扰动函数\n\nHashMap不是直接使用key的hashcode，而是要做异或加工。**目的是减少散列冲突,使元素能够更均匀的分布在数组中。**\n\n```\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n```\n\nhashcode是一个int类型32位的数，h >>> 16即把hashcode的高16位向右移动到低16位。然后将**hashCode的高16位和低16位异或**，异或混合过后**高16位的特征也掺杂进低16位**，让数字的每一位都参加了散列运算当中。就像下面一样（h代表原本hashcode）\n\n```java\nh:        1111 1111 1111 1111 1111 0000 1110 1010\nh>>16:    0000 0000 0000 0000 1111 1111 1111 1111\nnewh=h^h>>16:1111 1111 1111 1111 0000 1111 0001 0101\n```\n\n这样就混合了高位低位数据特征。此外，还有一个重要的原因，在后面使用（length - 1) & hash算下标时，因为length必然是2的次幂，length-1的二进制看起来就是一堆0后面跟着一个1（这个在下面第三套也会提到），如果不做扰动，高位的hashcode大部分情况都用不上。\n\n### 第二套：key是如何hash出对应的数组下标？\n\nhash出应的数组下标理所当然的做法就取余hashcode % length，但jdk用了更有效率的**位操作(length - 1) & hash**来代替取余操作。\n\n### 第三套：为什么长度一定要是2的整次幂？\n\n只有当数组长度是2的整次幂的时候，**(length - 1) & hash才可以代替取余操作hash%length** ，毕竟位运算比取余操作效率更高。当长度是2的整次幂时候，比如8的二进制是1000，肉眼看过去是“一个1后面跟着一堆0\"，在减一后就变成了0111，肉眼看过去是”前面全是0后面全是1“。再**和hash与运算出的结果不会超过数组长度，因为前面全是0，与的结果还是0。**\n\n比如长度如果是16，h是上面扰动函数算出的hashcode\n\n```java\nlength-1:     0000 0000 0000 0000 0000 0000 0000 1111\nh:            1111 1111 1111 1111 0000 1111 0001 0101\n(length-1)&h: 0000 0000 0000 0000 0000 0000 0000 0101\n```\n\n假设有两个个key，他们的hashcode不同，分别为code1和code2code1和code2分别与“前面全是0后面全是1“二进制相与，结果一定不同。**但是，如果code1和code2分别与一个“后面不一定是1“的二进制相与，结果有可能相同**。\n\n\n\n## lazy_load\n\nHashMap是延迟加载，即构造函数不负责初始化，而是由resize（）扩容承担初始化的责任。\n\n具体过程是：第一次调用put()方法判断数组是否为空，如果为空调用resize（）扩容方法初始化后再put（）。\n\n## 1.7链表插入区别\n\nHashMap在jdk**1.7中采用头插入法**，在扩容时会改变链表中元素原本的顺序，以至于在并发场景下导致链表成环的问题。\n\n而在jdk**1.8中采用尾插入法**，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。\n\n# 重要方法源码分析\n\n## put()\n\nput方法主要由putVal方法实现：\n\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n    //判断HashMap有没有初始化\n        if ((tab = table) == null || (n = tab.length) == 0) //jdk源码的风格 在判断语句赋值\n            n = (tab = resize()).length;\n    //如果没有产生hash冲突\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            //直接在数组tab[i = (n - 1) & hash]处新建一个结点\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n            //发生了hash冲突，并且key相同，对结点进行更新\n           \n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k)))) //HashMap允许为空，空值是不能直接判断相等的\n                e = p;\n            //如果结点是树节点，就插入到红黑树中\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {\n                //否则，则为链表，遍历查找\n                for (int binCount = 0; ; ++binCount) {\n                    //到链表尾也没有找到就在尾部插入一个新结点。\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        //注意添加之后链表长度若大于8的话，需将链表转为红黑树\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        //找到就跳出去更新结点的值\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n### put（）可能造成线程不安全的问题\n\n- JDK8之前，并发put下可能造成死循环。原因是多线程下单链表的数据结构被破环，指向混乱，造成了链表成环。JDK 8中对HashMap做了大量优化，已经不存在这个问题。\n- 并发put，有可能造成键值对的丢失，如果两个线程同时读取到当前node，在链表尾部插入，先插入的线程是无效的，会被后面的线程覆盖掉。\n\n### 总结\n\n1. 判断HashMap有没有初始化，并赋值\n2. 如果没有产生hash冲突，直接在数组tab[i = (n - 1) & hash]处新建一个结点；\n3. 否则，发生了hash冲突，此时key如果和头结点的key相同，找到要更新的结点，直接跳到最后去更新值\n4. 否则，如果数组下标中的类型是TreeNode，就插入到红黑树中\n5. 如果只是普通的链表，就在链表中查找，找到key相同的结点就跳出，到最后去更新值；到链表尾也没有找到就在尾部插入一个新结点。\n6. 判断此时链表长度若大于8的话，还需要将链表转为红黑树（注意在要将链表转为红黑树之前，再进行一次判断，若数组容量小于64，则用resize扩容，放弃转为红黑树）\n\n## get()\n\nget方法主要由getNode方法实现：\n\n```java\nfinal Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    //判断HashMap有没有被初始化\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n            //数组下标的链表头就找到key相同的，那么返回链表头的值\n            if (first.hash == hash && // always check first node\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;\n            if ((e = first.next) != null) {\n                //如果数组下标处的类型是TreeNode，就在红黑树中查找\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                //在链表中遍历查找了\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n    }\n```\n\n### 总结\n\n1. 如果在数组下标的链表头就找到key相同的，那么返回链表头的值\n2. 否则如果数组下标处的类型是TreeNode，就在红黑树中查找\n3. 否则就是在普通链表中查找了\n4. 都找不到就返回null\n\nremove方法的流程大致和get方法类似。\n\n## resize()\n\n扩容方法有这么一句`newCap = oldCap << 1`说明是扩容后数组大小是原数组的两倍。\n\n同时，该方法也承担了首次put值时，**初始化数组**的责任。\n\n这个方法有点长，我将它分为三段分析。\n\n下面三段在源码中是连在一起的一个方法，只是我这里为了逻辑清晰把它分开了。\n\n第一段，准备好新数组，并做对数组的大小的进行判断，如果是初始化数组，基本工作在这一段就完成了。\n\n```java\n    final Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;//\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            //如果旧数组的长度已经达到最大容量了2^30\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                //将阈值修改为int的最大值，不进行扩容直接返回旧数组\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }//新长度是新长度的2倍之后新长度小于最大容量+旧长度大于初始化长度16\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                //阈值扩大一倍\n                newThr = oldThr << 1; // double threshold\n        }//这种情况是指定了初始容量，new HashMap（int initialCapacity），第一次put初始化的时候\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        else {//这种情况是没指定初始容量，new HashMap（），第一次put初始化的时候      \n            // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n        //初始化新数组\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        //如果是初始化，到这里就结束啦，直接跳到最后返回table新数组。\n        table = newTab;\n```\n\n第二段，遍历原数组每一个结点，有三种情况：只有一个头结点、是红黑树、是链表。\n\n```java\n        if (oldTab != null) {\n            //遍历原数组\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    // 如果数组中只有一个元素，即只有一个头结点，重新哈希新下标就可以了\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    //如果是一个树节点\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { //否则就是链表，这种情况复制比较复杂，单独分一段讲\n```\n\n第三段，链表的复制比较复杂。\n\n- 旧链表拆分成两个新链表。首先我们要明白，新数组的的长度是旧数组的两倍。也就是说**旧数组的一个下标可以对应新数组的两个下标**。比如就数组的下标是k，新数组的就对应k和k+oldCap两个下标。于是我们准备**两个链表作为新数组的两个下标的结点**，这里我叫这两个链表为A和B。\n- 拆分的标准是e.hash & oldCap == 0。这句其实就是**取e的hashcode在长度范围内的最高位**，其实最高位不外乎两种情况，1和0。但是怎么能取到在长度范围内的最高位呢——把它和长度做与就可得到。比如长度是4，与上e的hashcode得最高位为1。\n\n```java\nhashcode:1111 1111 1111 1111 0000 1111 0001 0101\nlength:  0000 0000 0000 0000 0000 0000 0001 0000\n         0000 0000 0000 0000 0000 0000 0001 0000 \n```\n\n如果(e.hash & oldCap) 等于0，则该节点在新、旧数组的下标都是k。\n\n如果(e.hash & oldCap) 不等于0，则该节点在新数组的下标是k+oldCap。\n\n```java\n                   //loHead指向lo链表的头，loTail指向lo链表尾                 \n                        Node<K,V> loHead = null, loTail = null;\n                   //hiHead指向hi链表的头，hiTail指向hi链表尾     \n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            //(e.hash & oldCap) == 0)哈希值最高位是0分到链表lo\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            //否则分到链表hi\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                     //如果lo链表不为空，loHead挂到新数组[原下标]处；\n                        if (loTail != null) {\n                            loTail.next = null;\n                            \n                            newTab[j] = loHead;\n                        }//如果hi链表不为空，hiHead挂到新数组中[原下标+oldCap]处\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            \n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n```\n\n### 总结\n\n1. 如果数组未被初始化，就根据初始化值初始化数组\n2. 否则新生成一个长度是原来2倍的新数组，把所有元素复制到新数组\n3. 如果元素只有一个节点，复制到重新hash()计算的下标\n4. 如果是一个树节点，就对树进行复制\n5. 如果是链表，则新生成两个链表，一个挂在原下标位置，一个挂在原下标+原长度位置\n\n\n\n# 其他相似的集合\n\n## 与HashTable\n\n一、**是否允许为空**。HashMap可以允许存在**一个**为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。\n\n当HashMap遇到为null的key时，它会调用putForNullKey方法来进行处理。value如果为空则抛出NullPointerException()\n\n```java\nif (key == null)            return putForNullKey(value);      而当HashTable遇到null时，他会直接抛出NullPointerException异常信息。\nif (value == null) {    throw new NullPointerException();\n```\n\n二、**是否线程安全。**Hashtable的方法是线程安全的，而HashMap的方法不是。\n\nHashtable的方法都是用synchronized修饰的，在修改数组时锁住整个Hashtable，**这样的做法效率很低**。\n\n```java\npublic synchronized V put(K key, V value) {...}\npublic synchronized V put(K key, V value) {...}\n```\n\n三、HashTable基于Dictionary类，而HashMap是基于AbstractMap。\n\n四、HashTable直接调用hashcode，而HashMap会经过扰动函数，\t\t而且用与位运算代替了取余。因此**HashTable的长度不用是2的整次幂**\n\n## 与ConcurrentHashMap\n\nJDK1.7基于分段锁，减少锁粒度。ConcurrentHashMap中的分段锁称为**Segment**，它继承了ReentrantLock，扮演锁的角色，它有着类似于HashMap的结构，即守护着一个HashEntry数组。\n\nJDK1.8采用Node 数组+链表/红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）t\n\nget方法是**不加锁的**，因为get方法里的共享变量都定义成volatile类型，保证能被多线程的读，但只能被单线程的写。即使一个线程在读一个线程同时在写，根据happen before原则，对volatile字段的写入先于读操作，所以get总能拿到最新的值。这是用volatile替换锁的经典场景。\n\nput方法会检查是否有Node节点,如果没有则在循环中使用**CAS**进行添加(链表的头节点),如果检査到内部正在扩容,就helpTransfer协助扩容。否则使用 **synchronized锁住头元素**(链表/红黑二叉树的头元素)添加元素。\n\n扩容，让每个线程处理自己的区间。通过给每个线程分配桶区间，避免线程间的争用。而如果有新的线程想 put 数据时，也会帮助其扩容。无锁扩容的关键就是通过CAS设置sizeCtl与transferIndex变量，协调多个线程对table数组中的node进行迁移（transferIndex是指向剩余迁移结点的指针）。复制链表时同样会将链表拆成两份。\n\n","source":"_posts/HashMap.md","raw":"---\ntitle: HashMap深度探索\ndate: 2019-07-23 20:12:50\ncategories: java\ndescription: HashMap是java使用频率最高的集合类之一。本文将从定义、重要方法源码分析、与其他集合的比较来探索**JDK1.8**版本的HashMap。\n\n---\n\nHashMap是java使用频率最高的集合类之一。本文将从重要知识点、主要方法源码分析、与其他集合的比较三个方面来探索**JDK1.8**版本的HashMap。本文目录如下\n\n[TOC]\n\n# 重要知识点\n\n\n\n## 继承关系\n\n```java\npublic class HashMap<K,V> extends AbstractMap<K,V>implements Map<K,V>, Cloneable, Serializable\n```\n\n可以看到HashMap继承了AbstractMap实现了三个接口Map<K,V>, Cloneable, Serializable。我的理解是继承一个类是将HashMap**分为map类**，而实现接口是表明HashMap有可复制、可序列化的**能力**。\n\n*顺便说一句，不知道大家有没有想过为什么HashMap既然继承了AbstractMap为什么还要实现Map？并且AbstractMap也实现了Map？ 我看的时候好奇就去网上搜了搜，据java集合框架的创始人Josh Bloch描述，这样的写法其实是一个失误。在java集合框架中，类似这样的写法很多。最开始写java集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，JDK的维护者，后来不认为这个小小的失误值得去修改。所以就这样存在下来了。[stack overflow上的回答](https://stackoverflow.com/questions/2165204/why-does-linkedhashsete-extend-hashsete-and-implement-sete)*\n\n## 重要参数\n\n### 静态常量\n\n```java\n// 初始容量为2^4=16\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4;\n\n// 最大容量=2^30,传入容量过大将被这个值替换\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\n\n// 负载因子=0.75，当键值对个数达到>=容量* 负载因子（0.75）会触发resize扩容 \nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n// 树化的阀值=8，当链表长度大于8，且数组长度大于MIN_TREEIFY_CAPACITY，就会转为红黑树\nstatic final int TREEIFY_THRESHOLD = 8;\n\n// 非树化的阀值=6，当resize时候发现链表长度小于6时，从红黑树退化为链表\nstatic final int UNTREEIFY_THRESHOLD = 6;\n\n//最小的树化容量=64， 在要将链表转为红黑树之前，再进行一次判断，若数组容量小于该值，则用resize扩容，放弃转为红黑树\n// 意图：在建立Map的初期，放置过多键值对进入同一个数组下标中，而导致不必要的链表->红黑树的转化，此时扩容即可，可有效减少冲突\nstatic final int MIN_TREEIFY_CAPACITY = 64;\n```\n\n重点解释一下负载因子，HashMap不是在容量等于size的时候才扩容，而是在快接近size时候就提前扩容。负载因子就是决定提前到多大。负载因子越大表示散列表的装填程度越高，反之越小。\n它默认是0.75，也可以在构造函数里自定义。\n负载因子越大，散列表的数据越密集，空间利用率越大，key也越容易冲突化为链表/红黑树，查找效率低；\n负载因子越小，散列表的数据越稀疏，对空间的利用越浪费，但key也越不容易冲突，查找效率高。系统默认负载因子为0.75，一般情况下我们是无需修改的。\n\n## 数据结构\n\nHashMap是一个映射散列表，它存储的数据是键值对(key-value)。\nJDK1.8前采用数组+链表/红黑树， Node<K,V>[] table数组中的每一个Node元素是一个链表的头结点。这样结合数组和链表的优点，查询效率是大O(1)。\n\n构造函数如下：\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {{\n        final int hash;\n        final K key;\n        V value;\n        Node<K,V> next;\n}\n```\n\n## 位运算\n\nHashMap的位运算可以说是老*猪带胸罩，一套接一套的。\n\n### 第一套：扰动函数\n\nHashMap不是直接使用key的hashcode，而是要做异或加工。**目的是减少散列冲突,使元素能够更均匀的分布在数组中。**\n\n```\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n```\n\nhashcode是一个int类型32位的数，h >>> 16即把hashcode的高16位向右移动到低16位。然后将**hashCode的高16位和低16位异或**，异或混合过后**高16位的特征也掺杂进低16位**，让数字的每一位都参加了散列运算当中。就像下面一样（h代表原本hashcode）\n\n```java\nh:        1111 1111 1111 1111 1111 0000 1110 1010\nh>>16:    0000 0000 0000 0000 1111 1111 1111 1111\nnewh=h^h>>16:1111 1111 1111 1111 0000 1111 0001 0101\n```\n\n这样就混合了高位低位数据特征。此外，还有一个重要的原因，在后面使用（length - 1) & hash算下标时，因为length必然是2的次幂，length-1的二进制看起来就是一堆0后面跟着一个1（这个在下面第三套也会提到），如果不做扰动，高位的hashcode大部分情况都用不上。\n\n### 第二套：key是如何hash出对应的数组下标？\n\nhash出应的数组下标理所当然的做法就取余hashcode % length，但jdk用了更有效率的**位操作(length - 1) & hash**来代替取余操作。\n\n### 第三套：为什么长度一定要是2的整次幂？\n\n只有当数组长度是2的整次幂的时候，**(length - 1) & hash才可以代替取余操作hash%length** ，毕竟位运算比取余操作效率更高。当长度是2的整次幂时候，比如8的二进制是1000，肉眼看过去是“一个1后面跟着一堆0\"，在减一后就变成了0111，肉眼看过去是”前面全是0后面全是1“。再**和hash与运算出的结果不会超过数组长度，因为前面全是0，与的结果还是0。**\n\n比如长度如果是16，h是上面扰动函数算出的hashcode\n\n```java\nlength-1:     0000 0000 0000 0000 0000 0000 0000 1111\nh:            1111 1111 1111 1111 0000 1111 0001 0101\n(length-1)&h: 0000 0000 0000 0000 0000 0000 0000 0101\n```\n\n假设有两个个key，他们的hashcode不同，分别为code1和code2code1和code2分别与“前面全是0后面全是1“二进制相与，结果一定不同。**但是，如果code1和code2分别与一个“后面不一定是1“的二进制相与，结果有可能相同**。\n\n\n\n## lazy_load\n\nHashMap是延迟加载，即构造函数不负责初始化，而是由resize（）扩容承担初始化的责任。\n\n具体过程是：第一次调用put()方法判断数组是否为空，如果为空调用resize（）扩容方法初始化后再put（）。\n\n## 1.7链表插入区别\n\nHashMap在jdk**1.7中采用头插入法**，在扩容时会改变链表中元素原本的顺序，以至于在并发场景下导致链表成环的问题。\n\n而在jdk**1.8中采用尾插入法**，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。\n\n# 重要方法源码分析\n\n## put()\n\nput方法主要由putVal方法实现：\n\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n    //判断HashMap有没有初始化\n        if ((tab = table) == null || (n = tab.length) == 0) //jdk源码的风格 在判断语句赋值\n            n = (tab = resize()).length;\n    //如果没有产生hash冲突\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            //直接在数组tab[i = (n - 1) & hash]处新建一个结点\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n            //发生了hash冲突，并且key相同，对结点进行更新\n           \n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k)))) //HashMap允许为空，空值是不能直接判断相等的\n                e = p;\n            //如果结点是树节点，就插入到红黑树中\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {\n                //否则，则为链表，遍历查找\n                for (int binCount = 0; ; ++binCount) {\n                    //到链表尾也没有找到就在尾部插入一个新结点。\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        //注意添加之后链表长度若大于8的话，需将链表转为红黑树\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        //找到就跳出去更新结点的值\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n### put（）可能造成线程不安全的问题\n\n- JDK8之前，并发put下可能造成死循环。原因是多线程下单链表的数据结构被破环，指向混乱，造成了链表成环。JDK 8中对HashMap做了大量优化，已经不存在这个问题。\n- 并发put，有可能造成键值对的丢失，如果两个线程同时读取到当前node，在链表尾部插入，先插入的线程是无效的，会被后面的线程覆盖掉。\n\n### 总结\n\n1. 判断HashMap有没有初始化，并赋值\n2. 如果没有产生hash冲突，直接在数组tab[i = (n - 1) & hash]处新建一个结点；\n3. 否则，发生了hash冲突，此时key如果和头结点的key相同，找到要更新的结点，直接跳到最后去更新值\n4. 否则，如果数组下标中的类型是TreeNode，就插入到红黑树中\n5. 如果只是普通的链表，就在链表中查找，找到key相同的结点就跳出，到最后去更新值；到链表尾也没有找到就在尾部插入一个新结点。\n6. 判断此时链表长度若大于8的话，还需要将链表转为红黑树（注意在要将链表转为红黑树之前，再进行一次判断，若数组容量小于64，则用resize扩容，放弃转为红黑树）\n\n## get()\n\nget方法主要由getNode方法实现：\n\n```java\nfinal Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    //判断HashMap有没有被初始化\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n            //数组下标的链表头就找到key相同的，那么返回链表头的值\n            if (first.hash == hash && // always check first node\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;\n            if ((e = first.next) != null) {\n                //如果数组下标处的类型是TreeNode，就在红黑树中查找\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                //在链表中遍历查找了\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n    }\n```\n\n### 总结\n\n1. 如果在数组下标的链表头就找到key相同的，那么返回链表头的值\n2. 否则如果数组下标处的类型是TreeNode，就在红黑树中查找\n3. 否则就是在普通链表中查找了\n4. 都找不到就返回null\n\nremove方法的流程大致和get方法类似。\n\n## resize()\n\n扩容方法有这么一句`newCap = oldCap << 1`说明是扩容后数组大小是原数组的两倍。\n\n同时，该方法也承担了首次put值时，**初始化数组**的责任。\n\n这个方法有点长，我将它分为三段分析。\n\n下面三段在源码中是连在一起的一个方法，只是我这里为了逻辑清晰把它分开了。\n\n第一段，准备好新数组，并做对数组的大小的进行判断，如果是初始化数组，基本工作在这一段就完成了。\n\n```java\n    final Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;//\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            //如果旧数组的长度已经达到最大容量了2^30\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                //将阈值修改为int的最大值，不进行扩容直接返回旧数组\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }//新长度是新长度的2倍之后新长度小于最大容量+旧长度大于初始化长度16\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                //阈值扩大一倍\n                newThr = oldThr << 1; // double threshold\n        }//这种情况是指定了初始容量，new HashMap（int initialCapacity），第一次put初始化的时候\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        else {//这种情况是没指定初始容量，new HashMap（），第一次put初始化的时候      \n            // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n        //初始化新数组\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        //如果是初始化，到这里就结束啦，直接跳到最后返回table新数组。\n        table = newTab;\n```\n\n第二段，遍历原数组每一个结点，有三种情况：只有一个头结点、是红黑树、是链表。\n\n```java\n        if (oldTab != null) {\n            //遍历原数组\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    // 如果数组中只有一个元素，即只有一个头结点，重新哈希新下标就可以了\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    //如果是一个树节点\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { //否则就是链表，这种情况复制比较复杂，单独分一段讲\n```\n\n第三段，链表的复制比较复杂。\n\n- 旧链表拆分成两个新链表。首先我们要明白，新数组的的长度是旧数组的两倍。也就是说**旧数组的一个下标可以对应新数组的两个下标**。比如就数组的下标是k，新数组的就对应k和k+oldCap两个下标。于是我们准备**两个链表作为新数组的两个下标的结点**，这里我叫这两个链表为A和B。\n- 拆分的标准是e.hash & oldCap == 0。这句其实就是**取e的hashcode在长度范围内的最高位**，其实最高位不外乎两种情况，1和0。但是怎么能取到在长度范围内的最高位呢——把它和长度做与就可得到。比如长度是4，与上e的hashcode得最高位为1。\n\n```java\nhashcode:1111 1111 1111 1111 0000 1111 0001 0101\nlength:  0000 0000 0000 0000 0000 0000 0001 0000\n         0000 0000 0000 0000 0000 0000 0001 0000 \n```\n\n如果(e.hash & oldCap) 等于0，则该节点在新、旧数组的下标都是k。\n\n如果(e.hash & oldCap) 不等于0，则该节点在新数组的下标是k+oldCap。\n\n```java\n                   //loHead指向lo链表的头，loTail指向lo链表尾                 \n                        Node<K,V> loHead = null, loTail = null;\n                   //hiHead指向hi链表的头，hiTail指向hi链表尾     \n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            //(e.hash & oldCap) == 0)哈希值最高位是0分到链表lo\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            //否则分到链表hi\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                     //如果lo链表不为空，loHead挂到新数组[原下标]处；\n                        if (loTail != null) {\n                            loTail.next = null;\n                            \n                            newTab[j] = loHead;\n                        }//如果hi链表不为空，hiHead挂到新数组中[原下标+oldCap]处\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            \n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n```\n\n### 总结\n\n1. 如果数组未被初始化，就根据初始化值初始化数组\n2. 否则新生成一个长度是原来2倍的新数组，把所有元素复制到新数组\n3. 如果元素只有一个节点，复制到重新hash()计算的下标\n4. 如果是一个树节点，就对树进行复制\n5. 如果是链表，则新生成两个链表，一个挂在原下标位置，一个挂在原下标+原长度位置\n\n\n\n# 其他相似的集合\n\n## 与HashTable\n\n一、**是否允许为空**。HashMap可以允许存在**一个**为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。\n\n当HashMap遇到为null的key时，它会调用putForNullKey方法来进行处理。value如果为空则抛出NullPointerException()\n\n```java\nif (key == null)            return putForNullKey(value);      而当HashTable遇到null时，他会直接抛出NullPointerException异常信息。\nif (value == null) {    throw new NullPointerException();\n```\n\n二、**是否线程安全。**Hashtable的方法是线程安全的，而HashMap的方法不是。\n\nHashtable的方法都是用synchronized修饰的，在修改数组时锁住整个Hashtable，**这样的做法效率很低**。\n\n```java\npublic synchronized V put(K key, V value) {...}\npublic synchronized V put(K key, V value) {...}\n```\n\n三、HashTable基于Dictionary类，而HashMap是基于AbstractMap。\n\n四、HashTable直接调用hashcode，而HashMap会经过扰动函数，\t\t而且用与位运算代替了取余。因此**HashTable的长度不用是2的整次幂**\n\n## 与ConcurrentHashMap\n\nJDK1.7基于分段锁，减少锁粒度。ConcurrentHashMap中的分段锁称为**Segment**，它继承了ReentrantLock，扮演锁的角色，它有着类似于HashMap的结构，即守护着一个HashEntry数组。\n\nJDK1.8采用Node 数组+链表/红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）t\n\nget方法是**不加锁的**，因为get方法里的共享变量都定义成volatile类型，保证能被多线程的读，但只能被单线程的写。即使一个线程在读一个线程同时在写，根据happen before原则，对volatile字段的写入先于读操作，所以get总能拿到最新的值。这是用volatile替换锁的经典场景。\n\nput方法会检查是否有Node节点,如果没有则在循环中使用**CAS**进行添加(链表的头节点),如果检査到内部正在扩容,就helpTransfer协助扩容。否则使用 **synchronized锁住头元素**(链表/红黑二叉树的头元素)添加元素。\n\n扩容，让每个线程处理自己的区间。通过给每个线程分配桶区间，避免线程间的争用。而如果有新的线程想 put 数据时，也会帮助其扩容。无锁扩容的关键就是通过CAS设置sizeCtl与transferIndex变量，协调多个线程对table数组中的node进行迁移（transferIndex是指向剩余迁移结点的指针）。复制链表时同样会将链表拆成两份。\n\n","slug":"HashMap","published":1,"updated":"2022-02-08T07:09:41.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qjt0004w9rp2dmg6d2x","content":"<p>HashMap是java使用频率最高的集合类之一。本文将从重要知识点、主要方法源码分析、与其他集合的比较三个方面来探索<strong>JDK1.8</strong>版本的HashMap。本文目录如下</p>\n<p>[TOC]</p>\n<h1 id=\"重要知识点\"><a href=\"#重要知识点\" class=\"headerlink\" title=\"重要知识点\"></a>重要知识点</h1><h2 id=\"继承关系\"><a href=\"#继承关系\" class=\"headerlink\" title=\"继承关系\"></a>继承关系</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;<span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure>\n<p>可以看到HashMap继承了AbstractMap实现了三个接口Map&lt;K,V&gt;, Cloneable, Serializable。我的理解是继承一个类是将HashMap<strong>分为map类</strong>，而实现接口是表明HashMap有可复制、可序列化的<strong>能力</strong>。</p>\n<p><em>顺便说一句，不知道大家有没有想过为什么HashMap既然继承了AbstractMap为什么还要实现Map？并且AbstractMap也实现了Map？ 我看的时候好奇就去网上搜了搜，据java集合框架的创始人Josh Bloch描述，这样的写法其实是一个失误。在java集合框架中，类似这样的写法很多。最开始写java集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，JDK的维护者，后来不认为这个小小的失误值得去修改。所以就这样存在下来了。<a href=\"https://stackoverflow.com/questions/2165204/why-does-linkedhashsete-extend-hashsete-and-implement-sete\" target=\"_blank\" rel=\"noopener\">stack overflow上的回答</a></em></p>\n<h2 id=\"重要参数\"><a href=\"#重要参数\" class=\"headerlink\" title=\"重要参数\"></a>重要参数</h2><h3 id=\"静态常量\"><a href=\"#静态常量\" class=\"headerlink\" title=\"静态常量\"></a>静态常量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始容量为2^4=16</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 最大容量=2^30,传入容量过大将被这个值替换</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 负载因子=0.75，当键值对个数达到&gt;=容量* 负载因子（0.75）会触发resize扩容 </span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 树化的阀值=8，当链表长度大于8，且数组长度大于MIN_TREEIFY_CAPACITY，就会转为红黑树</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非树化的阀值=6，当resize时候发现链表长度小于6时，从红黑树退化为链表</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//最小的树化容量=64， 在要将链表转为红黑树之前，再进行一次判断，若数组容量小于该值，则用resize扩容，放弃转为红黑树</span></span><br><span class=\"line\"><span class=\"comment\">// 意图：在建立Map的初期，放置过多键值对进入同一个数组下标中，而导致不必要的链表-&gt;红黑树的转化，此时扩容即可，可有效减少冲突</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;</span><br></pre></td></tr></table></figure>\n<p>重点解释一下负载因子，HashMap不是在容量等于size的时候才扩容，而是在快接近size时候就提前扩容。负载因子就是决定提前到多大。负载因子越大表示散列表的装填程度越高，反之越小。<br>它默认是0.75，也可以在构造函数里自定义。<br>负载因子越大，散列表的数据越密集，空间利用率越大，key也越容易冲突化为链表/红黑树，查找效率低；<br>负载因子越小，散列表的数据越稀疏，对空间的利用越浪费，但key也越不容易冲突，查找效率高。系统默认负载因子为0.75，一般情况下我们是无需修改的。</p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>HashMap是一个映射散列表，它存储的数据是键值对(key-value)。<br>JDK1.8前采用数组+链表/红黑树， Node&lt;K,V&gt;[] table数组中的每一个Node元素是一个链表的头结点。这样结合数组和链表的优点，查询效率是大O(1)。</p>\n<p>构造函数如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        Node&lt;K,V&gt; next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><p>HashMap的位运算可以说是老*猪带胸罩，一套接一套的。</p>\n<h3 id=\"第一套：扰动函数\"><a href=\"#第一套：扰动函数\" class=\"headerlink\" title=\"第一套：扰动函数\"></a>第一套：扰动函数</h3><p>HashMap不是直接使用key的hashcode，而是要做异或加工。<strong>目的是减少散列冲突,使元素能够更均匀的分布在数组中。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final int hash(Object key) &#123;</span><br><span class=\"line\">        int h;</span><br><span class=\"line\">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>hashcode是一个int类型32位的数，h &gt;&gt;&gt; 16即把hashcode的高16位向右移动到低16位。然后将<strong>hashCode的高16位和低16位异或</strong>，异或混合过后<strong>高16位的特征也掺杂进低16位</strong>，让数字的每一位都参加了散列运算当中。就像下面一样（h代表原本hashcode）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h:        <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">0000</span> <span class=\"number\">1110</span> <span class=\"number\">1010</span></span><br><span class=\"line\">h&gt;&gt;<span class=\"number\">16</span>:    <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span></span><br><span class=\"line\">newh=h^h&gt;&gt;<span class=\"number\">16</span>:<span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">0000</span> <span class=\"number\">1111</span> <span class=\"number\">0001</span> <span class=\"number\">0101</span></span><br></pre></td></tr></table></figure>\n<p>这样就混合了高位低位数据特征。此外，还有一个重要的原因，在后面使用（length - 1) &amp; hash算下标时，因为length必然是2的次幂，length-1的二进制看起来就是一堆0后面跟着一个1（这个在下面第三套也会提到），如果不做扰动，高位的hashcode大部分情况都用不上。</p>\n<h3 id=\"第二套：key是如何hash出对应的数组下标？\"><a href=\"#第二套：key是如何hash出对应的数组下标？\" class=\"headerlink\" title=\"第二套：key是如何hash出对应的数组下标？\"></a>第二套：key是如何hash出对应的数组下标？</h3><p>hash出应的数组下标理所当然的做法就取余hashcode % length，但jdk用了更有效率的<strong>位操作(length - 1) &amp; hash</strong>来代替取余操作。</p>\n<h3 id=\"第三套：为什么长度一定要是2的整次幂？\"><a href=\"#第三套：为什么长度一定要是2的整次幂？\" class=\"headerlink\" title=\"第三套：为什么长度一定要是2的整次幂？\"></a>第三套：为什么长度一定要是2的整次幂？</h3><p>只有当数组长度是2的整次幂的时候，<strong>(length - 1) &amp; hash才可以代替取余操作hash%length</strong> ，毕竟位运算比取余操作效率更高。当长度是2的整次幂时候，比如8的二进制是1000，肉眼看过去是“一个1后面跟着一堆0”，在减一后就变成了0111，肉眼看过去是”前面全是0后面全是1“。再<strong>和hash与运算出的结果不会超过数组长度，因为前面全是0，与的结果还是0。</strong></p>\n<p>比如长度如果是16，h是上面扰动函数算出的hashcode</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">length-<span class=\"number\">1</span>:     <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">1111</span></span><br><span class=\"line\">h:            <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">0000</span> <span class=\"number\">1111</span> <span class=\"number\">0001</span> <span class=\"number\">0101</span></span><br><span class=\"line\">(length-<span class=\"number\">1</span>)&amp;h: <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0101</span></span><br></pre></td></tr></table></figure>\n<p>假设有两个个key，他们的hashcode不同，分别为code1和code2code1和code2分别与“前面全是0后面全是1“二进制相与，结果一定不同。<strong>但是，如果code1和code2分别与一个“后面不一定是1“的二进制相与，结果有可能相同</strong>。</p>\n<h2 id=\"lazy-load\"><a href=\"#lazy-load\" class=\"headerlink\" title=\"lazy_load\"></a>lazy_load</h2><p>HashMap是延迟加载，即构造函数不负责初始化，而是由resize（）扩容承担初始化的责任。</p>\n<p>具体过程是：第一次调用put()方法判断数组是否为空，如果为空调用resize（）扩容方法初始化后再put（）。</p>\n<h2 id=\"1-7链表插入区别\"><a href=\"#1-7链表插入区别\" class=\"headerlink\" title=\"1.7链表插入区别\"></a>1.7链表插入区别</h2><p>HashMap在jdk<strong>1.7中采用头插入法</strong>，在扩容时会改变链表中元素原本的顺序，以至于在并发场景下导致链表成环的问题。</p>\n<p>而在jdk<strong>1.8中采用尾插入法</strong>，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。</p>\n<h1 id=\"重要方法源码分析\"><a href=\"#重要方法源码分析\" class=\"headerlink\" title=\"重要方法源码分析\"></a>重要方法源码分析</h1><h2 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put()\"></a>put()</h2><p>put方法主要由putVal方法实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">//判断HashMap有没有初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>) <span class=\"comment\">//jdk源码的风格 在判断语句赋值</span></span><br><span class=\"line\">            n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">//如果没有产生hash冲突</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"comment\">//直接在数组tab[i = (n - 1) &amp; hash]处新建一个结点</span></span><br><span class=\"line\">            tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">            <span class=\"comment\">//发生了hash冲突，并且key相同，对结点进行更新</span></span><br><span class=\"line\">           </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) <span class=\"comment\">//HashMap允许为空，空值是不能直接判断相等的</span></span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">            <span class=\"comment\">//如果结点是树节点，就插入到红黑树中</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//否则，则为链表，遍历查找</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//到链表尾也没有找到就在尾部插入一个新结点。</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                        <span class=\"comment\">//注意添加之后链表长度若大于8的话，需将链表转为红黑树</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                            treeifyBin(tab, hash);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                        <span class=\"comment\">//找到就跳出去更新结点的值</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    p = e;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">                V oldValue = e.value;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    e.value = value;</span><br><span class=\"line\">                afterNodeAccess(e);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++modCount;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        afterNodeInsertion(evict);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"put（）可能造成线程不安全的问题\"><a href=\"#put（）可能造成线程不安全的问题\" class=\"headerlink\" title=\"put（）可能造成线程不安全的问题\"></a>put（）可能造成线程不安全的问题</h3><ul>\n<li>JDK8之前，并发put下可能造成死循环。原因是多线程下单链表的数据结构被破环，指向混乱，造成了链表成环。JDK 8中对HashMap做了大量优化，已经不存在这个问题。</li>\n<li>并发put，有可能造成键值对的丢失，如果两个线程同时读取到当前node，在链表尾部插入，先插入的线程是无效的，会被后面的线程覆盖掉。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>判断HashMap有没有初始化，并赋值</li>\n<li>如果没有产生hash冲突，直接在数组tab[i = (n - 1) &amp; hash]处新建一个结点；</li>\n<li>否则，发生了hash冲突，此时key如果和头结点的key相同，找到要更新的结点，直接跳到最后去更新值</li>\n<li>否则，如果数组下标中的类型是TreeNode，就插入到红黑树中</li>\n<li>如果只是普通的链表，就在链表中查找，找到key相同的结点就跳出，到最后去更新值；到链表尾也没有找到就在尾部插入一个新结点。</li>\n<li>判断此时链表长度若大于8的话，还需要将链表转为红黑树（注意在要将链表转为红黑树之前，再进行一次判断，若数组容量小于64，则用resize扩容，放弃转为红黑树）</li>\n</ol>\n<h2 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h2><p>get方法主要由getNode方法实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">    <span class=\"comment\">//判断HashMap有没有被初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">            (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//数组下标的链表头就找到key相同的，那么返回链表头的值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">                ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果数组下标处的类型是TreeNode，就在红黑树中查找</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">                <span class=\"comment\">//在链表中遍历查找了</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>如果在数组下标的链表头就找到key相同的，那么返回链表头的值</li>\n<li>否则如果数组下标处的类型是TreeNode，就在红黑树中查找</li>\n<li>否则就是在普通链表中查找了</li>\n<li>都找不到就返回null</li>\n</ol>\n<p>remove方法的流程大致和get方法类似。</p>\n<h2 id=\"resize\"><a href=\"#resize\" class=\"headerlink\" title=\"resize()\"></a>resize()</h2><p>扩容方法有这么一句<code>newCap = oldCap &lt;&lt; 1</code>说明是扩容后数组大小是原数组的两倍。</p>\n<p>同时，该方法也承担了首次put值时，<strong>初始化数组</strong>的责任。</p>\n<p>这个方法有点长，我将它分为三段分析。</p>\n<p>下面三段在源码中是连在一起的一个方法，只是我这里为了逻辑清晰把它分开了。</p>\n<p>第一段，准备好新数组，并做对数组的大小的进行判断，如果是初始化数组，基本工作在这一段就完成了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;<span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果旧数组的长度已经达到最大容量了2^30</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//将阈值修改为int的最大值，不进行扩容直接返回旧数组</span></span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">        &#125;<span class=\"comment\">//新长度是新长度的2倍之后新长度小于最大容量+旧长度大于初始化长度16</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            <span class=\"comment\">//阈值扩大一倍</span></span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">    &#125;<span class=\"comment\">//这种情况是指定了初始容量，new HashMap（int initialCapacity），第一次put初始化的时候</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//这种情况是没指定初始容量，new HashMap（），第一次put初始化的时候      </span></span><br><span class=\"line\">        <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                  (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"comment\">//初始化新数组</span></span><br><span class=\"line\">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">    <span class=\"comment\">//如果是初始化，到这里就结束啦，直接跳到最后返回table新数组。</span></span><br><span class=\"line\">    table = newTab;</span><br></pre></td></tr></table></figure>\n<p>第二段，遍历原数组每一个结点，有三种情况：只有一个头结点、是红黑树、是链表。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//遍历原数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 如果数组中只有一个元素，即只有一个头结点，重新哈希新下标就可以了</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">            <span class=\"comment\">//如果是一个树节点</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//否则就是链表，这种情况复制比较复杂，单独分一段讲</span></span><br></pre></td></tr></table></figure>\n<p>第三段，链表的复制比较复杂。</p>\n<ul>\n<li>旧链表拆分成两个新链表。首先我们要明白，新数组的的长度是旧数组的两倍。也就是说<strong>旧数组的一个下标可以对应新数组的两个下标</strong>。比如就数组的下标是k，新数组的就对应k和k+oldCap两个下标。于是我们准备<strong>两个链表作为新数组的两个下标的结点</strong>，这里我叫这两个链表为A和B。</li>\n<li>拆分的标准是e.hash &amp; oldCap == 0。这句其实就是<strong>取e的hashcode在长度范围内的最高位</strong>，其实最高位不外乎两种情况，1和0。但是怎么能取到在长度范围内的最高位呢——把它和长度做与就可得到。比如长度是4，与上e的hashcode得最高位为1。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hashcode:<span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">0000</span> <span class=\"number\">1111</span> <span class=\"number\">0001</span> <span class=\"number\">0101</span></span><br><span class=\"line\">length:  <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0001</span> <span class=\"number\">0000</span></span><br><span class=\"line\">         <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0001</span> <span class=\"number\">0000</span></span><br></pre></td></tr></table></figure>\n<p>如果(e.hash &amp; oldCap) 等于0，则该节点在新、旧数组的下标都是k。</p>\n<p>如果(e.hash &amp; oldCap) 不等于0，则该节点在新数组的下标是k+oldCap。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">           <span class=\"comment\">//loHead指向lo链表的头，loTail指向lo链表尾                 </span></span><br><span class=\"line\">                Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">           <span class=\"comment\">//hiHead指向hi链表的头，hiTail指向hi链表尾     </span></span><br><span class=\"line\">                Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                Node&lt;K,V&gt; next;</span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    next = e.next;</span><br><span class=\"line\">                    <span class=\"comment\">//(e.hash &amp; oldCap) == 0)哈希值最高位是0分到链表lo</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                            loHead = e;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            loTail.next = e;</span><br><span class=\"line\">                        loTail = e;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//否则分到链表hi</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                            hiHead = e;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            hiTail.next = e;</span><br><span class=\"line\">                        hiTail = e;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">             <span class=\"comment\">//如果lo链表不为空，loHead挂到新数组[原下标]处；</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    newTab[j] = loHead;</span><br><span class=\"line\">                &#125;<span class=\"comment\">//如果hi链表不为空，hiHead挂到新数组中[原下标+oldCap]处</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> newTab;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>如果数组未被初始化，就根据初始化值初始化数组</li>\n<li>否则新生成一个长度是原来2倍的新数组，把所有元素复制到新数组</li>\n<li>如果元素只有一个节点，复制到重新hash()计算的下标</li>\n<li>如果是一个树节点，就对树进行复制</li>\n<li>如果是链表，则新生成两个链表，一个挂在原下标位置，一个挂在原下标+原长度位置</li>\n</ol>\n<h1 id=\"其他相似的集合\"><a href=\"#其他相似的集合\" class=\"headerlink\" title=\"其他相似的集合\"></a>其他相似的集合</h1><h2 id=\"与HashTable\"><a href=\"#与HashTable\" class=\"headerlink\" title=\"与HashTable\"></a>与HashTable</h2><p>一、<strong>是否允许为空</strong>。HashMap可以允许存在<strong>一个</strong>为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。</p>\n<p>当HashMap遇到为null的key时，它会调用putForNullKey方法来进行处理。value如果为空则抛出NullPointerException()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)            <span class=\"keyword\">return</span> putForNullKey(value);      而当HashTable遇到<span class=\"keyword\">null</span>时，他会直接抛出NullPointerException异常信息。</span><br><span class=\"line\"><span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br></pre></td></tr></table></figure>\n<p>二、<strong>是否线程安全。</strong>Hashtable的方法是线程安全的，而HashMap的方法不是。</p>\n<p>Hashtable的方法都是用synchronized修饰的，在修改数组时锁住整个Hashtable，<strong>这样的做法效率很低</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;...&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>三、HashTable基于Dictionary类，而HashMap是基于AbstractMap。</p>\n<p>四、HashTable直接调用hashcode，而HashMap会经过扰动函数，        而且用与位运算代替了取余。因此<strong>HashTable的长度不用是2的整次幂</strong></p>\n<h2 id=\"与ConcurrentHashMap\"><a href=\"#与ConcurrentHashMap\" class=\"headerlink\" title=\"与ConcurrentHashMap\"></a>与ConcurrentHashMap</h2><p>JDK1.7基于分段锁，减少锁粒度。ConcurrentHashMap中的分段锁称为<strong>Segment</strong>，它继承了ReentrantLock，扮演锁的角色，它有着类似于HashMap的结构，即守护着一个HashEntry数组。</p>\n<p>JDK1.8采用Node 数组+链表/红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）t</p>\n<p>get方法是<strong>不加锁的</strong>，因为get方法里的共享变量都定义成volatile类型，保证能被多线程的读，但只能被单线程的写。即使一个线程在读一个线程同时在写，根据happen before原则，对volatile字段的写入先于读操作，所以get总能拿到最新的值。这是用volatile替换锁的经典场景。</p>\n<p>put方法会检查是否有Node节点,如果没有则在循环中使用<strong>CAS</strong>进行添加(链表的头节点),如果检査到内部正在扩容,就helpTransfer协助扩容。否则使用 <strong>synchronized锁住头元素</strong>(链表/红黑二叉树的头元素)添加元素。</p>\n<p>扩容，让每个线程处理自己的区间。通过给每个线程分配桶区间，避免线程间的争用。而如果有新的线程想 put 数据时，也会帮助其扩容。无锁扩容的关键就是通过CAS设置sizeCtl与transferIndex变量，协调多个线程对table数组中的node进行迁移（transferIndex是指向剩余迁移结点的指针）。复制链表时同样会将链表拆成两份。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>HashMap是java使用频率最高的集合类之一。本文将从重要知识点、主要方法源码分析、与其他集合的比较三个方面来探索<strong>JDK1.8</strong>版本的HashMap。本文目录如下</p>\n<p>[TOC]</p>\n<h1 id=\"重要知识点\"><a href=\"#重要知识点\" class=\"headerlink\" title=\"重要知识点\"></a>重要知识点</h1><h2 id=\"继承关系\"><a href=\"#继承关系\" class=\"headerlink\" title=\"继承关系\"></a>继承关系</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;<span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure>\n<p>可以看到HashMap继承了AbstractMap实现了三个接口Map&lt;K,V&gt;, Cloneable, Serializable。我的理解是继承一个类是将HashMap<strong>分为map类</strong>，而实现接口是表明HashMap有可复制、可序列化的<strong>能力</strong>。</p>\n<p><em>顺便说一句，不知道大家有没有想过为什么HashMap既然继承了AbstractMap为什么还要实现Map？并且AbstractMap也实现了Map？ 我看的时候好奇就去网上搜了搜，据java集合框架的创始人Josh Bloch描述，这样的写法其实是一个失误。在java集合框架中，类似这样的写法很多。最开始写java集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，JDK的维护者，后来不认为这个小小的失误值得去修改。所以就这样存在下来了。<a href=\"https://stackoverflow.com/questions/2165204/why-does-linkedhashsete-extend-hashsete-and-implement-sete\" target=\"_blank\" rel=\"noopener\">stack overflow上的回答</a></em></p>\n<h2 id=\"重要参数\"><a href=\"#重要参数\" class=\"headerlink\" title=\"重要参数\"></a>重要参数</h2><h3 id=\"静态常量\"><a href=\"#静态常量\" class=\"headerlink\" title=\"静态常量\"></a>静态常量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始容量为2^4=16</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 最大容量=2^30,传入容量过大将被这个值替换</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 负载因子=0.75，当键值对个数达到&gt;=容量* 负载因子（0.75）会触发resize扩容 </span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 树化的阀值=8，当链表长度大于8，且数组长度大于MIN_TREEIFY_CAPACITY，就会转为红黑树</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非树化的阀值=6，当resize时候发现链表长度小于6时，从红黑树退化为链表</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//最小的树化容量=64， 在要将链表转为红黑树之前，再进行一次判断，若数组容量小于该值，则用resize扩容，放弃转为红黑树</span></span><br><span class=\"line\"><span class=\"comment\">// 意图：在建立Map的初期，放置过多键值对进入同一个数组下标中，而导致不必要的链表-&gt;红黑树的转化，此时扩容即可，可有效减少冲突</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;</span><br></pre></td></tr></table></figure>\n<p>重点解释一下负载因子，HashMap不是在容量等于size的时候才扩容，而是在快接近size时候就提前扩容。负载因子就是决定提前到多大。负载因子越大表示散列表的装填程度越高，反之越小。<br>它默认是0.75，也可以在构造函数里自定义。<br>负载因子越大，散列表的数据越密集，空间利用率越大，key也越容易冲突化为链表/红黑树，查找效率低；<br>负载因子越小，散列表的数据越稀疏，对空间的利用越浪费，但key也越不容易冲突，查找效率高。系统默认负载因子为0.75，一般情况下我们是无需修改的。</p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>HashMap是一个映射散列表，它存储的数据是键值对(key-value)。<br>JDK1.8前采用数组+链表/红黑树， Node&lt;K,V&gt;[] table数组中的每一个Node元素是一个链表的头结点。这样结合数组和链表的优点，查询效率是大O(1)。</p>\n<p>构造函数如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        Node&lt;K,V&gt; next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><p>HashMap的位运算可以说是老*猪带胸罩，一套接一套的。</p>\n<h3 id=\"第一套：扰动函数\"><a href=\"#第一套：扰动函数\" class=\"headerlink\" title=\"第一套：扰动函数\"></a>第一套：扰动函数</h3><p>HashMap不是直接使用key的hashcode，而是要做异或加工。<strong>目的是减少散列冲突,使元素能够更均匀的分布在数组中。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final int hash(Object key) &#123;</span><br><span class=\"line\">        int h;</span><br><span class=\"line\">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>hashcode是一个int类型32位的数，h &gt;&gt;&gt; 16即把hashcode的高16位向右移动到低16位。然后将<strong>hashCode的高16位和低16位异或</strong>，异或混合过后<strong>高16位的特征也掺杂进低16位</strong>，让数字的每一位都参加了散列运算当中。就像下面一样（h代表原本hashcode）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h:        <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">0000</span> <span class=\"number\">1110</span> <span class=\"number\">1010</span></span><br><span class=\"line\">h&gt;&gt;<span class=\"number\">16</span>:    <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span></span><br><span class=\"line\">newh=h^h&gt;&gt;<span class=\"number\">16</span>:<span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">0000</span> <span class=\"number\">1111</span> <span class=\"number\">0001</span> <span class=\"number\">0101</span></span><br></pre></td></tr></table></figure>\n<p>这样就混合了高位低位数据特征。此外，还有一个重要的原因，在后面使用（length - 1) &amp; hash算下标时，因为length必然是2的次幂，length-1的二进制看起来就是一堆0后面跟着一个1（这个在下面第三套也会提到），如果不做扰动，高位的hashcode大部分情况都用不上。</p>\n<h3 id=\"第二套：key是如何hash出对应的数组下标？\"><a href=\"#第二套：key是如何hash出对应的数组下标？\" class=\"headerlink\" title=\"第二套：key是如何hash出对应的数组下标？\"></a>第二套：key是如何hash出对应的数组下标？</h3><p>hash出应的数组下标理所当然的做法就取余hashcode % length，但jdk用了更有效率的<strong>位操作(length - 1) &amp; hash</strong>来代替取余操作。</p>\n<h3 id=\"第三套：为什么长度一定要是2的整次幂？\"><a href=\"#第三套：为什么长度一定要是2的整次幂？\" class=\"headerlink\" title=\"第三套：为什么长度一定要是2的整次幂？\"></a>第三套：为什么长度一定要是2的整次幂？</h3><p>只有当数组长度是2的整次幂的时候，<strong>(length - 1) &amp; hash才可以代替取余操作hash%length</strong> ，毕竟位运算比取余操作效率更高。当长度是2的整次幂时候，比如8的二进制是1000，肉眼看过去是“一个1后面跟着一堆0”，在减一后就变成了0111，肉眼看过去是”前面全是0后面全是1“。再<strong>和hash与运算出的结果不会超过数组长度，因为前面全是0，与的结果还是0。</strong></p>\n<p>比如长度如果是16，h是上面扰动函数算出的hashcode</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">length-<span class=\"number\">1</span>:     <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">1111</span></span><br><span class=\"line\">h:            <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">0000</span> <span class=\"number\">1111</span> <span class=\"number\">0001</span> <span class=\"number\">0101</span></span><br><span class=\"line\">(length-<span class=\"number\">1</span>)&amp;h: <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0101</span></span><br></pre></td></tr></table></figure>\n<p>假设有两个个key，他们的hashcode不同，分别为code1和code2code1和code2分别与“前面全是0后面全是1“二进制相与，结果一定不同。<strong>但是，如果code1和code2分别与一个“后面不一定是1“的二进制相与，结果有可能相同</strong>。</p>\n<h2 id=\"lazy-load\"><a href=\"#lazy-load\" class=\"headerlink\" title=\"lazy_load\"></a>lazy_load</h2><p>HashMap是延迟加载，即构造函数不负责初始化，而是由resize（）扩容承担初始化的责任。</p>\n<p>具体过程是：第一次调用put()方法判断数组是否为空，如果为空调用resize（）扩容方法初始化后再put（）。</p>\n<h2 id=\"1-7链表插入区别\"><a href=\"#1-7链表插入区别\" class=\"headerlink\" title=\"1.7链表插入区别\"></a>1.7链表插入区别</h2><p>HashMap在jdk<strong>1.7中采用头插入法</strong>，在扩容时会改变链表中元素原本的顺序，以至于在并发场景下导致链表成环的问题。</p>\n<p>而在jdk<strong>1.8中采用尾插入法</strong>，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。</p>\n<h1 id=\"重要方法源码分析\"><a href=\"#重要方法源码分析\" class=\"headerlink\" title=\"重要方法源码分析\"></a>重要方法源码分析</h1><h2 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put()\"></a>put()</h2><p>put方法主要由putVal方法实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">//判断HashMap有没有初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>) <span class=\"comment\">//jdk源码的风格 在判断语句赋值</span></span><br><span class=\"line\">            n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">//如果没有产生hash冲突</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"comment\">//直接在数组tab[i = (n - 1) &amp; hash]处新建一个结点</span></span><br><span class=\"line\">            tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">            <span class=\"comment\">//发生了hash冲突，并且key相同，对结点进行更新</span></span><br><span class=\"line\">           </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) <span class=\"comment\">//HashMap允许为空，空值是不能直接判断相等的</span></span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">            <span class=\"comment\">//如果结点是树节点，就插入到红黑树中</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//否则，则为链表，遍历查找</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//到链表尾也没有找到就在尾部插入一个新结点。</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                        <span class=\"comment\">//注意添加之后链表长度若大于8的话，需将链表转为红黑树</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                            treeifyBin(tab, hash);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                        <span class=\"comment\">//找到就跳出去更新结点的值</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    p = e;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">                V oldValue = e.value;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    e.value = value;</span><br><span class=\"line\">                afterNodeAccess(e);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++modCount;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        afterNodeInsertion(evict);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"put（）可能造成线程不安全的问题\"><a href=\"#put（）可能造成线程不安全的问题\" class=\"headerlink\" title=\"put（）可能造成线程不安全的问题\"></a>put（）可能造成线程不安全的问题</h3><ul>\n<li>JDK8之前，并发put下可能造成死循环。原因是多线程下单链表的数据结构被破环，指向混乱，造成了链表成环。JDK 8中对HashMap做了大量优化，已经不存在这个问题。</li>\n<li>并发put，有可能造成键值对的丢失，如果两个线程同时读取到当前node，在链表尾部插入，先插入的线程是无效的，会被后面的线程覆盖掉。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>判断HashMap有没有初始化，并赋值</li>\n<li>如果没有产生hash冲突，直接在数组tab[i = (n - 1) &amp; hash]处新建一个结点；</li>\n<li>否则，发生了hash冲突，此时key如果和头结点的key相同，找到要更新的结点，直接跳到最后去更新值</li>\n<li>否则，如果数组下标中的类型是TreeNode，就插入到红黑树中</li>\n<li>如果只是普通的链表，就在链表中查找，找到key相同的结点就跳出，到最后去更新值；到链表尾也没有找到就在尾部插入一个新结点。</li>\n<li>判断此时链表长度若大于8的话，还需要将链表转为红黑树（注意在要将链表转为红黑树之前，再进行一次判断，若数组容量小于64，则用resize扩容，放弃转为红黑树）</li>\n</ol>\n<h2 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h2><p>get方法主要由getNode方法实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">    <span class=\"comment\">//判断HashMap有没有被初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">            (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//数组下标的链表头就找到key相同的，那么返回链表头的值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">                ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果数组下标处的类型是TreeNode，就在红黑树中查找</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">                <span class=\"comment\">//在链表中遍历查找了</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>如果在数组下标的链表头就找到key相同的，那么返回链表头的值</li>\n<li>否则如果数组下标处的类型是TreeNode，就在红黑树中查找</li>\n<li>否则就是在普通链表中查找了</li>\n<li>都找不到就返回null</li>\n</ol>\n<p>remove方法的流程大致和get方法类似。</p>\n<h2 id=\"resize\"><a href=\"#resize\" class=\"headerlink\" title=\"resize()\"></a>resize()</h2><p>扩容方法有这么一句<code>newCap = oldCap &lt;&lt; 1</code>说明是扩容后数组大小是原数组的两倍。</p>\n<p>同时，该方法也承担了首次put值时，<strong>初始化数组</strong>的责任。</p>\n<p>这个方法有点长，我将它分为三段分析。</p>\n<p>下面三段在源码中是连在一起的一个方法，只是我这里为了逻辑清晰把它分开了。</p>\n<p>第一段，准备好新数组，并做对数组的大小的进行判断，如果是初始化数组，基本工作在这一段就完成了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;<span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果旧数组的长度已经达到最大容量了2^30</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//将阈值修改为int的最大值，不进行扩容直接返回旧数组</span></span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">        &#125;<span class=\"comment\">//新长度是新长度的2倍之后新长度小于最大容量+旧长度大于初始化长度16</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            <span class=\"comment\">//阈值扩大一倍</span></span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">    &#125;<span class=\"comment\">//这种情况是指定了初始容量，new HashMap（int initialCapacity），第一次put初始化的时候</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//这种情况是没指定初始容量，new HashMap（），第一次put初始化的时候      </span></span><br><span class=\"line\">        <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                  (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"comment\">//初始化新数组</span></span><br><span class=\"line\">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">    <span class=\"comment\">//如果是初始化，到这里就结束啦，直接跳到最后返回table新数组。</span></span><br><span class=\"line\">    table = newTab;</span><br></pre></td></tr></table></figure>\n<p>第二段，遍历原数组每一个结点，有三种情况：只有一个头结点、是红黑树、是链表。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//遍历原数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 如果数组中只有一个元素，即只有一个头结点，重新哈希新下标就可以了</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">            <span class=\"comment\">//如果是一个树节点</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//否则就是链表，这种情况复制比较复杂，单独分一段讲</span></span><br></pre></td></tr></table></figure>\n<p>第三段，链表的复制比较复杂。</p>\n<ul>\n<li>旧链表拆分成两个新链表。首先我们要明白，新数组的的长度是旧数组的两倍。也就是说<strong>旧数组的一个下标可以对应新数组的两个下标</strong>。比如就数组的下标是k，新数组的就对应k和k+oldCap两个下标。于是我们准备<strong>两个链表作为新数组的两个下标的结点</strong>，这里我叫这两个链表为A和B。</li>\n<li>拆分的标准是e.hash &amp; oldCap == 0。这句其实就是<strong>取e的hashcode在长度范围内的最高位</strong>，其实最高位不外乎两种情况，1和0。但是怎么能取到在长度范围内的最高位呢——把它和长度做与就可得到。比如长度是4，与上e的hashcode得最高位为1。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hashcode:<span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">1111</span> <span class=\"number\">0000</span> <span class=\"number\">1111</span> <span class=\"number\">0001</span> <span class=\"number\">0101</span></span><br><span class=\"line\">length:  <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0001</span> <span class=\"number\">0000</span></span><br><span class=\"line\">         <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0001</span> <span class=\"number\">0000</span></span><br></pre></td></tr></table></figure>\n<p>如果(e.hash &amp; oldCap) 等于0，则该节点在新、旧数组的下标都是k。</p>\n<p>如果(e.hash &amp; oldCap) 不等于0，则该节点在新数组的下标是k+oldCap。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">           <span class=\"comment\">//loHead指向lo链表的头，loTail指向lo链表尾                 </span></span><br><span class=\"line\">                Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">           <span class=\"comment\">//hiHead指向hi链表的头，hiTail指向hi链表尾     </span></span><br><span class=\"line\">                Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                Node&lt;K,V&gt; next;</span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    next = e.next;</span><br><span class=\"line\">                    <span class=\"comment\">//(e.hash &amp; oldCap) == 0)哈希值最高位是0分到链表lo</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                            loHead = e;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            loTail.next = e;</span><br><span class=\"line\">                        loTail = e;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//否则分到链表hi</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                            hiHead = e;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            hiTail.next = e;</span><br><span class=\"line\">                        hiTail = e;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">             <span class=\"comment\">//如果lo链表不为空，loHead挂到新数组[原下标]处；</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    newTab[j] = loHead;</span><br><span class=\"line\">                &#125;<span class=\"comment\">//如果hi链表不为空，hiHead挂到新数组中[原下标+oldCap]处</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> newTab;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>如果数组未被初始化，就根据初始化值初始化数组</li>\n<li>否则新生成一个长度是原来2倍的新数组，把所有元素复制到新数组</li>\n<li>如果元素只有一个节点，复制到重新hash()计算的下标</li>\n<li>如果是一个树节点，就对树进行复制</li>\n<li>如果是链表，则新生成两个链表，一个挂在原下标位置，一个挂在原下标+原长度位置</li>\n</ol>\n<h1 id=\"其他相似的集合\"><a href=\"#其他相似的集合\" class=\"headerlink\" title=\"其他相似的集合\"></a>其他相似的集合</h1><h2 id=\"与HashTable\"><a href=\"#与HashTable\" class=\"headerlink\" title=\"与HashTable\"></a>与HashTable</h2><p>一、<strong>是否允许为空</strong>。HashMap可以允许存在<strong>一个</strong>为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。</p>\n<p>当HashMap遇到为null的key时，它会调用putForNullKey方法来进行处理。value如果为空则抛出NullPointerException()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)            <span class=\"keyword\">return</span> putForNullKey(value);      而当HashTable遇到<span class=\"keyword\">null</span>时，他会直接抛出NullPointerException异常信息。</span><br><span class=\"line\"><span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br></pre></td></tr></table></figure>\n<p>二、<strong>是否线程安全。</strong>Hashtable的方法是线程安全的，而HashMap的方法不是。</p>\n<p>Hashtable的方法都是用synchronized修饰的，在修改数组时锁住整个Hashtable，<strong>这样的做法效率很低</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;...&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>三、HashTable基于Dictionary类，而HashMap是基于AbstractMap。</p>\n<p>四、HashTable直接调用hashcode，而HashMap会经过扰动函数，        而且用与位运算代替了取余。因此<strong>HashTable的长度不用是2的整次幂</strong></p>\n<h2 id=\"与ConcurrentHashMap\"><a href=\"#与ConcurrentHashMap\" class=\"headerlink\" title=\"与ConcurrentHashMap\"></a>与ConcurrentHashMap</h2><p>JDK1.7基于分段锁，减少锁粒度。ConcurrentHashMap中的分段锁称为<strong>Segment</strong>，它继承了ReentrantLock，扮演锁的角色，它有着类似于HashMap的结构，即守护着一个HashEntry数组。</p>\n<p>JDK1.8采用Node 数组+链表/红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）t</p>\n<p>get方法是<strong>不加锁的</strong>，因为get方法里的共享变量都定义成volatile类型，保证能被多线程的读，但只能被单线程的写。即使一个线程在读一个线程同时在写，根据happen before原则，对volatile字段的写入先于读操作，所以get总能拿到最新的值。这是用volatile替换锁的经典场景。</p>\n<p>put方法会检查是否有Node节点,如果没有则在循环中使用<strong>CAS</strong>进行添加(链表的头节点),如果检査到内部正在扩容,就helpTransfer协助扩容。否则使用 <strong>synchronized锁住头元素</strong>(链表/红黑二叉树的头元素)添加元素。</p>\n<p>扩容，让每个线程处理自己的区间。通过给每个线程分配桶区间，避免线程间的争用。而如果有新的线程想 put 数据时，也会帮助其扩容。无锁扩容的关键就是通过CAS设置sizeCtl与transferIndex变量，协调多个线程对table数组中的node进行迁移（transferIndex是指向剩余迁移结点的指针）。复制链表时同样会将链表拆成两份。</p>\n"},{"title":"Hibernate简单入门","date":"2018-09-27T13:13:50.000Z","description":"Hibernate","_content":"\n# Hibernate简单入门\n用这个框架，只需要三步。配置Product.hbm.xml文件和hibernate.cfg.xml文件、编写测试类\n## Product.hbm.xml文件\n作用是将javabean对应数据库中的表\n```\n<?xml version=\"1.0\"?>\n   <!DOCTYPE hibernate-mapping PUBLIC\n           \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n           \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n    \n   <hibernate-mapping package=\"com.how2java.pojo\">\n       <class name=\"Product\" table=\"product_\">//表示类Product对应表product_\n\n           <id name=\"id\" column=\"id\">//表示属性id,映射表里的字段id\n               <generator class=\"native\">//意味着id的自增长方式采用数据库的本地方式\n               </generator>\n           </id>\n           <property name=\"name\" />//这里没有通过column=\"name\" 显式的指定字段），因为属性和字段同名\n           <property name=\"price\" />\n       </class>\n        \n   </hibernate-mapping>\n ```\n\n\n##  hibernate.cfg.xml文件\n访问数据库配置。注意，这个文件要放在**src目录**下\n```\n<?xml version='1.0' encoding='utf-8'?>\n<!DOCTYPE hibernate-configuration PUBLIC\n       \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n\"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\">\n \n<hibernate-configuration>\n \n    <session-factory>\n        <!-- Database connection settings -->\n        <property name=\"connection.driver_class\">com.mysql.jdbc.Driver</property>\n        <property name=\"connection.url\">jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8</property>//这表示使用MYSQL方言\n        <property name=\"connection.username\">root</property>\n        <property name=\"connection.password\">admin</property>\n        <!-- SQL dialect -->\n        <property name=\"dialect\">org.hibernate.dialect.MySQLDialect</property>\n        <property name=\"current_session_context_class\">thread</property>\n        <property name=\"show_sql\">true</property>//这表示是否在控制台显示执行的sql语句\n        <property name=\"hbm2ddl.auto\">update</property>//这表示是否会自动更新数据库的表结构，有这句话Hibernate会自动去创建表结构\n        <mapping resource=\"com/how2java/pojo/Product.hbm.xml\" />//识别Product这个实体类\n    </session-factory>\n \n</hibernate-configuration>\n```\n## 测试类\n\nhibernate的基本步骤是：\n1. 获取SessionFactory \n2. 通过SessionFactory 获取一个Session\n3. 在Session基础上开启一个事务\n4. 通过调用Session的save方法把对象保存到数据库\n5. 提交事务\n6. 关闭Session\n7. 关闭SessionFactory\n```\nSessionFactory sf = new Configuration().configure().buildSessionFactory();//1.获取SessionFactory\n\nSession s = sf.openSession();//2.通过SessionFactory 获取一个Session\ns.beginTransaction();//3.在Session基础上开启一个事务\n\nProduct p = new Product();\np.setName(\"iphone7\");\np.setPrice(7000);\ns.save(p);//4. 通过调用Session的save方法把对象保存到数据库\n\ns.getTransaction().commit();//5. 提交事务\ns.close();//6. 关闭Session\nsf.close();//7. 关闭SessionFactory\n```","source":"_posts/Hibernate.md","raw":"---\ntitle: Hibernate简单入门\ndate: 2018-09-27 21:13:50\ncategories: java\ndescription: Hibernate\n---\n\n# Hibernate简单入门\n用这个框架，只需要三步。配置Product.hbm.xml文件和hibernate.cfg.xml文件、编写测试类\n## Product.hbm.xml文件\n作用是将javabean对应数据库中的表\n```\n<?xml version=\"1.0\"?>\n   <!DOCTYPE hibernate-mapping PUBLIC\n           \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n           \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n    \n   <hibernate-mapping package=\"com.how2java.pojo\">\n       <class name=\"Product\" table=\"product_\">//表示类Product对应表product_\n\n           <id name=\"id\" column=\"id\">//表示属性id,映射表里的字段id\n               <generator class=\"native\">//意味着id的自增长方式采用数据库的本地方式\n               </generator>\n           </id>\n           <property name=\"name\" />//这里没有通过column=\"name\" 显式的指定字段），因为属性和字段同名\n           <property name=\"price\" />\n       </class>\n        \n   </hibernate-mapping>\n ```\n\n\n##  hibernate.cfg.xml文件\n访问数据库配置。注意，这个文件要放在**src目录**下\n```\n<?xml version='1.0' encoding='utf-8'?>\n<!DOCTYPE hibernate-configuration PUBLIC\n       \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n\"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\">\n \n<hibernate-configuration>\n \n    <session-factory>\n        <!-- Database connection settings -->\n        <property name=\"connection.driver_class\">com.mysql.jdbc.Driver</property>\n        <property name=\"connection.url\">jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8</property>//这表示使用MYSQL方言\n        <property name=\"connection.username\">root</property>\n        <property name=\"connection.password\">admin</property>\n        <!-- SQL dialect -->\n        <property name=\"dialect\">org.hibernate.dialect.MySQLDialect</property>\n        <property name=\"current_session_context_class\">thread</property>\n        <property name=\"show_sql\">true</property>//这表示是否在控制台显示执行的sql语句\n        <property name=\"hbm2ddl.auto\">update</property>//这表示是否会自动更新数据库的表结构，有这句话Hibernate会自动去创建表结构\n        <mapping resource=\"com/how2java/pojo/Product.hbm.xml\" />//识别Product这个实体类\n    </session-factory>\n \n</hibernate-configuration>\n```\n## 测试类\n\nhibernate的基本步骤是：\n1. 获取SessionFactory \n2. 通过SessionFactory 获取一个Session\n3. 在Session基础上开启一个事务\n4. 通过调用Session的save方法把对象保存到数据库\n5. 提交事务\n6. 关闭Session\n7. 关闭SessionFactory\n```\nSessionFactory sf = new Configuration().configure().buildSessionFactory();//1.获取SessionFactory\n\nSession s = sf.openSession();//2.通过SessionFactory 获取一个Session\ns.beginTransaction();//3.在Session基础上开启一个事务\n\nProduct p = new Product();\np.setName(\"iphone7\");\np.setPrice(7000);\ns.save(p);//4. 通过调用Session的save方法把对象保存到数据库\n\ns.getTransaction().commit();//5. 提交事务\ns.close();//6. 关闭Session\nsf.close();//7. 关闭SessionFactory\n```","slug":"Hibernate","published":1,"updated":"2022-02-08T07:09:41.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qju0005w9rprwnfxb8t","content":"<h1 id=\"Hibernate简单入门\"><a href=\"#Hibernate简单入门\" class=\"headerlink\" title=\"Hibernate简单入门\"></a>Hibernate简单入门</h1><p>用这个框架，只需要三步。配置Product.hbm.xml文件和hibernate.cfg.xml文件、编写测试类</p>\n<h2 id=\"Product-hbm-xml文件\"><a href=\"#Product-hbm-xml文件\" class=\"headerlink\" title=\"Product.hbm.xml文件\"></a>Product.hbm.xml文件</h2><p>作用是将javabean对应数据库中的表<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">   &lt;!DOCTYPE hibernate-mapping PUBLIC</span><br><span class=\"line\">           &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span><br><span class=\"line\">           &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">   &lt;hibernate-mapping package=&quot;com.how2java.pojo&quot;&gt;</span><br><span class=\"line\">       &lt;class name=&quot;Product&quot; table=&quot;product_&quot;&gt;//表示类Product对应表product_</span><br><span class=\"line\"></span><br><span class=\"line\">           &lt;id name=&quot;id&quot; column=&quot;id&quot;&gt;//表示属性id,映射表里的字段id</span><br><span class=\"line\">               &lt;generator class=&quot;native&quot;&gt;//意味着id的自增长方式采用数据库的本地方式</span><br><span class=\"line\">               &lt;/generator&gt;</span><br><span class=\"line\">           &lt;/id&gt;</span><br><span class=\"line\">           &lt;property name=&quot;name&quot; /&gt;//这里没有通过column=&quot;name&quot; 显式的指定字段），因为属性和字段同名</span><br><span class=\"line\">           &lt;property name=&quot;price&quot; /&gt;</span><br><span class=\"line\">       &lt;/class&gt;</span><br><span class=\"line\">        </span><br><span class=\"line\">   &lt;/hibernate-mapping&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"hibernate-cfg-xml文件\"><a href=\"#hibernate-cfg-xml文件\" class=\"headerlink\" title=\"hibernate.cfg.xml文件\"></a>hibernate.cfg.xml文件</h2><p>访问数据库配置。注意，这个文件要放在<strong>src目录</strong>下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE hibernate-configuration PUBLIC</span><br><span class=\"line\">       &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;</span><br><span class=\"line\">&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;hibernate-configuration&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;session-factory&gt;</span><br><span class=\"line\">        &lt;!-- Database connection settings --&gt;</span><br><span class=\"line\">        &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;</span><br><span class=\"line\">        &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8&lt;/property&gt;//这表示使用MYSQL方言</span><br><span class=\"line\">        &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt;</span><br><span class=\"line\">        &lt;property name=&quot;connection.password&quot;&gt;admin&lt;/property&gt;</span><br><span class=\"line\">        &lt;!-- SQL dialect --&gt;</span><br><span class=\"line\">        &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;</span><br><span class=\"line\">        &lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt;</span><br><span class=\"line\">        &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt;//这表示是否在控制台显示执行的sql语句</span><br><span class=\"line\">        &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt;//这表示是否会自动更新数据库的表结构，有这句话Hibernate会自动去创建表结构</span><br><span class=\"line\">        &lt;mapping resource=&quot;com/how2java/pojo/Product.hbm.xml&quot; /&gt;//识别Product这个实体类</span><br><span class=\"line\">    &lt;/session-factory&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;/hibernate-configuration&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"测试类\"><a href=\"#测试类\" class=\"headerlink\" title=\"测试类\"></a>测试类</h2><p>hibernate的基本步骤是：</p>\n<ol>\n<li>获取SessionFactory </li>\n<li>通过SessionFactory 获取一个Session</li>\n<li>在Session基础上开启一个事务</li>\n<li>通过调用Session的save方法把对象保存到数据库</li>\n<li>提交事务</li>\n<li>关闭Session</li>\n<li>关闭SessionFactory<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SessionFactory sf = new Configuration().configure().buildSessionFactory();//1.获取SessionFactory</span><br><span class=\"line\"></span><br><span class=\"line\">Session s = sf.openSession();//2.通过SessionFactory 获取一个Session</span><br><span class=\"line\">s.beginTransaction();//3.在Session基础上开启一个事务</span><br><span class=\"line\"></span><br><span class=\"line\">Product p = new Product();</span><br><span class=\"line\">p.setName(&quot;iphone7&quot;);</span><br><span class=\"line\">p.setPrice(7000);</span><br><span class=\"line\">s.save(p);//4. 通过调用Session的save方法把对象保存到数据库</span><br><span class=\"line\"></span><br><span class=\"line\">s.getTransaction().commit();//5. 提交事务</span><br><span class=\"line\">s.close();//6. 关闭Session</span><br><span class=\"line\">sf.close();//7. 关闭SessionFactory</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Hibernate简单入门\"><a href=\"#Hibernate简单入门\" class=\"headerlink\" title=\"Hibernate简单入门\"></a>Hibernate简单入门</h1><p>用这个框架，只需要三步。配置Product.hbm.xml文件和hibernate.cfg.xml文件、编写测试类</p>\n<h2 id=\"Product-hbm-xml文件\"><a href=\"#Product-hbm-xml文件\" class=\"headerlink\" title=\"Product.hbm.xml文件\"></a>Product.hbm.xml文件</h2><p>作用是将javabean对应数据库中的表<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">   &lt;!DOCTYPE hibernate-mapping PUBLIC</span><br><span class=\"line\">           &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span><br><span class=\"line\">           &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">   &lt;hibernate-mapping package=&quot;com.how2java.pojo&quot;&gt;</span><br><span class=\"line\">       &lt;class name=&quot;Product&quot; table=&quot;product_&quot;&gt;//表示类Product对应表product_</span><br><span class=\"line\"></span><br><span class=\"line\">           &lt;id name=&quot;id&quot; column=&quot;id&quot;&gt;//表示属性id,映射表里的字段id</span><br><span class=\"line\">               &lt;generator class=&quot;native&quot;&gt;//意味着id的自增长方式采用数据库的本地方式</span><br><span class=\"line\">               &lt;/generator&gt;</span><br><span class=\"line\">           &lt;/id&gt;</span><br><span class=\"line\">           &lt;property name=&quot;name&quot; /&gt;//这里没有通过column=&quot;name&quot; 显式的指定字段），因为属性和字段同名</span><br><span class=\"line\">           &lt;property name=&quot;price&quot; /&gt;</span><br><span class=\"line\">       &lt;/class&gt;</span><br><span class=\"line\">        </span><br><span class=\"line\">   &lt;/hibernate-mapping&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"hibernate-cfg-xml文件\"><a href=\"#hibernate-cfg-xml文件\" class=\"headerlink\" title=\"hibernate.cfg.xml文件\"></a>hibernate.cfg.xml文件</h2><p>访问数据库配置。注意，这个文件要放在<strong>src目录</strong>下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE hibernate-configuration PUBLIC</span><br><span class=\"line\">       &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;</span><br><span class=\"line\">&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;hibernate-configuration&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;session-factory&gt;</span><br><span class=\"line\">        &lt;!-- Database connection settings --&gt;</span><br><span class=\"line\">        &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;</span><br><span class=\"line\">        &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8&lt;/property&gt;//这表示使用MYSQL方言</span><br><span class=\"line\">        &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt;</span><br><span class=\"line\">        &lt;property name=&quot;connection.password&quot;&gt;admin&lt;/property&gt;</span><br><span class=\"line\">        &lt;!-- SQL dialect --&gt;</span><br><span class=\"line\">        &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;</span><br><span class=\"line\">        &lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt;</span><br><span class=\"line\">        &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt;//这表示是否在控制台显示执行的sql语句</span><br><span class=\"line\">        &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt;//这表示是否会自动更新数据库的表结构，有这句话Hibernate会自动去创建表结构</span><br><span class=\"line\">        &lt;mapping resource=&quot;com/how2java/pojo/Product.hbm.xml&quot; /&gt;//识别Product这个实体类</span><br><span class=\"line\">    &lt;/session-factory&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;/hibernate-configuration&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"测试类\"><a href=\"#测试类\" class=\"headerlink\" title=\"测试类\"></a>测试类</h2><p>hibernate的基本步骤是：</p>\n<ol>\n<li>获取SessionFactory </li>\n<li>通过SessionFactory 获取一个Session</li>\n<li>在Session基础上开启一个事务</li>\n<li>通过调用Session的save方法把对象保存到数据库</li>\n<li>提交事务</li>\n<li>关闭Session</li>\n<li>关闭SessionFactory<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SessionFactory sf = new Configuration().configure().buildSessionFactory();//1.获取SessionFactory</span><br><span class=\"line\"></span><br><span class=\"line\">Session s = sf.openSession();//2.通过SessionFactory 获取一个Session</span><br><span class=\"line\">s.beginTransaction();//3.在Session基础上开启一个事务</span><br><span class=\"line\"></span><br><span class=\"line\">Product p = new Product();</span><br><span class=\"line\">p.setName(&quot;iphone7&quot;);</span><br><span class=\"line\">p.setPrice(7000);</span><br><span class=\"line\">s.save(p);//4. 通过调用Session的save方法把对象保存到数据库</span><br><span class=\"line\"></span><br><span class=\"line\">s.getTransaction().commit();//5. 提交事务</span><br><span class=\"line\">s.close();//6. 关闭Session</span><br><span class=\"line\">sf.close();//7. 关闭SessionFactory</span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"用java实现一个LRU","date":"2019-07-25T08:36:50.000Z","description":"Least Recently Used(LRU)，即最近最少使用页面置换算法。","_content":"\n# 概念\n\nLeast Recently Used(LRU)，即最近最少使用页面置换算法。**选择最长时间没有被引用的页面进行置换**，思想是：如果一个页面很久没有被引用到，那么可以认为在将来该页面也很少被访问到。\n\n在操作系统中的应用：当发生缺页（CPU要访问的页不在内存中），计算内存中每个页上一次被访问的时间，置换上次使用到当前时间最长的一个页面。\n\n使用java可以有两种实现方式。\n\n# 第一种：双向链表+哈希表\n\n可以使用**双向链表+哈希表**的方式。**HashMap主要是为了判断是否命中缓存。LinkedList用于维护一个按最近一次访问时间排序的页面链表。**链表头结点是最近刚刚访问过的页面，链表尾结点是最久未被访问的页面。访问内存时，若命中缓存，找到响应的页面，将其移动到链表头部，表示该页面是最近刚刚访问的。缺页时，将链表尾部的页面移除，同时新页面放到链表头。\n\n该类有四个方法：\n\n- moveToFirst()：把该元素移动链表的头部\n- removeLast()：把链表尾部元素删除。\n- get()：同步获取元素,map未命中，返回null。map命中则获取，并调用moveToFirst。\n- put()：同步放入元素。如果map未命中，如果链表长度已经超过缓存的大小，移除链表尾部的元素，把元素放入链表的头部和map里。如果map命中，则moveToFirst把该元素移到链表的头。\n\n\n\n```java\npublic class LRUCache<K, V> {\n    public static void main(String[] args) {\n        LRUCache<String,String> lru=new LRUCache<>(10);\n        lru.put(\"C\", null);\n        lru.put(\"A\", null);\n        lru.put(\"D\", null);\n        lru.put(\"B\", null);\n        lru.put(\"E\", null);\n        lru.put(\"B\", null);\n        lru.put(\"A\", null);\n        lru.put(\"B\", null);\n        lru.put(\"C\", null);\n        lru.put(\"D\", null);\n\n        System.out.println(lru);\n        /*\n        out:[D, C, B, A, E]\n        */\n\n    }\n    //缓存大小，put时候需判断有没超过缓存大小\n    private final int cacheSize;\n    //用散列表判断是否命中缓存。\n    private HashMap<K, V> map = new HashMap<>();\n    //用链表维护最近一次访问时间排序的页面链表\n    private LinkedList<K> linkCache = new LinkedList();\n\n    LRUCache(int cacheSize) {\n        this.cacheSize = cacheSize;\n    }\n    \n    private synchronized void removeLast() {\n        linkCache.removeLast();\n    }\n    \n//用syn保证线程安全\n    public synchronized void put(K key, V val) {\n        if (!map.containsKey(key)) {\n            if (map.size() >= cacheSize) {\n                removeLast();\n            }\n            map.put(key, val);\n            linkCache.addFirst(key);//put加到链表头\n        } else {\n            moveToFirst(key);\n        }\n    }\n\n    public synchronized V get(K key) {\n        if (!map.containsKey(key)) {\n            return null;\n        }\n        moveToFirst(key);\n        return map.get(key);\n    }\n\n    private synchronized void moveToFirst(K key) {\n        linkCache.remove(key);\n        linkCache.addFirst(key);\n\n    }\n    \n    @Override\n    public String toString() {\n        return linkCache.toString();\n    }\n}\n\n```\n\n\n\n# 第二种：LinkedHashMap\n\nJDK其实已经实现了一种顺序存储的HashMap，我们可以直接使用。代码如下\n\n\n\n```java\npackage other;\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * @description:\n * @author: wangxuanni\n * @create: 2019-08-13 23:40\n **/\n\npublic class LRU3<K, V> {\n    public static void main(String[] args) {\n        LRU3<String, Integer> lru3 = new LRU3<>(3);\n        lru3.put(\"A\", 1);\n        lru3.put(\"B\", 2);\n        lru3.put(\"C\", 3);\n        lru3.put(\"D\", 4);\n        lru3.put(\"A\", 1);\n        lru3.put(\"B\", 2);\n        lru3.print();\n        //out：D--A--B--\n\n    }\n\n    private static final float hashLoadFactory = 0.75f;\n    private LinkedHashMap<K, V> map;\n    private int cacheSize;\n\n    public LRU3(int cacheSize) {\n        this.cacheSize = cacheSize;\n        int capacity = (int) Math.ceil(cacheSize / hashLoadFactory) + 1;\n        // 最后一个参数true 表示按访问顺序来进行排序\n        map = new LinkedHashMap<K, V>(capacity, hashLoadFactory, true) {\n            private static final long serialVersionUID = 1;\n       // 当 map中的数据量大于cacheSize的时候，就自动删除最老的数据。\n            @Override\n            protected boolean removeEldestEntry(Map.Entry eldest){\n                return size() > LRU3.this.cacheSize;\n            }\n        };\n    }\n\n    public synchronized void put(K key, V value) {\n        map.put(key, value);\n    }\n\n    public void print() {\n        for (Map.Entry<K, V> entry : map.entrySet()) {\n            System.out.print(entry.getKey() + \"--\");\n        }\n        System.out.println();\n    }\n}\n\n```\n\n\n\n## LinkedHashMap原理\n\nLinkedHashMap继承了HashMap，作为HashMap的亲儿子，它们有很多相似的地方。\n\n### 构造方法\n\n```java\n    public LinkedHashMap() {\n        // 调用HashMap的构造方法，其实就是初始化Entry[] table\n        super();\n        // 这里是指是否基于访问排序，默认为false\n        accessOrder = false;\n    }\n```\n\n这里有一个重要的成员变量accessOrder。因LinkedHashMap存储数据是有序的，而且分为两种：插入顺序和访问顺序。accessOrder则表示是否按访问顺序存储。这里设置为**false**，表示是**插入顺序存储的**，这也是默认值。\n\n在上面代码中，构造函数的最后一个参数就是把accessOrder设置为**true**，表示按访问顺序排序\n\n```java\nmap = new LinkedHashMap<K, V>(capacity, hashLoadFactory, true)\n```\n\n### Entry\n\nLinkedHashMap与HashMap最大的不同在于它的Entry有**前后指针—**— Entry<K,V> before, after\n\n```cpp\n    /**\n     * LinkedHashMap entry.\n     */\n    private static class Entry<K,V> extends HashMap.Entry<K,V> {\n        // These fields comprise the doubly linked list used for iteration.\n        Entry<K,V> before, after;\n\n        Entry(int hash, K key, V value, HashMap.Entry<K,V> next) {\n            super(hash, key, value, next);\n        }\n```\n\n此外，在初始化的时候除了初始化了一个Entry[] table，还会额外初始化一个hash=-1，key、value、next都为null的**只有头结点的双向链表**，如图\n\n![img](https://upload-images.jianshu.io/upload_images/4843132-cac0b65e4d23b6bd.png?imageMogr2/auto-orient/strip|imageView2/2/w/524/format/webp)\n\n```java\n@Override\nvoid init() {\n        // 创建了一个hash=-1，key、value、next都为null的Entry\n        header = new Entry<>(-1, null, null, null);\n        // 让创建的Entry的before和after都指向自身，注意after不是之前提到的next\n        // 其实就是创建了一个只有头部节点的双向链表\n        header.before = header.after = header;\n    }\n```\n\n### put元素\n\n当put元素时，不但要把它加入到HashMap中去，还要加入到双向链表中。\n\n首先是只加入一个元素Entry1，假设index为0：\n\n![img](https://upload-images.jianshu.io/upload_images/4843132-d48bb58775418c95.png?imageMogr2/auto-orient/strip|imageView2/2/w/475/format/webp)\n\nLinkedHashMap结构一个元素.png\n\n当再加入一个元素Entry2，假设index为15：\n\n![img](https://upload-images.jianshu.io/upload_images/4843132-10c917166c1f4745.png?imageMogr2/auto-orient/strip|imageView2/2/w/525/format/webp)\n\nLinkedHashMap结构两个元素.png\n\n### 双向链表的重排序\n\n当key如果已经存在时，并且accessOrder为true，即是访问顺序模式，才会put时对更新的Entry进行重新排序，而如果是插入顺序模式时，不会重新排序，这里的排序跟在HashMap中存储没有关系，只是指在双向链表中的顺序。\n\n举个栗子：开始时，HashMap中有Entry1、Entry2、Entry3，并设置LinkedHashMap为访问顺序，则更新Entry1时，会先把Entry1从双向链表中删除，然后再把Entry1加入到双向链表的表尾，而Entry1在HashMap结构中的存储位置没有变化。\n\n\n\n\n\n最后，有一个面试问题是如何实现顺序存储的hashmap，看完这篇文章，可以轻松回答了：可以使用双向链表加哈希表，也可以参照LinkedHashMap实现原理。\n\n> [图解LinkedHashMap原理，关于LinkedHashMap大部分原理都来自该博文](https://www.jianshu.com/p/8f4f58b4b8ab)","source":"_posts/LRU.md","raw":"---\ntitle: 用java实现一个LRU\ndate: 2019-07-25 16:36:50\ncategories: 算法\ndescription: Least Recently Used(LRU)，即最近最少使用页面置换算法。\n---\n\n# 概念\n\nLeast Recently Used(LRU)，即最近最少使用页面置换算法。**选择最长时间没有被引用的页面进行置换**，思想是：如果一个页面很久没有被引用到，那么可以认为在将来该页面也很少被访问到。\n\n在操作系统中的应用：当发生缺页（CPU要访问的页不在内存中），计算内存中每个页上一次被访问的时间，置换上次使用到当前时间最长的一个页面。\n\n使用java可以有两种实现方式。\n\n# 第一种：双向链表+哈希表\n\n可以使用**双向链表+哈希表**的方式。**HashMap主要是为了判断是否命中缓存。LinkedList用于维护一个按最近一次访问时间排序的页面链表。**链表头结点是最近刚刚访问过的页面，链表尾结点是最久未被访问的页面。访问内存时，若命中缓存，找到响应的页面，将其移动到链表头部，表示该页面是最近刚刚访问的。缺页时，将链表尾部的页面移除，同时新页面放到链表头。\n\n该类有四个方法：\n\n- moveToFirst()：把该元素移动链表的头部\n- removeLast()：把链表尾部元素删除。\n- get()：同步获取元素,map未命中，返回null。map命中则获取，并调用moveToFirst。\n- put()：同步放入元素。如果map未命中，如果链表长度已经超过缓存的大小，移除链表尾部的元素，把元素放入链表的头部和map里。如果map命中，则moveToFirst把该元素移到链表的头。\n\n\n\n```java\npublic class LRUCache<K, V> {\n    public static void main(String[] args) {\n        LRUCache<String,String> lru=new LRUCache<>(10);\n        lru.put(\"C\", null);\n        lru.put(\"A\", null);\n        lru.put(\"D\", null);\n        lru.put(\"B\", null);\n        lru.put(\"E\", null);\n        lru.put(\"B\", null);\n        lru.put(\"A\", null);\n        lru.put(\"B\", null);\n        lru.put(\"C\", null);\n        lru.put(\"D\", null);\n\n        System.out.println(lru);\n        /*\n        out:[D, C, B, A, E]\n        */\n\n    }\n    //缓存大小，put时候需判断有没超过缓存大小\n    private final int cacheSize;\n    //用散列表判断是否命中缓存。\n    private HashMap<K, V> map = new HashMap<>();\n    //用链表维护最近一次访问时间排序的页面链表\n    private LinkedList<K> linkCache = new LinkedList();\n\n    LRUCache(int cacheSize) {\n        this.cacheSize = cacheSize;\n    }\n    \n    private synchronized void removeLast() {\n        linkCache.removeLast();\n    }\n    \n//用syn保证线程安全\n    public synchronized void put(K key, V val) {\n        if (!map.containsKey(key)) {\n            if (map.size() >= cacheSize) {\n                removeLast();\n            }\n            map.put(key, val);\n            linkCache.addFirst(key);//put加到链表头\n        } else {\n            moveToFirst(key);\n        }\n    }\n\n    public synchronized V get(K key) {\n        if (!map.containsKey(key)) {\n            return null;\n        }\n        moveToFirst(key);\n        return map.get(key);\n    }\n\n    private synchronized void moveToFirst(K key) {\n        linkCache.remove(key);\n        linkCache.addFirst(key);\n\n    }\n    \n    @Override\n    public String toString() {\n        return linkCache.toString();\n    }\n}\n\n```\n\n\n\n# 第二种：LinkedHashMap\n\nJDK其实已经实现了一种顺序存储的HashMap，我们可以直接使用。代码如下\n\n\n\n```java\npackage other;\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * @description:\n * @author: wangxuanni\n * @create: 2019-08-13 23:40\n **/\n\npublic class LRU3<K, V> {\n    public static void main(String[] args) {\n        LRU3<String, Integer> lru3 = new LRU3<>(3);\n        lru3.put(\"A\", 1);\n        lru3.put(\"B\", 2);\n        lru3.put(\"C\", 3);\n        lru3.put(\"D\", 4);\n        lru3.put(\"A\", 1);\n        lru3.put(\"B\", 2);\n        lru3.print();\n        //out：D--A--B--\n\n    }\n\n    private static final float hashLoadFactory = 0.75f;\n    private LinkedHashMap<K, V> map;\n    private int cacheSize;\n\n    public LRU3(int cacheSize) {\n        this.cacheSize = cacheSize;\n        int capacity = (int) Math.ceil(cacheSize / hashLoadFactory) + 1;\n        // 最后一个参数true 表示按访问顺序来进行排序\n        map = new LinkedHashMap<K, V>(capacity, hashLoadFactory, true) {\n            private static final long serialVersionUID = 1;\n       // 当 map中的数据量大于cacheSize的时候，就自动删除最老的数据。\n            @Override\n            protected boolean removeEldestEntry(Map.Entry eldest){\n                return size() > LRU3.this.cacheSize;\n            }\n        };\n    }\n\n    public synchronized void put(K key, V value) {\n        map.put(key, value);\n    }\n\n    public void print() {\n        for (Map.Entry<K, V> entry : map.entrySet()) {\n            System.out.print(entry.getKey() + \"--\");\n        }\n        System.out.println();\n    }\n}\n\n```\n\n\n\n## LinkedHashMap原理\n\nLinkedHashMap继承了HashMap，作为HashMap的亲儿子，它们有很多相似的地方。\n\n### 构造方法\n\n```java\n    public LinkedHashMap() {\n        // 调用HashMap的构造方法，其实就是初始化Entry[] table\n        super();\n        // 这里是指是否基于访问排序，默认为false\n        accessOrder = false;\n    }\n```\n\n这里有一个重要的成员变量accessOrder。因LinkedHashMap存储数据是有序的，而且分为两种：插入顺序和访问顺序。accessOrder则表示是否按访问顺序存储。这里设置为**false**，表示是**插入顺序存储的**，这也是默认值。\n\n在上面代码中，构造函数的最后一个参数就是把accessOrder设置为**true**，表示按访问顺序排序\n\n```java\nmap = new LinkedHashMap<K, V>(capacity, hashLoadFactory, true)\n```\n\n### Entry\n\nLinkedHashMap与HashMap最大的不同在于它的Entry有**前后指针—**— Entry<K,V> before, after\n\n```cpp\n    /**\n     * LinkedHashMap entry.\n     */\n    private static class Entry<K,V> extends HashMap.Entry<K,V> {\n        // These fields comprise the doubly linked list used for iteration.\n        Entry<K,V> before, after;\n\n        Entry(int hash, K key, V value, HashMap.Entry<K,V> next) {\n            super(hash, key, value, next);\n        }\n```\n\n此外，在初始化的时候除了初始化了一个Entry[] table，还会额外初始化一个hash=-1，key、value、next都为null的**只有头结点的双向链表**，如图\n\n![img](https://upload-images.jianshu.io/upload_images/4843132-cac0b65e4d23b6bd.png?imageMogr2/auto-orient/strip|imageView2/2/w/524/format/webp)\n\n```java\n@Override\nvoid init() {\n        // 创建了一个hash=-1，key、value、next都为null的Entry\n        header = new Entry<>(-1, null, null, null);\n        // 让创建的Entry的before和after都指向自身，注意after不是之前提到的next\n        // 其实就是创建了一个只有头部节点的双向链表\n        header.before = header.after = header;\n    }\n```\n\n### put元素\n\n当put元素时，不但要把它加入到HashMap中去，还要加入到双向链表中。\n\n首先是只加入一个元素Entry1，假设index为0：\n\n![img](https://upload-images.jianshu.io/upload_images/4843132-d48bb58775418c95.png?imageMogr2/auto-orient/strip|imageView2/2/w/475/format/webp)\n\nLinkedHashMap结构一个元素.png\n\n当再加入一个元素Entry2，假设index为15：\n\n![img](https://upload-images.jianshu.io/upload_images/4843132-10c917166c1f4745.png?imageMogr2/auto-orient/strip|imageView2/2/w/525/format/webp)\n\nLinkedHashMap结构两个元素.png\n\n### 双向链表的重排序\n\n当key如果已经存在时，并且accessOrder为true，即是访问顺序模式，才会put时对更新的Entry进行重新排序，而如果是插入顺序模式时，不会重新排序，这里的排序跟在HashMap中存储没有关系，只是指在双向链表中的顺序。\n\n举个栗子：开始时，HashMap中有Entry1、Entry2、Entry3，并设置LinkedHashMap为访问顺序，则更新Entry1时，会先把Entry1从双向链表中删除，然后再把Entry1加入到双向链表的表尾，而Entry1在HashMap结构中的存储位置没有变化。\n\n\n\n\n\n最后，有一个面试问题是如何实现顺序存储的hashmap，看完这篇文章，可以轻松回答了：可以使用双向链表加哈希表，也可以参照LinkedHashMap实现原理。\n\n> [图解LinkedHashMap原理，关于LinkedHashMap大部分原理都来自该博文](https://www.jianshu.com/p/8f4f58b4b8ab)","slug":"LRU","published":1,"updated":"2022-02-08T07:09:41.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qjx0007w9rp2u9nw9ia","content":"<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><p>Least Recently Used(LRU)，即最近最少使用页面置换算法。<strong>选择最长时间没有被引用的页面进行置换</strong>，思想是：如果一个页面很久没有被引用到，那么可以认为在将来该页面也很少被访问到。</p>\n<p>在操作系统中的应用：当发生缺页（CPU要访问的页不在内存中），计算内存中每个页上一次被访问的时间，置换上次使用到当前时间最长的一个页面。</p>\n<p>使用java可以有两种实现方式。</p>\n<h1 id=\"第一种：双向链表-哈希表\"><a href=\"#第一种：双向链表-哈希表\" class=\"headerlink\" title=\"第一种：双向链表+哈希表\"></a>第一种：双向链表+哈希表</h1><p>可以使用<strong>双向链表+哈希表</strong>的方式。<strong>HashMap主要是为了判断是否命中缓存。LinkedList用于维护一个按最近一次访问时间排序的页面链表。</strong>链表头结点是最近刚刚访问过的页面，链表尾结点是最久未被访问的页面。访问内存时，若命中缓存，找到响应的页面，将其移动到链表头部，表示该页面是最近刚刚访问的。缺页时，将链表尾部的页面移除，同时新页面放到链表头。</p>\n<p>该类有四个方法：</p>\n<ul>\n<li>moveToFirst()：把该元素移动链表的头部</li>\n<li>removeLast()：把链表尾部元素删除。</li>\n<li>get()：同步获取元素,map未命中，返回null。map命中则获取，并调用moveToFirst。</li>\n<li>put()：同步放入元素。如果map未命中，如果链表长度已经超过缓存的大小，移除链表尾部的元素，把元素放入链表的头部和map里。如果map命中，则moveToFirst把该元素移到链表的头。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCache</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LRUCache&lt;String,String&gt; lru=<span class=\"keyword\">new</span> LRUCache&lt;&gt;(<span class=\"number\">10</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"C\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"A\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"D\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"B\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"E\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"B\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"A\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"B\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"C\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"D\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(lru);</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        out:[D, C, B, A, E]</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//缓存大小，put时候需判断有没超过缓存大小</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> cacheSize;</span><br><span class=\"line\">    <span class=\"comment\">//用散列表判断是否命中缓存。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> HashMap&lt;K, V&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//用链表维护最近一次访问时间排序的页面链表</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedList&lt;K&gt; linkCache = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\"></span><br><span class=\"line\">    LRUCache(<span class=\"keyword\">int</span> cacheSize) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cacheSize = cacheSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">removeLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        linkCache.removeLast();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//用syn保证线程安全</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(K key, V val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!map.containsKey(key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.size() &gt;= cacheSize) &#123;</span><br><span class=\"line\">                removeLast();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            map.put(key, val);</span><br><span class=\"line\">            linkCache.addFirst(key);<span class=\"comment\">//put加到链表头</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            moveToFirst(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">get</span><span class=\"params\">(K key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!map.containsKey(key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        moveToFirst(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.get(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">moveToFirst</span><span class=\"params\">(K key)</span> </span>&#123;</span><br><span class=\"line\">        linkCache.remove(key);</span><br><span class=\"line\">        linkCache.addFirst(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> linkCache.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"第二种：LinkedHashMap\"><a href=\"#第二种：LinkedHashMap\" class=\"headerlink\" title=\"第二种：LinkedHashMap\"></a>第二种：LinkedHashMap</h1><p>JDK其实已经实现了一种顺序存储的HashMap，我们可以直接使用。代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> other;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedHashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>: wangxuanni</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span>: 2019-08-13 23:40</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRU3</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LRU3&lt;String, Integer&gt; lru3 = <span class=\"keyword\">new</span> LRU3&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\">        lru3.put(<span class=\"string\">\"A\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        lru3.put(<span class=\"string\">\"B\"</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        lru3.put(<span class=\"string\">\"C\"</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        lru3.put(<span class=\"string\">\"D\"</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">        lru3.put(<span class=\"string\">\"A\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        lru3.put(<span class=\"string\">\"B\"</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        lru3.print();</span><br><span class=\"line\">        <span class=\"comment\">//out：D--A--B--</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> hashLoadFactory = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedHashMap&lt;K, V&gt; map;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> cacheSize;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LRU3</span><span class=\"params\">(<span class=\"keyword\">int</span> cacheSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cacheSize = cacheSize;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> capacity = (<span class=\"keyword\">int</span>) Math.ceil(cacheSize / hashLoadFactory) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 最后一个参数true 表示按访问顺序来进行排序</span></span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> LinkedHashMap&lt;K, V&gt;(capacity, hashLoadFactory, <span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 当 map中的数据量大于cacheSize的时候，就自动删除最老的数据。</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeEldestEntry</span><span class=\"params\">(Map.Entry eldest)</span></span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> size() &gt; LRU3.<span class=\"keyword\">this</span>.cacheSize;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">        map.put(key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">            System.out.print(entry.getKey() + <span class=\"string\">\"--\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"LinkedHashMap原理\"><a href=\"#LinkedHashMap原理\" class=\"headerlink\" title=\"LinkedHashMap原理\"></a>LinkedHashMap原理</h2><p>LinkedHashMap继承了HashMap，作为HashMap的亲儿子，它们有很多相似的地方。</p>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用HashMap的构造方法，其实就是初始化Entry[] table</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 这里是指是否基于访问排序，默认为false</span></span><br><span class=\"line\">    accessOrder = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有一个重要的成员变量accessOrder。因LinkedHashMap存储数据是有序的，而且分为两种：插入顺序和访问顺序。accessOrder则表示是否按访问顺序存储。这里设置为<strong>false</strong>，表示是<strong>插入顺序存储的</strong>，这也是默认值。</p>\n<p>在上面代码中，构造函数的最后一个参数就是把accessOrder设置为<strong>true</strong>，表示按访问顺序排序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map = <span class=\"keyword\">new</span> LinkedHashMap&lt;K, V&gt;(capacity, hashLoadFactory, <span class=\"keyword\">true</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Entry\"><a href=\"#Entry\" class=\"headerlink\" title=\"Entry\"></a>Entry</h3><p>LinkedHashMap与HashMap最大的不同在于它的Entry有<strong>前后指针—</strong>— Entry&lt;K,V&gt; before, after</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * LinkedHashMap entry.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;K,V&gt; <span class=\"title\">extends</span> <span class=\"title\">HashMap</span>.<span class=\"title\">Entry</span>&lt;K,V&gt; &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// These fields comprise the doubly linked list used for iteration.</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; before, after;</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry(<span class=\"keyword\">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        super(hash, key, value, next);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>此外，在初始化的时候除了初始化了一个Entry[] table，还会额外初始化一个hash=-1，key、value、next都为null的<strong>只有头结点的双向链表</strong>，如图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4843132-cac0b65e4d23b6bd.png?imageMogr2/auto-orient/strip|imageView2/2/w/524/format/webp\" alt=\"img\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建了一个hash=-1，key、value、next都为null的Entry</span></span><br><span class=\"line\">        header = <span class=\"keyword\">new</span> Entry&lt;&gt;(-<span class=\"number\">1</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 让创建的Entry的before和after都指向自身，注意after不是之前提到的next</span></span><br><span class=\"line\">        <span class=\"comment\">// 其实就是创建了一个只有头部节点的双向链表</span></span><br><span class=\"line\">        header.before = header.after = header;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"put元素\"><a href=\"#put元素\" class=\"headerlink\" title=\"put元素\"></a>put元素</h3><p>当put元素时，不但要把它加入到HashMap中去，还要加入到双向链表中。</p>\n<p>首先是只加入一个元素Entry1，假设index为0：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4843132-d48bb58775418c95.png?imageMogr2/auto-orient/strip|imageView2/2/w/475/format/webp\" alt=\"img\"></p>\n<p>LinkedHashMap结构一个元素.png</p>\n<p>当再加入一个元素Entry2，假设index为15：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4843132-10c917166c1f4745.png?imageMogr2/auto-orient/strip|imageView2/2/w/525/format/webp\" alt=\"img\"></p>\n<p>LinkedHashMap结构两个元素.png</p>\n<h3 id=\"双向链表的重排序\"><a href=\"#双向链表的重排序\" class=\"headerlink\" title=\"双向链表的重排序\"></a>双向链表的重排序</h3><p>当key如果已经存在时，并且accessOrder为true，即是访问顺序模式，才会put时对更新的Entry进行重新排序，而如果是插入顺序模式时，不会重新排序，这里的排序跟在HashMap中存储没有关系，只是指在双向链表中的顺序。</p>\n<p>举个栗子：开始时，HashMap中有Entry1、Entry2、Entry3，并设置LinkedHashMap为访问顺序，则更新Entry1时，会先把Entry1从双向链表中删除，然后再把Entry1加入到双向链表的表尾，而Entry1在HashMap结构中的存储位置没有变化。</p>\n<p>最后，有一个面试问题是如何实现顺序存储的hashmap，看完这篇文章，可以轻松回答了：可以使用双向链表加哈希表，也可以参照LinkedHashMap实现原理。</p>\n<blockquote>\n<p><a href=\"https://www.jianshu.com/p/8f4f58b4b8ab\" target=\"_blank\" rel=\"noopener\">图解LinkedHashMap原理，关于LinkedHashMap大部分原理都来自该博文</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><p>Least Recently Used(LRU)，即最近最少使用页面置换算法。<strong>选择最长时间没有被引用的页面进行置换</strong>，思想是：如果一个页面很久没有被引用到，那么可以认为在将来该页面也很少被访问到。</p>\n<p>在操作系统中的应用：当发生缺页（CPU要访问的页不在内存中），计算内存中每个页上一次被访问的时间，置换上次使用到当前时间最长的一个页面。</p>\n<p>使用java可以有两种实现方式。</p>\n<h1 id=\"第一种：双向链表-哈希表\"><a href=\"#第一种：双向链表-哈希表\" class=\"headerlink\" title=\"第一种：双向链表+哈希表\"></a>第一种：双向链表+哈希表</h1><p>可以使用<strong>双向链表+哈希表</strong>的方式。<strong>HashMap主要是为了判断是否命中缓存。LinkedList用于维护一个按最近一次访问时间排序的页面链表。</strong>链表头结点是最近刚刚访问过的页面，链表尾结点是最久未被访问的页面。访问内存时，若命中缓存，找到响应的页面，将其移动到链表头部，表示该页面是最近刚刚访问的。缺页时，将链表尾部的页面移除，同时新页面放到链表头。</p>\n<p>该类有四个方法：</p>\n<ul>\n<li>moveToFirst()：把该元素移动链表的头部</li>\n<li>removeLast()：把链表尾部元素删除。</li>\n<li>get()：同步获取元素,map未命中，返回null。map命中则获取，并调用moveToFirst。</li>\n<li>put()：同步放入元素。如果map未命中，如果链表长度已经超过缓存的大小，移除链表尾部的元素，把元素放入链表的头部和map里。如果map命中，则moveToFirst把该元素移到链表的头。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCache</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LRUCache&lt;String,String&gt; lru=<span class=\"keyword\">new</span> LRUCache&lt;&gt;(<span class=\"number\">10</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"C\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"A\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"D\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"B\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"E\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"B\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"A\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"B\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"C\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        lru.put(<span class=\"string\">\"D\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(lru);</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        out:[D, C, B, A, E]</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//缓存大小，put时候需判断有没超过缓存大小</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> cacheSize;</span><br><span class=\"line\">    <span class=\"comment\">//用散列表判断是否命中缓存。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> HashMap&lt;K, V&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//用链表维护最近一次访问时间排序的页面链表</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedList&lt;K&gt; linkCache = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\"></span><br><span class=\"line\">    LRUCache(<span class=\"keyword\">int</span> cacheSize) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cacheSize = cacheSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">removeLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        linkCache.removeLast();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//用syn保证线程安全</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(K key, V val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!map.containsKey(key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.size() &gt;= cacheSize) &#123;</span><br><span class=\"line\">                removeLast();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            map.put(key, val);</span><br><span class=\"line\">            linkCache.addFirst(key);<span class=\"comment\">//put加到链表头</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            moveToFirst(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">get</span><span class=\"params\">(K key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!map.containsKey(key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        moveToFirst(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.get(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">moveToFirst</span><span class=\"params\">(K key)</span> </span>&#123;</span><br><span class=\"line\">        linkCache.remove(key);</span><br><span class=\"line\">        linkCache.addFirst(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> linkCache.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"第二种：LinkedHashMap\"><a href=\"#第二种：LinkedHashMap\" class=\"headerlink\" title=\"第二种：LinkedHashMap\"></a>第二种：LinkedHashMap</h1><p>JDK其实已经实现了一种顺序存储的HashMap，我们可以直接使用。代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> other;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedHashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>: wangxuanni</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span>: 2019-08-13 23:40</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRU3</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LRU3&lt;String, Integer&gt; lru3 = <span class=\"keyword\">new</span> LRU3&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\">        lru3.put(<span class=\"string\">\"A\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        lru3.put(<span class=\"string\">\"B\"</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        lru3.put(<span class=\"string\">\"C\"</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        lru3.put(<span class=\"string\">\"D\"</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">        lru3.put(<span class=\"string\">\"A\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        lru3.put(<span class=\"string\">\"B\"</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        lru3.print();</span><br><span class=\"line\">        <span class=\"comment\">//out：D--A--B--</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> hashLoadFactory = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedHashMap&lt;K, V&gt; map;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> cacheSize;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LRU3</span><span class=\"params\">(<span class=\"keyword\">int</span> cacheSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cacheSize = cacheSize;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> capacity = (<span class=\"keyword\">int</span>) Math.ceil(cacheSize / hashLoadFactory) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 最后一个参数true 表示按访问顺序来进行排序</span></span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> LinkedHashMap&lt;K, V&gt;(capacity, hashLoadFactory, <span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 当 map中的数据量大于cacheSize的时候，就自动删除最老的数据。</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeEldestEntry</span><span class=\"params\">(Map.Entry eldest)</span></span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> size() &gt; LRU3.<span class=\"keyword\">this</span>.cacheSize;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">        map.put(key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">            System.out.print(entry.getKey() + <span class=\"string\">\"--\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"LinkedHashMap原理\"><a href=\"#LinkedHashMap原理\" class=\"headerlink\" title=\"LinkedHashMap原理\"></a>LinkedHashMap原理</h2><p>LinkedHashMap继承了HashMap，作为HashMap的亲儿子，它们有很多相似的地方。</p>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用HashMap的构造方法，其实就是初始化Entry[] table</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 这里是指是否基于访问排序，默认为false</span></span><br><span class=\"line\">    accessOrder = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有一个重要的成员变量accessOrder。因LinkedHashMap存储数据是有序的，而且分为两种：插入顺序和访问顺序。accessOrder则表示是否按访问顺序存储。这里设置为<strong>false</strong>，表示是<strong>插入顺序存储的</strong>，这也是默认值。</p>\n<p>在上面代码中，构造函数的最后一个参数就是把accessOrder设置为<strong>true</strong>，表示按访问顺序排序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map = <span class=\"keyword\">new</span> LinkedHashMap&lt;K, V&gt;(capacity, hashLoadFactory, <span class=\"keyword\">true</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Entry\"><a href=\"#Entry\" class=\"headerlink\" title=\"Entry\"></a>Entry</h3><p>LinkedHashMap与HashMap最大的不同在于它的Entry有<strong>前后指针—</strong>— Entry&lt;K,V&gt; before, after</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * LinkedHashMap entry.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;K,V&gt; <span class=\"title\">extends</span> <span class=\"title\">HashMap</span>.<span class=\"title\">Entry</span>&lt;K,V&gt; &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// These fields comprise the doubly linked list used for iteration.</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; before, after;</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry(<span class=\"keyword\">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        super(hash, key, value, next);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>此外，在初始化的时候除了初始化了一个Entry[] table，还会额外初始化一个hash=-1，key、value、next都为null的<strong>只有头结点的双向链表</strong>，如图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4843132-cac0b65e4d23b6bd.png?imageMogr2/auto-orient/strip|imageView2/2/w/524/format/webp\" alt=\"img\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建了一个hash=-1，key、value、next都为null的Entry</span></span><br><span class=\"line\">        header = <span class=\"keyword\">new</span> Entry&lt;&gt;(-<span class=\"number\">1</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 让创建的Entry的before和after都指向自身，注意after不是之前提到的next</span></span><br><span class=\"line\">        <span class=\"comment\">// 其实就是创建了一个只有头部节点的双向链表</span></span><br><span class=\"line\">        header.before = header.after = header;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"put元素\"><a href=\"#put元素\" class=\"headerlink\" title=\"put元素\"></a>put元素</h3><p>当put元素时，不但要把它加入到HashMap中去，还要加入到双向链表中。</p>\n<p>首先是只加入一个元素Entry1，假设index为0：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4843132-d48bb58775418c95.png?imageMogr2/auto-orient/strip|imageView2/2/w/475/format/webp\" alt=\"img\"></p>\n<p>LinkedHashMap结构一个元素.png</p>\n<p>当再加入一个元素Entry2，假设index为15：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4843132-10c917166c1f4745.png?imageMogr2/auto-orient/strip|imageView2/2/w/525/format/webp\" alt=\"img\"></p>\n<p>LinkedHashMap结构两个元素.png</p>\n<h3 id=\"双向链表的重排序\"><a href=\"#双向链表的重排序\" class=\"headerlink\" title=\"双向链表的重排序\"></a>双向链表的重排序</h3><p>当key如果已经存在时，并且accessOrder为true，即是访问顺序模式，才会put时对更新的Entry进行重新排序，而如果是插入顺序模式时，不会重新排序，这里的排序跟在HashMap中存储没有关系，只是指在双向链表中的顺序。</p>\n<p>举个栗子：开始时，HashMap中有Entry1、Entry2、Entry3，并设置LinkedHashMap为访问顺序，则更新Entry1时，会先把Entry1从双向链表中删除，然后再把Entry1加入到双向链表的表尾，而Entry1在HashMap结构中的存储位置没有变化。</p>\n<p>最后，有一个面试问题是如何实现顺序存储的hashmap，看完这篇文章，可以轻松回答了：可以使用双向链表加哈希表，也可以参照LinkedHashMap实现原理。</p>\n<blockquote>\n<p><a href=\"https://www.jianshu.com/p/8f4f58b4b8ab\" target=\"_blank\" rel=\"noopener\">图解LinkedHashMap原理，关于LinkedHashMap大部分原理都来自该博文</a></p>\n</blockquote>\n"},{"title":"ThreadLocal源码分析","date":"2019-08-10T13:24:50.000Z","description":"线程局部变量，为每一个使用该变量的线程都提供一个变量值的副本，每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。即“以空间换时间”的方式解决线程不安全问题。","_content":"\n[TOC]\n\n前言：ThreadLocal线程局部变量，为每一个使用该变量的线程都提供一个变量值的副本，每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。即“以空间换时间”的方式解决线程不安全问题。\n\n本文首先对ThreadLocal进行源码分析以阐明其原理，而后介绍ThreadLocal重要的三个知识点：它用来解决冲突的办法——线性探测法、它用来解决内存泄露的办法——弱引用、ThreadLocal的清理时机尤其要注意线程池这个例外。\n\n## 源码分析\n\n### 原理\n\nThreadLocal中有一个静态内部类ThreadLocalMap（类似于HashMap但不是）。这个Map的**key是ThreadLocal当前对象，value就是我们存起来的值**。\n\n下面通过分析重要方法的源码来一探究竟。\n\n#### getMap()\n\n取得的是当前线程的ThreadLocalMap\n\n```\n ThreadLocalMap getMap(Thread t) {\n        return t.threadLocals;\n    }\n```\n\n注意：这个map取得的是Thread类的成员变量ThreadLocalMap\n\n```\nclass Thread implements Runnable {\n//每个线程都有自己ThreadLocalMap！\n\tThreadLocal.ThreadLocalMap threadLocals = null;\n```\n\n\n\n#### set()\n\n取当前线程的ThreadLocalMap，key设置为ThreadLocal当前对象，value设置为传入的值\n\n```\n   public void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n```\n\n\n\n#### get()\n\n取当前线程的ThreadLocalMap，将threadLocal作为key获取Entry后获取value。\n\n```java\n   public T get() {\n        Thread t = Thread.currentThread();\n        //取当前对象的map\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n        //将自己作为key取值\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                return (T)e.value;\n            }\n        }\n        return setInitialValue();\n    }\n```\n\n\n\n## 线性探测法\n\nThreadLocalMap是典型的使用线性探测法解决hash冲突的：发生冲突，从该位置向后找到表中的下一个空槽放入。这种简单的方法会导致相同hash值的元素挨在一起和其他hash值对应的槽被占用。\n\n```java\nprivate void set(ThreadLocal<?> key, Object value) {\n......\n//发生冲突，循环去找下一个为空的槽\n//nextIndex()方法就是在长度范围内做i++的操作\n for (Entry e = tab[i];\n                 e != null;\n                 e = tab[i = nextIndex(i, len)]) {\n                ThreadLocal<?> k = e.get();\n\t\t\t\t//key是一样就更新\n                if (k == key) {\n                    e.value = value;\n                    return;\n                }\n\t\t\t//找到下一个空槽就放进去\n                if (k == null) {\n                    replaceStaleEntry(key, value, i);\n                    return;\n                }\n            }\n```\n\n\n\n## 弱引用\n\n总所周知，只要还有引用指向，这个对象就不会被回收。这是针对强引用而言。如果一个类继承了软引用指向实例，如果这个实例没有其他引用了，只有该类引用了，这个对象会被GC立即回收。\n\n```\nA a = new A();\nB b = new B(a);\na = null;//这样a是不会被回收是，因为b还依赖a，造成了内存泄漏。\n\nb = null;//此时，a才会被回收，因为没有引用指向了\n```\n\n如果b还有有用，不能赋值为空，岂非a一直不能被回收？非也，我们还可以用弱引用。\n\n```\nA a = new A();\nWeakReference b = new WeakReference(a);\na=null//GC会立刻回收A这个对象\n```\n\n顺便说一嘴，软引用和弱引用一样, 但被GC回收的时候需要多一个条件: 当系统内存不足时才会被回收. 正因为有这个特性, 软引用比弱引用更加适合做缓存对象的引用。\n\n**ThreadLocal使用了弱引用**.key指向ThreadLocal实例，当ThreadLocal外部强引用被回收时候，key虽然还是指向ThreadLocal，但因为是弱引用，GC会发现并回收。\n\n```\n     static class Entry extends WeakReference<ThreadLocal<?>> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal<?> k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n```\n\n通过表格来说明一下，如下：\n\n| 引用类型 | 被垃圾回收时间 | 用途               |\n| -------- | -------------- | ------------------ |\n| 强引用   | 从来不会       | 对象的一般状态     |\n| 软引用   | 当内存不足时   | 对象缓存           |\n| 弱引用   | 正常垃圾回收时 | 对象缓存           |\n| 虚引用   | 正常垃圾回收时 | 跟踪对象的垃圾回收 |\n\n[理解Java的强引用、软引用、弱引用和虚引用](https://juejin.im/post/5b82c02df265da436152f5ad#heading-5)\n\n## 清理时机\n\n线程退出时，会做一个清理工作，其中就包括清理ThreadLocalMap，即把threadLocals=null。\n\n而然使用线程池会对线程进行**复用**，就意味当前线程未必会退出，可能会出现内存泄露，**即你不用这个对象了，但它无法被回收。因此最好每次使ThreadLocal.remove()方法将这个变量移除。**\n\n> 参考\n>\n> 《Java高并发程序设计》\n>\n> [解决Hash冲突的几种方法](https://blog.csdn.net/u012104435/article/details/47951357)\n>\n> [ThreadLocal和弱引用](https://www.jianshu.com/p/d3e1282ba7ca)\n\n\n\n​     ","source":"_posts/ThreadLocal.md","raw":"---\ntitle: ThreadLocal源码分析\ndate: 2019-08-10 21:24:50\ncategories: 并发\ndescription: 线程局部变量，为每一个使用该变量的线程都提供一个变量值的副本，每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。即“以空间换时间”的方式解决线程不安全问题。\n\n\n\n---\n\n[TOC]\n\n前言：ThreadLocal线程局部变量，为每一个使用该变量的线程都提供一个变量值的副本，每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。即“以空间换时间”的方式解决线程不安全问题。\n\n本文首先对ThreadLocal进行源码分析以阐明其原理，而后介绍ThreadLocal重要的三个知识点：它用来解决冲突的办法——线性探测法、它用来解决内存泄露的办法——弱引用、ThreadLocal的清理时机尤其要注意线程池这个例外。\n\n## 源码分析\n\n### 原理\n\nThreadLocal中有一个静态内部类ThreadLocalMap（类似于HashMap但不是）。这个Map的**key是ThreadLocal当前对象，value就是我们存起来的值**。\n\n下面通过分析重要方法的源码来一探究竟。\n\n#### getMap()\n\n取得的是当前线程的ThreadLocalMap\n\n```\n ThreadLocalMap getMap(Thread t) {\n        return t.threadLocals;\n    }\n```\n\n注意：这个map取得的是Thread类的成员变量ThreadLocalMap\n\n```\nclass Thread implements Runnable {\n//每个线程都有自己ThreadLocalMap！\n\tThreadLocal.ThreadLocalMap threadLocals = null;\n```\n\n\n\n#### set()\n\n取当前线程的ThreadLocalMap，key设置为ThreadLocal当前对象，value设置为传入的值\n\n```\n   public void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n```\n\n\n\n#### get()\n\n取当前线程的ThreadLocalMap，将threadLocal作为key获取Entry后获取value。\n\n```java\n   public T get() {\n        Thread t = Thread.currentThread();\n        //取当前对象的map\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n        //将自己作为key取值\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                return (T)e.value;\n            }\n        }\n        return setInitialValue();\n    }\n```\n\n\n\n## 线性探测法\n\nThreadLocalMap是典型的使用线性探测法解决hash冲突的：发生冲突，从该位置向后找到表中的下一个空槽放入。这种简单的方法会导致相同hash值的元素挨在一起和其他hash值对应的槽被占用。\n\n```java\nprivate void set(ThreadLocal<?> key, Object value) {\n......\n//发生冲突，循环去找下一个为空的槽\n//nextIndex()方法就是在长度范围内做i++的操作\n for (Entry e = tab[i];\n                 e != null;\n                 e = tab[i = nextIndex(i, len)]) {\n                ThreadLocal<?> k = e.get();\n\t\t\t\t//key是一样就更新\n                if (k == key) {\n                    e.value = value;\n                    return;\n                }\n\t\t\t//找到下一个空槽就放进去\n                if (k == null) {\n                    replaceStaleEntry(key, value, i);\n                    return;\n                }\n            }\n```\n\n\n\n## 弱引用\n\n总所周知，只要还有引用指向，这个对象就不会被回收。这是针对强引用而言。如果一个类继承了软引用指向实例，如果这个实例没有其他引用了，只有该类引用了，这个对象会被GC立即回收。\n\n```\nA a = new A();\nB b = new B(a);\na = null;//这样a是不会被回收是，因为b还依赖a，造成了内存泄漏。\n\nb = null;//此时，a才会被回收，因为没有引用指向了\n```\n\n如果b还有有用，不能赋值为空，岂非a一直不能被回收？非也，我们还可以用弱引用。\n\n```\nA a = new A();\nWeakReference b = new WeakReference(a);\na=null//GC会立刻回收A这个对象\n```\n\n顺便说一嘴，软引用和弱引用一样, 但被GC回收的时候需要多一个条件: 当系统内存不足时才会被回收. 正因为有这个特性, 软引用比弱引用更加适合做缓存对象的引用。\n\n**ThreadLocal使用了弱引用**.key指向ThreadLocal实例，当ThreadLocal外部强引用被回收时候，key虽然还是指向ThreadLocal，但因为是弱引用，GC会发现并回收。\n\n```\n     static class Entry extends WeakReference<ThreadLocal<?>> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal<?> k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n```\n\n通过表格来说明一下，如下：\n\n| 引用类型 | 被垃圾回收时间 | 用途               |\n| -------- | -------------- | ------------------ |\n| 强引用   | 从来不会       | 对象的一般状态     |\n| 软引用   | 当内存不足时   | 对象缓存           |\n| 弱引用   | 正常垃圾回收时 | 对象缓存           |\n| 虚引用   | 正常垃圾回收时 | 跟踪对象的垃圾回收 |\n\n[理解Java的强引用、软引用、弱引用和虚引用](https://juejin.im/post/5b82c02df265da436152f5ad#heading-5)\n\n## 清理时机\n\n线程退出时，会做一个清理工作，其中就包括清理ThreadLocalMap，即把threadLocals=null。\n\n而然使用线程池会对线程进行**复用**，就意味当前线程未必会退出，可能会出现内存泄露，**即你不用这个对象了，但它无法被回收。因此最好每次使ThreadLocal.remove()方法将这个变量移除。**\n\n> 参考\n>\n> 《Java高并发程序设计》\n>\n> [解决Hash冲突的几种方法](https://blog.csdn.net/u012104435/article/details/47951357)\n>\n> [ThreadLocal和弱引用](https://www.jianshu.com/p/d3e1282ba7ca)\n\n\n\n​     ","slug":"ThreadLocal","published":1,"updated":"2022-02-08T07:09:41.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qjy0008w9rp04b8a9l1","content":"<p>[TOC]</p>\n<p>前言：ThreadLocal线程局部变量，为每一个使用该变量的线程都提供一个变量值的副本，每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。即“以空间换时间”的方式解决线程不安全问题。</p>\n<p>本文首先对ThreadLocal进行源码分析以阐明其原理，而后介绍ThreadLocal重要的三个知识点：它用来解决冲突的办法——线性探测法、它用来解决内存泄露的办法——弱引用、ThreadLocal的清理时机尤其要注意线程池这个例外。</p>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>ThreadLocal中有一个静态内部类ThreadLocalMap（类似于HashMap但不是）。这个Map的<strong>key是ThreadLocal当前对象，value就是我们存起来的值</strong>。</p>\n<p>下面通过分析重要方法的源码来一探究竟。</p>\n<h4 id=\"getMap\"><a href=\"#getMap\" class=\"headerlink\" title=\"getMap()\"></a>getMap()</h4><p>取得的是当前线程的ThreadLocalMap</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class=\"line\">       return t.threadLocals;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>注意：这个map取得的是Thread类的成员变量ThreadLocalMap</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Thread implements Runnable &#123;</span><br><span class=\"line\">//每个线程都有自己ThreadLocalMap！</span><br><span class=\"line\">\tThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure>\n<h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h4><p>取当前线程的ThreadLocalMap，key设置为ThreadLocal当前对象，value设置为传入的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void set(T value) &#123;</span><br><span class=\"line\">     Thread t = Thread.currentThread();</span><br><span class=\"line\">     ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">     if (map != null)</span><br><span class=\"line\">         map.set(this, value);</span><br><span class=\"line\">     else</span><br><span class=\"line\">         createMap(t, value);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h4><p>取当前线程的ThreadLocalMap，将threadLocal作为key获取Entry后获取value。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     Thread t = Thread.currentThread();</span><br><span class=\"line\">     <span class=\"comment\">//取当前对象的map</span></span><br><span class=\"line\">     ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">     <span class=\"comment\">//将自己作为key取值</span></span><br><span class=\"line\">         ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> (T)e.value;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"线性探测法\"><a href=\"#线性探测法\" class=\"headerlink\" title=\"线性探测法\"></a>线性探测法</h2><p>ThreadLocalMap是典型的使用线性探测法解决hash冲突的：发生冲突，从该位置向后找到表中的下一个空槽放入。这种简单的方法会导致相同hash值的元素挨在一起和其他hash值对应的槽被占用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"comment\">//发生冲突，循环去找下一个为空的槽</span></span><br><span class=\"line\"><span class=\"comment\">//nextIndex()方法就是在长度范围内做i++的操作</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">                 e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//key是一样就更新</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">                    e.value = value;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//找到下一个空槽就放进去</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    replaceStaleEntry(key, value, i);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h2><p>总所周知，只要还有引用指向，这个对象就不会被回收。这是针对强引用而言。如果一个类继承了软引用指向实例，如果这个实例没有其他引用了，只有该类引用了，这个对象会被GC立即回收。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A a = new A();</span><br><span class=\"line\">B b = new B(a);</span><br><span class=\"line\">a = null;//这样a是不会被回收是，因为b还依赖a，造成了内存泄漏。</span><br><span class=\"line\"></span><br><span class=\"line\">b = null;//此时，a才会被回收，因为没有引用指向了</span><br></pre></td></tr></table></figure>\n<p>如果b还有有用，不能赋值为空，岂非a一直不能被回收？非也，我们还可以用弱引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A a = new A();</span><br><span class=\"line\">WeakReference b = new WeakReference(a);</span><br><span class=\"line\">a=null//GC会立刻回收A这个对象</span><br></pre></td></tr></table></figure>\n<p>顺便说一嘴，软引用和弱引用一样, 但被GC回收的时候需要多一个条件: 当系统内存不足时才会被回收. 正因为有这个特性, 软引用比弱引用更加适合做缓存对象的引用。</p>\n<p><strong>ThreadLocal使用了弱引用</strong>.key指向ThreadLocal实例，当ThreadLocal外部强引用被回收时候，key虽然还是指向ThreadLocal，但因为是弱引用，GC会发现并回收。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class=\"line\">       /** The value associated with this ThreadLocal. */</span><br><span class=\"line\">       Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">       Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">           super(k);</span><br><span class=\"line\">           value = v;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>通过表格来说明一下，如下：</p>\n<table>\n<thead>\n<tr>\n<th>引用类型</th>\n<th>被垃圾回收时间</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>强引用</td>\n<td>从来不会</td>\n<td>对象的一般状态</td>\n</tr>\n<tr>\n<td>软引用</td>\n<td>当内存不足时</td>\n<td>对象缓存</td>\n</tr>\n<tr>\n<td>弱引用</td>\n<td>正常垃圾回收时</td>\n<td>对象缓存</td>\n</tr>\n<tr>\n<td>虚引用</td>\n<td>正常垃圾回收时</td>\n<td>跟踪对象的垃圾回收</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://juejin.im/post/5b82c02df265da436152f5ad#heading-5\" target=\"_blank\" rel=\"noopener\">理解Java的强引用、软引用、弱引用和虚引用</a></p>\n<h2 id=\"清理时机\"><a href=\"#清理时机\" class=\"headerlink\" title=\"清理时机\"></a>清理时机</h2><p>线程退出时，会做一个清理工作，其中就包括清理ThreadLocalMap，即把threadLocals=null。</p>\n<p>而然使用线程池会对线程进行<strong>复用</strong>，就意味当前线程未必会退出，可能会出现内存泄露，<strong>即你不用这个对象了，但它无法被回收。因此最好每次使ThreadLocal.remove()方法将这个变量移除。</strong></p>\n<blockquote>\n<p>参考</p>\n<p>《Java高并发程序设计》</p>\n<p><a href=\"https://blog.csdn.net/u012104435/article/details/47951357\" target=\"_blank\" rel=\"noopener\">解决Hash冲突的几种方法</a></p>\n<p><a href=\"https://www.jianshu.com/p/d3e1282ba7ca\" target=\"_blank\" rel=\"noopener\">ThreadLocal和弱引用</a></p>\n</blockquote>\n<p>​     </p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<p>前言：ThreadLocal线程局部变量，为每一个使用该变量的线程都提供一个变量值的副本，每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。即“以空间换时间”的方式解决线程不安全问题。</p>\n<p>本文首先对ThreadLocal进行源码分析以阐明其原理，而后介绍ThreadLocal重要的三个知识点：它用来解决冲突的办法——线性探测法、它用来解决内存泄露的办法——弱引用、ThreadLocal的清理时机尤其要注意线程池这个例外。</p>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>ThreadLocal中有一个静态内部类ThreadLocalMap（类似于HashMap但不是）。这个Map的<strong>key是ThreadLocal当前对象，value就是我们存起来的值</strong>。</p>\n<p>下面通过分析重要方法的源码来一探究竟。</p>\n<h4 id=\"getMap\"><a href=\"#getMap\" class=\"headerlink\" title=\"getMap()\"></a>getMap()</h4><p>取得的是当前线程的ThreadLocalMap</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class=\"line\">       return t.threadLocals;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>注意：这个map取得的是Thread类的成员变量ThreadLocalMap</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Thread implements Runnable &#123;</span><br><span class=\"line\">//每个线程都有自己ThreadLocalMap！</span><br><span class=\"line\">\tThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure>\n<h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h4><p>取当前线程的ThreadLocalMap，key设置为ThreadLocal当前对象，value设置为传入的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void set(T value) &#123;</span><br><span class=\"line\">     Thread t = Thread.currentThread();</span><br><span class=\"line\">     ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">     if (map != null)</span><br><span class=\"line\">         map.set(this, value);</span><br><span class=\"line\">     else</span><br><span class=\"line\">         createMap(t, value);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h4><p>取当前线程的ThreadLocalMap，将threadLocal作为key获取Entry后获取value。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     Thread t = Thread.currentThread();</span><br><span class=\"line\">     <span class=\"comment\">//取当前对象的map</span></span><br><span class=\"line\">     ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">     <span class=\"comment\">//将自己作为key取值</span></span><br><span class=\"line\">         ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> (T)e.value;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"线性探测法\"><a href=\"#线性探测法\" class=\"headerlink\" title=\"线性探测法\"></a>线性探测法</h2><p>ThreadLocalMap是典型的使用线性探测法解决hash冲突的：发生冲突，从该位置向后找到表中的下一个空槽放入。这种简单的方法会导致相同hash值的元素挨在一起和其他hash值对应的槽被占用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"comment\">//发生冲突，循环去找下一个为空的槽</span></span><br><span class=\"line\"><span class=\"comment\">//nextIndex()方法就是在长度范围内做i++的操作</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">                 e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//key是一样就更新</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">                    e.value = value;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//找到下一个空槽就放进去</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    replaceStaleEntry(key, value, i);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h2><p>总所周知，只要还有引用指向，这个对象就不会被回收。这是针对强引用而言。如果一个类继承了软引用指向实例，如果这个实例没有其他引用了，只有该类引用了，这个对象会被GC立即回收。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A a = new A();</span><br><span class=\"line\">B b = new B(a);</span><br><span class=\"line\">a = null;//这样a是不会被回收是，因为b还依赖a，造成了内存泄漏。</span><br><span class=\"line\"></span><br><span class=\"line\">b = null;//此时，a才会被回收，因为没有引用指向了</span><br></pre></td></tr></table></figure>\n<p>如果b还有有用，不能赋值为空，岂非a一直不能被回收？非也，我们还可以用弱引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A a = new A();</span><br><span class=\"line\">WeakReference b = new WeakReference(a);</span><br><span class=\"line\">a=null//GC会立刻回收A这个对象</span><br></pre></td></tr></table></figure>\n<p>顺便说一嘴，软引用和弱引用一样, 但被GC回收的时候需要多一个条件: 当系统内存不足时才会被回收. 正因为有这个特性, 软引用比弱引用更加适合做缓存对象的引用。</p>\n<p><strong>ThreadLocal使用了弱引用</strong>.key指向ThreadLocal实例，当ThreadLocal外部强引用被回收时候，key虽然还是指向ThreadLocal，但因为是弱引用，GC会发现并回收。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class=\"line\">       /** The value associated with this ThreadLocal. */</span><br><span class=\"line\">       Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">       Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">           super(k);</span><br><span class=\"line\">           value = v;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>通过表格来说明一下，如下：</p>\n<table>\n<thead>\n<tr>\n<th>引用类型</th>\n<th>被垃圾回收时间</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>强引用</td>\n<td>从来不会</td>\n<td>对象的一般状态</td>\n</tr>\n<tr>\n<td>软引用</td>\n<td>当内存不足时</td>\n<td>对象缓存</td>\n</tr>\n<tr>\n<td>弱引用</td>\n<td>正常垃圾回收时</td>\n<td>对象缓存</td>\n</tr>\n<tr>\n<td>虚引用</td>\n<td>正常垃圾回收时</td>\n<td>跟踪对象的垃圾回收</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://juejin.im/post/5b82c02df265da436152f5ad#heading-5\" target=\"_blank\" rel=\"noopener\">理解Java的强引用、软引用、弱引用和虚引用</a></p>\n<h2 id=\"清理时机\"><a href=\"#清理时机\" class=\"headerlink\" title=\"清理时机\"></a>清理时机</h2><p>线程退出时，会做一个清理工作，其中就包括清理ThreadLocalMap，即把threadLocals=null。</p>\n<p>而然使用线程池会对线程进行<strong>复用</strong>，就意味当前线程未必会退出，可能会出现内存泄露，<strong>即你不用这个对象了，但它无法被回收。因此最好每次使ThreadLocal.remove()方法将这个变量移除。</strong></p>\n<blockquote>\n<p>参考</p>\n<p>《Java高并发程序设计》</p>\n<p><a href=\"https://blog.csdn.net/u012104435/article/details/47951357\" target=\"_blank\" rel=\"noopener\">解决Hash冲突的几种方法</a></p>\n<p><a href=\"https://www.jianshu.com/p/d3e1282ba7ca\" target=\"_blank\" rel=\"noopener\">ThreadLocal和弱引用</a></p>\n</blockquote>\n<p>​     </p>\n"},{"title":"限流算法及RateLimiter源码解析","date":"2020-04-17T13:29:50.000Z","description":"超详细！限流算法及RateLimiter源码解析","_content":"\n\n\n\n\n\n\n\n\n## 前言：\n\n之所以对RateLimiter感兴趣，是之前实习的时候有一个需求，需要调用一个qps为10的合成图片接口。因为达不到实时调用的要求，我就写了一个定时任务事先调用该接口把结果放在缓存里面，外部不调用该接口而是去缓存里查数据。重点来了，因为需要合成的图片大概有两三百张，肯定不能直接一次调用该接口，于是用了限流去慢慢调用。代码类似这样：\n\n```java\n  RateLimiter rateLimiter = RateLimiter.create(10);\n        for (int i = 1; i < 200; i++) {\n            rateLimiter.acquire();\n            System.out.println(\"生成第\"+i+\"张合成图片\");\n        }\n```\n\n当时只是简单的使用了，并没有深究其原理，现在放假有空就把他的源码撸了一遍。\n\n\n\n## 令牌桶算法：\n\n\n\n在学习令牌桶算法之前我们现在来看看几种比较简单的限流算法，了解它们有什么问题，令牌桶算法是怎么解决这些问题的\n\n### 计数器算法\n\n计数器算法是限流算法里最简单也是最容易实现的一种算法。每个时间段，比如1min，都有一个计数器，到了下一分钟则重置计数器。\n\n缺陷具有**边界问题**。用户通过在时间窗口的重置节点处突发请求， 可以瞬间超过我们的速率限制，比如0:59时发送了100个请求，并且1:00又发送了100个请求，也就是1秒内发送了200个请求。这个计数器算法的漏洞，可能导致应用崩溃。\n\n那么如何将临界问题的影响降低呢？我们可以看下面的滑动窗口算法。\n\n**滑动窗口**\n\n![](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%BB%91%E5%8A%A8.jpg)\n\n 滑动窗口会将一分钟进行划分，比如图中，我们就将1分钟划成了6格，所以每格代表的是10秒钟。每过10秒钟，我们的时间窗口就会往右滑动一格。每**一个格子都有自己独立的计数器counter**。\n\n那么滑动窗口怎么解决刚才的临界问题的呢？我们可以看上图，0:59到达的100个请求会落在灰色的格子中，而1:00到达的请求会落在橘黄色的格 子中。当时间到达1:00时，我们的窗口会往右移动一格，那么此时时间窗口内的总请求数量一共是200个，超过了限定的100个，所以此时能够检测出来触 发了限流。\n\n再来回顾一下刚才的计数器算法，**计数器算法其实就是滑动窗口算法。只是它没有对时间窗口做进一步地划分，只有1格。**由此可见，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。\n\n### 漏桶算法\n\n漏桶算法顾名思义就是注水漏水过程，往桶中以一定速率流出水，以任意速率流入水，当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。它是可以**限制瞬时并发数**。特点是\n\n- 存下请求\n- 匀速处理\n- 多于丢弃\n\n\n\n漏桶算法的实现往往依赖于队列，请求到达如果队列未满则直接放入队列，然后有一个处理器按照固定频率从队列头取出请求进行处理。如果请求量大，则会导致队列满，那么新来的请求就会被抛弃。\n\nNginx的限流模块就是基于漏桶算法的，它最大的特点就是**强行限制流量按照指定的比例下发**，适合那种对流量有绝对要求的场景，就是流量可以容许在我指定的值之下，可以被多次打回，但是无论如何决不能超过指定的。\n\n![img](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%BC%8F%E6%A1%B6.png)\n\n**缺陷：以均匀的速率，是无法应对短时间的突发流量。**\n\n\n\n### 令牌桶算法\n\n令牌桶算法整个的过程是这样的：\n\n- 系统以恒定的速率产生令牌，然后将令牌放入令牌桶中\n- 令牌桶有一个容量，当令牌桶满了的时候，再向其中放入的令牌就会被丢弃\n- 每次一个请求过来，需要从令牌桶中获取一个令牌，假设有令牌，那么提供服务；假设没有令牌，那么拒绝服务\n\n![img](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%A1%B6%E4%BB%A4%E7%89%8C.png)\n\n它可以说是对漏桶算法的一种改进，它的优点是可接受突然大的流量。 桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用，即可以**限制时间窗口内的平均速率**。假设我们想要的速率是1000QPS，那么往桶中放令牌的速度就是1000个/s，假设第1秒只有800个请求，那意味着第2秒可以容许1200个请求，这就是**一定程度**突发流量的意思，反之我们看漏桶算法，第一秒只有800个请求，那么全部放过，第二秒这1200个请求将会被打回200个。\n\n\n\n## RateLimiter源码解析：\n\n### 介绍：\n\n\n\n突发流量预支处理\n\n### 关键变量\n\n首先我们看下几个比较关键的变量：\n\n- storedPermits 目前桶里令牌数\n- maxPermits 最大的令牌保存量，即桶大小\n- stableIntervalMicros 添加一个令牌到桶中的时间间隔\n- long nextFreeTicketMicros = 0L  下次可获得令牌的时间，当一个请求被授权之后（通过acquire可以预定），这个时间会被继续往后推，大令牌量的请求会比少量的请求推的更远。\n\n### create()\n\n调用create接口时，实际实例化的为SmoothBursty类\n\n```\npublic static RateLimiter create(double permitsPerSecond) {\n    return create(permitsPerSecond, SleepingStopwatch.createFromSystemTimer());\n}\n \nstatic RateLimiter create(double permitsPerSecond, SleepingStopwatch stopwatch) {\n    RateLimiter rateLimiter = new SmoothBursty(stopwatch, 1.0 /* maxBurstSeconds */);\n    rateLimiter.setRate(permitsPerSecond);\n    return rateLimiter;\n}\n```\n\n\n\n### acquire()\n\n```\npublic double acquire() {\n    return acquire(1);\n  }\n  \n  public double acquire(int permits) {\n    long microsToWait = reserve(permits);\n    stopwatch.sleepMicrosUninterruptibly(microsToWait);\n    //把毫秒转为秒 SECONDS.toMicros(1L)=1000000\n    return 1.0 * microsToWait / SECONDS.toMicros(1L);\n  }\n```\n\n\n\n第一个acquire无参方法委托到acquire(1)\n\n第二个acquire()\n\n调用reserve()方法得到获取permits个令牌需要的等待时间\n\n通过stopwatch直接无中断地sleep这么长的时间\n\n返回等待的时间毫秒数。\n\n再点进去看看reserve方法做了什么：\n\n```\n  final long reserve(int permits) {\n    checkPermits(permits);\n    synchronized (mutex()) {\n      return reserveAndGetWaitLength(permits, stopwatch.readMicros());\n    }\n  }\n```\n\n做一些参数检验\n\n获取互斥锁\n\n调用reserveAndGetWaitTime，传入需要获取的令牌数和当前的毫秒数。\n\n再点进去看看reserveAndGetWaitLength方法做了什么：\n\n```\nfinal long reserveAndGetWaitLength(int permits, long nowMicros) {\n    long momentAvailable = reserveEarliestAvailable(permits, nowMicros);\n    return max(momentAvailable - nowMicros, 0);\n  }\n```\n\n这一段代码通过调用reserveEarliestAvailable来得到该请求能够获取令牌授权的毫秒时刻，然后通过运算返回得到需要等待的毫秒数\n\n再点进去看看reserveEarliestAvailable方法：\n\n```\n  abstract long reserveEarliestAvailable(int permits, long nowMicros);\n```\n\nemmm，在RateLimiter类里它是一个抽象方法。点进它的实现发现是在SmoothRateLimiter类\n\n```java\n  @Override\n  final long reserveEarliestAvailable(int requiredPermits, long nowMicros) {\n    resync(nowMicros);\n    long returnValue = nextFreeTicketMicros;\n    double storedPermitsToSpend = min(requiredPermits, this.storedPermits);\n    double freshPermits = requiredPermits - storedPermitsToSpend;\n    long waitMicros =\n        storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend)\n            + (long) (freshPermits * stableIntervalMicros);\n\n    this.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);\n    this.storedPermits -= storedPermitsToSpend;\n    return returnValue;\n  }\n\n```\n\n这个方法很关键，也比较复杂的，且听我逐行解析。\n\n首先调用resync，更新令牌桶\n\n先将下次能获得令牌的时间先存起来\n\n判断桶里的令牌数够不够用，**storedPermitsToSpend可获取的令牌数，freshPermits为不够用的令牌数**，当然在够用的情况下storedPermitsToSpend就等于请求数而freshPermits等于0。\n\n比如请求是10个，桶里有5个，套入上面代码则是：storedPermitsToSpend（5个） = min(requiredPermits（10个）, this.storedPermits（5个）\n\nfreshPermits（5个） = requiredPermits（10个） - storedPermitsToSpend（5个）\n\n再比如请求是1个，桶里有5个，套入上面代码则是：storedPermitsToSpend（1个） = min(requiredPermits（1个）, this.storedPermits（5个）\n\nfreshPermits（0个） = requiredPermits（1个） - storedPermitsToSpend（0个）\n\n然后算出需要等待的毫秒，这里用了一个抽象方法storedPermitsToWaitTime，它有两个实现SmoothWarmingUp和SmoothBursty。这主要是为了SmoothWarmingUp时用的，因为SmoothBursty的这个方法直接返回0。\n\n下次可获得令牌的时间更新为：它本身+本次需要等待的时间。注意这里支持令牌预分发。\n\n桶里的令牌数减去本次拿走的令牌数\n\n返回直接保存好的nextFreeTicketMicros（下次能获得令牌的时间）\n\n至此reserveEarliestAvailable方法就解析完了。\n\n\n\nacquire()小朋友的调用链还真是有点长。总结一下，目前我们已经往下点进去了4个方法了。通过IDEA导航栏里的Navigate >>Call Hierarchy可以看查看它的调用链。\n\n![0f224caa9cb48ffbe107cc2bda862fe](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.png)\n\n\n\n#### 令牌预分发\n\n现在让我们来看看刚才更新下次可获得令牌的时间提到的令牌预分发是什么意思。\n\n```java\nthis.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);\n```\n\n当限流器当前处于空闲状态时，一个大量令牌请求进来的时候，可以提前预授权给他足够的令牌让它能够立即执行，并推迟后续请求的等待时间（如之前所述），因此才会出现nowMicros < nextFreeTicketMicro的情况，而这种情况就说明当前仍处于对于之前一个请求的预授权阶段，不需要更新storedPermits，否则就还是nowMicros >= nextFreeTicketMicro的情况。\n\n为什么需要令牌预分发呢？如果QPS=5的需求，限流算法需要保证没有请求能够在上个请求之后的200ms内获得授权。（至于为什么不是一秒发五个，而要把时间段分细，请往上看看计算器算法的问题。）\n\n这次的问题在于，如果很长时间都没有请求呢？限流器处于一种**低利用率**的状态，然而它只记录新的请求的时间戳，下个请求也只能在这个请求之后的200ms之后才能获得授权，也就是QPS=2。这显然与我们期望的QPS不太匹配，并最终会导致低利用率或者请求溢出。**低利用率本应该意味着有多的资源可以立即使用。**比如说\n\n- 第一次请求过来需要获取1个令牌，直接拿到\n- RateLimiter在1秒钟后放一个令牌，第一次请求预支的1个令牌还上了\n- 1秒钟之后第二次请求过来需要获得5个令牌，直接拿到\n- RateLimiter在花了5秒钟放了5个令牌，还上了第二次请求预支的5个令牌\n- 第三个请求在5秒钟之后拿到3个令牌\n\n突发流量的处理，在令牌桶算法中有两种方式，一种是有足够的令牌才能消费，一种是先消费后还令牌。后者就像我们0首付买车似的，30万的车很少有等攒到30万才全款买的，先签了相关合同把车子给你，然后贷款慢慢还，这样就爽了。RateLimiter也是同样的道理，先让请求得到处理，再慢慢还上预支的令牌，客户端同样也爽了，否则我假设预支60个令牌，1分钟之后才能处理我的请求，不合理也不人性化。\n\n因此我们需要添加另外一个衡量维度——storedPermits（桶里令牌数）。当storedPermits（桶里令牌数）为0，令牌都被用光了，代表没有低利用率存在。当storedPermits（桶里令牌数）=桶容量，令牌没有被使用，代表有低利用率存在。\n\nRateLimiter允许某次请求拿走了超出剩余令牌数的令牌，但是下一次请求将为此付出代价，一直等到令牌亏空补上，并且桶中有足够本次请求使用的令牌为止。\n\n此外它还构建了一个自定义注解，方便松耦合，灵活的对服务进行限流。\n\n\n\n#### resync()令牌懒加载机制\n\n如果是由你来写rateLImiter，可以理所当然想到需要一个定时插入令牌的方法。但Guava并没有这么做，而采用了触发式的更新令牌桶机制，即懒加载。**每次请求到来的时候才去执行令牌插入工作和其他字段如nextFreeTicketMicros的更新工作，这样减少了线程使用**， 节约了资源，并且也简化了操作。也就resync这个方法所做的事情。\n\n\n\n```java\n//根据现在的时间更新桶里令牌数和下一次获取令牌的毫秒\nvoid resync(long nowMicros) {\n    // if nextFreeTicket is in the past, resync to now\n    if (nowMicros > nextFreeTicketMicros) {\n      double newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();\n      storedPermits = min(maxPermits, storedPermits + newPermits);\n        //更新nextFreeTiecket为now\n      nextFreeTicketMicros = nowMicros;\n    }\n  }\n```\n\nresync()具体逻辑是：如果现在的毫秒（比如40ms）大于下次能授权的毫秒数（比如20ms），说明这个限流器已经有一段时间没有使用了，需要计算这段时间产生的令牌数。否则说明这段时间限流器一直有请求进来，则不需要更新.\n\n\n\n\n\n### 稳定和渐进模式\n\nGuava有两种限流模式，一种为稳定模式(SmoothBursty:令牌生成速度恒定)，一种为渐进模式(SmoothWarmingUp:令牌生成速度缓慢提升直到维持在一个稳定值)。还记得前面在看reserveEarliestAvailable时，这两种模式对storedPermitsToWaitTime有不同的实现吗？\n\n```java\nlong waitMicros =\n        storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend)\n            + (long) (freshPermits * stableIntervalMicros);\n```\n\n\n\nSmoothBursty的实现,等待毫秒数直接等于需要新增令牌数*生成一个令牌需要的时间\n\n```java\n@Override\n    long storedPermitsToWaitTime(double storedPermits, double permitsToTake) {\n      return 0L;\n    }\n```\n\nSmoothWarmingUp的实现\n\n```java\n@Override\n    long storedPermitsToWaitTime(double storedPermits, double permitsToTake) {\n      double availablePermitsAboveThreshold = storedPermits - thresholdPermits;\n      long micros = 0;\n      // measuring the integral on the right part of the function (the climbing line)\n      if (availablePermitsAboveThreshold > 0.0) {\n        double permitsAboveThresholdToTake = min(availablePermitsAboveThreshold, permitsToTake);\n        // TODO(cpovirk): Figure out a good name for this variable.\n        double length = permitsToTime(availablePermitsAboveThreshold)\n                + permitsToTime(availablePermitsAboveThreshold - permitsAboveThresholdToTake);\n        micros = (long) (permitsAboveThresholdToTake * length / 2.0);\n        permitsToTake -= permitsAboveThresholdToTake;\n      }\n      // measuring the integral on the left part of the function (the horizontal line)\n      micros += (stableIntervalMicros * permitsToTake);\n      return micros;\n    }\n```\n\n\n\n## 常见问题\n\n### acquire和tryAcquire的区别\n\n- acquire是阻塞的且会一直等待到获取令牌为止，它有一个返回值为double型，意思是从阻塞开始到获取到令牌的等待时间，单位为秒\n- tryAcquire是另外一个方法，它可以指定超时时间，返回值为boolean型，即假设线程等待了指定时间后仍然没有获取到令牌，那么就会返回给客户端false，客户端根据自身情况是打回给前台错误还是定时重试\n\n### RateLimiter的缺陷\n\n特别注意RateLimiter是单机的，也就是说它无法跨JVM使用，设置的1000QPS，那也在单机中保证平均1000QPS的流量。\n\n假设集群中部署了10台服务器，想要保证集群1000QPS的接口调用量，那么RateLimiter就不适用了，集群流控最常见的方法是使用强大的Redis：\n\n- 一种是固定窗口的计数，例如当前是2019/8/26 20:05:00，就往这个\"2019/8/26 20:05:00\"这个key进行incr，当前是2019/8/26 20:05:01，就往\"2019/8/26 20:05:01\"这个key进行incr，incr后的结果只要大于我们设定的值，那么就打回去，小于就相当于获取到了执行权限\n- 一种是结合lua脚本，实现分布式的令牌桶算法，网上实现还是比较多的，可以参考https://blog.csdn.net/sunlihuo/article/details/79700225这篇文章\n\n总得来说，集群限流的实现也比较简单。\n\n## 总结\n\n推荐大家自己去读读这个google的手笔，从注释到命名一目了然，读起来很舒服。\n\n其他收获：\n\n静态工厂方法代替构造函数。`RateLimiter`是入口类，它提供了两套工厂方法来创建出两个子类。\n\n最后以SmoothRateLimiter的一个可可爱爱注释收尾。\n\n![1587137971779](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%B3%A8%E9%87%8A.png)","source":"_posts/RateLimiter.md","raw":"---\ntitle: 限流算法及RateLimiter源码解析\ndate: 2020-04-17 21:29:50\ncategories: 并发\ndescription: 超详细！限流算法及RateLimiter源码解析\n---\n\n\n\n\n\n\n\n\n\n## 前言：\n\n之所以对RateLimiter感兴趣，是之前实习的时候有一个需求，需要调用一个qps为10的合成图片接口。因为达不到实时调用的要求，我就写了一个定时任务事先调用该接口把结果放在缓存里面，外部不调用该接口而是去缓存里查数据。重点来了，因为需要合成的图片大概有两三百张，肯定不能直接一次调用该接口，于是用了限流去慢慢调用。代码类似这样：\n\n```java\n  RateLimiter rateLimiter = RateLimiter.create(10);\n        for (int i = 1; i < 200; i++) {\n            rateLimiter.acquire();\n            System.out.println(\"生成第\"+i+\"张合成图片\");\n        }\n```\n\n当时只是简单的使用了，并没有深究其原理，现在放假有空就把他的源码撸了一遍。\n\n\n\n## 令牌桶算法：\n\n\n\n在学习令牌桶算法之前我们现在来看看几种比较简单的限流算法，了解它们有什么问题，令牌桶算法是怎么解决这些问题的\n\n### 计数器算法\n\n计数器算法是限流算法里最简单也是最容易实现的一种算法。每个时间段，比如1min，都有一个计数器，到了下一分钟则重置计数器。\n\n缺陷具有**边界问题**。用户通过在时间窗口的重置节点处突发请求， 可以瞬间超过我们的速率限制，比如0:59时发送了100个请求，并且1:00又发送了100个请求，也就是1秒内发送了200个请求。这个计数器算法的漏洞，可能导致应用崩溃。\n\n那么如何将临界问题的影响降低呢？我们可以看下面的滑动窗口算法。\n\n**滑动窗口**\n\n![](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%BB%91%E5%8A%A8.jpg)\n\n 滑动窗口会将一分钟进行划分，比如图中，我们就将1分钟划成了6格，所以每格代表的是10秒钟。每过10秒钟，我们的时间窗口就会往右滑动一格。每**一个格子都有自己独立的计数器counter**。\n\n那么滑动窗口怎么解决刚才的临界问题的呢？我们可以看上图，0:59到达的100个请求会落在灰色的格子中，而1:00到达的请求会落在橘黄色的格 子中。当时间到达1:00时，我们的窗口会往右移动一格，那么此时时间窗口内的总请求数量一共是200个，超过了限定的100个，所以此时能够检测出来触 发了限流。\n\n再来回顾一下刚才的计数器算法，**计数器算法其实就是滑动窗口算法。只是它没有对时间窗口做进一步地划分，只有1格。**由此可见，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。\n\n### 漏桶算法\n\n漏桶算法顾名思义就是注水漏水过程，往桶中以一定速率流出水，以任意速率流入水，当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。它是可以**限制瞬时并发数**。特点是\n\n- 存下请求\n- 匀速处理\n- 多于丢弃\n\n\n\n漏桶算法的实现往往依赖于队列，请求到达如果队列未满则直接放入队列，然后有一个处理器按照固定频率从队列头取出请求进行处理。如果请求量大，则会导致队列满，那么新来的请求就会被抛弃。\n\nNginx的限流模块就是基于漏桶算法的，它最大的特点就是**强行限制流量按照指定的比例下发**，适合那种对流量有绝对要求的场景，就是流量可以容许在我指定的值之下，可以被多次打回，但是无论如何决不能超过指定的。\n\n![img](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%BC%8F%E6%A1%B6.png)\n\n**缺陷：以均匀的速率，是无法应对短时间的突发流量。**\n\n\n\n### 令牌桶算法\n\n令牌桶算法整个的过程是这样的：\n\n- 系统以恒定的速率产生令牌，然后将令牌放入令牌桶中\n- 令牌桶有一个容量，当令牌桶满了的时候，再向其中放入的令牌就会被丢弃\n- 每次一个请求过来，需要从令牌桶中获取一个令牌，假设有令牌，那么提供服务；假设没有令牌，那么拒绝服务\n\n![img](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%A1%B6%E4%BB%A4%E7%89%8C.png)\n\n它可以说是对漏桶算法的一种改进，它的优点是可接受突然大的流量。 桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用，即可以**限制时间窗口内的平均速率**。假设我们想要的速率是1000QPS，那么往桶中放令牌的速度就是1000个/s，假设第1秒只有800个请求，那意味着第2秒可以容许1200个请求，这就是**一定程度**突发流量的意思，反之我们看漏桶算法，第一秒只有800个请求，那么全部放过，第二秒这1200个请求将会被打回200个。\n\n\n\n## RateLimiter源码解析：\n\n### 介绍：\n\n\n\n突发流量预支处理\n\n### 关键变量\n\n首先我们看下几个比较关键的变量：\n\n- storedPermits 目前桶里令牌数\n- maxPermits 最大的令牌保存量，即桶大小\n- stableIntervalMicros 添加一个令牌到桶中的时间间隔\n- long nextFreeTicketMicros = 0L  下次可获得令牌的时间，当一个请求被授权之后（通过acquire可以预定），这个时间会被继续往后推，大令牌量的请求会比少量的请求推的更远。\n\n### create()\n\n调用create接口时，实际实例化的为SmoothBursty类\n\n```\npublic static RateLimiter create(double permitsPerSecond) {\n    return create(permitsPerSecond, SleepingStopwatch.createFromSystemTimer());\n}\n \nstatic RateLimiter create(double permitsPerSecond, SleepingStopwatch stopwatch) {\n    RateLimiter rateLimiter = new SmoothBursty(stopwatch, 1.0 /* maxBurstSeconds */);\n    rateLimiter.setRate(permitsPerSecond);\n    return rateLimiter;\n}\n```\n\n\n\n### acquire()\n\n```\npublic double acquire() {\n    return acquire(1);\n  }\n  \n  public double acquire(int permits) {\n    long microsToWait = reserve(permits);\n    stopwatch.sleepMicrosUninterruptibly(microsToWait);\n    //把毫秒转为秒 SECONDS.toMicros(1L)=1000000\n    return 1.0 * microsToWait / SECONDS.toMicros(1L);\n  }\n```\n\n\n\n第一个acquire无参方法委托到acquire(1)\n\n第二个acquire()\n\n调用reserve()方法得到获取permits个令牌需要的等待时间\n\n通过stopwatch直接无中断地sleep这么长的时间\n\n返回等待的时间毫秒数。\n\n再点进去看看reserve方法做了什么：\n\n```\n  final long reserve(int permits) {\n    checkPermits(permits);\n    synchronized (mutex()) {\n      return reserveAndGetWaitLength(permits, stopwatch.readMicros());\n    }\n  }\n```\n\n做一些参数检验\n\n获取互斥锁\n\n调用reserveAndGetWaitTime，传入需要获取的令牌数和当前的毫秒数。\n\n再点进去看看reserveAndGetWaitLength方法做了什么：\n\n```\nfinal long reserveAndGetWaitLength(int permits, long nowMicros) {\n    long momentAvailable = reserveEarliestAvailable(permits, nowMicros);\n    return max(momentAvailable - nowMicros, 0);\n  }\n```\n\n这一段代码通过调用reserveEarliestAvailable来得到该请求能够获取令牌授权的毫秒时刻，然后通过运算返回得到需要等待的毫秒数\n\n再点进去看看reserveEarliestAvailable方法：\n\n```\n  abstract long reserveEarliestAvailable(int permits, long nowMicros);\n```\n\nemmm，在RateLimiter类里它是一个抽象方法。点进它的实现发现是在SmoothRateLimiter类\n\n```java\n  @Override\n  final long reserveEarliestAvailable(int requiredPermits, long nowMicros) {\n    resync(nowMicros);\n    long returnValue = nextFreeTicketMicros;\n    double storedPermitsToSpend = min(requiredPermits, this.storedPermits);\n    double freshPermits = requiredPermits - storedPermitsToSpend;\n    long waitMicros =\n        storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend)\n            + (long) (freshPermits * stableIntervalMicros);\n\n    this.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);\n    this.storedPermits -= storedPermitsToSpend;\n    return returnValue;\n  }\n\n```\n\n这个方法很关键，也比较复杂的，且听我逐行解析。\n\n首先调用resync，更新令牌桶\n\n先将下次能获得令牌的时间先存起来\n\n判断桶里的令牌数够不够用，**storedPermitsToSpend可获取的令牌数，freshPermits为不够用的令牌数**，当然在够用的情况下storedPermitsToSpend就等于请求数而freshPermits等于0。\n\n比如请求是10个，桶里有5个，套入上面代码则是：storedPermitsToSpend（5个） = min(requiredPermits（10个）, this.storedPermits（5个）\n\nfreshPermits（5个） = requiredPermits（10个） - storedPermitsToSpend（5个）\n\n再比如请求是1个，桶里有5个，套入上面代码则是：storedPermitsToSpend（1个） = min(requiredPermits（1个）, this.storedPermits（5个）\n\nfreshPermits（0个） = requiredPermits（1个） - storedPermitsToSpend（0个）\n\n然后算出需要等待的毫秒，这里用了一个抽象方法storedPermitsToWaitTime，它有两个实现SmoothWarmingUp和SmoothBursty。这主要是为了SmoothWarmingUp时用的，因为SmoothBursty的这个方法直接返回0。\n\n下次可获得令牌的时间更新为：它本身+本次需要等待的时间。注意这里支持令牌预分发。\n\n桶里的令牌数减去本次拿走的令牌数\n\n返回直接保存好的nextFreeTicketMicros（下次能获得令牌的时间）\n\n至此reserveEarliestAvailable方法就解析完了。\n\n\n\nacquire()小朋友的调用链还真是有点长。总结一下，目前我们已经往下点进去了4个方法了。通过IDEA导航栏里的Navigate >>Call Hierarchy可以看查看它的调用链。\n\n![0f224caa9cb48ffbe107cc2bda862fe](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.png)\n\n\n\n#### 令牌预分发\n\n现在让我们来看看刚才更新下次可获得令牌的时间提到的令牌预分发是什么意思。\n\n```java\nthis.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);\n```\n\n当限流器当前处于空闲状态时，一个大量令牌请求进来的时候，可以提前预授权给他足够的令牌让它能够立即执行，并推迟后续请求的等待时间（如之前所述），因此才会出现nowMicros < nextFreeTicketMicro的情况，而这种情况就说明当前仍处于对于之前一个请求的预授权阶段，不需要更新storedPermits，否则就还是nowMicros >= nextFreeTicketMicro的情况。\n\n为什么需要令牌预分发呢？如果QPS=5的需求，限流算法需要保证没有请求能够在上个请求之后的200ms内获得授权。（至于为什么不是一秒发五个，而要把时间段分细，请往上看看计算器算法的问题。）\n\n这次的问题在于，如果很长时间都没有请求呢？限流器处于一种**低利用率**的状态，然而它只记录新的请求的时间戳，下个请求也只能在这个请求之后的200ms之后才能获得授权，也就是QPS=2。这显然与我们期望的QPS不太匹配，并最终会导致低利用率或者请求溢出。**低利用率本应该意味着有多的资源可以立即使用。**比如说\n\n- 第一次请求过来需要获取1个令牌，直接拿到\n- RateLimiter在1秒钟后放一个令牌，第一次请求预支的1个令牌还上了\n- 1秒钟之后第二次请求过来需要获得5个令牌，直接拿到\n- RateLimiter在花了5秒钟放了5个令牌，还上了第二次请求预支的5个令牌\n- 第三个请求在5秒钟之后拿到3个令牌\n\n突发流量的处理，在令牌桶算法中有两种方式，一种是有足够的令牌才能消费，一种是先消费后还令牌。后者就像我们0首付买车似的，30万的车很少有等攒到30万才全款买的，先签了相关合同把车子给你，然后贷款慢慢还，这样就爽了。RateLimiter也是同样的道理，先让请求得到处理，再慢慢还上预支的令牌，客户端同样也爽了，否则我假设预支60个令牌，1分钟之后才能处理我的请求，不合理也不人性化。\n\n因此我们需要添加另外一个衡量维度——storedPermits（桶里令牌数）。当storedPermits（桶里令牌数）为0，令牌都被用光了，代表没有低利用率存在。当storedPermits（桶里令牌数）=桶容量，令牌没有被使用，代表有低利用率存在。\n\nRateLimiter允许某次请求拿走了超出剩余令牌数的令牌，但是下一次请求将为此付出代价，一直等到令牌亏空补上，并且桶中有足够本次请求使用的令牌为止。\n\n此外它还构建了一个自定义注解，方便松耦合，灵活的对服务进行限流。\n\n\n\n#### resync()令牌懒加载机制\n\n如果是由你来写rateLImiter，可以理所当然想到需要一个定时插入令牌的方法。但Guava并没有这么做，而采用了触发式的更新令牌桶机制，即懒加载。**每次请求到来的时候才去执行令牌插入工作和其他字段如nextFreeTicketMicros的更新工作，这样减少了线程使用**， 节约了资源，并且也简化了操作。也就resync这个方法所做的事情。\n\n\n\n```java\n//根据现在的时间更新桶里令牌数和下一次获取令牌的毫秒\nvoid resync(long nowMicros) {\n    // if nextFreeTicket is in the past, resync to now\n    if (nowMicros > nextFreeTicketMicros) {\n      double newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();\n      storedPermits = min(maxPermits, storedPermits + newPermits);\n        //更新nextFreeTiecket为now\n      nextFreeTicketMicros = nowMicros;\n    }\n  }\n```\n\nresync()具体逻辑是：如果现在的毫秒（比如40ms）大于下次能授权的毫秒数（比如20ms），说明这个限流器已经有一段时间没有使用了，需要计算这段时间产生的令牌数。否则说明这段时间限流器一直有请求进来，则不需要更新.\n\n\n\n\n\n### 稳定和渐进模式\n\nGuava有两种限流模式，一种为稳定模式(SmoothBursty:令牌生成速度恒定)，一种为渐进模式(SmoothWarmingUp:令牌生成速度缓慢提升直到维持在一个稳定值)。还记得前面在看reserveEarliestAvailable时，这两种模式对storedPermitsToWaitTime有不同的实现吗？\n\n```java\nlong waitMicros =\n        storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend)\n            + (long) (freshPermits * stableIntervalMicros);\n```\n\n\n\nSmoothBursty的实现,等待毫秒数直接等于需要新增令牌数*生成一个令牌需要的时间\n\n```java\n@Override\n    long storedPermitsToWaitTime(double storedPermits, double permitsToTake) {\n      return 0L;\n    }\n```\n\nSmoothWarmingUp的实现\n\n```java\n@Override\n    long storedPermitsToWaitTime(double storedPermits, double permitsToTake) {\n      double availablePermitsAboveThreshold = storedPermits - thresholdPermits;\n      long micros = 0;\n      // measuring the integral on the right part of the function (the climbing line)\n      if (availablePermitsAboveThreshold > 0.0) {\n        double permitsAboveThresholdToTake = min(availablePermitsAboveThreshold, permitsToTake);\n        // TODO(cpovirk): Figure out a good name for this variable.\n        double length = permitsToTime(availablePermitsAboveThreshold)\n                + permitsToTime(availablePermitsAboveThreshold - permitsAboveThresholdToTake);\n        micros = (long) (permitsAboveThresholdToTake * length / 2.0);\n        permitsToTake -= permitsAboveThresholdToTake;\n      }\n      // measuring the integral on the left part of the function (the horizontal line)\n      micros += (stableIntervalMicros * permitsToTake);\n      return micros;\n    }\n```\n\n\n\n## 常见问题\n\n### acquire和tryAcquire的区别\n\n- acquire是阻塞的且会一直等待到获取令牌为止，它有一个返回值为double型，意思是从阻塞开始到获取到令牌的等待时间，单位为秒\n- tryAcquire是另外一个方法，它可以指定超时时间，返回值为boolean型，即假设线程等待了指定时间后仍然没有获取到令牌，那么就会返回给客户端false，客户端根据自身情况是打回给前台错误还是定时重试\n\n### RateLimiter的缺陷\n\n特别注意RateLimiter是单机的，也就是说它无法跨JVM使用，设置的1000QPS，那也在单机中保证平均1000QPS的流量。\n\n假设集群中部署了10台服务器，想要保证集群1000QPS的接口调用量，那么RateLimiter就不适用了，集群流控最常见的方法是使用强大的Redis：\n\n- 一种是固定窗口的计数，例如当前是2019/8/26 20:05:00，就往这个\"2019/8/26 20:05:00\"这个key进行incr，当前是2019/8/26 20:05:01，就往\"2019/8/26 20:05:01\"这个key进行incr，incr后的结果只要大于我们设定的值，那么就打回去，小于就相当于获取到了执行权限\n- 一种是结合lua脚本，实现分布式的令牌桶算法，网上实现还是比较多的，可以参考https://blog.csdn.net/sunlihuo/article/details/79700225这篇文章\n\n总得来说，集群限流的实现也比较简单。\n\n## 总结\n\n推荐大家自己去读读这个google的手笔，从注释到命名一目了然，读起来很舒服。\n\n其他收获：\n\n静态工厂方法代替构造函数。`RateLimiter`是入口类，它提供了两套工厂方法来创建出两个子类。\n\n最后以SmoothRateLimiter的一个可可爱爱注释收尾。\n\n![1587137971779](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%B3%A8%E9%87%8A.png)","slug":"RateLimiter","published":1,"updated":"2022-02-08T07:09:41.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qk0000bw9rptkz2xomj","content":"<h2 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h2><p>之所以对RateLimiter感兴趣，是之前实习的时候有一个需求，需要调用一个qps为10的合成图片接口。因为达不到实时调用的要求，我就写了一个定时任务事先调用该接口把结果放在缓存里面，外部不调用该接口而是去缓存里查数据。重点来了，因为需要合成的图片大概有两三百张，肯定不能直接一次调用该接口，于是用了限流去慢慢调用。代码类似这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RateLimiter rateLimiter = RateLimiter.create(<span class=\"number\">10</span>);</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">200</span>; i++) &#123;</span><br><span class=\"line\">          rateLimiter.acquire();</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"生成第\"</span>+i+<span class=\"string\">\"张合成图片\"</span>);</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<p>当时只是简单的使用了，并没有深究其原理，现在放假有空就把他的源码撸了一遍。</p>\n<h2 id=\"令牌桶算法：\"><a href=\"#令牌桶算法：\" class=\"headerlink\" title=\"令牌桶算法：\"></a>令牌桶算法：</h2><p>在学习令牌桶算法之前我们现在来看看几种比较简单的限流算法，了解它们有什么问题，令牌桶算法是怎么解决这些问题的</p>\n<h3 id=\"计数器算法\"><a href=\"#计数器算法\" class=\"headerlink\" title=\"计数器算法\"></a>计数器算法</h3><p>计数器算法是限流算法里最简单也是最容易实现的一种算法。每个时间段，比如1min，都有一个计数器，到了下一分钟则重置计数器。</p>\n<p>缺陷具有<strong>边界问题</strong>。用户通过在时间窗口的重置节点处突发请求， 可以瞬间超过我们的速率限制，比如0:59时发送了100个请求，并且1:00又发送了100个请求，也就是1秒内发送了200个请求。这个计数器算法的漏洞，可能导致应用崩溃。</p>\n<p>那么如何将临界问题的影响降低呢？我们可以看下面的滑动窗口算法。</p>\n<p><strong>滑动窗口</strong></p>\n<p><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%BB%91%E5%8A%A8.jpg\" alt></p>\n<p> 滑动窗口会将一分钟进行划分，比如图中，我们就将1分钟划成了6格，所以每格代表的是10秒钟。每过10秒钟，我们的时间窗口就会往右滑动一格。每<strong>一个格子都有自己独立的计数器counter</strong>。</p>\n<p>那么滑动窗口怎么解决刚才的临界问题的呢？我们可以看上图，0:59到达的100个请求会落在灰色的格子中，而1:00到达的请求会落在橘黄色的格 子中。当时间到达1:00时，我们的窗口会往右移动一格，那么此时时间窗口内的总请求数量一共是200个，超过了限定的100个，所以此时能够检测出来触 发了限流。</p>\n<p>再来回顾一下刚才的计数器算法，<strong>计数器算法其实就是滑动窗口算法。只是它没有对时间窗口做进一步地划分，只有1格。</strong>由此可见，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。</p>\n<h3 id=\"漏桶算法\"><a href=\"#漏桶算法\" class=\"headerlink\" title=\"漏桶算法\"></a>漏桶算法</h3><p>漏桶算法顾名思义就是注水漏水过程，往桶中以一定速率流出水，以任意速率流入水，当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。它是可以<strong>限制瞬时并发数</strong>。特点是</p>\n<ul>\n<li>存下请求</li>\n<li>匀速处理</li>\n<li>多于丢弃</li>\n</ul>\n<p>漏桶算法的实现往往依赖于队列，请求到达如果队列未满则直接放入队列，然后有一个处理器按照固定频率从队列头取出请求进行处理。如果请求量大，则会导致队列满，那么新来的请求就会被抛弃。</p>\n<p>Nginx的限流模块就是基于漏桶算法的，它最大的特点就是<strong>强行限制流量按照指定的比例下发</strong>，适合那种对流量有绝对要求的场景，就是流量可以容许在我指定的值之下，可以被多次打回，但是无论如何决不能超过指定的。</p>\n<p><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%BC%8F%E6%A1%B6.png\" alt=\"img\"></p>\n<p><strong>缺陷：以均匀的速率，是无法应对短时间的突发流量。</strong></p>\n<h3 id=\"令牌桶算法\"><a href=\"#令牌桶算法\" class=\"headerlink\" title=\"令牌桶算法\"></a>令牌桶算法</h3><p>令牌桶算法整个的过程是这样的：</p>\n<ul>\n<li>系统以恒定的速率产生令牌，然后将令牌放入令牌桶中</li>\n<li>令牌桶有一个容量，当令牌桶满了的时候，再向其中放入的令牌就会被丢弃</li>\n<li>每次一个请求过来，需要从令牌桶中获取一个令牌，假设有令牌，那么提供服务；假设没有令牌，那么拒绝服务</li>\n</ul>\n<p><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%A1%B6%E4%BB%A4%E7%89%8C.png\" alt=\"img\"></p>\n<p>它可以说是对漏桶算法的一种改进，它的优点是可接受突然大的流量。 桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用，即可以<strong>限制时间窗口内的平均速率</strong>。假设我们想要的速率是1000QPS，那么往桶中放令牌的速度就是1000个/s，假设第1秒只有800个请求，那意味着第2秒可以容许1200个请求，这就是<strong>一定程度</strong>突发流量的意思，反之我们看漏桶算法，第一秒只有800个请求，那么全部放过，第二秒这1200个请求将会被打回200个。</p>\n<h2 id=\"RateLimiter源码解析：\"><a href=\"#RateLimiter源码解析：\" class=\"headerlink\" title=\"RateLimiter源码解析：\"></a>RateLimiter源码解析：</h2><h3 id=\"介绍：\"><a href=\"#介绍：\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>突发流量预支处理</p>\n<h3 id=\"关键变量\"><a href=\"#关键变量\" class=\"headerlink\" title=\"关键变量\"></a>关键变量</h3><p>首先我们看下几个比较关键的变量：</p>\n<ul>\n<li>storedPermits 目前桶里令牌数</li>\n<li>maxPermits 最大的令牌保存量，即桶大小</li>\n<li>stableIntervalMicros 添加一个令牌到桶中的时间间隔</li>\n<li>long nextFreeTicketMicros = 0L  下次可获得令牌的时间，当一个请求被授权之后（通过acquire可以预定），这个时间会被继续往后推，大令牌量的请求会比少量的请求推的更远。</li>\n</ul>\n<h3 id=\"create\"><a href=\"#create\" class=\"headerlink\" title=\"create()\"></a>create()</h3><p>调用create接口时，实际实例化的为SmoothBursty类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static RateLimiter create(double permitsPerSecond) &#123;</span><br><span class=\"line\">    return create(permitsPerSecond, SleepingStopwatch.createFromSystemTimer());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">static RateLimiter create(double permitsPerSecond, SleepingStopwatch stopwatch) &#123;</span><br><span class=\"line\">    RateLimiter rateLimiter = new SmoothBursty(stopwatch, 1.0 /* maxBurstSeconds */);</span><br><span class=\"line\">    rateLimiter.setRate(permitsPerSecond);</span><br><span class=\"line\">    return rateLimiter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"acquire\"><a href=\"#acquire\" class=\"headerlink\" title=\"acquire()\"></a>acquire()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public double acquire() &#123;</span><br><span class=\"line\">    return acquire(1);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  public double acquire(int permits) &#123;</span><br><span class=\"line\">    long microsToWait = reserve(permits);</span><br><span class=\"line\">    stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class=\"line\">    //把毫秒转为秒 SECONDS.toMicros(1L)=1000000</span><br><span class=\"line\">    return 1.0 * microsToWait / SECONDS.toMicros(1L);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>第一个acquire无参方法委托到acquire(1)</p>\n<p>第二个acquire()</p>\n<p>调用reserve()方法得到获取permits个令牌需要的等待时间</p>\n<p>通过stopwatch直接无中断地sleep这么长的时间</p>\n<p>返回等待的时间毫秒数。</p>\n<p>再点进去看看reserve方法做了什么：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final long reserve(int permits) &#123;</span><br><span class=\"line\">  checkPermits(permits);</span><br><span class=\"line\">  synchronized (mutex()) &#123;</span><br><span class=\"line\">    return reserveAndGetWaitLength(permits, stopwatch.readMicros());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>做一些参数检验</p>\n<p>获取互斥锁</p>\n<p>调用reserveAndGetWaitTime，传入需要获取的令牌数和当前的毫秒数。</p>\n<p>再点进去看看reserveAndGetWaitLength方法做了什么：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final long reserveAndGetWaitLength(int permits, long nowMicros) &#123;</span><br><span class=\"line\">    long momentAvailable = reserveEarliestAvailable(permits, nowMicros);</span><br><span class=\"line\">    return max(momentAvailable - nowMicros, 0);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这一段代码通过调用reserveEarliestAvailable来得到该请求能够获取令牌授权的毫秒时刻，然后通过运算返回得到需要等待的毫秒数</p>\n<p>再点进去看看reserveEarliestAvailable方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abstract long reserveEarliestAvailable(int permits, long nowMicros);</span><br></pre></td></tr></table></figure>\n<p>emmm，在RateLimiter类里它是一个抽象方法。点进它的实现发现是在SmoothRateLimiter类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">long</span> <span class=\"title\">reserveEarliestAvailable</span><span class=\"params\">(<span class=\"keyword\">int</span> requiredPermits, <span class=\"keyword\">long</span> nowMicros)</span> </span>&#123;</span><br><span class=\"line\">  resync(nowMicros);</span><br><span class=\"line\">  <span class=\"keyword\">long</span> returnValue = nextFreeTicketMicros;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> storedPermitsToSpend = min(requiredPermits, <span class=\"keyword\">this</span>.storedPermits);</span><br><span class=\"line\">  <span class=\"keyword\">double</span> freshPermits = requiredPermits - storedPermitsToSpend;</span><br><span class=\"line\">  <span class=\"keyword\">long</span> waitMicros =</span><br><span class=\"line\">      storedPermitsToWaitTime(<span class=\"keyword\">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class=\"line\">          + (<span class=\"keyword\">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.storedPermits -= storedPermitsToSpend;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> returnValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法很关键，也比较复杂的，且听我逐行解析。</p>\n<p>首先调用resync，更新令牌桶</p>\n<p>先将下次能获得令牌的时间先存起来</p>\n<p>判断桶里的令牌数够不够用，<strong>storedPermitsToSpend可获取的令牌数，freshPermits为不够用的令牌数</strong>，当然在够用的情况下storedPermitsToSpend就等于请求数而freshPermits等于0。</p>\n<p>比如请求是10个，桶里有5个，套入上面代码则是：storedPermitsToSpend（5个） = min(requiredPermits（10个）, this.storedPermits（5个）</p>\n<p>freshPermits（5个） = requiredPermits（10个） - storedPermitsToSpend（5个）</p>\n<p>再比如请求是1个，桶里有5个，套入上面代码则是：storedPermitsToSpend（1个） = min(requiredPermits（1个）, this.storedPermits（5个）</p>\n<p>freshPermits（0个） = requiredPermits（1个） - storedPermitsToSpend（0个）</p>\n<p>然后算出需要等待的毫秒，这里用了一个抽象方法storedPermitsToWaitTime，它有两个实现SmoothWarmingUp和SmoothBursty。这主要是为了SmoothWarmingUp时用的，因为SmoothBursty的这个方法直接返回0。</p>\n<p>下次可获得令牌的时间更新为：它本身+本次需要等待的时间。注意这里支持令牌预分发。</p>\n<p>桶里的令牌数减去本次拿走的令牌数</p>\n<p>返回直接保存好的nextFreeTicketMicros（下次能获得令牌的时间）</p>\n<p>至此reserveEarliestAvailable方法就解析完了。</p>\n<p>acquire()小朋友的调用链还真是有点长。总结一下，目前我们已经往下点进去了4个方法了。通过IDEA导航栏里的Navigate &gt;&gt;Call Hierarchy可以看查看它的调用链。</p>\n<p><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.png\" alt=\"0f224caa9cb48ffbe107cc2bda862fe\"></p>\n<h4 id=\"令牌预分发\"><a href=\"#令牌预分发\" class=\"headerlink\" title=\"令牌预分发\"></a>令牌预分发</h4><p>现在让我们来看看刚才更新下次可获得令牌的时间提到的令牌预分发是什么意思。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);</span><br></pre></td></tr></table></figure>\n<p>当限流器当前处于空闲状态时，一个大量令牌请求进来的时候，可以提前预授权给他足够的令牌让它能够立即执行，并推迟后续请求的等待时间（如之前所述），因此才会出现nowMicros &lt; nextFreeTicketMicro的情况，而这种情况就说明当前仍处于对于之前一个请求的预授权阶段，不需要更新storedPermits，否则就还是nowMicros &gt;= nextFreeTicketMicro的情况。</p>\n<p>为什么需要令牌预分发呢？如果QPS=5的需求，限流算法需要保证没有请求能够在上个请求之后的200ms内获得授权。（至于为什么不是一秒发五个，而要把时间段分细，请往上看看计算器算法的问题。）</p>\n<p>这次的问题在于，如果很长时间都没有请求呢？限流器处于一种<strong>低利用率</strong>的状态，然而它只记录新的请求的时间戳，下个请求也只能在这个请求之后的200ms之后才能获得授权，也就是QPS=2。这显然与我们期望的QPS不太匹配，并最终会导致低利用率或者请求溢出。<strong>低利用率本应该意味着有多的资源可以立即使用。</strong>比如说</p>\n<ul>\n<li>第一次请求过来需要获取1个令牌，直接拿到</li>\n<li>RateLimiter在1秒钟后放一个令牌，第一次请求预支的1个令牌还上了</li>\n<li>1秒钟之后第二次请求过来需要获得5个令牌，直接拿到</li>\n<li>RateLimiter在花了5秒钟放了5个令牌，还上了第二次请求预支的5个令牌</li>\n<li>第三个请求在5秒钟之后拿到3个令牌</li>\n</ul>\n<p>突发流量的处理，在令牌桶算法中有两种方式，一种是有足够的令牌才能消费，一种是先消费后还令牌。后者就像我们0首付买车似的，30万的车很少有等攒到30万才全款买的，先签了相关合同把车子给你，然后贷款慢慢还，这样就爽了。RateLimiter也是同样的道理，先让请求得到处理，再慢慢还上预支的令牌，客户端同样也爽了，否则我假设预支60个令牌，1分钟之后才能处理我的请求，不合理也不人性化。</p>\n<p>因此我们需要添加另外一个衡量维度——storedPermits（桶里令牌数）。当storedPermits（桶里令牌数）为0，令牌都被用光了，代表没有低利用率存在。当storedPermits（桶里令牌数）=桶容量，令牌没有被使用，代表有低利用率存在。</p>\n<p>RateLimiter允许某次请求拿走了超出剩余令牌数的令牌，但是下一次请求将为此付出代价，一直等到令牌亏空补上，并且桶中有足够本次请求使用的令牌为止。</p>\n<p>此外它还构建了一个自定义注解，方便松耦合，灵活的对服务进行限流。</p>\n<h4 id=\"resync-令牌懒加载机制\"><a href=\"#resync-令牌懒加载机制\" class=\"headerlink\" title=\"resync()令牌懒加载机制\"></a>resync()令牌懒加载机制</h4><p>如果是由你来写rateLImiter，可以理所当然想到需要一个定时插入令牌的方法。但Guava并没有这么做，而采用了触发式的更新令牌桶机制，即懒加载。<strong>每次请求到来的时候才去执行令牌插入工作和其他字段如nextFreeTicketMicros的更新工作，这样减少了线程使用</strong>， 节约了资源，并且也简化了操作。也就resync这个方法所做的事情。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//根据现在的时间更新桶里令牌数和下一次获取令牌的毫秒</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resync</span><span class=\"params\">(<span class=\"keyword\">long</span> nowMicros)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// if nextFreeTicket is in the past, resync to now</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">double</span> newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();</span><br><span class=\"line\">      storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class=\"line\">        <span class=\"comment\">//更新nextFreeTiecket为now</span></span><br><span class=\"line\">      nextFreeTicketMicros = nowMicros;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>resync()具体逻辑是：如果现在的毫秒（比如40ms）大于下次能授权的毫秒数（比如20ms），说明这个限流器已经有一段时间没有使用了，需要计算这段时间产生的令牌数。否则说明这段时间限流器一直有请求进来，则不需要更新.</p>\n<h3 id=\"稳定和渐进模式\"><a href=\"#稳定和渐进模式\" class=\"headerlink\" title=\"稳定和渐进模式\"></a>稳定和渐进模式</h3><p>Guava有两种限流模式，一种为稳定模式(SmoothBursty:令牌生成速度恒定)，一种为渐进模式(SmoothWarmingUp:令牌生成速度缓慢提升直到维持在一个稳定值)。还记得前面在看reserveEarliestAvailable时，这两种模式对storedPermitsToWaitTime有不同的实现吗？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> waitMicros =</span><br><span class=\"line\">        storedPermitsToWaitTime(<span class=\"keyword\">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class=\"line\">            + (<span class=\"keyword\">long</span>) (freshPermits * stableIntervalMicros);</span><br></pre></td></tr></table></figure>\n<p>SmoothBursty的实现,等待毫秒数直接等于需要新增令牌数*生成一个令牌需要的时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">storedPermitsToWaitTime</span><span class=\"params\">(<span class=\"keyword\">double</span> storedPermits, <span class=\"keyword\">double</span> permitsToTake)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0L</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>SmoothWarmingUp的实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">storedPermitsToWaitTime</span><span class=\"params\">(<span class=\"keyword\">double</span> storedPermits, <span class=\"keyword\">double</span> permitsToTake)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">double</span> availablePermitsAboveThreshold = storedPermits - thresholdPermits;</span><br><span class=\"line\">      <span class=\"keyword\">long</span> micros = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"comment\">// measuring the integral on the right part of the function (the climbing line)</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (availablePermitsAboveThreshold &gt; <span class=\"number\">0.0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> permitsAboveThresholdToTake = min(availablePermitsAboveThreshold, permitsToTake);</span><br><span class=\"line\">        <span class=\"comment\">// TODO(cpovirk): Figure out a good name for this variable.</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> length = permitsToTime(availablePermitsAboveThreshold)</span><br><span class=\"line\">                + permitsToTime(availablePermitsAboveThreshold - permitsAboveThresholdToTake);</span><br><span class=\"line\">        micros = (<span class=\"keyword\">long</span>) (permitsAboveThresholdToTake * length / <span class=\"number\">2.0</span>);</span><br><span class=\"line\">        permitsToTake -= permitsAboveThresholdToTake;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// measuring the integral on the left part of the function (the horizontal line)</span></span><br><span class=\"line\">      micros += (stableIntervalMicros * permitsToTake);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> micros;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h3 id=\"acquire和tryAcquire的区别\"><a href=\"#acquire和tryAcquire的区别\" class=\"headerlink\" title=\"acquire和tryAcquire的区别\"></a>acquire和tryAcquire的区别</h3><ul>\n<li>acquire是阻塞的且会一直等待到获取令牌为止，它有一个返回值为double型，意思是从阻塞开始到获取到令牌的等待时间，单位为秒</li>\n<li>tryAcquire是另外一个方法，它可以指定超时时间，返回值为boolean型，即假设线程等待了指定时间后仍然没有获取到令牌，那么就会返回给客户端false，客户端根据自身情况是打回给前台错误还是定时重试</li>\n</ul>\n<h3 id=\"RateLimiter的缺陷\"><a href=\"#RateLimiter的缺陷\" class=\"headerlink\" title=\"RateLimiter的缺陷\"></a>RateLimiter的缺陷</h3><p>特别注意RateLimiter是单机的，也就是说它无法跨JVM使用，设置的1000QPS，那也在单机中保证平均1000QPS的流量。</p>\n<p>假设集群中部署了10台服务器，想要保证集群1000QPS的接口调用量，那么RateLimiter就不适用了，集群流控最常见的方法是使用强大的Redis：</p>\n<ul>\n<li>一种是固定窗口的计数，例如当前是2019/8/26 20:05:00，就往这个”2019/8/26 20:05:00”这个key进行incr，当前是2019/8/26 20:05:01，就往”2019/8/26 20:05:01”这个key进行incr，incr后的结果只要大于我们设定的值，那么就打回去，小于就相当于获取到了执行权限</li>\n<li>一种是结合lua脚本，实现分布式的令牌桶算法，网上实现还是比较多的，可以参考<a href=\"https://blog.csdn.net/sunlihuo/article/details/79700225这篇文章\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/sunlihuo/article/details/79700225这篇文章</a></li>\n</ul>\n<p>总得来说，集群限流的实现也比较简单。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>推荐大家自己去读读这个google的手笔，从注释到命名一目了然，读起来很舒服。</p>\n<p>其他收获：</p>\n<p>静态工厂方法代替构造函数。<code>RateLimiter</code>是入口类，它提供了两套工厂方法来创建出两个子类。</p>\n<p>最后以SmoothRateLimiter的一个可可爱爱注释收尾。</p>\n<p><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%B3%A8%E9%87%8A.png\" alt=\"1587137971779\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h2><p>之所以对RateLimiter感兴趣，是之前实习的时候有一个需求，需要调用一个qps为10的合成图片接口。因为达不到实时调用的要求，我就写了一个定时任务事先调用该接口把结果放在缓存里面，外部不调用该接口而是去缓存里查数据。重点来了，因为需要合成的图片大概有两三百张，肯定不能直接一次调用该接口，于是用了限流去慢慢调用。代码类似这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RateLimiter rateLimiter = RateLimiter.create(<span class=\"number\">10</span>);</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">200</span>; i++) &#123;</span><br><span class=\"line\">          rateLimiter.acquire();</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"生成第\"</span>+i+<span class=\"string\">\"张合成图片\"</span>);</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<p>当时只是简单的使用了，并没有深究其原理，现在放假有空就把他的源码撸了一遍。</p>\n<h2 id=\"令牌桶算法：\"><a href=\"#令牌桶算法：\" class=\"headerlink\" title=\"令牌桶算法：\"></a>令牌桶算法：</h2><p>在学习令牌桶算法之前我们现在来看看几种比较简单的限流算法，了解它们有什么问题，令牌桶算法是怎么解决这些问题的</p>\n<h3 id=\"计数器算法\"><a href=\"#计数器算法\" class=\"headerlink\" title=\"计数器算法\"></a>计数器算法</h3><p>计数器算法是限流算法里最简单也是最容易实现的一种算法。每个时间段，比如1min，都有一个计数器，到了下一分钟则重置计数器。</p>\n<p>缺陷具有<strong>边界问题</strong>。用户通过在时间窗口的重置节点处突发请求， 可以瞬间超过我们的速率限制，比如0:59时发送了100个请求，并且1:00又发送了100个请求，也就是1秒内发送了200个请求。这个计数器算法的漏洞，可能导致应用崩溃。</p>\n<p>那么如何将临界问题的影响降低呢？我们可以看下面的滑动窗口算法。</p>\n<p><strong>滑动窗口</strong></p>\n<p><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%BB%91%E5%8A%A8.jpg\" alt></p>\n<p> 滑动窗口会将一分钟进行划分，比如图中，我们就将1分钟划成了6格，所以每格代表的是10秒钟。每过10秒钟，我们的时间窗口就会往右滑动一格。每<strong>一个格子都有自己独立的计数器counter</strong>。</p>\n<p>那么滑动窗口怎么解决刚才的临界问题的呢？我们可以看上图，0:59到达的100个请求会落在灰色的格子中，而1:00到达的请求会落在橘黄色的格 子中。当时间到达1:00时，我们的窗口会往右移动一格，那么此时时间窗口内的总请求数量一共是200个，超过了限定的100个，所以此时能够检测出来触 发了限流。</p>\n<p>再来回顾一下刚才的计数器算法，<strong>计数器算法其实就是滑动窗口算法。只是它没有对时间窗口做进一步地划分，只有1格。</strong>由此可见，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。</p>\n<h3 id=\"漏桶算法\"><a href=\"#漏桶算法\" class=\"headerlink\" title=\"漏桶算法\"></a>漏桶算法</h3><p>漏桶算法顾名思义就是注水漏水过程，往桶中以一定速率流出水，以任意速率流入水，当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。它是可以<strong>限制瞬时并发数</strong>。特点是</p>\n<ul>\n<li>存下请求</li>\n<li>匀速处理</li>\n<li>多于丢弃</li>\n</ul>\n<p>漏桶算法的实现往往依赖于队列，请求到达如果队列未满则直接放入队列，然后有一个处理器按照固定频率从队列头取出请求进行处理。如果请求量大，则会导致队列满，那么新来的请求就会被抛弃。</p>\n<p>Nginx的限流模块就是基于漏桶算法的，它最大的特点就是<strong>强行限制流量按照指定的比例下发</strong>，适合那种对流量有绝对要求的场景，就是流量可以容许在我指定的值之下，可以被多次打回，但是无论如何决不能超过指定的。</p>\n<p><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%BC%8F%E6%A1%B6.png\" alt=\"img\"></p>\n<p><strong>缺陷：以均匀的速率，是无法应对短时间的突发流量。</strong></p>\n<h3 id=\"令牌桶算法\"><a href=\"#令牌桶算法\" class=\"headerlink\" title=\"令牌桶算法\"></a>令牌桶算法</h3><p>令牌桶算法整个的过程是这样的：</p>\n<ul>\n<li>系统以恒定的速率产生令牌，然后将令牌放入令牌桶中</li>\n<li>令牌桶有一个容量，当令牌桶满了的时候，再向其中放入的令牌就会被丢弃</li>\n<li>每次一个请求过来，需要从令牌桶中获取一个令牌，假设有令牌，那么提供服务；假设没有令牌，那么拒绝服务</li>\n</ul>\n<p><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%A1%B6%E4%BB%A4%E7%89%8C.png\" alt=\"img\"></p>\n<p>它可以说是对漏桶算法的一种改进，它的优点是可接受突然大的流量。 桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用，即可以<strong>限制时间窗口内的平均速率</strong>。假设我们想要的速率是1000QPS，那么往桶中放令牌的速度就是1000个/s，假设第1秒只有800个请求，那意味着第2秒可以容许1200个请求，这就是<strong>一定程度</strong>突发流量的意思，反之我们看漏桶算法，第一秒只有800个请求，那么全部放过，第二秒这1200个请求将会被打回200个。</p>\n<h2 id=\"RateLimiter源码解析：\"><a href=\"#RateLimiter源码解析：\" class=\"headerlink\" title=\"RateLimiter源码解析：\"></a>RateLimiter源码解析：</h2><h3 id=\"介绍：\"><a href=\"#介绍：\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>突发流量预支处理</p>\n<h3 id=\"关键变量\"><a href=\"#关键变量\" class=\"headerlink\" title=\"关键变量\"></a>关键变量</h3><p>首先我们看下几个比较关键的变量：</p>\n<ul>\n<li>storedPermits 目前桶里令牌数</li>\n<li>maxPermits 最大的令牌保存量，即桶大小</li>\n<li>stableIntervalMicros 添加一个令牌到桶中的时间间隔</li>\n<li>long nextFreeTicketMicros = 0L  下次可获得令牌的时间，当一个请求被授权之后（通过acquire可以预定），这个时间会被继续往后推，大令牌量的请求会比少量的请求推的更远。</li>\n</ul>\n<h3 id=\"create\"><a href=\"#create\" class=\"headerlink\" title=\"create()\"></a>create()</h3><p>调用create接口时，实际实例化的为SmoothBursty类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static RateLimiter create(double permitsPerSecond) &#123;</span><br><span class=\"line\">    return create(permitsPerSecond, SleepingStopwatch.createFromSystemTimer());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">static RateLimiter create(double permitsPerSecond, SleepingStopwatch stopwatch) &#123;</span><br><span class=\"line\">    RateLimiter rateLimiter = new SmoothBursty(stopwatch, 1.0 /* maxBurstSeconds */);</span><br><span class=\"line\">    rateLimiter.setRate(permitsPerSecond);</span><br><span class=\"line\">    return rateLimiter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"acquire\"><a href=\"#acquire\" class=\"headerlink\" title=\"acquire()\"></a>acquire()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public double acquire() &#123;</span><br><span class=\"line\">    return acquire(1);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  public double acquire(int permits) &#123;</span><br><span class=\"line\">    long microsToWait = reserve(permits);</span><br><span class=\"line\">    stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class=\"line\">    //把毫秒转为秒 SECONDS.toMicros(1L)=1000000</span><br><span class=\"line\">    return 1.0 * microsToWait / SECONDS.toMicros(1L);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>第一个acquire无参方法委托到acquire(1)</p>\n<p>第二个acquire()</p>\n<p>调用reserve()方法得到获取permits个令牌需要的等待时间</p>\n<p>通过stopwatch直接无中断地sleep这么长的时间</p>\n<p>返回等待的时间毫秒数。</p>\n<p>再点进去看看reserve方法做了什么：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final long reserve(int permits) &#123;</span><br><span class=\"line\">  checkPermits(permits);</span><br><span class=\"line\">  synchronized (mutex()) &#123;</span><br><span class=\"line\">    return reserveAndGetWaitLength(permits, stopwatch.readMicros());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>做一些参数检验</p>\n<p>获取互斥锁</p>\n<p>调用reserveAndGetWaitTime，传入需要获取的令牌数和当前的毫秒数。</p>\n<p>再点进去看看reserveAndGetWaitLength方法做了什么：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final long reserveAndGetWaitLength(int permits, long nowMicros) &#123;</span><br><span class=\"line\">    long momentAvailable = reserveEarliestAvailable(permits, nowMicros);</span><br><span class=\"line\">    return max(momentAvailable - nowMicros, 0);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这一段代码通过调用reserveEarliestAvailable来得到该请求能够获取令牌授权的毫秒时刻，然后通过运算返回得到需要等待的毫秒数</p>\n<p>再点进去看看reserveEarliestAvailable方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abstract long reserveEarliestAvailable(int permits, long nowMicros);</span><br></pre></td></tr></table></figure>\n<p>emmm，在RateLimiter类里它是一个抽象方法。点进它的实现发现是在SmoothRateLimiter类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">long</span> <span class=\"title\">reserveEarliestAvailable</span><span class=\"params\">(<span class=\"keyword\">int</span> requiredPermits, <span class=\"keyword\">long</span> nowMicros)</span> </span>&#123;</span><br><span class=\"line\">  resync(nowMicros);</span><br><span class=\"line\">  <span class=\"keyword\">long</span> returnValue = nextFreeTicketMicros;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> storedPermitsToSpend = min(requiredPermits, <span class=\"keyword\">this</span>.storedPermits);</span><br><span class=\"line\">  <span class=\"keyword\">double</span> freshPermits = requiredPermits - storedPermitsToSpend;</span><br><span class=\"line\">  <span class=\"keyword\">long</span> waitMicros =</span><br><span class=\"line\">      storedPermitsToWaitTime(<span class=\"keyword\">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class=\"line\">          + (<span class=\"keyword\">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.storedPermits -= storedPermitsToSpend;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> returnValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法很关键，也比较复杂的，且听我逐行解析。</p>\n<p>首先调用resync，更新令牌桶</p>\n<p>先将下次能获得令牌的时间先存起来</p>\n<p>判断桶里的令牌数够不够用，<strong>storedPermitsToSpend可获取的令牌数，freshPermits为不够用的令牌数</strong>，当然在够用的情况下storedPermitsToSpend就等于请求数而freshPermits等于0。</p>\n<p>比如请求是10个，桶里有5个，套入上面代码则是：storedPermitsToSpend（5个） = min(requiredPermits（10个）, this.storedPermits（5个）</p>\n<p>freshPermits（5个） = requiredPermits（10个） - storedPermitsToSpend（5个）</p>\n<p>再比如请求是1个，桶里有5个，套入上面代码则是：storedPermitsToSpend（1个） = min(requiredPermits（1个）, this.storedPermits（5个）</p>\n<p>freshPermits（0个） = requiredPermits（1个） - storedPermitsToSpend（0个）</p>\n<p>然后算出需要等待的毫秒，这里用了一个抽象方法storedPermitsToWaitTime，它有两个实现SmoothWarmingUp和SmoothBursty。这主要是为了SmoothWarmingUp时用的，因为SmoothBursty的这个方法直接返回0。</p>\n<p>下次可获得令牌的时间更新为：它本身+本次需要等待的时间。注意这里支持令牌预分发。</p>\n<p>桶里的令牌数减去本次拿走的令牌数</p>\n<p>返回直接保存好的nextFreeTicketMicros（下次能获得令牌的时间）</p>\n<p>至此reserveEarliestAvailable方法就解析完了。</p>\n<p>acquire()小朋友的调用链还真是有点长。总结一下，目前我们已经往下点进去了4个方法了。通过IDEA导航栏里的Navigate &gt;&gt;Call Hierarchy可以看查看它的调用链。</p>\n<p><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.png\" alt=\"0f224caa9cb48ffbe107cc2bda862fe\"></p>\n<h4 id=\"令牌预分发\"><a href=\"#令牌预分发\" class=\"headerlink\" title=\"令牌预分发\"></a>令牌预分发</h4><p>现在让我们来看看刚才更新下次可获得令牌的时间提到的令牌预分发是什么意思。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);</span><br></pre></td></tr></table></figure>\n<p>当限流器当前处于空闲状态时，一个大量令牌请求进来的时候，可以提前预授权给他足够的令牌让它能够立即执行，并推迟后续请求的等待时间（如之前所述），因此才会出现nowMicros &lt; nextFreeTicketMicro的情况，而这种情况就说明当前仍处于对于之前一个请求的预授权阶段，不需要更新storedPermits，否则就还是nowMicros &gt;= nextFreeTicketMicro的情况。</p>\n<p>为什么需要令牌预分发呢？如果QPS=5的需求，限流算法需要保证没有请求能够在上个请求之后的200ms内获得授权。（至于为什么不是一秒发五个，而要把时间段分细，请往上看看计算器算法的问题。）</p>\n<p>这次的问题在于，如果很长时间都没有请求呢？限流器处于一种<strong>低利用率</strong>的状态，然而它只记录新的请求的时间戳，下个请求也只能在这个请求之后的200ms之后才能获得授权，也就是QPS=2。这显然与我们期望的QPS不太匹配，并最终会导致低利用率或者请求溢出。<strong>低利用率本应该意味着有多的资源可以立即使用。</strong>比如说</p>\n<ul>\n<li>第一次请求过来需要获取1个令牌，直接拿到</li>\n<li>RateLimiter在1秒钟后放一个令牌，第一次请求预支的1个令牌还上了</li>\n<li>1秒钟之后第二次请求过来需要获得5个令牌，直接拿到</li>\n<li>RateLimiter在花了5秒钟放了5个令牌，还上了第二次请求预支的5个令牌</li>\n<li>第三个请求在5秒钟之后拿到3个令牌</li>\n</ul>\n<p>突发流量的处理，在令牌桶算法中有两种方式，一种是有足够的令牌才能消费，一种是先消费后还令牌。后者就像我们0首付买车似的，30万的车很少有等攒到30万才全款买的，先签了相关合同把车子给你，然后贷款慢慢还，这样就爽了。RateLimiter也是同样的道理，先让请求得到处理，再慢慢还上预支的令牌，客户端同样也爽了，否则我假设预支60个令牌，1分钟之后才能处理我的请求，不合理也不人性化。</p>\n<p>因此我们需要添加另外一个衡量维度——storedPermits（桶里令牌数）。当storedPermits（桶里令牌数）为0，令牌都被用光了，代表没有低利用率存在。当storedPermits（桶里令牌数）=桶容量，令牌没有被使用，代表有低利用率存在。</p>\n<p>RateLimiter允许某次请求拿走了超出剩余令牌数的令牌，但是下一次请求将为此付出代价，一直等到令牌亏空补上，并且桶中有足够本次请求使用的令牌为止。</p>\n<p>此外它还构建了一个自定义注解，方便松耦合，灵活的对服务进行限流。</p>\n<h4 id=\"resync-令牌懒加载机制\"><a href=\"#resync-令牌懒加载机制\" class=\"headerlink\" title=\"resync()令牌懒加载机制\"></a>resync()令牌懒加载机制</h4><p>如果是由你来写rateLImiter，可以理所当然想到需要一个定时插入令牌的方法。但Guava并没有这么做，而采用了触发式的更新令牌桶机制，即懒加载。<strong>每次请求到来的时候才去执行令牌插入工作和其他字段如nextFreeTicketMicros的更新工作，这样减少了线程使用</strong>， 节约了资源，并且也简化了操作。也就resync这个方法所做的事情。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//根据现在的时间更新桶里令牌数和下一次获取令牌的毫秒</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resync</span><span class=\"params\">(<span class=\"keyword\">long</span> nowMicros)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// if nextFreeTicket is in the past, resync to now</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">double</span> newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();</span><br><span class=\"line\">      storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class=\"line\">        <span class=\"comment\">//更新nextFreeTiecket为now</span></span><br><span class=\"line\">      nextFreeTicketMicros = nowMicros;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>resync()具体逻辑是：如果现在的毫秒（比如40ms）大于下次能授权的毫秒数（比如20ms），说明这个限流器已经有一段时间没有使用了，需要计算这段时间产生的令牌数。否则说明这段时间限流器一直有请求进来，则不需要更新.</p>\n<h3 id=\"稳定和渐进模式\"><a href=\"#稳定和渐进模式\" class=\"headerlink\" title=\"稳定和渐进模式\"></a>稳定和渐进模式</h3><p>Guava有两种限流模式，一种为稳定模式(SmoothBursty:令牌生成速度恒定)，一种为渐进模式(SmoothWarmingUp:令牌生成速度缓慢提升直到维持在一个稳定值)。还记得前面在看reserveEarliestAvailable时，这两种模式对storedPermitsToWaitTime有不同的实现吗？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> waitMicros =</span><br><span class=\"line\">        storedPermitsToWaitTime(<span class=\"keyword\">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class=\"line\">            + (<span class=\"keyword\">long</span>) (freshPermits * stableIntervalMicros);</span><br></pre></td></tr></table></figure>\n<p>SmoothBursty的实现,等待毫秒数直接等于需要新增令牌数*生成一个令牌需要的时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">storedPermitsToWaitTime</span><span class=\"params\">(<span class=\"keyword\">double</span> storedPermits, <span class=\"keyword\">double</span> permitsToTake)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0L</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>SmoothWarmingUp的实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">storedPermitsToWaitTime</span><span class=\"params\">(<span class=\"keyword\">double</span> storedPermits, <span class=\"keyword\">double</span> permitsToTake)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">double</span> availablePermitsAboveThreshold = storedPermits - thresholdPermits;</span><br><span class=\"line\">      <span class=\"keyword\">long</span> micros = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"comment\">// measuring the integral on the right part of the function (the climbing line)</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (availablePermitsAboveThreshold &gt; <span class=\"number\">0.0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> permitsAboveThresholdToTake = min(availablePermitsAboveThreshold, permitsToTake);</span><br><span class=\"line\">        <span class=\"comment\">// TODO(cpovirk): Figure out a good name for this variable.</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> length = permitsToTime(availablePermitsAboveThreshold)</span><br><span class=\"line\">                + permitsToTime(availablePermitsAboveThreshold - permitsAboveThresholdToTake);</span><br><span class=\"line\">        micros = (<span class=\"keyword\">long</span>) (permitsAboveThresholdToTake * length / <span class=\"number\">2.0</span>);</span><br><span class=\"line\">        permitsToTake -= permitsAboveThresholdToTake;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// measuring the integral on the left part of the function (the horizontal line)</span></span><br><span class=\"line\">      micros += (stableIntervalMicros * permitsToTake);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> micros;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h3 id=\"acquire和tryAcquire的区别\"><a href=\"#acquire和tryAcquire的区别\" class=\"headerlink\" title=\"acquire和tryAcquire的区别\"></a>acquire和tryAcquire的区别</h3><ul>\n<li>acquire是阻塞的且会一直等待到获取令牌为止，它有一个返回值为double型，意思是从阻塞开始到获取到令牌的等待时间，单位为秒</li>\n<li>tryAcquire是另外一个方法，它可以指定超时时间，返回值为boolean型，即假设线程等待了指定时间后仍然没有获取到令牌，那么就会返回给客户端false，客户端根据自身情况是打回给前台错误还是定时重试</li>\n</ul>\n<h3 id=\"RateLimiter的缺陷\"><a href=\"#RateLimiter的缺陷\" class=\"headerlink\" title=\"RateLimiter的缺陷\"></a>RateLimiter的缺陷</h3><p>特别注意RateLimiter是单机的，也就是说它无法跨JVM使用，设置的1000QPS，那也在单机中保证平均1000QPS的流量。</p>\n<p>假设集群中部署了10台服务器，想要保证集群1000QPS的接口调用量，那么RateLimiter就不适用了，集群流控最常见的方法是使用强大的Redis：</p>\n<ul>\n<li>一种是固定窗口的计数，例如当前是2019/8/26 20:05:00，就往这个”2019/8/26 20:05:00”这个key进行incr，当前是2019/8/26 20:05:01，就往”2019/8/26 20:05:01”这个key进行incr，incr后的结果只要大于我们设定的值，那么就打回去，小于就相当于获取到了执行权限</li>\n<li>一种是结合lua脚本，实现分布式的令牌桶算法，网上实现还是比较多的，可以参考<a href=\"https://blog.csdn.net/sunlihuo/article/details/79700225这篇文章\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/sunlihuo/article/details/79700225这篇文章</a></li>\n</ul>\n<p>总得来说，集群限流的实现也比较简单。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>推荐大家自己去读读这个google的手笔，从注释到命名一目了然，读起来很舒服。</p>\n<p>其他收获：</p>\n<p>静态工厂方法代替构造函数。<code>RateLimiter</code>是入口类，它提供了两套工厂方法来创建出两个子类。</p>\n<p>最后以SmoothRateLimiter的一个可可爱爱注释收尾。</p>\n<p><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/ratelimiter/%E6%B3%A8%E9%87%8A.png\" alt=\"1587137971779\"></p>\n"},{"title":"CSS拾遗","date":"2018-09-18T06:00:50.000Z","description":"css查漏补缺","_content":"\n# css的三种写处\n\n## 内联式\n`style=\"color:red;\"`\n\n## 嵌入式\n```\n<style>\n\n</style>\n```\n\n## 外部式\ncss外部式\n`<link href=\"css/style.css\" rel=\"stylesheet\">`\n\njs外部式\n`<script type=\"text/javascript\" src=\"js/jquery-1.8.3.min.js\"></script>`\n\n## 优先级：内联式 > 嵌入式 > 外部式\n其实总结来说，就是--就近原则（离被设置元素越近优先级别越高）。\n\n# 选择器\n```\n p{ color:red;}/*元素选择器*/\n \n #p1{color:blue;}/*id选择器*/\n \n .after{color:green; }/*类选择器*/\n \n *{color:red;}/*通用选择器*/\n \n a:hover{color:red;}/*伪类选择器*/\n \n  h1,span{color:red;}/*两个都*/\n```\n选择官方参考手册http://www.w3school.com.cn/cssref/css_selectors.asp\n\n!important 注意要写在分号的前面，比如\n`a:hover{color:red!important;}/`\n# 布局\n这个慕课老师发了许多关于布局的课程，其中一些给人启发\nhttp://www.imooc.com/t/197450\n## 一、基本知识\n- 块级元素\n特点：\n1.一个块级元素独占一行\n2.元素的高度、宽度、行高以及顶和底边距都可设置。\n常用的块状元素有：\n`<div>、<p>、<h1>、<h6>、<ol>、<ul>、<dl>、<table>、<address>、<blockquote> 、<form>`\n\n\n- 内联元素\n特点：\n1.和其他元素都在一行上。\n2.元素的高度、宽度及顶部和底部边距**不可**设置；\n常用的内联元素有：\n`<a>、<span>、<br>、<i>、<em>、<strong>、<label>、<q>、<var>、<cite>、<code>`\n\n\ninline-block 元素特点：\n1、和其他元素都在一行上；\n2、元素的高度、宽度、行高以及顶和底边距都**可**设置。\n\ndisplay:block  -- 显示为块级元素\ndisplay:inline  -- 显示为内联元素\ndisplay:inline-block -- 显示为内联块元素，表现为同行显示并可修改宽高内外边距等属性\n\ntips：常将<ul>元素加上display:inline-block样式，原本垂直的列表就可以水平显示了。\n\n\n## 二、定位\n### float浮动定位\nfloat的设计初衷仅仅是-文字环绕效果\n属性有left、right、none\n\n### positioin\nrelative相对定位：相对于它的初始位置而言移动。不可层叠。\nabsolute绝对定位：相对于最近的已定位的父元素。可层叠。\nfixed悬浮定位：本质和absolute一样，不过不随浏览器滚动条向上或向下移动。\n\n\n## 三、盒模型\n元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。\n\n## 四、布局模型\n  1、流动模型（Flow）\n \n  2、浮动模型 (Float)\n  float的设计初衷仅仅是-文字环绕效果\n  3、层模型（Layer）\n\n\n# 静态网页常用代码\n\n## 1.如何将网页整体居中？\n- 方法一将整个网页放在一个大div容器下，容器设置margin和具体宽度。\n`<div style=\"margin: 0 auto;width:1000px;\">`\n解释：上下边距为0，左右边距为自适应。\n- 方法二1.定义大div的宽度 2.把容器position睡醒设置为relative 3.把left属性设置为50%\n`<div style=\"width:1000px;position:relative;left:50%;\">`\n\n\n## 2.如何消除默认样式？\n`2.<body style=\"margin:0;padding:0;\">`\n\n\n## 3.如何隐藏滚动条？\n - 方法一html { overflow-y: scroll; }\n    原理：强制显示ie的垂直滚动条，而忽略水平滚动条\n    优点：完全解决了这个问题, 允许你保持完整的XHTML doctype.\n    缺点：即使页面不需要垂直滚动条的时候也会出现垂直滚动条。\n    \n - 方法2:html { overflow-x: hidden; overflow-y: auto; }\n    原理：隐藏横向滚动，垂直滚动根据内容自适应\n    优点：在视觉上解决了这个问题.在不必要的时候, 未强制垂直滚动条出现.\n    缺点：只是隐藏了水平滚动条，如果页面真正需要水平滚动条的时候，\n    屏幕以外的内容会因为用户无法水平滚动，而看不到。\n\n\n## 4.常用代码，搁这了，方便复制。\n- 清除一些默认样式\n ```\n*{margin:0;padding:0;}\nbody{font-size:12px;}\nimg{border:none;}\nli{list-style:none;}\ninput,select,textarea{outline:none;}\ntextarea{resize:none;}\na{text-decoration:none;}\n```\n- 刚开始肯定就是刷刷几个div包起来\n```\n<div class=\"\"></div>\n<div class=\"\"></div>\n<div class=\"\"></div>\n```\n- Bootstrap框架引用代码\n```$xslt\n<script src=\"http://how2j.cn/study/js/jquery/2.0.0/jquery.min.js\"></script>\n<link href=\"http://how2j.cn/study/css/bootstrap/3.3.6/bootstrap.min.css\" rel=\"stylesheet\">\n<script src=\"http://how2j.cn/study/js/bootstrap/3.3.6/bootstrap.min.js\"></script>\n```\n","source":"_posts/css.md","raw":"---\ntitle: CSS拾遗\ndate: 2018-09-18 14:00:50\ncategories: 前端\ndescription: css查漏补缺\n---\n\n# css的三种写处\n\n## 内联式\n`style=\"color:red;\"`\n\n## 嵌入式\n```\n<style>\n\n</style>\n```\n\n## 外部式\ncss外部式\n`<link href=\"css/style.css\" rel=\"stylesheet\">`\n\njs外部式\n`<script type=\"text/javascript\" src=\"js/jquery-1.8.3.min.js\"></script>`\n\n## 优先级：内联式 > 嵌入式 > 外部式\n其实总结来说，就是--就近原则（离被设置元素越近优先级别越高）。\n\n# 选择器\n```\n p{ color:red;}/*元素选择器*/\n \n #p1{color:blue;}/*id选择器*/\n \n .after{color:green; }/*类选择器*/\n \n *{color:red;}/*通用选择器*/\n \n a:hover{color:red;}/*伪类选择器*/\n \n  h1,span{color:red;}/*两个都*/\n```\n选择官方参考手册http://www.w3school.com.cn/cssref/css_selectors.asp\n\n!important 注意要写在分号的前面，比如\n`a:hover{color:red!important;}/`\n# 布局\n这个慕课老师发了许多关于布局的课程，其中一些给人启发\nhttp://www.imooc.com/t/197450\n## 一、基本知识\n- 块级元素\n特点：\n1.一个块级元素独占一行\n2.元素的高度、宽度、行高以及顶和底边距都可设置。\n常用的块状元素有：\n`<div>、<p>、<h1>、<h6>、<ol>、<ul>、<dl>、<table>、<address>、<blockquote> 、<form>`\n\n\n- 内联元素\n特点：\n1.和其他元素都在一行上。\n2.元素的高度、宽度及顶部和底部边距**不可**设置；\n常用的内联元素有：\n`<a>、<span>、<br>、<i>、<em>、<strong>、<label>、<q>、<var>、<cite>、<code>`\n\n\ninline-block 元素特点：\n1、和其他元素都在一行上；\n2、元素的高度、宽度、行高以及顶和底边距都**可**设置。\n\ndisplay:block  -- 显示为块级元素\ndisplay:inline  -- 显示为内联元素\ndisplay:inline-block -- 显示为内联块元素，表现为同行显示并可修改宽高内外边距等属性\n\ntips：常将<ul>元素加上display:inline-block样式，原本垂直的列表就可以水平显示了。\n\n\n## 二、定位\n### float浮动定位\nfloat的设计初衷仅仅是-文字环绕效果\n属性有left、right、none\n\n### positioin\nrelative相对定位：相对于它的初始位置而言移动。不可层叠。\nabsolute绝对定位：相对于最近的已定位的父元素。可层叠。\nfixed悬浮定位：本质和absolute一样，不过不随浏览器滚动条向上或向下移动。\n\n\n## 三、盒模型\n元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。\n\n## 四、布局模型\n  1、流动模型（Flow）\n \n  2、浮动模型 (Float)\n  float的设计初衷仅仅是-文字环绕效果\n  3、层模型（Layer）\n\n\n# 静态网页常用代码\n\n## 1.如何将网页整体居中？\n- 方法一将整个网页放在一个大div容器下，容器设置margin和具体宽度。\n`<div style=\"margin: 0 auto;width:1000px;\">`\n解释：上下边距为0，左右边距为自适应。\n- 方法二1.定义大div的宽度 2.把容器position睡醒设置为relative 3.把left属性设置为50%\n`<div style=\"width:1000px;position:relative;left:50%;\">`\n\n\n## 2.如何消除默认样式？\n`2.<body style=\"margin:0;padding:0;\">`\n\n\n## 3.如何隐藏滚动条？\n - 方法一html { overflow-y: scroll; }\n    原理：强制显示ie的垂直滚动条，而忽略水平滚动条\n    优点：完全解决了这个问题, 允许你保持完整的XHTML doctype.\n    缺点：即使页面不需要垂直滚动条的时候也会出现垂直滚动条。\n    \n - 方法2:html { overflow-x: hidden; overflow-y: auto; }\n    原理：隐藏横向滚动，垂直滚动根据内容自适应\n    优点：在视觉上解决了这个问题.在不必要的时候, 未强制垂直滚动条出现.\n    缺点：只是隐藏了水平滚动条，如果页面真正需要水平滚动条的时候，\n    屏幕以外的内容会因为用户无法水平滚动，而看不到。\n\n\n## 4.常用代码，搁这了，方便复制。\n- 清除一些默认样式\n ```\n*{margin:0;padding:0;}\nbody{font-size:12px;}\nimg{border:none;}\nli{list-style:none;}\ninput,select,textarea{outline:none;}\ntextarea{resize:none;}\na{text-decoration:none;}\n```\n- 刚开始肯定就是刷刷几个div包起来\n```\n<div class=\"\"></div>\n<div class=\"\"></div>\n<div class=\"\"></div>\n```\n- Bootstrap框架引用代码\n```$xslt\n<script src=\"http://how2j.cn/study/js/jquery/2.0.0/jquery.min.js\"></script>\n<link href=\"http://how2j.cn/study/css/bootstrap/3.3.6/bootstrap.min.css\" rel=\"stylesheet\">\n<script src=\"http://how2j.cn/study/js/bootstrap/3.3.6/bootstrap.min.js\"></script>\n```\n","slug":"css","published":1,"updated":"2022-02-08T07:09:41.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qk1000cw9rpsbu5ep9a","content":"<h1 id=\"css的三种写处\"><a href=\"#css的三种写处\" class=\"headerlink\" title=\"css的三种写处\"></a>css的三种写处</h1><h2 id=\"内联式\"><a href=\"#内联式\" class=\"headerlink\" title=\"内联式\"></a>内联式</h2><p><code>style=&quot;color:red;&quot;</code></p>\n<h2 id=\"嵌入式\"><a href=\"#嵌入式\" class=\"headerlink\" title=\"嵌入式\"></a>嵌入式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"外部式\"><a href=\"#外部式\" class=\"headerlink\" title=\"外部式\"></a>外部式</h2><p>css外部式<br><code>&lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt;</code></p>\n<p>js外部式<br><code>&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;</code></p>\n<h2 id=\"优先级：内联式-gt-嵌入式-gt-外部式\"><a href=\"#优先级：内联式-gt-嵌入式-gt-外部式\" class=\"headerlink\" title=\"优先级：内联式 &gt; 嵌入式 &gt; 外部式\"></a>优先级：内联式 &gt; 嵌入式 &gt; 外部式</h2><p>其实总结来说，就是–就近原则（离被设置元素越近优先级别越高）。</p>\n<h1 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p&#123; color:red;&#125;/*元素选择器*/</span><br><span class=\"line\"></span><br><span class=\"line\">#p1&#123;color:blue;&#125;/*id选择器*/</span><br><span class=\"line\"></span><br><span class=\"line\">.after&#123;color:green; &#125;/*类选择器*/</span><br><span class=\"line\"></span><br><span class=\"line\">*&#123;color:red;&#125;/*通用选择器*/</span><br><span class=\"line\"></span><br><span class=\"line\">a:hover&#123;color:red;&#125;/*伪类选择器*/</span><br><span class=\"line\"></span><br><span class=\"line\"> h1,span&#123;color:red;&#125;/*两个都*/</span><br></pre></td></tr></table></figure>\n<p>选择官方参考手册<a href=\"http://www.w3school.com.cn/cssref/css_selectors.asp\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/cssref/css_selectors.asp</a></p>\n<p>!important 注意要写在分号的前面，比如<br><code>a:hover{color:red!important;}/</code></p>\n<h1 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h1><p>这个慕课老师发了许多关于布局的课程，其中一些给人启发<br><a href=\"http://www.imooc.com/t/197450\" target=\"_blank\" rel=\"noopener\">http://www.imooc.com/t/197450</a></p>\n<h2 id=\"一、基本知识\"><a href=\"#一、基本知识\" class=\"headerlink\" title=\"一、基本知识\"></a>一、基本知识</h2><ul>\n<li>块级元素<br>特点：<br>1.一个块级元素独占一行<br>2.元素的高度、宽度、行高以及顶和底边距都可设置。<br>常用的块状元素有：<br><code>&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;、&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;</code></li>\n</ul>\n<ul>\n<li>内联元素<br>特点：<br>1.和其他元素都在一行上。<br>2.元素的高度、宽度及顶部和底部边距<strong>不可</strong>设置；<br>常用的内联元素有：<br><code>&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;</code></li>\n</ul>\n<p>inline-block 元素特点：<br>1、和其他元素都在一行上；<br>2、元素的高度、宽度、行高以及顶和底边距都<strong>可</strong>设置。</p>\n<p>display:block  – 显示为块级元素<br>display:inline  – 显示为内联元素<br>display:inline-block – 显示为内联块元素，表现为同行显示并可修改宽高内外边距等属性</p>\n<p>tips：常将<ul>元素加上display:inline-block样式，原本垂直的列表就可以水平显示了。</ul></p>\n<h2 id=\"二、定位\"><a href=\"#二、定位\" class=\"headerlink\" title=\"二、定位\"></a>二、定位</h2><h3 id=\"float浮动定位\"><a href=\"#float浮动定位\" class=\"headerlink\" title=\"float浮动定位\"></a>float浮动定位</h3><p>float的设计初衷仅仅是-文字环绕效果<br>属性有left、right、none</p>\n<h3 id=\"positioin\"><a href=\"#positioin\" class=\"headerlink\" title=\"positioin\"></a>positioin</h3><p>relative相对定位：相对于它的初始位置而言移动。不可层叠。<br>absolute绝对定位：相对于最近的已定位的父元素。可层叠。<br>fixed悬浮定位：本质和absolute一样，不过不随浏览器滚动条向上或向下移动。</p>\n<h2 id=\"三、盒模型\"><a href=\"#三、盒模型\" class=\"headerlink\" title=\"三、盒模型\"></a>三、盒模型</h2><p>元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。</p>\n<h2 id=\"四、布局模型\"><a href=\"#四、布局模型\" class=\"headerlink\" title=\"四、布局模型\"></a>四、布局模型</h2><p>  1、流动模型（Flow）</p>\n<p>  2、浮动模型 (Float)<br>  float的设计初衷仅仅是-文字环绕效果<br>  3、层模型（Layer）</p>\n<h1 id=\"静态网页常用代码\"><a href=\"#静态网页常用代码\" class=\"headerlink\" title=\"静态网页常用代码\"></a>静态网页常用代码</h1><h2 id=\"1-如何将网页整体居中？\"><a href=\"#1-如何将网页整体居中？\" class=\"headerlink\" title=\"1.如何将网页整体居中？\"></a>1.如何将网页整体居中？</h2><ul>\n<li>方法一将整个网页放在一个大div容器下，容器设置margin和具体宽度。<br><code>&lt;div style=&quot;margin: 0 auto;width:1000px;&quot;&gt;</code><br>解释：上下边距为0，左右边距为自适应。</li>\n<li>方法二1.定义大div的宽度 2.把容器position睡醒设置为relative 3.把left属性设置为50%<br><code>&lt;div style=&quot;width:1000px;position:relative;left:50%;&quot;&gt;</code></li>\n</ul>\n<h2 id=\"2-如何消除默认样式？\"><a href=\"#2-如何消除默认样式？\" class=\"headerlink\" title=\"2.如何消除默认样式？\"></a>2.如何消除默认样式？</h2><p><code>2.&lt;body style=&quot;margin:0;padding:0;&quot;&gt;</code></p>\n<h2 id=\"3-如何隐藏滚动条？\"><a href=\"#3-如何隐藏滚动条？\" class=\"headerlink\" title=\"3.如何隐藏滚动条？\"></a>3.如何隐藏滚动条？</h2><ul>\n<li><p>方法一html { overflow-y: scroll; }<br> 原理：强制显示ie的垂直滚动条，而忽略水平滚动条<br> 优点：完全解决了这个问题, 允许你保持完整的XHTML doctype.<br> 缺点：即使页面不需要垂直滚动条的时候也会出现垂直滚动条。</p>\n</li>\n<li><p>方法2:html { overflow-x: hidden; overflow-y: auto; }<br> 原理：隐藏横向滚动，垂直滚动根据内容自适应<br> 优点：在视觉上解决了这个问题.在不必要的时候, 未强制垂直滚动条出现.<br> 缺点：只是隐藏了水平滚动条，如果页面真正需要水平滚动条的时候，<br> 屏幕以外的内容会因为用户无法水平滚动，而看不到。</p>\n</li>\n</ul>\n<h2 id=\"4-常用代码，搁这了，方便复制。\"><a href=\"#4-常用代码，搁这了，方便复制。\" class=\"headerlink\" title=\"4.常用代码，搁这了，方便复制。\"></a>4.常用代码，搁这了，方便复制。</h2><ul>\n<li><p>清除一些默认样式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&#123;margin:0;padding:0;&#125;</span><br><span class=\"line\">body&#123;font-size:12px;&#125;</span><br><span class=\"line\">img&#123;border:none;&#125;</span><br><span class=\"line\">li&#123;list-style:none;&#125;</span><br><span class=\"line\">input,select,textarea&#123;outline:none;&#125;</span><br><span class=\"line\">textarea&#123;resize:none;&#125;</span><br><span class=\"line\">a&#123;text-decoration:none;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>刚开始肯定就是刷刷几个div包起来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Bootstrap框架引用代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;http://how2j.cn/study/js/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;link href=&quot;http://how2j.cn/study/css/bootstrap/3.3.6/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class=\"line\">&lt;script src=&quot;http://how2j.cn/study/js/bootstrap/3.3.6/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"css的三种写处\"><a href=\"#css的三种写处\" class=\"headerlink\" title=\"css的三种写处\"></a>css的三种写处</h1><h2 id=\"内联式\"><a href=\"#内联式\" class=\"headerlink\" title=\"内联式\"></a>内联式</h2><p><code>style=&quot;color:red;&quot;</code></p>\n<h2 id=\"嵌入式\"><a href=\"#嵌入式\" class=\"headerlink\" title=\"嵌入式\"></a>嵌入式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"外部式\"><a href=\"#外部式\" class=\"headerlink\" title=\"外部式\"></a>外部式</h2><p>css外部式<br><code>&lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt;</code></p>\n<p>js外部式<br><code>&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;</code></p>\n<h2 id=\"优先级：内联式-gt-嵌入式-gt-外部式\"><a href=\"#优先级：内联式-gt-嵌入式-gt-外部式\" class=\"headerlink\" title=\"优先级：内联式 &gt; 嵌入式 &gt; 外部式\"></a>优先级：内联式 &gt; 嵌入式 &gt; 外部式</h2><p>其实总结来说，就是–就近原则（离被设置元素越近优先级别越高）。</p>\n<h1 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p&#123; color:red;&#125;/*元素选择器*/</span><br><span class=\"line\"></span><br><span class=\"line\">#p1&#123;color:blue;&#125;/*id选择器*/</span><br><span class=\"line\"></span><br><span class=\"line\">.after&#123;color:green; &#125;/*类选择器*/</span><br><span class=\"line\"></span><br><span class=\"line\">*&#123;color:red;&#125;/*通用选择器*/</span><br><span class=\"line\"></span><br><span class=\"line\">a:hover&#123;color:red;&#125;/*伪类选择器*/</span><br><span class=\"line\"></span><br><span class=\"line\"> h1,span&#123;color:red;&#125;/*两个都*/</span><br></pre></td></tr></table></figure>\n<p>选择官方参考手册<a href=\"http://www.w3school.com.cn/cssref/css_selectors.asp\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/cssref/css_selectors.asp</a></p>\n<p>!important 注意要写在分号的前面，比如<br><code>a:hover{color:red!important;}/</code></p>\n<h1 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h1><p>这个慕课老师发了许多关于布局的课程，其中一些给人启发<br><a href=\"http://www.imooc.com/t/197450\" target=\"_blank\" rel=\"noopener\">http://www.imooc.com/t/197450</a></p>\n<h2 id=\"一、基本知识\"><a href=\"#一、基本知识\" class=\"headerlink\" title=\"一、基本知识\"></a>一、基本知识</h2><ul>\n<li>块级元素<br>特点：<br>1.一个块级元素独占一行<br>2.元素的高度、宽度、行高以及顶和底边距都可设置。<br>常用的块状元素有：<br><code>&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;、&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;</code></li>\n</ul>\n<ul>\n<li>内联元素<br>特点：<br>1.和其他元素都在一行上。<br>2.元素的高度、宽度及顶部和底部边距<strong>不可</strong>设置；<br>常用的内联元素有：<br><code>&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;</code></li>\n</ul>\n<p>inline-block 元素特点：<br>1、和其他元素都在一行上；<br>2、元素的高度、宽度、行高以及顶和底边距都<strong>可</strong>设置。</p>\n<p>display:block  – 显示为块级元素<br>display:inline  – 显示为内联元素<br>display:inline-block – 显示为内联块元素，表现为同行显示并可修改宽高内外边距等属性</p>\n<p>tips：常将<ul>元素加上display:inline-block样式，原本垂直的列表就可以水平显示了。</ul></p>\n<h2 id=\"二、定位\"><a href=\"#二、定位\" class=\"headerlink\" title=\"二、定位\"></a>二、定位</h2><h3 id=\"float浮动定位\"><a href=\"#float浮动定位\" class=\"headerlink\" title=\"float浮动定位\"></a>float浮动定位</h3><p>float的设计初衷仅仅是-文字环绕效果<br>属性有left、right、none</p>\n<h3 id=\"positioin\"><a href=\"#positioin\" class=\"headerlink\" title=\"positioin\"></a>positioin</h3><p>relative相对定位：相对于它的初始位置而言移动。不可层叠。<br>absolute绝对定位：相对于最近的已定位的父元素。可层叠。<br>fixed悬浮定位：本质和absolute一样，不过不随浏览器滚动条向上或向下移动。</p>\n<h2 id=\"三、盒模型\"><a href=\"#三、盒模型\" class=\"headerlink\" title=\"三、盒模型\"></a>三、盒模型</h2><p>元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。</p>\n<h2 id=\"四、布局模型\"><a href=\"#四、布局模型\" class=\"headerlink\" title=\"四、布局模型\"></a>四、布局模型</h2><p>  1、流动模型（Flow）</p>\n<p>  2、浮动模型 (Float)<br>  float的设计初衷仅仅是-文字环绕效果<br>  3、层模型（Layer）</p>\n<h1 id=\"静态网页常用代码\"><a href=\"#静态网页常用代码\" class=\"headerlink\" title=\"静态网页常用代码\"></a>静态网页常用代码</h1><h2 id=\"1-如何将网页整体居中？\"><a href=\"#1-如何将网页整体居中？\" class=\"headerlink\" title=\"1.如何将网页整体居中？\"></a>1.如何将网页整体居中？</h2><ul>\n<li>方法一将整个网页放在一个大div容器下，容器设置margin和具体宽度。<br><code>&lt;div style=&quot;margin: 0 auto;width:1000px;&quot;&gt;</code><br>解释：上下边距为0，左右边距为自适应。</li>\n<li>方法二1.定义大div的宽度 2.把容器position睡醒设置为relative 3.把left属性设置为50%<br><code>&lt;div style=&quot;width:1000px;position:relative;left:50%;&quot;&gt;</code></li>\n</ul>\n<h2 id=\"2-如何消除默认样式？\"><a href=\"#2-如何消除默认样式？\" class=\"headerlink\" title=\"2.如何消除默认样式？\"></a>2.如何消除默认样式？</h2><p><code>2.&lt;body style=&quot;margin:0;padding:0;&quot;&gt;</code></p>\n<h2 id=\"3-如何隐藏滚动条？\"><a href=\"#3-如何隐藏滚动条？\" class=\"headerlink\" title=\"3.如何隐藏滚动条？\"></a>3.如何隐藏滚动条？</h2><ul>\n<li><p>方法一html { overflow-y: scroll; }<br> 原理：强制显示ie的垂直滚动条，而忽略水平滚动条<br> 优点：完全解决了这个问题, 允许你保持完整的XHTML doctype.<br> 缺点：即使页面不需要垂直滚动条的时候也会出现垂直滚动条。</p>\n</li>\n<li><p>方法2:html { overflow-x: hidden; overflow-y: auto; }<br> 原理：隐藏横向滚动，垂直滚动根据内容自适应<br> 优点：在视觉上解决了这个问题.在不必要的时候, 未强制垂直滚动条出现.<br> 缺点：只是隐藏了水平滚动条，如果页面真正需要水平滚动条的时候，<br> 屏幕以外的内容会因为用户无法水平滚动，而看不到。</p>\n</li>\n</ul>\n<h2 id=\"4-常用代码，搁这了，方便复制。\"><a href=\"#4-常用代码，搁这了，方便复制。\" class=\"headerlink\" title=\"4.常用代码，搁这了，方便复制。\"></a>4.常用代码，搁这了，方便复制。</h2><ul>\n<li><p>清除一些默认样式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&#123;margin:0;padding:0;&#125;</span><br><span class=\"line\">body&#123;font-size:12px;&#125;</span><br><span class=\"line\">img&#123;border:none;&#125;</span><br><span class=\"line\">li&#123;list-style:none;&#125;</span><br><span class=\"line\">input,select,textarea&#123;outline:none;&#125;</span><br><span class=\"line\">textarea&#123;resize:none;&#125;</span><br><span class=\"line\">a&#123;text-decoration:none;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>刚开始肯定就是刷刷几个div包起来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Bootstrap框架引用代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;http://how2j.cn/study/js/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;link href=&quot;http://how2j.cn/study/css/bootstrap/3.3.6/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class=\"line\">&lt;script src=&quot;http://how2j.cn/study/js/bootstrap/3.3.6/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"javaSE（上）","date":"2018-10-06T13:00:50.000Z","description":"不要小瞧基础呀!","_content":"\n# 封装、继承、多态\n## 封装\n访问修饰权限：\nprivate（私有）, default（同一包）, public（共有）, protected（同一包和子孙类）\n如果不写修饰符默认用default（package/friendly）修饰。\n**default和protected区别：protected能访问子孙类，default不能。**\n**会被子类继承的方法，通常使用protected**\n\n## 继承\n\n接口和抽象类的主要区别？\n从概念上来说\n抽象类是一种对**事物的抽象**，而接口就像是一种约定，是一种对**行为**的抽象；\n抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。\n抽象类是一种模板式设计，而接口是一种**行为规范**，是一种辐射式设计。\n\n模板式设计：如果B和C都使用了公共模板A，如果他们的公共部分需要改动，那么只改动A就可以了；\n辐射式设计：如果B和C都实现了公共接口A，如果现在要向A中添加新的方法，那么B和C都必须进行相应改动。\n\n区别1：\n**一个类只能继承一个父类。\n一个类可以实现多个接口**\n\n区别2：\n抽象类可以定义\npublic,protected,package,private、静态和非静态属性、final和非final属性\n但是接口中声明的属性，只能是public、静态、final的\n\n问题：Override(重写)和Overload(重载)的区别?Overload能改变返回值类型吗?\n\n子类**重写**父类方法：子类的方法名与父类的一样，但是参数类型不一样。\n重载：**本类**中出现的方法名一样，参数列表不同的方法。\n与返回值类型无关。\n\n思考：如果没有重写这样的机制，会发生什么？\n答：一旦继承了父类，**所有方法都不能修改了**。另外，对象调用方法的时候，先找子类本身的方法，再找父类。(就近原则)\n\n隐藏，就是子类覆盖父类的**类方法**。（重写是子类覆盖父类的对象方法 ）\n\n\n为什么Java语言不支持c++所有的多重继承?\n多重继承有它的弊端。\n1)多重继承存在**二义性**。比如，类C同时继承类A和类B,如果类A和类B中都有方法f,那么调用类C的的f方法时,无法确定是调用类A还是类B的方法,将会产生二义性。但是Java语言却可以通过实现多个接口的方式间接地支持多重继承,由于接口只有方法体,没有方法实现,假设类C实现了接口A和接口B，即使AB都有f方法，但接口只有定义没有实现，在C中才有一个方法的实现，也就不存在二义性了。\n2）多重继承会使得类型转换，构造方法的调用顺序变得非常复杂。\n\n\n\n\n\n\n\n\n## 多态\n**操作符**的多态 \n加号+可以作为算数运算，也可以作为字符串连接。不同情境下，具备不同的作用\n如果+号两侧都是整型，那么+代表数字**相加**\n如果+号两侧，任意一个是字符串，那么+代表**字符串连接**\n\n**类**的多态 比如**父类的引用指向子类的对象**、重写。\n\n\n<u>下面程序的运行结果是？</u>\n```\nclass Base\n{\n    int num = 1;\n    public Base(){\n        this.print();\n        num=2;\n    }\n    public void print(){\n        System.out.println(\"Base.num=\"+num);\n    }\n}\nclass Sub extends Base{\n    int num= 3;\n    public Sub(){\n        this.print();\n        num=4;\n    }\n    public void print(){\n        System.out.println(\"Sub.num=\"+num);\n   }\n}\npublic class Test1 {\n  public static void main(String[] args)\n  {\n      Base b = new Sub();\n      System.out.println(b.num);\n  }\n}\n```\n\n在执行语句 Base b= new Sub时,会首先调用父类的构造方法。**根据多态的特性,此时实例化的是sub类的对象,因此,base构造方法会调用Sub类的print()方法。由于此时Sub类中的初始化代码 Int num=3还没有执行,num的默认值为0,输出为 Sub num=0。** 下一条语句父类num初始化为2。\n然后会调用子类的构造方法,根据初始化的顺序可知在调用子类构造方法时,非静态的变量会先执行初始化动作,所以,此时子类Sub的mum值为3,因此,调用 print方法会输出 Sub num=3。\n接着输出b.num,由于b的类型为Base,**而属性没有多态的概念**因此,此时会输出父类中的mm值:2\n程序的运行结果如下：\nSub.num=0\nSub.num=3\n2\n\n题目总结：1.当父类的引用指向子类的对象时，会先初始化父类。\n2.如果子类重写某方法，不管父类子类都是调用子类方法。\n3.属性没有多态的概念。\n\n\n\n## 其他\n### java初始化原则\n### 对象属性初始化方法有3种\n1. 声明该属性的时候初始化 \n2. 构造方法中初始化\n3. 初始化块\n\n如果同时初始化同一变量，则优先级是：构造方法中初始化>初始化块> 声明该属性的时候初始化 \n\n静态成员变量>成员变量>构造方法。\n1静态变量优先与非静态变量\n2父类优先于子类\n3按照成员变量定义的顺序。\n父子类的初始化执行顺序如下：\n父类静态变量，父类静态代码块\n子类静态变量，子类静态代码块\n父类非静态变量，父类非静态代码块，父类构造方法\n子类非静态变量，子类非静态代码块和子类构造函数。\n\n    \n### this关键字\n this关键字代表自身实例\n```\n //参数名和属性名一样\n    //在方法体中，只能访问到参数name\n    public void setName1(String name){\n        name = name;\n    }\n     \n    //为了避免setName1中的问题，参数名不得不使用其他变量名\n    public void setName2(String heroName){\n        name = heroName;\n    }\n     \n    //通过this访问属性\n    public void setName3(String name){\n        //name代表的是参数name\n        //this.name代表的是属性name\n        this.name = name;\n    }\n```\n### 实参与行参的问题\n<u>猜一猜程序运行结果</u>\n```\npublic class Test {\n\n    public void change(int j, StringBuffer ss1) {\n        j = 100;\n        ss1.append(\"world\");\n    }\n\n    public static void main(String[] args) {\n        int i = 1;\n        StringBuffer s1 = new StringBuffer(\"hello \");\n        Test t = new Test();\n        t.change(i, s1);\n        System.out.println(i);//1处\n        System.out.println(s1);//2处\n    }\n}\n```\n\n\n由于i是基本类型，因此参数是**按值**传递。**会创建一个i的副本**。把这个副本作为参数赋值给j。既然j是i的副本，那么对副本的任何修改都不会对i有影响。因此1处输出1。\n由于StringBuffer是一个类，因此是按**引用**传递。当ss1修改的时候。由于实参s1和形参ss1指向的是同一块储存空间，因此ss1修改了值之后，s1指向的字符串也被修改了。因此2处输出hello world。\n那么，下面程序运行结果又是什么\n```\n\npublic class Test {\n\n    public void change(StringBuffer ss1) {\n       ss1 = new StringBuffer(\"world\");\n    }\n\n   public static void main(String[] args) {\n   StringBuffer s1 = new StringBuffer(\"hello \");\n        Test t = new Test();\n        t.change(s1);\n        System.out.println(s1);\n    }}\n```\n\n\n由于StringBuffer是一个类，因此是按引用传递。**但是**这里的change方法不是对\"hello \"进行修改，而是使形参ss1的指向另一个字符串 “world”。而对形参ss1的改变对实参s1没有影响，实参s1仍然指向 \"hello \"。\n\n<u>引用就是指针吗？</u>\n不是，二者不能等同。虽然java引用在底层是通过指针实现的，但指针可以执行比较运算和整数的加减运算，而引用却不行。\n\n\n\n\n\n### 关键字 final\n修饰变量时，用以定义常量；\n修饰方法时，方法不能被重写（Override）；\n修饰类时，类不能被继承。\n\n\n# 变量、数组、循环\n## 变量\n变量的范围\n1.变量声明在类下，叫做**字段**或者**属性**或者**成员变量**\n2.变量声明在一个方法上的，就叫做**参数**或者**局部变量**\n \n数据类型    \n八种基本类型(二进制位数)： \n 整型 4种： byte（8位）、short（16位）、int（32位）、long（64位）\n 浮点型 2种： float（32位）、double （64位）\n 字符型 1种： char（16位）\n 布尔型 1种：boolean（1位）\n \n 现在问题来了\n \n\n\n<u>问：int和integer的区别？</u>\n答：1)int默认值为0。而integer默认值为null。由此可见,证int无法区分未赋值与赋值为0的情况,而integer却可以区分这两种情况。\n2)int是是值传递。而integer是引用传递\n3)int只能用来运算,而integer提供了很多有用的方法\n4)当需要往容器(例如List)里存放整数时,无法直接存放int,因为List里面放的都是对象,所以,在这种情况下只能使用 Integer\n\n<u>问：char型变量中能不能存贮一个中文汉字?为什么?</u>\n答：char是16位的，占两个字节\n汉字通常使用GBK或者UNICODE编码，也是使用两个字节，可以正常存放汉字。如果是utf-8编码，一个中文占三个字节，编译不会报错。但运行会报error“未结束的字符文字”\n\n\n<u>问：请解释这三条语句的输出</u>\n```\n  System.out.println((byte)127);//127\nSystem.out.println((byte)128);//-128\nSystem.out.println((byte)129);//-127\n```\n答：byte的取值是{-128,127},如果把128强制转换成byte已结超出了byte范围，此时会溢出，相当于最小的负数-128.而129强转后就是-127\n\n\n<u>问：请解释这条语句的输出</u>\n```\nSystem.out.println(Math.min(Double.MIN_VALUE,0.0));//输出0.0\n```\n答：对于Double来说MIN_VALUE并不是取值范围的最小数，而是正数范围的最小数，也就是最接近于0的正数。最接近于0的正数和0比起来，当然是0小。\n\n\n\n<u>问：在java里调用什么方法能把二进制数转化为十进制？</u>\n答：\n```\nSystem.out.println(Integer.valueOf(\"11101\",2));\n```\n\n\n### 类型转换\n#### 强制转换   \n```\nint i1 = 10;\nbyte b = (byte) i1;\n```\n\n\n#### 自动装箱和拆箱\n把基本数据类型和对应的包装类之间转换。比如int和Integer。\n```\nInteger i = 100;  //自动装箱，编译器执行Integer.valueOf(100)\nint j = i;        //自动拆箱，编译器执行i.intValue()\n```\n\n\n\n#### ==与equals()\n==比较的是两个对象的引用是否相同，或者是比较原始数据类型是否相等；\nequals()比较的是两个对象的内容是否相同。\n\n### 关于变量的题目\n\n<u> 题目一：解释为何行3编译错误，而行4编译正确</u>\n```\n        byte b1 = 3;\n        byte b2 = 4;\n        byte b3 = b1 + b2;                //编译错误\n        byte b4 = 3 + 4;                //编译正确\n//（1）变量相加，首先首先进行类型提升，之后再进行计算，计算后将结果赋值；\n//（2）常量相加，首先进行计算，之后判断是否在接受类型的范围，在则赋值。\n```\n \n\n\n<u>\n题目二：判断下列代码是否有误，并指出错误</u>\n``` \n        short s = 1;\n        s = s + 1;                //错误，s在参加运算时会自动提示类型为int。int类型值无法直接赋值于short类型\n        \n        short z = 1;\n        z += 1;                //正确,扩展赋值运算符包含强制类型转换。等价于 z = (short)(z + 1);\n//还有，-128~127的Integer值可以从缓存中取得。其他情况要重新创建\n```\n\n\n\n<u>题目三，int i = 1;i+=++i;的运算结果？</u>\ni+=++i,其中先算++i,得到2\n由于++i并未进行赋值，所以i还是1\n1+=2结果为3\n\n\n## 数组\n一维数组的3种创建方式\n```\nint[] arr1 = {1,2,3,4};             //正确\nint[] arr2 = new int[4];            //正确\nint[] arr3 = new int[]{1,2,3,4};    //正确\nint[] arr4 = new int[4]{1,2,3,4};  //错误，编译不通过\n```\n\n二维数组的3种声明方式\n```\nint arr1[][];\nint [][]arr2;\nint []arr3[];\n```\n与C/C++不同的是，java的二维数组允许第二维的长度可以不同。\n## 循环\n### for循环\n<u>写出下面程序运行结果</u>\n```\npublic class Test {\n\n   static boolean p(char c) {\n       System.out.print(c);\n       return true;\n    }\n\n    public static void main(String[] args) {\n       int i=0;\n        for (p('a'); p('b')&&i<2; p('c')) {//for(表达式1;表达式2;表达式3){循环体]\n            p('d');\n            i++; } }}\n```\n\n因为，1.初始化只会执行一次2.先执行循环体后执行for循环的表达式3\n所以答案是：abdcbdcb\n\n### switch\n```\n switch(day){\n            case 1:\n                System.out.println(\"星期一\");\n                break;\n            case 2:\n                System.out.println(\"星期二\");\n                break;\n            case 3:\n                System.out.println(\"星期三\");\n                break;\n            case 4:\n                System.out.println(\"星期四\");\n                break;\n            case 5:\n                System.out.println(\"星期五\");\n                break;\n            case 6:\n                System.out.println(\"星期六\");\n                break;\n            case 7:\n                System.out.println(\"星期天\");\n                break;\n            default:\n                System.out.println(\"输入有误\");\n        }\n```\n**使用switch特别注意，必须在case语句后加break **   \n\n### 枚举\n```\npublic enum Season {//是枚举enum不是类class\n            SPRING, SUMMER, AUTUMN, WINTER;//直接这样写\n\n            public static void main(String[] args) {\n                Season season = Season.SPRING;\n                switch (season) {\n                    case SPRING:\n                        System.out.println(\"春天\");\n                        break;\n                    case SUMMER:\n                        System.out.println(\"夏天\");\n                        break;\n                    case AUTUMN:\n                        System.out.println(\"秋天\");\n                        break;\n                    case WINTER:\n                        System.out.println(\"冬天\");\n                        break;\n                }}}\n```\n\n#### 如何跳出多重循环？\n在外部循环的前一行，加上自定义标签，比如 out:\n在break的时候使用该标签。break out;\n\n\n\n\n# 内部类\n\n## 非静态内部类\n可以被看作外部类的一个成员（与类的属性和方法类似）\n1可以自由的引用外部类的属性和方法。2外部类被实例化之后，内部类才能被实例化。3不能有静态成员。\n\n```\npublic class Hero {//英雄类\n    private String name; \n    float hp; \n    // 非静态内部类，只有一个外部类对象存在的时候，才有意义\n    // 比如战斗成绩只有在一个英雄对象存在的时候才有意义\n    \n    class BattleScore {//战斗成绩类\n        int kill;\n\n        public void legendary() {\n            if (kill >= 8)\n                System.out.println(name + \"超神！\");\n            else\n                System.out.println(name + \"尚未超神！\");\n        }\n    }\n \n    public static void main(String[] args) {\n        Hero garen = new Hero();\n        garen.name = \"盖伦\";\n        \n        // BattleScore对象只有在一个英雄对象存在的时候才有意义\n        BattleScore score = garen.new BattleScore();// 所以其实例化必须建立在一个外部类对象的基础之上\n                                                    \n        score.kill = 9;\n        score.legendary();\n    }\n \n}\n```\n\n## 静态内部类。\n1不能访问外部类普通成员，只能访问外部内中静态成员和静态方法。\n2可以不依赖于外部类实例化而实例化。\n3不可以与外部类同名。\n## 局部内部类\n是指定义在一个代码块内的类，不可以被修饰符修饰。\n## 匿名内部类\n是一种没有类名的内部类，不使用关键字class、extends、implement，没有构造方法，必须继承类或其他接口。一般用于gui编程中事件处理。\n\n```\npublic abstract class Hero{\n\n    public abstract void attack();\n\n    public static void main(String[] args) {\n        Hero h = new Hero(){\n            //当场实现attack方法\n            public void attack() {\n                System.out.println(\"新的进攻手段\");\n            }\n        };\n        h.attack();\n        //通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名\n        System.out.println(h);\n    }}\n\n\n```\n\n\n# 字符串\n\n\n\n## 格式化\n%s 表示字符串\n%d 表示数字\n%n 表示换行\n```\n        String name =\"盖伦\";\n        int kill = 8;\n        String title=\"超神\";\n         \n        String sentenceFormat =\"%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n\";\n        //使用printf格式化输出\n        System.out.printf(sentenceFormat,name,kill,title);//第一个是原字符串\n```\n\n## StringBuffer追加 删除 插入 反转\n```\nString str1 = \"let there \";\nStringBuffer sb = new StringBuffer(str1); //根据str1创建一个StringBuffer对象\nsb.append(\"be light\"); //在最后追加\nsb.delete(4, 10);//删除4-10之间的字符\nsb.insert(4, \"there \");//在4这个位置插入 there\nsb.reverse(); //反转\n```\n\n## 字符串的转化\n\n### 数字与字符串\n- 数字转字符串\n方法1： 使用String类的静态方法valueOf \nString str = String.valueOf(i);\n方法2： 先把基本类型装箱为对象，然后调用对象的toString\nInteger it = i;\nString str2 = it.toString();\n\n\n- 字符串转数字\nString str = \"999\";\nint i= Integer.parseInt(str);\n\n### 字符串与字符串数组\n- 字符数组 转 字符串\nchar[] data={'a','b','c'};\nString s=new String(data);\n\n字符数组转换成字符串\n```\nchar[]   data={'a','b','c'};   \nString  s=new   String(data);\n```\n\n\ns1.charAt(0)=c1;是不行的\ns1.charAt(0);是可以的\n\n## 字符串是否相等的提问\n问：1和2处分别输出什么?\n```\n        String str1 = \"the light\";\n        String str2 = new String(str1);\n        System.out.println( str1  ==  str2);//1\n       String str4 = new String(\"the light\");//2\n\n        String str3 = \"the light\";\n        String str4 = \"the light\";\n        System.out.println( str4  ==  str3);//3\n```\n答：1输出false。因为new String会为str2开辟一个新的区域.\n2输出true。因为str3创建了一个新的字符串\"the light\"，在str4编译器发现已经存在现成的\"the light\"，那么就直接拿来使用，而没有进行重复创建\n# 时间\n## 格式化时间\n时间（注意月和小时是大写的喔）\n\ny 代表年\nM 代表月\nd 代表日\nH 代表24进制的小时\nh 代表12进制的小时\nm 代表分钟\ns 代表秒\nS 代表毫秒\n```\nDate d = new Date();\nSystem.out.println(d);//输出当前时间\nSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日,HH时mm分ss秒\");//设置样式\nString s = sdf.format(d);//把d这个时间实例格式化，并且赋值给字符串s\nSystem.out.println(s);//输出的字符串s就是格式化好的时间啦\n```\n\n\n## 日历（可以做“查看明年的今天是几号”之类的事）\n```\nCalendar c = Calendar.getInstance();//Calendar用单例模式创造实例\nDate now = c.getTime();\n\nc.setTime(now);\n//先翻到下下个月\nc.add(Calendar.MONTH,2);\n//设置到月初\nc.set(Calendar.DATE,1);\n//再往回翻3天\nc.add(Calendar.DATE,-3);\n\nSystem.out.println(\"下个月的倒数第3天是哪天\"+s);\n```\n\n# 一些基础但不重要的知识\n- 变量名起名规则\n    1. 字母 数字 $ _ 组成\n    2. 变量第一个字符，不能使用数字。\n    3. 不可以使用关键字。\n为什么不重要？\n起名的时候选择有意义描述性的词比如“toString”\"getFlow\"，不要用关键字。起名规则无需死记硬背。","source":"_posts/javaSE上.md","raw":"---\ntitle: javaSE（上）\ndate: 2018-10-6 21:00:50\ncategories: java\ndescription: 不要小瞧基础呀!\n---\n\n# 封装、继承、多态\n## 封装\n访问修饰权限：\nprivate（私有）, default（同一包）, public（共有）, protected（同一包和子孙类）\n如果不写修饰符默认用default（package/friendly）修饰。\n**default和protected区别：protected能访问子孙类，default不能。**\n**会被子类继承的方法，通常使用protected**\n\n## 继承\n\n接口和抽象类的主要区别？\n从概念上来说\n抽象类是一种对**事物的抽象**，而接口就像是一种约定，是一种对**行为**的抽象；\n抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。\n抽象类是一种模板式设计，而接口是一种**行为规范**，是一种辐射式设计。\n\n模板式设计：如果B和C都使用了公共模板A，如果他们的公共部分需要改动，那么只改动A就可以了；\n辐射式设计：如果B和C都实现了公共接口A，如果现在要向A中添加新的方法，那么B和C都必须进行相应改动。\n\n区别1：\n**一个类只能继承一个父类。\n一个类可以实现多个接口**\n\n区别2：\n抽象类可以定义\npublic,protected,package,private、静态和非静态属性、final和非final属性\n但是接口中声明的属性，只能是public、静态、final的\n\n问题：Override(重写)和Overload(重载)的区别?Overload能改变返回值类型吗?\n\n子类**重写**父类方法：子类的方法名与父类的一样，但是参数类型不一样。\n重载：**本类**中出现的方法名一样，参数列表不同的方法。\n与返回值类型无关。\n\n思考：如果没有重写这样的机制，会发生什么？\n答：一旦继承了父类，**所有方法都不能修改了**。另外，对象调用方法的时候，先找子类本身的方法，再找父类。(就近原则)\n\n隐藏，就是子类覆盖父类的**类方法**。（重写是子类覆盖父类的对象方法 ）\n\n\n为什么Java语言不支持c++所有的多重继承?\n多重继承有它的弊端。\n1)多重继承存在**二义性**。比如，类C同时继承类A和类B,如果类A和类B中都有方法f,那么调用类C的的f方法时,无法确定是调用类A还是类B的方法,将会产生二义性。但是Java语言却可以通过实现多个接口的方式间接地支持多重继承,由于接口只有方法体,没有方法实现,假设类C实现了接口A和接口B，即使AB都有f方法，但接口只有定义没有实现，在C中才有一个方法的实现，也就不存在二义性了。\n2）多重继承会使得类型转换，构造方法的调用顺序变得非常复杂。\n\n\n\n\n\n\n\n\n## 多态\n**操作符**的多态 \n加号+可以作为算数运算，也可以作为字符串连接。不同情境下，具备不同的作用\n如果+号两侧都是整型，那么+代表数字**相加**\n如果+号两侧，任意一个是字符串，那么+代表**字符串连接**\n\n**类**的多态 比如**父类的引用指向子类的对象**、重写。\n\n\n<u>下面程序的运行结果是？</u>\n```\nclass Base\n{\n    int num = 1;\n    public Base(){\n        this.print();\n        num=2;\n    }\n    public void print(){\n        System.out.println(\"Base.num=\"+num);\n    }\n}\nclass Sub extends Base{\n    int num= 3;\n    public Sub(){\n        this.print();\n        num=4;\n    }\n    public void print(){\n        System.out.println(\"Sub.num=\"+num);\n   }\n}\npublic class Test1 {\n  public static void main(String[] args)\n  {\n      Base b = new Sub();\n      System.out.println(b.num);\n  }\n}\n```\n\n在执行语句 Base b= new Sub时,会首先调用父类的构造方法。**根据多态的特性,此时实例化的是sub类的对象,因此,base构造方法会调用Sub类的print()方法。由于此时Sub类中的初始化代码 Int num=3还没有执行,num的默认值为0,输出为 Sub num=0。** 下一条语句父类num初始化为2。\n然后会调用子类的构造方法,根据初始化的顺序可知在调用子类构造方法时,非静态的变量会先执行初始化动作,所以,此时子类Sub的mum值为3,因此,调用 print方法会输出 Sub num=3。\n接着输出b.num,由于b的类型为Base,**而属性没有多态的概念**因此,此时会输出父类中的mm值:2\n程序的运行结果如下：\nSub.num=0\nSub.num=3\n2\n\n题目总结：1.当父类的引用指向子类的对象时，会先初始化父类。\n2.如果子类重写某方法，不管父类子类都是调用子类方法。\n3.属性没有多态的概念。\n\n\n\n## 其他\n### java初始化原则\n### 对象属性初始化方法有3种\n1. 声明该属性的时候初始化 \n2. 构造方法中初始化\n3. 初始化块\n\n如果同时初始化同一变量，则优先级是：构造方法中初始化>初始化块> 声明该属性的时候初始化 \n\n静态成员变量>成员变量>构造方法。\n1静态变量优先与非静态变量\n2父类优先于子类\n3按照成员变量定义的顺序。\n父子类的初始化执行顺序如下：\n父类静态变量，父类静态代码块\n子类静态变量，子类静态代码块\n父类非静态变量，父类非静态代码块，父类构造方法\n子类非静态变量，子类非静态代码块和子类构造函数。\n\n    \n### this关键字\n this关键字代表自身实例\n```\n //参数名和属性名一样\n    //在方法体中，只能访问到参数name\n    public void setName1(String name){\n        name = name;\n    }\n     \n    //为了避免setName1中的问题，参数名不得不使用其他变量名\n    public void setName2(String heroName){\n        name = heroName;\n    }\n     \n    //通过this访问属性\n    public void setName3(String name){\n        //name代表的是参数name\n        //this.name代表的是属性name\n        this.name = name;\n    }\n```\n### 实参与行参的问题\n<u>猜一猜程序运行结果</u>\n```\npublic class Test {\n\n    public void change(int j, StringBuffer ss1) {\n        j = 100;\n        ss1.append(\"world\");\n    }\n\n    public static void main(String[] args) {\n        int i = 1;\n        StringBuffer s1 = new StringBuffer(\"hello \");\n        Test t = new Test();\n        t.change(i, s1);\n        System.out.println(i);//1处\n        System.out.println(s1);//2处\n    }\n}\n```\n\n\n由于i是基本类型，因此参数是**按值**传递。**会创建一个i的副本**。把这个副本作为参数赋值给j。既然j是i的副本，那么对副本的任何修改都不会对i有影响。因此1处输出1。\n由于StringBuffer是一个类，因此是按**引用**传递。当ss1修改的时候。由于实参s1和形参ss1指向的是同一块储存空间，因此ss1修改了值之后，s1指向的字符串也被修改了。因此2处输出hello world。\n那么，下面程序运行结果又是什么\n```\n\npublic class Test {\n\n    public void change(StringBuffer ss1) {\n       ss1 = new StringBuffer(\"world\");\n    }\n\n   public static void main(String[] args) {\n   StringBuffer s1 = new StringBuffer(\"hello \");\n        Test t = new Test();\n        t.change(s1);\n        System.out.println(s1);\n    }}\n```\n\n\n由于StringBuffer是一个类，因此是按引用传递。**但是**这里的change方法不是对\"hello \"进行修改，而是使形参ss1的指向另一个字符串 “world”。而对形参ss1的改变对实参s1没有影响，实参s1仍然指向 \"hello \"。\n\n<u>引用就是指针吗？</u>\n不是，二者不能等同。虽然java引用在底层是通过指针实现的，但指针可以执行比较运算和整数的加减运算，而引用却不行。\n\n\n\n\n\n### 关键字 final\n修饰变量时，用以定义常量；\n修饰方法时，方法不能被重写（Override）；\n修饰类时，类不能被继承。\n\n\n# 变量、数组、循环\n## 变量\n变量的范围\n1.变量声明在类下，叫做**字段**或者**属性**或者**成员变量**\n2.变量声明在一个方法上的，就叫做**参数**或者**局部变量**\n \n数据类型    \n八种基本类型(二进制位数)： \n 整型 4种： byte（8位）、short（16位）、int（32位）、long（64位）\n 浮点型 2种： float（32位）、double （64位）\n 字符型 1种： char（16位）\n 布尔型 1种：boolean（1位）\n \n 现在问题来了\n \n\n\n<u>问：int和integer的区别？</u>\n答：1)int默认值为0。而integer默认值为null。由此可见,证int无法区分未赋值与赋值为0的情况,而integer却可以区分这两种情况。\n2)int是是值传递。而integer是引用传递\n3)int只能用来运算,而integer提供了很多有用的方法\n4)当需要往容器(例如List)里存放整数时,无法直接存放int,因为List里面放的都是对象,所以,在这种情况下只能使用 Integer\n\n<u>问：char型变量中能不能存贮一个中文汉字?为什么?</u>\n答：char是16位的，占两个字节\n汉字通常使用GBK或者UNICODE编码，也是使用两个字节，可以正常存放汉字。如果是utf-8编码，一个中文占三个字节，编译不会报错。但运行会报error“未结束的字符文字”\n\n\n<u>问：请解释这三条语句的输出</u>\n```\n  System.out.println((byte)127);//127\nSystem.out.println((byte)128);//-128\nSystem.out.println((byte)129);//-127\n```\n答：byte的取值是{-128,127},如果把128强制转换成byte已结超出了byte范围，此时会溢出，相当于最小的负数-128.而129强转后就是-127\n\n\n<u>问：请解释这条语句的输出</u>\n```\nSystem.out.println(Math.min(Double.MIN_VALUE,0.0));//输出0.0\n```\n答：对于Double来说MIN_VALUE并不是取值范围的最小数，而是正数范围的最小数，也就是最接近于0的正数。最接近于0的正数和0比起来，当然是0小。\n\n\n\n<u>问：在java里调用什么方法能把二进制数转化为十进制？</u>\n答：\n```\nSystem.out.println(Integer.valueOf(\"11101\",2));\n```\n\n\n### 类型转换\n#### 强制转换   \n```\nint i1 = 10;\nbyte b = (byte) i1;\n```\n\n\n#### 自动装箱和拆箱\n把基本数据类型和对应的包装类之间转换。比如int和Integer。\n```\nInteger i = 100;  //自动装箱，编译器执行Integer.valueOf(100)\nint j = i;        //自动拆箱，编译器执行i.intValue()\n```\n\n\n\n#### ==与equals()\n==比较的是两个对象的引用是否相同，或者是比较原始数据类型是否相等；\nequals()比较的是两个对象的内容是否相同。\n\n### 关于变量的题目\n\n<u> 题目一：解释为何行3编译错误，而行4编译正确</u>\n```\n        byte b1 = 3;\n        byte b2 = 4;\n        byte b3 = b1 + b2;                //编译错误\n        byte b4 = 3 + 4;                //编译正确\n//（1）变量相加，首先首先进行类型提升，之后再进行计算，计算后将结果赋值；\n//（2）常量相加，首先进行计算，之后判断是否在接受类型的范围，在则赋值。\n```\n \n\n\n<u>\n题目二：判断下列代码是否有误，并指出错误</u>\n``` \n        short s = 1;\n        s = s + 1;                //错误，s在参加运算时会自动提示类型为int。int类型值无法直接赋值于short类型\n        \n        short z = 1;\n        z += 1;                //正确,扩展赋值运算符包含强制类型转换。等价于 z = (short)(z + 1);\n//还有，-128~127的Integer值可以从缓存中取得。其他情况要重新创建\n```\n\n\n\n<u>题目三，int i = 1;i+=++i;的运算结果？</u>\ni+=++i,其中先算++i,得到2\n由于++i并未进行赋值，所以i还是1\n1+=2结果为3\n\n\n## 数组\n一维数组的3种创建方式\n```\nint[] arr1 = {1,2,3,4};             //正确\nint[] arr2 = new int[4];            //正确\nint[] arr3 = new int[]{1,2,3,4};    //正确\nint[] arr4 = new int[4]{1,2,3,4};  //错误，编译不通过\n```\n\n二维数组的3种声明方式\n```\nint arr1[][];\nint [][]arr2;\nint []arr3[];\n```\n与C/C++不同的是，java的二维数组允许第二维的长度可以不同。\n## 循环\n### for循环\n<u>写出下面程序运行结果</u>\n```\npublic class Test {\n\n   static boolean p(char c) {\n       System.out.print(c);\n       return true;\n    }\n\n    public static void main(String[] args) {\n       int i=0;\n        for (p('a'); p('b')&&i<2; p('c')) {//for(表达式1;表达式2;表达式3){循环体]\n            p('d');\n            i++; } }}\n```\n\n因为，1.初始化只会执行一次2.先执行循环体后执行for循环的表达式3\n所以答案是：abdcbdcb\n\n### switch\n```\n switch(day){\n            case 1:\n                System.out.println(\"星期一\");\n                break;\n            case 2:\n                System.out.println(\"星期二\");\n                break;\n            case 3:\n                System.out.println(\"星期三\");\n                break;\n            case 4:\n                System.out.println(\"星期四\");\n                break;\n            case 5:\n                System.out.println(\"星期五\");\n                break;\n            case 6:\n                System.out.println(\"星期六\");\n                break;\n            case 7:\n                System.out.println(\"星期天\");\n                break;\n            default:\n                System.out.println(\"输入有误\");\n        }\n```\n**使用switch特别注意，必须在case语句后加break **   \n\n### 枚举\n```\npublic enum Season {//是枚举enum不是类class\n            SPRING, SUMMER, AUTUMN, WINTER;//直接这样写\n\n            public static void main(String[] args) {\n                Season season = Season.SPRING;\n                switch (season) {\n                    case SPRING:\n                        System.out.println(\"春天\");\n                        break;\n                    case SUMMER:\n                        System.out.println(\"夏天\");\n                        break;\n                    case AUTUMN:\n                        System.out.println(\"秋天\");\n                        break;\n                    case WINTER:\n                        System.out.println(\"冬天\");\n                        break;\n                }}}\n```\n\n#### 如何跳出多重循环？\n在外部循环的前一行，加上自定义标签，比如 out:\n在break的时候使用该标签。break out;\n\n\n\n\n# 内部类\n\n## 非静态内部类\n可以被看作外部类的一个成员（与类的属性和方法类似）\n1可以自由的引用外部类的属性和方法。2外部类被实例化之后，内部类才能被实例化。3不能有静态成员。\n\n```\npublic class Hero {//英雄类\n    private String name; \n    float hp; \n    // 非静态内部类，只有一个外部类对象存在的时候，才有意义\n    // 比如战斗成绩只有在一个英雄对象存在的时候才有意义\n    \n    class BattleScore {//战斗成绩类\n        int kill;\n\n        public void legendary() {\n            if (kill >= 8)\n                System.out.println(name + \"超神！\");\n            else\n                System.out.println(name + \"尚未超神！\");\n        }\n    }\n \n    public static void main(String[] args) {\n        Hero garen = new Hero();\n        garen.name = \"盖伦\";\n        \n        // BattleScore对象只有在一个英雄对象存在的时候才有意义\n        BattleScore score = garen.new BattleScore();// 所以其实例化必须建立在一个外部类对象的基础之上\n                                                    \n        score.kill = 9;\n        score.legendary();\n    }\n \n}\n```\n\n## 静态内部类。\n1不能访问外部类普通成员，只能访问外部内中静态成员和静态方法。\n2可以不依赖于外部类实例化而实例化。\n3不可以与外部类同名。\n## 局部内部类\n是指定义在一个代码块内的类，不可以被修饰符修饰。\n## 匿名内部类\n是一种没有类名的内部类，不使用关键字class、extends、implement，没有构造方法，必须继承类或其他接口。一般用于gui编程中事件处理。\n\n```\npublic abstract class Hero{\n\n    public abstract void attack();\n\n    public static void main(String[] args) {\n        Hero h = new Hero(){\n            //当场实现attack方法\n            public void attack() {\n                System.out.println(\"新的进攻手段\");\n            }\n        };\n        h.attack();\n        //通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名\n        System.out.println(h);\n    }}\n\n\n```\n\n\n# 字符串\n\n\n\n## 格式化\n%s 表示字符串\n%d 表示数字\n%n 表示换行\n```\n        String name =\"盖伦\";\n        int kill = 8;\n        String title=\"超神\";\n         \n        String sentenceFormat =\"%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n\";\n        //使用printf格式化输出\n        System.out.printf(sentenceFormat,name,kill,title);//第一个是原字符串\n```\n\n## StringBuffer追加 删除 插入 反转\n```\nString str1 = \"let there \";\nStringBuffer sb = new StringBuffer(str1); //根据str1创建一个StringBuffer对象\nsb.append(\"be light\"); //在最后追加\nsb.delete(4, 10);//删除4-10之间的字符\nsb.insert(4, \"there \");//在4这个位置插入 there\nsb.reverse(); //反转\n```\n\n## 字符串的转化\n\n### 数字与字符串\n- 数字转字符串\n方法1： 使用String类的静态方法valueOf \nString str = String.valueOf(i);\n方法2： 先把基本类型装箱为对象，然后调用对象的toString\nInteger it = i;\nString str2 = it.toString();\n\n\n- 字符串转数字\nString str = \"999\";\nint i= Integer.parseInt(str);\n\n### 字符串与字符串数组\n- 字符数组 转 字符串\nchar[] data={'a','b','c'};\nString s=new String(data);\n\n字符数组转换成字符串\n```\nchar[]   data={'a','b','c'};   \nString  s=new   String(data);\n```\n\n\ns1.charAt(0)=c1;是不行的\ns1.charAt(0);是可以的\n\n## 字符串是否相等的提问\n问：1和2处分别输出什么?\n```\n        String str1 = \"the light\";\n        String str2 = new String(str1);\n        System.out.println( str1  ==  str2);//1\n       String str4 = new String(\"the light\");//2\n\n        String str3 = \"the light\";\n        String str4 = \"the light\";\n        System.out.println( str4  ==  str3);//3\n```\n答：1输出false。因为new String会为str2开辟一个新的区域.\n2输出true。因为str3创建了一个新的字符串\"the light\"，在str4编译器发现已经存在现成的\"the light\"，那么就直接拿来使用，而没有进行重复创建\n# 时间\n## 格式化时间\n时间（注意月和小时是大写的喔）\n\ny 代表年\nM 代表月\nd 代表日\nH 代表24进制的小时\nh 代表12进制的小时\nm 代表分钟\ns 代表秒\nS 代表毫秒\n```\nDate d = new Date();\nSystem.out.println(d);//输出当前时间\nSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日,HH时mm分ss秒\");//设置样式\nString s = sdf.format(d);//把d这个时间实例格式化，并且赋值给字符串s\nSystem.out.println(s);//输出的字符串s就是格式化好的时间啦\n```\n\n\n## 日历（可以做“查看明年的今天是几号”之类的事）\n```\nCalendar c = Calendar.getInstance();//Calendar用单例模式创造实例\nDate now = c.getTime();\n\nc.setTime(now);\n//先翻到下下个月\nc.add(Calendar.MONTH,2);\n//设置到月初\nc.set(Calendar.DATE,1);\n//再往回翻3天\nc.add(Calendar.DATE,-3);\n\nSystem.out.println(\"下个月的倒数第3天是哪天\"+s);\n```\n\n# 一些基础但不重要的知识\n- 变量名起名规则\n    1. 字母 数字 $ _ 组成\n    2. 变量第一个字符，不能使用数字。\n    3. 不可以使用关键字。\n为什么不重要？\n起名的时候选择有意义描述性的词比如“toString”\"getFlow\"，不要用关键字。起名规则无需死记硬背。","slug":"javaSE上","published":1,"updated":"2022-02-08T07:09:41.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qk3000fw9rp7tqrnly8","content":"<h1 id=\"封装、继承、多态\"><a href=\"#封装、继承、多态\" class=\"headerlink\" title=\"封装、继承、多态\"></a>封装、继承、多态</h1><h2 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h2><p>访问修饰权限：<br>private（私有）, default（同一包）, public（共有）, protected（同一包和子孙类）<br>如果不写修饰符默认用default（package/friendly）修饰。<br><strong>default和protected区别：protected能访问子孙类，default不能。</strong><br><strong>会被子类继承的方法，通常使用protected</strong></p>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>接口和抽象类的主要区别？<br>从概念上来说<br>抽象类是一种对<strong>事物的抽象</strong>，而接口就像是一种约定，是一种对<strong>行为</strong>的抽象；<br>抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。<br>抽象类是一种模板式设计，而接口是一种<strong>行为规范</strong>，是一种辐射式设计。</p>\n<p>模板式设计：如果B和C都使用了公共模板A，如果他们的公共部分需要改动，那么只改动A就可以了；<br>辐射式设计：如果B和C都实现了公共接口A，如果现在要向A中添加新的方法，那么B和C都必须进行相应改动。</p>\n<p>区别1：<br><strong>一个类只能继承一个父类。<br>一个类可以实现多个接口</strong></p>\n<p>区别2：<br>抽象类可以定义<br>public,protected,package,private、静态和非静态属性、final和非final属性<br>但是接口中声明的属性，只能是public、静态、final的</p>\n<p>问题：Override(重写)和Overload(重载)的区别?Overload能改变返回值类型吗?</p>\n<p>子类<strong>重写</strong>父类方法：子类的方法名与父类的一样，但是参数类型不一样。<br>重载：<strong>本类</strong>中出现的方法名一样，参数列表不同的方法。<br>与返回值类型无关。</p>\n<p>思考：如果没有重写这样的机制，会发生什么？<br>答：一旦继承了父类，<strong>所有方法都不能修改了</strong>。另外，对象调用方法的时候，先找子类本身的方法，再找父类。(就近原则)</p>\n<p>隐藏，就是子类覆盖父类的<strong>类方法</strong>。（重写是子类覆盖父类的对象方法 ）</p>\n<p>为什么Java语言不支持c++所有的多重继承?<br>多重继承有它的弊端。<br>1)多重继承存在<strong>二义性</strong>。比如，类C同时继承类A和类B,如果类A和类B中都有方法f,那么调用类C的的f方法时,无法确定是调用类A还是类B的方法,将会产生二义性。但是Java语言却可以通过实现多个接口的方式间接地支持多重继承,由于接口只有方法体,没有方法实现,假设类C实现了接口A和接口B，即使AB都有f方法，但接口只有定义没有实现，在C中才有一个方法的实现，也就不存在二义性了。<br>2）多重继承会使得类型转换，构造方法的调用顺序变得非常复杂。</p>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p><strong>操作符</strong>的多态<br>加号+可以作为算数运算，也可以作为字符串连接。不同情境下，具备不同的作用<br>如果+号两侧都是整型，那么+代表数字<strong>相加</strong><br>如果+号两侧，任意一个是字符串，那么+代表<strong>字符串连接</strong></p>\n<p><strong>类</strong>的多态 比如<strong>父类的引用指向子类的对象</strong>、重写。</p>\n<p><u>下面程序的运行结果是？</u><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int num = 1;</span><br><span class=\"line\">    public Base()&#123;</span><br><span class=\"line\">        this.print();</span><br><span class=\"line\">        num=2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void print()&#123;</span><br><span class=\"line\">        System.out.println(&quot;Base.num=&quot;+num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Sub extends Base&#123;</span><br><span class=\"line\">    int num= 3;</span><br><span class=\"line\">    public Sub()&#123;</span><br><span class=\"line\">        this.print();</span><br><span class=\"line\">        num=4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void print()&#123;</span><br><span class=\"line\">        System.out.println(&quot;Sub.num=&quot;+num);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Test1 &#123;</span><br><span class=\"line\">  public static void main(String[] args)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      Base b = new Sub();</span><br><span class=\"line\">      System.out.println(b.num);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在执行语句 Base b= new Sub时,会首先调用父类的构造方法。<strong>根据多态的特性,此时实例化的是sub类的对象,因此,base构造方法会调用Sub类的print()方法。由于此时Sub类中的初始化代码 Int num=3还没有执行,num的默认值为0,输出为 Sub num=0。</strong> 下一条语句父类num初始化为2。<br>然后会调用子类的构造方法,根据初始化的顺序可知在调用子类构造方法时,非静态的变量会先执行初始化动作,所以,此时子类Sub的mum值为3,因此,调用 print方法会输出 Sub num=3。<br>接着输出b.num,由于b的类型为Base,<strong>而属性没有多态的概念</strong>因此,此时会输出父类中的mm值:2<br>程序的运行结果如下：<br>Sub.num=0<br>Sub.num=3<br>2</p>\n<p>题目总结：1.当父类的引用指向子类的对象时，会先初始化父类。<br>2.如果子类重写某方法，不管父类子类都是调用子类方法。<br>3.属性没有多态的概念。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"java初始化原则\"><a href=\"#java初始化原则\" class=\"headerlink\" title=\"java初始化原则\"></a>java初始化原则</h3><h3 id=\"对象属性初始化方法有3种\"><a href=\"#对象属性初始化方法有3种\" class=\"headerlink\" title=\"对象属性初始化方法有3种\"></a>对象属性初始化方法有3种</h3><ol>\n<li>声明该属性的时候初始化 </li>\n<li>构造方法中初始化</li>\n<li>初始化块</li>\n</ol>\n<p>如果同时初始化同一变量，则优先级是：构造方法中初始化&gt;初始化块&gt; 声明该属性的时候初始化 </p>\n<p>静态成员变量&gt;成员变量&gt;构造方法。<br>1静态变量优先与非静态变量<br>2父类优先于子类<br>3按照成员变量定义的顺序。<br>父子类的初始化执行顺序如下：<br>父类静态变量，父类静态代码块<br>子类静态变量，子类静态代码块<br>父类非静态变量，父类非静态代码块，父类构造方法<br>子类非静态变量，子类非静态代码块和子类构造函数。</p>\n<h3 id=\"this关键字\"><a href=\"#this关键字\" class=\"headerlink\" title=\"this关键字\"></a>this关键字</h3><p> this关键字代表自身实例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//参数名和属性名一样</span><br><span class=\"line\">   //在方法体中，只能访问到参数name</span><br><span class=\"line\">   public void setName1(String name)&#123;</span><br><span class=\"line\">       name = name;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">   //为了避免setName1中的问题，参数名不得不使用其他变量名</span><br><span class=\"line\">   public void setName2(String heroName)&#123;</span><br><span class=\"line\">       name = heroName;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">   //通过this访问属性</span><br><span class=\"line\">   public void setName3(String name)&#123;</span><br><span class=\"line\">       //name代表的是参数name</span><br><span class=\"line\">       //this.name代表的是属性name</span><br><span class=\"line\">       this.name = name;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"实参与行参的问题\"><a href=\"#实参与行参的问题\" class=\"headerlink\" title=\"实参与行参的问题\"></a>实参与行参的问题</h3><p><u>猜一猜程序运行结果</u><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void change(int j, StringBuffer ss1) &#123;</span><br><span class=\"line\">        j = 100;</span><br><span class=\"line\">        ss1.append(&quot;world&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int i = 1;</span><br><span class=\"line\">        StringBuffer s1 = new StringBuffer(&quot;hello &quot;);</span><br><span class=\"line\">        Test t = new Test();</span><br><span class=\"line\">        t.change(i, s1);</span><br><span class=\"line\">        System.out.println(i);//1处</span><br><span class=\"line\">        System.out.println(s1);//2处</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于i是基本类型，因此参数是<strong>按值</strong>传递。<strong>会创建一个i的副本</strong>。把这个副本作为参数赋值给j。既然j是i的副本，那么对副本的任何修改都不会对i有影响。因此1处输出1。<br>由于StringBuffer是一个类，因此是按<strong>引用</strong>传递。当ss1修改的时候。由于实参s1和形参ss1指向的是同一块储存空间，因此ss1修改了值之后，s1指向的字符串也被修改了。因此2处输出hello world。<br>那么，下面程序运行结果又是什么<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class Test &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void change(StringBuffer ss1) &#123;</span><br><span class=\"line\">       ss1 = new StringBuffer(&quot;world&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   public static void main(String[] args) &#123;</span><br><span class=\"line\">   StringBuffer s1 = new StringBuffer(&quot;hello &quot;);</span><br><span class=\"line\">        Test t = new Test();</span><br><span class=\"line\">        t.change(s1);</span><br><span class=\"line\">        System.out.println(s1);</span><br><span class=\"line\">    &#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于StringBuffer是一个类，因此是按引用传递。<strong>但是</strong>这里的change方法不是对”hello “进行修改，而是使形参ss1的指向另一个字符串 “world”。而对形参ss1的改变对实参s1没有影响，实参s1仍然指向 “hello “。</p>\n<p><u>引用就是指针吗？</u><br>不是，二者不能等同。虽然java引用在底层是通过指针实现的，但指针可以执行比较运算和整数的加减运算，而引用却不行。</p>\n<h3 id=\"关键字-final\"><a href=\"#关键字-final\" class=\"headerlink\" title=\"关键字 final\"></a>关键字 final</h3><p>修饰变量时，用以定义常量；<br>修饰方法时，方法不能被重写（Override）；<br>修饰类时，类不能被继承。</p>\n<h1 id=\"变量、数组、循环\"><a href=\"#变量、数组、循环\" class=\"headerlink\" title=\"变量、数组、循环\"></a>变量、数组、循环</h1><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>变量的范围<br>1.变量声明在类下，叫做<strong>字段</strong>或者<strong>属性</strong>或者<strong>成员变量</strong><br>2.变量声明在一个方法上的，就叫做<strong>参数</strong>或者<strong>局部变量</strong></p>\n<p>数据类型<br>八种基本类型(二进制位数)：<br> 整型 4种： byte（8位）、short（16位）、int（32位）、long（64位）<br> 浮点型 2种： float（32位）、double （64位）<br> 字符型 1种： char（16位）<br> 布尔型 1种：boolean（1位）</p>\n<p> 现在问题来了</p>\n<p><u>问：int和integer的区别？</u><br>答：1)int默认值为0。而integer默认值为null。由此可见,证int无法区分未赋值与赋值为0的情况,而integer却可以区分这两种情况。<br>2)int是是值传递。而integer是引用传递<br>3)int只能用来运算,而integer提供了很多有用的方法<br>4)当需要往容器(例如List)里存放整数时,无法直接存放int,因为List里面放的都是对象,所以,在这种情况下只能使用 Integer</p>\n<p><u>问：char型变量中能不能存贮一个中文汉字?为什么?</u><br>答：char是16位的，占两个字节<br>汉字通常使用GBK或者UNICODE编码，也是使用两个字节，可以正常存放汉字。如果是utf-8编码，一个中文占三个字节，编译不会报错。但运行会报error“未结束的字符文字”</p>\n<p><u>问：请解释这三条语句的输出</u><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  System.out.println((byte)127);//127</span><br><span class=\"line\">System.out.println((byte)128);//-128</span><br><span class=\"line\">System.out.println((byte)129);//-127</span><br></pre></td></tr></table></figure></p>\n<p>答：byte的取值是{-128,127},如果把128强制转换成byte已结超出了byte范围，此时会溢出，相当于最小的负数-128.而129强转后就是-127</p>\n<p><u>问：请解释这条语句的输出</u><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(Math.min(Double.MIN_VALUE,0.0));//输出0.0</span><br></pre></td></tr></table></figure></p>\n<p>答：对于Double来说MIN_VALUE并不是取值范围的最小数，而是正数范围的最小数，也就是最接近于0的正数。最接近于0的正数和0比起来，当然是0小。</p>\n<p><u>问：在java里调用什么方法能把二进制数转化为十进制？</u><br>答：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(Integer.valueOf(&quot;11101&quot;,2));</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><h4 id=\"强制转换\"><a href=\"#强制转换\" class=\"headerlink\" title=\"强制转换\"></a>强制转换</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i1 = 10;</span><br><span class=\"line\">byte b = (byte) i1;</span><br></pre></td></tr></table></figure>\n<h4 id=\"自动装箱和拆箱\"><a href=\"#自动装箱和拆箱\" class=\"headerlink\" title=\"自动装箱和拆箱\"></a>自动装箱和拆箱</h4><p>把基本数据类型和对应的包装类之间转换。比如int和Integer。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i = 100;  //自动装箱，编译器执行Integer.valueOf(100)</span><br><span class=\"line\">int j = i;        //自动拆箱，编译器执行i.intValue()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"与equals\"><a href=\"#与equals\" class=\"headerlink\" title=\"==与equals()\"></a>==与equals()</h4><p>==比较的是两个对象的引用是否相同，或者是比较原始数据类型是否相等；<br>equals()比较的是两个对象的内容是否相同。</p>\n<h3 id=\"关于变量的题目\"><a href=\"#关于变量的题目\" class=\"headerlink\" title=\"关于变量的题目\"></a>关于变量的题目</h3><p><u> 题目一：解释为何行3编译错误，而行4编译正确</u><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        byte b1 = 3;</span><br><span class=\"line\">        byte b2 = 4;</span><br><span class=\"line\">        byte b3 = b1 + b2;                //编译错误</span><br><span class=\"line\">        byte b4 = 3 + 4;                //编译正确</span><br><span class=\"line\">//（1）变量相加，首先首先进行类型提升，之后再进行计算，计算后将结果赋值；</span><br><span class=\"line\">//（2）常量相加，首先进行计算，之后判断是否在接受类型的范围，在则赋值。</span><br></pre></td></tr></table></figure></p>\n<p><u><br>题目二：判断下列代码是否有误，并指出错误</u><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        short s = 1;</span><br><span class=\"line\">        s = s + 1;                //错误，s在参加运算时会自动提示类型为int。int类型值无法直接赋值于short类型</span><br><span class=\"line\">        </span><br><span class=\"line\">        short z = 1;</span><br><span class=\"line\">        z += 1;                //正确,扩展赋值运算符包含强制类型转换。等价于 z = (short)(z + 1);</span><br><span class=\"line\">//还有，-128~127的Integer值可以从缓存中取得。其他情况要重新创建</span><br></pre></td></tr></table></figure></p>\n<p><u>题目三，int i = 1;i+=++i;的运算结果？</u><br>i+=++i,其中先算++i,得到2<br>由于++i并未进行赋值，所以i还是1<br>1+=2结果为3</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>一维数组的3种创建方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int[] arr1 = &#123;1,2,3,4&#125;;             //正确</span><br><span class=\"line\">int[] arr2 = new int[4];            //正确</span><br><span class=\"line\">int[] arr3 = new int[]&#123;1,2,3,4&#125;;    //正确</span><br><span class=\"line\">int[] arr4 = new int[4]&#123;1,2,3,4&#125;;  //错误，编译不通过</span><br></pre></td></tr></table></figure></p>\n<p>二维数组的3种声明方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int arr1[][];</span><br><span class=\"line\">int [][]arr2;</span><br><span class=\"line\">int []arr3[];</span><br></pre></td></tr></table></figure></p>\n<p>与C/C++不同的是，java的二维数组允许第二维的长度可以不同。</p>\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><h3 id=\"for循环\"><a href=\"#for循环\" class=\"headerlink\" title=\"for循环\"></a>for循环</h3><p><u>写出下面程序运行结果</u><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   static boolean p(char c) &#123;</span><br><span class=\"line\">       System.out.print(c);</span><br><span class=\"line\">       return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">       int i=0;</span><br><span class=\"line\">        for (p(&apos;a&apos;); p(&apos;b&apos;)&amp;&amp;i&lt;2; p(&apos;c&apos;)) &#123;//for(表达式1;表达式2;表达式3)&#123;循环体]</span><br><span class=\"line\">            p(&apos;d&apos;);</span><br><span class=\"line\">            i++; &#125; &#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为，1.初始化只会执行一次2.先执行循环体后执行for循环的表达式3<br>所以答案是：abdcbdcb</p>\n<h3 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(day)&#123;</span><br><span class=\"line\">           case 1:</span><br><span class=\"line\">               System.out.println(&quot;星期一&quot;);</span><br><span class=\"line\">               break;</span><br><span class=\"line\">           case 2:</span><br><span class=\"line\">               System.out.println(&quot;星期二&quot;);</span><br><span class=\"line\">               break;</span><br><span class=\"line\">           case 3:</span><br><span class=\"line\">               System.out.println(&quot;星期三&quot;);</span><br><span class=\"line\">               break;</span><br><span class=\"line\">           case 4:</span><br><span class=\"line\">               System.out.println(&quot;星期四&quot;);</span><br><span class=\"line\">               break;</span><br><span class=\"line\">           case 5:</span><br><span class=\"line\">               System.out.println(&quot;星期五&quot;);</span><br><span class=\"line\">               break;</span><br><span class=\"line\">           case 6:</span><br><span class=\"line\">               System.out.println(&quot;星期六&quot;);</span><br><span class=\"line\">               break;</span><br><span class=\"line\">           case 7:</span><br><span class=\"line\">               System.out.println(&quot;星期天&quot;);</span><br><span class=\"line\">               break;</span><br><span class=\"line\">           default:</span><br><span class=\"line\">               System.out.println(&quot;输入有误&quot;);</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>使用switch特别注意，必须在case语句后加break </strong>   </p>\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Season &#123;//是枚举enum不是类class</span><br><span class=\"line\">            SPRING, SUMMER, AUTUMN, WINTER;//直接这样写</span><br><span class=\"line\"></span><br><span class=\"line\">            public static void main(String[] args) &#123;</span><br><span class=\"line\">                Season season = Season.SPRING;</span><br><span class=\"line\">                switch (season) &#123;</span><br><span class=\"line\">                    case SPRING:</span><br><span class=\"line\">                        System.out.println(&quot;春天&quot;);</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case SUMMER:</span><br><span class=\"line\">                        System.out.println(&quot;夏天&quot;);</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case AUTUMN:</span><br><span class=\"line\">                        System.out.println(&quot;秋天&quot;);</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case WINTER:</span><br><span class=\"line\">                        System.out.println(&quot;冬天&quot;);</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"如何跳出多重循环？\"><a href=\"#如何跳出多重循环？\" class=\"headerlink\" title=\"如何跳出多重循环？\"></a>如何跳出多重循环？</h4><p>在外部循环的前一行，加上自定义标签，比如 out:<br>在break的时候使用该标签。break out;</p>\n<h1 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h1><h2 id=\"非静态内部类\"><a href=\"#非静态内部类\" class=\"headerlink\" title=\"非静态内部类\"></a>非静态内部类</h2><p>可以被看作外部类的一个成员（与类的属性和方法类似）<br>1可以自由的引用外部类的属性和方法。2外部类被实例化之后，内部类才能被实例化。3不能有静态成员。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Hero &#123;//英雄类</span><br><span class=\"line\">    private String name; </span><br><span class=\"line\">    float hp; </span><br><span class=\"line\">    // 非静态内部类，只有一个外部类对象存在的时候，才有意义</span><br><span class=\"line\">    // 比如战斗成绩只有在一个英雄对象存在的时候才有意义</span><br><span class=\"line\">    </span><br><span class=\"line\">    class BattleScore &#123;//战斗成绩类</span><br><span class=\"line\">        int kill;</span><br><span class=\"line\"></span><br><span class=\"line\">        public void legendary() &#123;</span><br><span class=\"line\">            if (kill &gt;= 8)</span><br><span class=\"line\">                System.out.println(name + &quot;超神！&quot;);</span><br><span class=\"line\">            else</span><br><span class=\"line\">                System.out.println(name + &quot;尚未超神！&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Hero garen = new Hero();</span><br><span class=\"line\">        garen.name = &quot;盖伦&quot;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // BattleScore对象只有在一个英雄对象存在的时候才有意义</span><br><span class=\"line\">        BattleScore score = garen.new BattleScore();// 所以其实例化必须建立在一个外部类对象的基础之上</span><br><span class=\"line\">                                                    </span><br><span class=\"line\">        score.kill = 9;</span><br><span class=\"line\">        score.legendary();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"静态内部类。\"><a href=\"#静态内部类。\" class=\"headerlink\" title=\"静态内部类。\"></a>静态内部类。</h2><p>1不能访问外部类普通成员，只能访问外部内中静态成员和静态方法。<br>2可以不依赖于外部类实例化而实例化。<br>3不可以与外部类同名。</p>\n<h2 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h2><p>是指定义在一个代码块内的类，不可以被修饰符修饰。</p>\n<h2 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h2><p>是一种没有类名的内部类，不使用关键字class、extends、implement，没有构造方法，必须继承类或其他接口。一般用于gui编程中事件处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class Hero&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public abstract void attack();</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Hero h = new Hero()&#123;</span><br><span class=\"line\">            //当场实现attack方法</span><br><span class=\"line\">            public void attack() &#123;</span><br><span class=\"line\">                System.out.println(&quot;新的进攻手段&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        h.attack();</span><br><span class=\"line\">        //通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名</span><br><span class=\"line\">        System.out.println(h);</span><br><span class=\"line\">    &#125;&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h1><h2 id=\"格式化\"><a href=\"#格式化\" class=\"headerlink\" title=\"格式化\"></a>格式化</h2><p>%s 表示字符串<br>%d 表示数字<br>%n 表示换行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String name =&quot;盖伦&quot;;</span><br><span class=\"line\">int kill = 8;</span><br><span class=\"line\">String title=&quot;超神&quot;;</span><br><span class=\"line\"> </span><br><span class=\"line\">String sentenceFormat =&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;;</span><br><span class=\"line\">//使用printf格式化输出</span><br><span class=\"line\">System.out.printf(sentenceFormat,name,kill,title);//第一个是原字符串</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"StringBuffer追加-删除-插入-反转\"><a href=\"#StringBuffer追加-删除-插入-反转\" class=\"headerlink\" title=\"StringBuffer追加 删除 插入 反转\"></a>StringBuffer追加 删除 插入 反转</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 = &quot;let there &quot;;</span><br><span class=\"line\">StringBuffer sb = new StringBuffer(str1); //根据str1创建一个StringBuffer对象</span><br><span class=\"line\">sb.append(&quot;be light&quot;); //在最后追加</span><br><span class=\"line\">sb.delete(4, 10);//删除4-10之间的字符</span><br><span class=\"line\">sb.insert(4, &quot;there &quot;);//在4这个位置插入 there</span><br><span class=\"line\">sb.reverse(); //反转</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串的转化\"><a href=\"#字符串的转化\" class=\"headerlink\" title=\"字符串的转化\"></a>字符串的转化</h2><h3 id=\"数字与字符串\"><a href=\"#数字与字符串\" class=\"headerlink\" title=\"数字与字符串\"></a>数字与字符串</h3><ul>\n<li>数字转字符串<br>方法1： 使用String类的静态方法valueOf<br>String str = String.valueOf(i);<br>方法2： 先把基本类型装箱为对象，然后调用对象的toString<br>Integer it = i;<br>String str2 = it.toString();</li>\n</ul>\n<ul>\n<li>字符串转数字<br>String str = “999”;<br>int i= Integer.parseInt(str);</li>\n</ul>\n<h3 id=\"字符串与字符串数组\"><a href=\"#字符串与字符串数组\" class=\"headerlink\" title=\"字符串与字符串数组\"></a>字符串与字符串数组</h3><ul>\n<li>字符数组 转 字符串<br>char[] data={‘a’,’b’,’c’};<br>String s=new String(data);</li>\n</ul>\n<p>字符数组转换成字符串<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char[]   data=&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;;   </span><br><span class=\"line\">String  s=new   String(data);</span><br></pre></td></tr></table></figure></p>\n<p>s1.charAt(0)=c1;是不行的<br>s1.charAt(0);是可以的</p>\n<h2 id=\"字符串是否相等的提问\"><a href=\"#字符串是否相等的提问\" class=\"headerlink\" title=\"字符串是否相等的提问\"></a>字符串是否相等的提问</h2><p>问：1和2处分别输出什么?<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> String str1 = &quot;the light&quot;;</span><br><span class=\"line\"> String str2 = new String(str1);</span><br><span class=\"line\"> System.out.println( str1  ==  str2);//1</span><br><span class=\"line\">String str4 = new String(&quot;the light&quot;);//2</span><br><span class=\"line\"></span><br><span class=\"line\"> String str3 = &quot;the light&quot;;</span><br><span class=\"line\"> String str4 = &quot;the light&quot;;</span><br><span class=\"line\"> System.out.println( str4  ==  str3);//3</span><br></pre></td></tr></table></figure></p>\n<p>答：1输出false。因为new String会为str2开辟一个新的区域.<br>2输出true。因为str3创建了一个新的字符串”the light”，在str4编译器发现已经存在现成的”the light”，那么就直接拿来使用，而没有进行重复创建</p>\n<h1 id=\"时间\"><a href=\"#时间\" class=\"headerlink\" title=\"时间\"></a>时间</h1><h2 id=\"格式化时间\"><a href=\"#格式化时间\" class=\"headerlink\" title=\"格式化时间\"></a>格式化时间</h2><p>时间（注意月和小时是大写的喔）</p>\n<p>y 代表年<br>M 代表月<br>d 代表日<br>H 代表24进制的小时<br>h 代表12进制的小时<br>m 代表分钟<br>s 代表秒<br>S 代表毫秒<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Date d = new Date();</span><br><span class=\"line\">System.out.println(d);//输出当前时间</span><br><span class=\"line\">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日,HH时mm分ss秒&quot;);//设置样式</span><br><span class=\"line\">String s = sdf.format(d);//把d这个时间实例格式化，并且赋值给字符串s</span><br><span class=\"line\">System.out.println(s);//输出的字符串s就是格式化好的时间啦</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"日历（可以做“查看明年的今天是几号”之类的事）\"><a href=\"#日历（可以做“查看明年的今天是几号”之类的事）\" class=\"headerlink\" title=\"日历（可以做“查看明年的今天是几号”之类的事）\"></a>日历（可以做“查看明年的今天是几号”之类的事）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Calendar c = Calendar.getInstance();//Calendar用单例模式创造实例</span><br><span class=\"line\">Date now = c.getTime();</span><br><span class=\"line\"></span><br><span class=\"line\">c.setTime(now);</span><br><span class=\"line\">//先翻到下下个月</span><br><span class=\"line\">c.add(Calendar.MONTH,2);</span><br><span class=\"line\">//设置到月初</span><br><span class=\"line\">c.set(Calendar.DATE,1);</span><br><span class=\"line\">//再往回翻3天</span><br><span class=\"line\">c.add(Calendar.DATE,-3);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;下个月的倒数第3天是哪天&quot;+s);</span><br></pre></td></tr></table></figure>\n<h1 id=\"一些基础但不重要的知识\"><a href=\"#一些基础但不重要的知识\" class=\"headerlink\" title=\"一些基础但不重要的知识\"></a>一些基础但不重要的知识</h1><ul>\n<li>变量名起名规则<ol>\n<li>字母 数字 $ _ 组成</li>\n<li>变量第一个字符，不能使用数字。</li>\n<li>不可以使用关键字。<br>为什么不重要？<br>起名的时候选择有意义描述性的词比如“toString””getFlow”，不要用关键字。起名规则无需死记硬背。</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"封装、继承、多态\"><a href=\"#封装、继承、多态\" class=\"headerlink\" title=\"封装、继承、多态\"></a>封装、继承、多态</h1><h2 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h2><p>访问修饰权限：<br>private（私有）, default（同一包）, public（共有）, protected（同一包和子孙类）<br>如果不写修饰符默认用default（package/friendly）修饰。<br><strong>default和protected区别：protected能访问子孙类，default不能。</strong><br><strong>会被子类继承的方法，通常使用protected</strong></p>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>接口和抽象类的主要区别？<br>从概念上来说<br>抽象类是一种对<strong>事物的抽象</strong>，而接口就像是一种约定，是一种对<strong>行为</strong>的抽象；<br>抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。<br>抽象类是一种模板式设计，而接口是一种<strong>行为规范</strong>，是一种辐射式设计。</p>\n<p>模板式设计：如果B和C都使用了公共模板A，如果他们的公共部分需要改动，那么只改动A就可以了；<br>辐射式设计：如果B和C都实现了公共接口A，如果现在要向A中添加新的方法，那么B和C都必须进行相应改动。</p>\n<p>区别1：<br><strong>一个类只能继承一个父类。<br>一个类可以实现多个接口</strong></p>\n<p>区别2：<br>抽象类可以定义<br>public,protected,package,private、静态和非静态属性、final和非final属性<br>但是接口中声明的属性，只能是public、静态、final的</p>\n<p>问题：Override(重写)和Overload(重载)的区别?Overload能改变返回值类型吗?</p>\n<p>子类<strong>重写</strong>父类方法：子类的方法名与父类的一样，但是参数类型不一样。<br>重载：<strong>本类</strong>中出现的方法名一样，参数列表不同的方法。<br>与返回值类型无关。</p>\n<p>思考：如果没有重写这样的机制，会发生什么？<br>答：一旦继承了父类，<strong>所有方法都不能修改了</strong>。另外，对象调用方法的时候，先找子类本身的方法，再找父类。(就近原则)</p>\n<p>隐藏，就是子类覆盖父类的<strong>类方法</strong>。（重写是子类覆盖父类的对象方法 ）</p>\n<p>为什么Java语言不支持c++所有的多重继承?<br>多重继承有它的弊端。<br>1)多重继承存在<strong>二义性</strong>。比如，类C同时继承类A和类B,如果类A和类B中都有方法f,那么调用类C的的f方法时,无法确定是调用类A还是类B的方法,将会产生二义性。但是Java语言却可以通过实现多个接口的方式间接地支持多重继承,由于接口只有方法体,没有方法实现,假设类C实现了接口A和接口B，即使AB都有f方法，但接口只有定义没有实现，在C中才有一个方法的实现，也就不存在二义性了。<br>2）多重继承会使得类型转换，构造方法的调用顺序变得非常复杂。</p>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p><strong>操作符</strong>的多态<br>加号+可以作为算数运算，也可以作为字符串连接。不同情境下，具备不同的作用<br>如果+号两侧都是整型，那么+代表数字<strong>相加</strong><br>如果+号两侧，任意一个是字符串，那么+代表<strong>字符串连接</strong></p>\n<p><strong>类</strong>的多态 比如<strong>父类的引用指向子类的对象</strong>、重写。</p>\n<p><u>下面程序的运行结果是？</u><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int num = 1;</span><br><span class=\"line\">    public Base()&#123;</span><br><span class=\"line\">        this.print();</span><br><span class=\"line\">        num=2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void print()&#123;</span><br><span class=\"line\">        System.out.println(&quot;Base.num=&quot;+num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Sub extends Base&#123;</span><br><span class=\"line\">    int num= 3;</span><br><span class=\"line\">    public Sub()&#123;</span><br><span class=\"line\">        this.print();</span><br><span class=\"line\">        num=4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void print()&#123;</span><br><span class=\"line\">        System.out.println(&quot;Sub.num=&quot;+num);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Test1 &#123;</span><br><span class=\"line\">  public static void main(String[] args)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      Base b = new Sub();</span><br><span class=\"line\">      System.out.println(b.num);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在执行语句 Base b= new Sub时,会首先调用父类的构造方法。<strong>根据多态的特性,此时实例化的是sub类的对象,因此,base构造方法会调用Sub类的print()方法。由于此时Sub类中的初始化代码 Int num=3还没有执行,num的默认值为0,输出为 Sub num=0。</strong> 下一条语句父类num初始化为2。<br>然后会调用子类的构造方法,根据初始化的顺序可知在调用子类构造方法时,非静态的变量会先执行初始化动作,所以,此时子类Sub的mum值为3,因此,调用 print方法会输出 Sub num=3。<br>接着输出b.num,由于b的类型为Base,<strong>而属性没有多态的概念</strong>因此,此时会输出父类中的mm值:2<br>程序的运行结果如下：<br>Sub.num=0<br>Sub.num=3<br>2</p>\n<p>题目总结：1.当父类的引用指向子类的对象时，会先初始化父类。<br>2.如果子类重写某方法，不管父类子类都是调用子类方法。<br>3.属性没有多态的概念。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"java初始化原则\"><a href=\"#java初始化原则\" class=\"headerlink\" title=\"java初始化原则\"></a>java初始化原则</h3><h3 id=\"对象属性初始化方法有3种\"><a href=\"#对象属性初始化方法有3种\" class=\"headerlink\" title=\"对象属性初始化方法有3种\"></a>对象属性初始化方法有3种</h3><ol>\n<li>声明该属性的时候初始化 </li>\n<li>构造方法中初始化</li>\n<li>初始化块</li>\n</ol>\n<p>如果同时初始化同一变量，则优先级是：构造方法中初始化&gt;初始化块&gt; 声明该属性的时候初始化 </p>\n<p>静态成员变量&gt;成员变量&gt;构造方法。<br>1静态变量优先与非静态变量<br>2父类优先于子类<br>3按照成员变量定义的顺序。<br>父子类的初始化执行顺序如下：<br>父类静态变量，父类静态代码块<br>子类静态变量，子类静态代码块<br>父类非静态变量，父类非静态代码块，父类构造方法<br>子类非静态变量，子类非静态代码块和子类构造函数。</p>\n<h3 id=\"this关键字\"><a href=\"#this关键字\" class=\"headerlink\" title=\"this关键字\"></a>this关键字</h3><p> this关键字代表自身实例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//参数名和属性名一样</span><br><span class=\"line\">   //在方法体中，只能访问到参数name</span><br><span class=\"line\">   public void setName1(String name)&#123;</span><br><span class=\"line\">       name = name;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">   //为了避免setName1中的问题，参数名不得不使用其他变量名</span><br><span class=\"line\">   public void setName2(String heroName)&#123;</span><br><span class=\"line\">       name = heroName;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">   //通过this访问属性</span><br><span class=\"line\">   public void setName3(String name)&#123;</span><br><span class=\"line\">       //name代表的是参数name</span><br><span class=\"line\">       //this.name代表的是属性name</span><br><span class=\"line\">       this.name = name;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"实参与行参的问题\"><a href=\"#实参与行参的问题\" class=\"headerlink\" title=\"实参与行参的问题\"></a>实参与行参的问题</h3><p><u>猜一猜程序运行结果</u><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void change(int j, StringBuffer ss1) &#123;</span><br><span class=\"line\">        j = 100;</span><br><span class=\"line\">        ss1.append(&quot;world&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int i = 1;</span><br><span class=\"line\">        StringBuffer s1 = new StringBuffer(&quot;hello &quot;);</span><br><span class=\"line\">        Test t = new Test();</span><br><span class=\"line\">        t.change(i, s1);</span><br><span class=\"line\">        System.out.println(i);//1处</span><br><span class=\"line\">        System.out.println(s1);//2处</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于i是基本类型，因此参数是<strong>按值</strong>传递。<strong>会创建一个i的副本</strong>。把这个副本作为参数赋值给j。既然j是i的副本，那么对副本的任何修改都不会对i有影响。因此1处输出1。<br>由于StringBuffer是一个类，因此是按<strong>引用</strong>传递。当ss1修改的时候。由于实参s1和形参ss1指向的是同一块储存空间，因此ss1修改了值之后，s1指向的字符串也被修改了。因此2处输出hello world。<br>那么，下面程序运行结果又是什么<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class Test &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void change(StringBuffer ss1) &#123;</span><br><span class=\"line\">       ss1 = new StringBuffer(&quot;world&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   public static void main(String[] args) &#123;</span><br><span class=\"line\">   StringBuffer s1 = new StringBuffer(&quot;hello &quot;);</span><br><span class=\"line\">        Test t = new Test();</span><br><span class=\"line\">        t.change(s1);</span><br><span class=\"line\">        System.out.println(s1);</span><br><span class=\"line\">    &#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于StringBuffer是一个类，因此是按引用传递。<strong>但是</strong>这里的change方法不是对”hello “进行修改，而是使形参ss1的指向另一个字符串 “world”。而对形参ss1的改变对实参s1没有影响，实参s1仍然指向 “hello “。</p>\n<p><u>引用就是指针吗？</u><br>不是，二者不能等同。虽然java引用在底层是通过指针实现的，但指针可以执行比较运算和整数的加减运算，而引用却不行。</p>\n<h3 id=\"关键字-final\"><a href=\"#关键字-final\" class=\"headerlink\" title=\"关键字 final\"></a>关键字 final</h3><p>修饰变量时，用以定义常量；<br>修饰方法时，方法不能被重写（Override）；<br>修饰类时，类不能被继承。</p>\n<h1 id=\"变量、数组、循环\"><a href=\"#变量、数组、循环\" class=\"headerlink\" title=\"变量、数组、循环\"></a>变量、数组、循环</h1><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>变量的范围<br>1.变量声明在类下，叫做<strong>字段</strong>或者<strong>属性</strong>或者<strong>成员变量</strong><br>2.变量声明在一个方法上的，就叫做<strong>参数</strong>或者<strong>局部变量</strong></p>\n<p>数据类型<br>八种基本类型(二进制位数)：<br> 整型 4种： byte（8位）、short（16位）、int（32位）、long（64位）<br> 浮点型 2种： float（32位）、double （64位）<br> 字符型 1种： char（16位）<br> 布尔型 1种：boolean（1位）</p>\n<p> 现在问题来了</p>\n<p><u>问：int和integer的区别？</u><br>答：1)int默认值为0。而integer默认值为null。由此可见,证int无法区分未赋值与赋值为0的情况,而integer却可以区分这两种情况。<br>2)int是是值传递。而integer是引用传递<br>3)int只能用来运算,而integer提供了很多有用的方法<br>4)当需要往容器(例如List)里存放整数时,无法直接存放int,因为List里面放的都是对象,所以,在这种情况下只能使用 Integer</p>\n<p><u>问：char型变量中能不能存贮一个中文汉字?为什么?</u><br>答：char是16位的，占两个字节<br>汉字通常使用GBK或者UNICODE编码，也是使用两个字节，可以正常存放汉字。如果是utf-8编码，一个中文占三个字节，编译不会报错。但运行会报error“未结束的字符文字”</p>\n<p><u>问：请解释这三条语句的输出</u><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  System.out.println((byte)127);//127</span><br><span class=\"line\">System.out.println((byte)128);//-128</span><br><span class=\"line\">System.out.println((byte)129);//-127</span><br></pre></td></tr></table></figure></p>\n<p>答：byte的取值是{-128,127},如果把128强制转换成byte已结超出了byte范围，此时会溢出，相当于最小的负数-128.而129强转后就是-127</p>\n<p><u>问：请解释这条语句的输出</u><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(Math.min(Double.MIN_VALUE,0.0));//输出0.0</span><br></pre></td></tr></table></figure></p>\n<p>答：对于Double来说MIN_VALUE并不是取值范围的最小数，而是正数范围的最小数，也就是最接近于0的正数。最接近于0的正数和0比起来，当然是0小。</p>\n<p><u>问：在java里调用什么方法能把二进制数转化为十进制？</u><br>答：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(Integer.valueOf(&quot;11101&quot;,2));</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><h4 id=\"强制转换\"><a href=\"#强制转换\" class=\"headerlink\" title=\"强制转换\"></a>强制转换</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i1 = 10;</span><br><span class=\"line\">byte b = (byte) i1;</span><br></pre></td></tr></table></figure>\n<h4 id=\"自动装箱和拆箱\"><a href=\"#自动装箱和拆箱\" class=\"headerlink\" title=\"自动装箱和拆箱\"></a>自动装箱和拆箱</h4><p>把基本数据类型和对应的包装类之间转换。比如int和Integer。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i = 100;  //自动装箱，编译器执行Integer.valueOf(100)</span><br><span class=\"line\">int j = i;        //自动拆箱，编译器执行i.intValue()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"与equals\"><a href=\"#与equals\" class=\"headerlink\" title=\"==与equals()\"></a>==与equals()</h4><p>==比较的是两个对象的引用是否相同，或者是比较原始数据类型是否相等；<br>equals()比较的是两个对象的内容是否相同。</p>\n<h3 id=\"关于变量的题目\"><a href=\"#关于变量的题目\" class=\"headerlink\" title=\"关于变量的题目\"></a>关于变量的题目</h3><p><u> 题目一：解释为何行3编译错误，而行4编译正确</u><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        byte b1 = 3;</span><br><span class=\"line\">        byte b2 = 4;</span><br><span class=\"line\">        byte b3 = b1 + b2;                //编译错误</span><br><span class=\"line\">        byte b4 = 3 + 4;                //编译正确</span><br><span class=\"line\">//（1）变量相加，首先首先进行类型提升，之后再进行计算，计算后将结果赋值；</span><br><span class=\"line\">//（2）常量相加，首先进行计算，之后判断是否在接受类型的范围，在则赋值。</span><br></pre></td></tr></table></figure></p>\n<p><u><br>题目二：判断下列代码是否有误，并指出错误</u><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        short s = 1;</span><br><span class=\"line\">        s = s + 1;                //错误，s在参加运算时会自动提示类型为int。int类型值无法直接赋值于short类型</span><br><span class=\"line\">        </span><br><span class=\"line\">        short z = 1;</span><br><span class=\"line\">        z += 1;                //正确,扩展赋值运算符包含强制类型转换。等价于 z = (short)(z + 1);</span><br><span class=\"line\">//还有，-128~127的Integer值可以从缓存中取得。其他情况要重新创建</span><br></pre></td></tr></table></figure></p>\n<p><u>题目三，int i = 1;i+=++i;的运算结果？</u><br>i+=++i,其中先算++i,得到2<br>由于++i并未进行赋值，所以i还是1<br>1+=2结果为3</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>一维数组的3种创建方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int[] arr1 = &#123;1,2,3,4&#125;;             //正确</span><br><span class=\"line\">int[] arr2 = new int[4];            //正确</span><br><span class=\"line\">int[] arr3 = new int[]&#123;1,2,3,4&#125;;    //正确</span><br><span class=\"line\">int[] arr4 = new int[4]&#123;1,2,3,4&#125;;  //错误，编译不通过</span><br></pre></td></tr></table></figure></p>\n<p>二维数组的3种声明方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int arr1[][];</span><br><span class=\"line\">int [][]arr2;</span><br><span class=\"line\">int []arr3[];</span><br></pre></td></tr></table></figure></p>\n<p>与C/C++不同的是，java的二维数组允许第二维的长度可以不同。</p>\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><h3 id=\"for循环\"><a href=\"#for循环\" class=\"headerlink\" title=\"for循环\"></a>for循环</h3><p><u>写出下面程序运行结果</u><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   static boolean p(char c) &#123;</span><br><span class=\"line\">       System.out.print(c);</span><br><span class=\"line\">       return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">       int i=0;</span><br><span class=\"line\">        for (p(&apos;a&apos;); p(&apos;b&apos;)&amp;&amp;i&lt;2; p(&apos;c&apos;)) &#123;//for(表达式1;表达式2;表达式3)&#123;循环体]</span><br><span class=\"line\">            p(&apos;d&apos;);</span><br><span class=\"line\">            i++; &#125; &#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为，1.初始化只会执行一次2.先执行循环体后执行for循环的表达式3<br>所以答案是：abdcbdcb</p>\n<h3 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(day)&#123;</span><br><span class=\"line\">           case 1:</span><br><span class=\"line\">               System.out.println(&quot;星期一&quot;);</span><br><span class=\"line\">               break;</span><br><span class=\"line\">           case 2:</span><br><span class=\"line\">               System.out.println(&quot;星期二&quot;);</span><br><span class=\"line\">               break;</span><br><span class=\"line\">           case 3:</span><br><span class=\"line\">               System.out.println(&quot;星期三&quot;);</span><br><span class=\"line\">               break;</span><br><span class=\"line\">           case 4:</span><br><span class=\"line\">               System.out.println(&quot;星期四&quot;);</span><br><span class=\"line\">               break;</span><br><span class=\"line\">           case 5:</span><br><span class=\"line\">               System.out.println(&quot;星期五&quot;);</span><br><span class=\"line\">               break;</span><br><span class=\"line\">           case 6:</span><br><span class=\"line\">               System.out.println(&quot;星期六&quot;);</span><br><span class=\"line\">               break;</span><br><span class=\"line\">           case 7:</span><br><span class=\"line\">               System.out.println(&quot;星期天&quot;);</span><br><span class=\"line\">               break;</span><br><span class=\"line\">           default:</span><br><span class=\"line\">               System.out.println(&quot;输入有误&quot;);</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>使用switch特别注意，必须在case语句后加break </strong>   </p>\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Season &#123;//是枚举enum不是类class</span><br><span class=\"line\">            SPRING, SUMMER, AUTUMN, WINTER;//直接这样写</span><br><span class=\"line\"></span><br><span class=\"line\">            public static void main(String[] args) &#123;</span><br><span class=\"line\">                Season season = Season.SPRING;</span><br><span class=\"line\">                switch (season) &#123;</span><br><span class=\"line\">                    case SPRING:</span><br><span class=\"line\">                        System.out.println(&quot;春天&quot;);</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case SUMMER:</span><br><span class=\"line\">                        System.out.println(&quot;夏天&quot;);</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case AUTUMN:</span><br><span class=\"line\">                        System.out.println(&quot;秋天&quot;);</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case WINTER:</span><br><span class=\"line\">                        System.out.println(&quot;冬天&quot;);</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"如何跳出多重循环？\"><a href=\"#如何跳出多重循环？\" class=\"headerlink\" title=\"如何跳出多重循环？\"></a>如何跳出多重循环？</h4><p>在外部循环的前一行，加上自定义标签，比如 out:<br>在break的时候使用该标签。break out;</p>\n<h1 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h1><h2 id=\"非静态内部类\"><a href=\"#非静态内部类\" class=\"headerlink\" title=\"非静态内部类\"></a>非静态内部类</h2><p>可以被看作外部类的一个成员（与类的属性和方法类似）<br>1可以自由的引用外部类的属性和方法。2外部类被实例化之后，内部类才能被实例化。3不能有静态成员。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Hero &#123;//英雄类</span><br><span class=\"line\">    private String name; </span><br><span class=\"line\">    float hp; </span><br><span class=\"line\">    // 非静态内部类，只有一个外部类对象存在的时候，才有意义</span><br><span class=\"line\">    // 比如战斗成绩只有在一个英雄对象存在的时候才有意义</span><br><span class=\"line\">    </span><br><span class=\"line\">    class BattleScore &#123;//战斗成绩类</span><br><span class=\"line\">        int kill;</span><br><span class=\"line\"></span><br><span class=\"line\">        public void legendary() &#123;</span><br><span class=\"line\">            if (kill &gt;= 8)</span><br><span class=\"line\">                System.out.println(name + &quot;超神！&quot;);</span><br><span class=\"line\">            else</span><br><span class=\"line\">                System.out.println(name + &quot;尚未超神！&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Hero garen = new Hero();</span><br><span class=\"line\">        garen.name = &quot;盖伦&quot;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // BattleScore对象只有在一个英雄对象存在的时候才有意义</span><br><span class=\"line\">        BattleScore score = garen.new BattleScore();// 所以其实例化必须建立在一个外部类对象的基础之上</span><br><span class=\"line\">                                                    </span><br><span class=\"line\">        score.kill = 9;</span><br><span class=\"line\">        score.legendary();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"静态内部类。\"><a href=\"#静态内部类。\" class=\"headerlink\" title=\"静态内部类。\"></a>静态内部类。</h2><p>1不能访问外部类普通成员，只能访问外部内中静态成员和静态方法。<br>2可以不依赖于外部类实例化而实例化。<br>3不可以与外部类同名。</p>\n<h2 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h2><p>是指定义在一个代码块内的类，不可以被修饰符修饰。</p>\n<h2 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h2><p>是一种没有类名的内部类，不使用关键字class、extends、implement，没有构造方法，必须继承类或其他接口。一般用于gui编程中事件处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class Hero&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public abstract void attack();</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Hero h = new Hero()&#123;</span><br><span class=\"line\">            //当场实现attack方法</span><br><span class=\"line\">            public void attack() &#123;</span><br><span class=\"line\">                System.out.println(&quot;新的进攻手段&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        h.attack();</span><br><span class=\"line\">        //通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名</span><br><span class=\"line\">        System.out.println(h);</span><br><span class=\"line\">    &#125;&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h1><h2 id=\"格式化\"><a href=\"#格式化\" class=\"headerlink\" title=\"格式化\"></a>格式化</h2><p>%s 表示字符串<br>%d 表示数字<br>%n 表示换行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String name =&quot;盖伦&quot;;</span><br><span class=\"line\">int kill = 8;</span><br><span class=\"line\">String title=&quot;超神&quot;;</span><br><span class=\"line\"> </span><br><span class=\"line\">String sentenceFormat =&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;;</span><br><span class=\"line\">//使用printf格式化输出</span><br><span class=\"line\">System.out.printf(sentenceFormat,name,kill,title);//第一个是原字符串</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"StringBuffer追加-删除-插入-反转\"><a href=\"#StringBuffer追加-删除-插入-反转\" class=\"headerlink\" title=\"StringBuffer追加 删除 插入 反转\"></a>StringBuffer追加 删除 插入 反转</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 = &quot;let there &quot;;</span><br><span class=\"line\">StringBuffer sb = new StringBuffer(str1); //根据str1创建一个StringBuffer对象</span><br><span class=\"line\">sb.append(&quot;be light&quot;); //在最后追加</span><br><span class=\"line\">sb.delete(4, 10);//删除4-10之间的字符</span><br><span class=\"line\">sb.insert(4, &quot;there &quot;);//在4这个位置插入 there</span><br><span class=\"line\">sb.reverse(); //反转</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串的转化\"><a href=\"#字符串的转化\" class=\"headerlink\" title=\"字符串的转化\"></a>字符串的转化</h2><h3 id=\"数字与字符串\"><a href=\"#数字与字符串\" class=\"headerlink\" title=\"数字与字符串\"></a>数字与字符串</h3><ul>\n<li>数字转字符串<br>方法1： 使用String类的静态方法valueOf<br>String str = String.valueOf(i);<br>方法2： 先把基本类型装箱为对象，然后调用对象的toString<br>Integer it = i;<br>String str2 = it.toString();</li>\n</ul>\n<ul>\n<li>字符串转数字<br>String str = “999”;<br>int i= Integer.parseInt(str);</li>\n</ul>\n<h3 id=\"字符串与字符串数组\"><a href=\"#字符串与字符串数组\" class=\"headerlink\" title=\"字符串与字符串数组\"></a>字符串与字符串数组</h3><ul>\n<li>字符数组 转 字符串<br>char[] data={‘a’,’b’,’c’};<br>String s=new String(data);</li>\n</ul>\n<p>字符数组转换成字符串<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char[]   data=&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;;   </span><br><span class=\"line\">String  s=new   String(data);</span><br></pre></td></tr></table></figure></p>\n<p>s1.charAt(0)=c1;是不行的<br>s1.charAt(0);是可以的</p>\n<h2 id=\"字符串是否相等的提问\"><a href=\"#字符串是否相等的提问\" class=\"headerlink\" title=\"字符串是否相等的提问\"></a>字符串是否相等的提问</h2><p>问：1和2处分别输出什么?<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> String str1 = &quot;the light&quot;;</span><br><span class=\"line\"> String str2 = new String(str1);</span><br><span class=\"line\"> System.out.println( str1  ==  str2);//1</span><br><span class=\"line\">String str4 = new String(&quot;the light&quot;);//2</span><br><span class=\"line\"></span><br><span class=\"line\"> String str3 = &quot;the light&quot;;</span><br><span class=\"line\"> String str4 = &quot;the light&quot;;</span><br><span class=\"line\"> System.out.println( str4  ==  str3);//3</span><br></pre></td></tr></table></figure></p>\n<p>答：1输出false。因为new String会为str2开辟一个新的区域.<br>2输出true。因为str3创建了一个新的字符串”the light”，在str4编译器发现已经存在现成的”the light”，那么就直接拿来使用，而没有进行重复创建</p>\n<h1 id=\"时间\"><a href=\"#时间\" class=\"headerlink\" title=\"时间\"></a>时间</h1><h2 id=\"格式化时间\"><a href=\"#格式化时间\" class=\"headerlink\" title=\"格式化时间\"></a>格式化时间</h2><p>时间（注意月和小时是大写的喔）</p>\n<p>y 代表年<br>M 代表月<br>d 代表日<br>H 代表24进制的小时<br>h 代表12进制的小时<br>m 代表分钟<br>s 代表秒<br>S 代表毫秒<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Date d = new Date();</span><br><span class=\"line\">System.out.println(d);//输出当前时间</span><br><span class=\"line\">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日,HH时mm分ss秒&quot;);//设置样式</span><br><span class=\"line\">String s = sdf.format(d);//把d这个时间实例格式化，并且赋值给字符串s</span><br><span class=\"line\">System.out.println(s);//输出的字符串s就是格式化好的时间啦</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"日历（可以做“查看明年的今天是几号”之类的事）\"><a href=\"#日历（可以做“查看明年的今天是几号”之类的事）\" class=\"headerlink\" title=\"日历（可以做“查看明年的今天是几号”之类的事）\"></a>日历（可以做“查看明年的今天是几号”之类的事）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Calendar c = Calendar.getInstance();//Calendar用单例模式创造实例</span><br><span class=\"line\">Date now = c.getTime();</span><br><span class=\"line\"></span><br><span class=\"line\">c.setTime(now);</span><br><span class=\"line\">//先翻到下下个月</span><br><span class=\"line\">c.add(Calendar.MONTH,2);</span><br><span class=\"line\">//设置到月初</span><br><span class=\"line\">c.set(Calendar.DATE,1);</span><br><span class=\"line\">//再往回翻3天</span><br><span class=\"line\">c.add(Calendar.DATE,-3);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;下个月的倒数第3天是哪天&quot;+s);</span><br></pre></td></tr></table></figure>\n<h1 id=\"一些基础但不重要的知识\"><a href=\"#一些基础但不重要的知识\" class=\"headerlink\" title=\"一些基础但不重要的知识\"></a>一些基础但不重要的知识</h1><ul>\n<li>变量名起名规则<ol>\n<li>字母 数字 $ _ 组成</li>\n<li>变量第一个字符，不能使用数字。</li>\n<li>不可以使用关键字。<br>为什么不重要？<br>起名的时候选择有意义描述性的词比如“toString””getFlow”，不要用关键字。起名规则无需死记硬背。</li>\n</ol>\n</li>\n</ul>\n"},{"title":"(译)实现 Bitcask ，一种日志结构的哈希表","date":"2022-12-01T15:53:50.000Z","description":"Bitcask 是一种使用日志结构哈希表，用于存储和检索数据的应用。","_content":"> * 我翻译的这篇文章参与了掘金翻译计划，选自英语优秀技术文章。\n> * 原文地址：[Implementing Bitcask, a Log-Structured Hash Table](https://healeycodes.com/implementing-bitcask-a-log-structured-hash-table)\n> * 原文作者：[Andrew Healey](https://healeycodes.com/)\n> * 译文出自：[掘金翻译计划](https://github.com/xitu/gold-miner)\n> * 本文永久链接：[https://github.com/xitu/gold-miner/blob/master/article/2022/implementing-bitcask-a-log-structured-hash-table.md](https://github.com/xitu/gold-miner/blob/master/article/2022/implementing-bitcask-a-log-structured-hash-table.md)\n> * 译者：[wangxuanni](https://github.com/wangxuanni)\n> * 校对者：[Quincy_Ye](https://github.com/Quincy-Ye) ,[CompetitiveLin](https://github.com/CompetitiveLin)\n\n# 实现 Bitcask ，一种日志结构的哈希表\n\n[Bitcask](https://en.wikipedia.org/wiki/Bitcask) 是一种使用日志结构哈希表，用于存储和检索数据的应用。它将键和元数据存储在内存里，将值存储在磁盘里。检索值的速度很快，因为它只需要一次磁盘寻址。\n\n主要的好处是：\n\n* 每一个数据低延时的读取或写入\n* 一致的性能\n* 能处理大于 RAM 的数据集\n* 设计规格小\n\n主要的缺点是：\n\n* 所有的键都必须放进 RAM\n\n周末，我在一个名为 [bitcask-lite](https://github.com/healeycodes/bitcask-lite) 的项目（一个使用 Go 标准库的键/值数据库和服务器）中实现了 Bitcask 的部分[设计规范](https://riak.com/assets/bitcask-intro.pdf)。\n\n我需要为一个其他项目提供一些值较大的数据，而不是使用 SQLite 之类的东西构建最小可行产品，我[在前人的基础上修补了](https://seths.blog/2005/03/dont_shave_that/)一个数据库。\n\n在 bitcask-lite 中，键和元数据存在于基于 [orcaman/concurrent-map](https://github.com/orcaman/concurrent-map) 的并发映射中 —— 映射分片的映射。Go 不允许并发地读取和写入映射 —— 因此每个映射分片都需要独立锁定，以避免将 bitcask-lite 的并发限制为单个请求。\n\n```\ntype ConcurrentMap[V any] []*MapShard[V]\n\ntype MapShard[V any] struct {\n  items map[string]V\n  mu    *sync.Mutex\n}\n```\n\n这个数据库是包含一个或者多个日志文件的目录。数据使用 schema 写入活跃日志文件：`expire, keySize, valueSize, key, value,`（我是人类可读数据的忠实拥护者）。\n\n键为`a`，值为`b`，于 2022 年 8 月 10 日到期的数据如下所示：[]()\n\n```\n1759300313415,1,1,a,b,\n```\n\n日志文件是 append-only （只许追加），所以不需要为**获取**值而上锁，但是当**设置**值时，会为活跃日志文件上一个锁，以确保数据库相对于传入请求的顺序是正确的。不幸地是，这意味着大量写的负载将比大量读的负载表现更差。\n\n我真的很喜欢 Go 用于读取/写入文件的 API。对我来说，这是明智的、一致的和显而易见的。它可以是很冗长的（尤其是错误处理），但我认为那是个特点。有时候表达清晰会更好。\n\n以下代码段详细说明了处理`/get`请求的热路径。我添加了一些额外的注释并减少了错误处理。\n\n```\n// StreamGet 从一个日志存储里获取一个值\nfunc (logStore *LogStore) StreamGet(key string, w io.Writer) (bool, error) {\n\n  // 锁住这个 map 分片\n  access := logStore.keys.AccessShard(key)\n  defer access.Unlock()\n  item, found := logStore.keys.Get(key)\n\n  if !found {\n    // Key 没找到\n    return false, nil\n  } else if int(time.Now().UnixMilli()) >= item.expire {\n    // Key 找到了但是过期了\n    // so we can clean it up (aka lazy garbage collection!)\n    logStore.keys.Delete(key)\n    return false, nil\n  }\n\n  f, err := os.Open(item.file)\n  // ..\n  defer f.Close()\n\n  // Set the offset for the upcoming read\n  _, err = f.Seek(int64(item.valuePos), 0)\n  // ..\n\n  // Pipe it to the HTTP response\n  _, err = io.CopyN(w, f, int64(item.valueSize))\n  // .. \n  return true, nil\n}\n```\n\n这个项目最棘手的部分是解析日志文件；主要是由于差一错误。我使用的算法相当幼稚。它进行了太多的系统调用，但我想尽早发布而不是优化。我的直觉是读入缓冲区因此解析速度更快，但真正的性能胜利是并行解析日志文件，所以如果启动时间困扰了我，我会优先解决这个问题！\n\n```\n// 解析一个 bitcask-lite 的日志文件\n\n// Loop:\n// - expire    = ReadBytes(COMMA)\n//   - EOF error? return\n// - keySize   = ReadBytes(COMMA)\n// - valueSize = ReadBytes(COMMA)\n// - key       = Read(keySize + 1)\n// - value     = Discard(valueSize+ 1)\n```\n\n## HTTP API\n\n我在一张便利贴上草拟了一下 API 就开始了这个项目。\n\n```\n/get?key=a\n/delete?key=c\n/set?key=b&expire=1759300313415\n  - HTTP body is read as the value\n  - expire is optional (default is infinite)\n```\n\n完成之后，我看到测试代码的行数超过了其他的代码。这大体上说明了软件的复杂度。我可以一口气描述这个 API，但我花了好几个小时来用测试和修复来覆盖每个边界值用例。\n\n服务器代码位于`func main()`并使用普通的旧 [net/http](https://pkg.go.dev/net/http) 。由于无法从 Go 中测试主要功能，我使用了一个我之前在其实项目中使用过的测试模式，它是一个用 Python 编写的端到端的测试脚本，它生成一个服务器进程，点击它，然后可以进行断言测试。\n\n```\n# 用 dev 命令去启动服务器\nproc = subprocess.Popen(\n    [\"go\", \"run\", \".\"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT\n)\n\n# 测试获取一个缺失的键\ng = requests.get(f\"{addr}/get?key=z\")\nprint(g.status_code, g.text)\nassert g.status_code == 404\n\n# ^ 失败断言以非零退出代码退出\n# 导致任何持续集成 (CI) 流程失败\n# 或其他测试运行器\n```\n\n## 缺失的部分\n\nBitcask 的[设计规范](https://riak.com/assets/bitcask-intro.pdf)还描述了如何随着时间的推移清理数据库。现在，bitcask-lite 越来越大。过期的数据们永远存在于磁盘上。\n\nBitcask 可以将多个文件合并成更紧凑的形式，并生成提示文件以加快启动时间 —— 在此过程中删除过期的密钥。此合并过程对性能有轻微影响，但可以在低流量期间执行。\n\n> 为了在白天处理大量写入而不降低性能，您可能希望将合并限制在非高峰期。将合并窗口设置为一天中流量较低的时间会有所帮助。\n\n我还跳过了添加 CRC（循环冗余校验），我不是设置逻辑删除值，我只是假装一个密钥已设置为零字节，过期时间为 1970 年。\n\n```\n// Set 处理 key, expire, value\nerr := logStore.Set(key, 0, []byte(\"\"))\nif err != nil {\n  log.Printf(\"couldn't delete %s: %s\", key, err)\n  w.WriteHeader(500)\n  return\n}\n```\n\n我对我走的捷径很满意。到目前为止，我的“玩具”数据库一直运转良好。\n\n当然，将 SQLite 与单个表一起使用会更快。但我主要是为了好玩写这个数据库。我确实想好奇 [bitcask-lite](https://github.com/healeycodes/bitcask-lite) 和 SQLite + server 之间的性能变化。当我无法弄清楚是否可以将单个 SQLite 值流式传输到客户端时，我准备设置一些基准。如果你知道，请[告诉我](mailto:healeycodes@gmail.com)！\n\n> 如果发现译文存在错误或其他需要改进的地方，欢迎到 [掘金翻译计划](https://github.com/xitu/gold-miner) 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 **本文永久链接** 即为本文在 GitHub 上的 MarkDown 链接。\n\n---\n\n> [掘金翻译计划](https://github.com/xitu/gold-miner) 是一个翻译优质互联网技术文章的社区，文章来源为 [掘金](https://juejin.im) 上的英文分享文章。内容覆盖 [Android](https://github.com/xitu/gold-miner#android)、[iOS](https://github.com/xitu/gold-miner#ios)、[前端](https://github.com/xitu/gold-miner#前端)、[后端](https://github.com/xitu/gold-miner#后端)、[区块链](https://github.com/xitu/gold-miner#区块链)、[产品](https://github.com/xitu/gold-miner#产品)、[设计](https://github.com/xitu/gold-miner#设计)、[人工智能](https://github.com/xitu/gold-miner#人工智能)等领域，想要查看更多优质译文请持续关注 [掘金翻译计划](https://github.com/xitu/gold-miner)、[官方微博](http://weibo.com/juejinfanyi)、[知乎专栏](https://zhuanlan.zhihu.com/juejinfanyi)。\n","source":"_posts/implementing-bitcask-a-log-structured-hash-table.md","raw":"---\ntitle: (译)实现 Bitcask ，一种日志结构的哈希表\ndate: 2022-12-01 23:53:50\ncategories: 翻译\ndescription: Bitcask 是一种使用日志结构哈希表，用于存储和检索数据的应用。\n---\n> * 我翻译的这篇文章参与了掘金翻译计划，选自英语优秀技术文章。\n> * 原文地址：[Implementing Bitcask, a Log-Structured Hash Table](https://healeycodes.com/implementing-bitcask-a-log-structured-hash-table)\n> * 原文作者：[Andrew Healey](https://healeycodes.com/)\n> * 译文出自：[掘金翻译计划](https://github.com/xitu/gold-miner)\n> * 本文永久链接：[https://github.com/xitu/gold-miner/blob/master/article/2022/implementing-bitcask-a-log-structured-hash-table.md](https://github.com/xitu/gold-miner/blob/master/article/2022/implementing-bitcask-a-log-structured-hash-table.md)\n> * 译者：[wangxuanni](https://github.com/wangxuanni)\n> * 校对者：[Quincy_Ye](https://github.com/Quincy-Ye) ,[CompetitiveLin](https://github.com/CompetitiveLin)\n\n# 实现 Bitcask ，一种日志结构的哈希表\n\n[Bitcask](https://en.wikipedia.org/wiki/Bitcask) 是一种使用日志结构哈希表，用于存储和检索数据的应用。它将键和元数据存储在内存里，将值存储在磁盘里。检索值的速度很快，因为它只需要一次磁盘寻址。\n\n主要的好处是：\n\n* 每一个数据低延时的读取或写入\n* 一致的性能\n* 能处理大于 RAM 的数据集\n* 设计规格小\n\n主要的缺点是：\n\n* 所有的键都必须放进 RAM\n\n周末，我在一个名为 [bitcask-lite](https://github.com/healeycodes/bitcask-lite) 的项目（一个使用 Go 标准库的键/值数据库和服务器）中实现了 Bitcask 的部分[设计规范](https://riak.com/assets/bitcask-intro.pdf)。\n\n我需要为一个其他项目提供一些值较大的数据，而不是使用 SQLite 之类的东西构建最小可行产品，我[在前人的基础上修补了](https://seths.blog/2005/03/dont_shave_that/)一个数据库。\n\n在 bitcask-lite 中，键和元数据存在于基于 [orcaman/concurrent-map](https://github.com/orcaman/concurrent-map) 的并发映射中 —— 映射分片的映射。Go 不允许并发地读取和写入映射 —— 因此每个映射分片都需要独立锁定，以避免将 bitcask-lite 的并发限制为单个请求。\n\n```\ntype ConcurrentMap[V any] []*MapShard[V]\n\ntype MapShard[V any] struct {\n  items map[string]V\n  mu    *sync.Mutex\n}\n```\n\n这个数据库是包含一个或者多个日志文件的目录。数据使用 schema 写入活跃日志文件：`expire, keySize, valueSize, key, value,`（我是人类可读数据的忠实拥护者）。\n\n键为`a`，值为`b`，于 2022 年 8 月 10 日到期的数据如下所示：[]()\n\n```\n1759300313415,1,1,a,b,\n```\n\n日志文件是 append-only （只许追加），所以不需要为**获取**值而上锁，但是当**设置**值时，会为活跃日志文件上一个锁，以确保数据库相对于传入请求的顺序是正确的。不幸地是，这意味着大量写的负载将比大量读的负载表现更差。\n\n我真的很喜欢 Go 用于读取/写入文件的 API。对我来说，这是明智的、一致的和显而易见的。它可以是很冗长的（尤其是错误处理），但我认为那是个特点。有时候表达清晰会更好。\n\n以下代码段详细说明了处理`/get`请求的热路径。我添加了一些额外的注释并减少了错误处理。\n\n```\n// StreamGet 从一个日志存储里获取一个值\nfunc (logStore *LogStore) StreamGet(key string, w io.Writer) (bool, error) {\n\n  // 锁住这个 map 分片\n  access := logStore.keys.AccessShard(key)\n  defer access.Unlock()\n  item, found := logStore.keys.Get(key)\n\n  if !found {\n    // Key 没找到\n    return false, nil\n  } else if int(time.Now().UnixMilli()) >= item.expire {\n    // Key 找到了但是过期了\n    // so we can clean it up (aka lazy garbage collection!)\n    logStore.keys.Delete(key)\n    return false, nil\n  }\n\n  f, err := os.Open(item.file)\n  // ..\n  defer f.Close()\n\n  // Set the offset for the upcoming read\n  _, err = f.Seek(int64(item.valuePos), 0)\n  // ..\n\n  // Pipe it to the HTTP response\n  _, err = io.CopyN(w, f, int64(item.valueSize))\n  // .. \n  return true, nil\n}\n```\n\n这个项目最棘手的部分是解析日志文件；主要是由于差一错误。我使用的算法相当幼稚。它进行了太多的系统调用，但我想尽早发布而不是优化。我的直觉是读入缓冲区因此解析速度更快，但真正的性能胜利是并行解析日志文件，所以如果启动时间困扰了我，我会优先解决这个问题！\n\n```\n// 解析一个 bitcask-lite 的日志文件\n\n// Loop:\n// - expire    = ReadBytes(COMMA)\n//   - EOF error? return\n// - keySize   = ReadBytes(COMMA)\n// - valueSize = ReadBytes(COMMA)\n// - key       = Read(keySize + 1)\n// - value     = Discard(valueSize+ 1)\n```\n\n## HTTP API\n\n我在一张便利贴上草拟了一下 API 就开始了这个项目。\n\n```\n/get?key=a\n/delete?key=c\n/set?key=b&expire=1759300313415\n  - HTTP body is read as the value\n  - expire is optional (default is infinite)\n```\n\n完成之后，我看到测试代码的行数超过了其他的代码。这大体上说明了软件的复杂度。我可以一口气描述这个 API，但我花了好几个小时来用测试和修复来覆盖每个边界值用例。\n\n服务器代码位于`func main()`并使用普通的旧 [net/http](https://pkg.go.dev/net/http) 。由于无法从 Go 中测试主要功能，我使用了一个我之前在其实项目中使用过的测试模式，它是一个用 Python 编写的端到端的测试脚本，它生成一个服务器进程，点击它，然后可以进行断言测试。\n\n```\n# 用 dev 命令去启动服务器\nproc = subprocess.Popen(\n    [\"go\", \"run\", \".\"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT\n)\n\n# 测试获取一个缺失的键\ng = requests.get(f\"{addr}/get?key=z\")\nprint(g.status_code, g.text)\nassert g.status_code == 404\n\n# ^ 失败断言以非零退出代码退出\n# 导致任何持续集成 (CI) 流程失败\n# 或其他测试运行器\n```\n\n## 缺失的部分\n\nBitcask 的[设计规范](https://riak.com/assets/bitcask-intro.pdf)还描述了如何随着时间的推移清理数据库。现在，bitcask-lite 越来越大。过期的数据们永远存在于磁盘上。\n\nBitcask 可以将多个文件合并成更紧凑的形式，并生成提示文件以加快启动时间 —— 在此过程中删除过期的密钥。此合并过程对性能有轻微影响，但可以在低流量期间执行。\n\n> 为了在白天处理大量写入而不降低性能，您可能希望将合并限制在非高峰期。将合并窗口设置为一天中流量较低的时间会有所帮助。\n\n我还跳过了添加 CRC（循环冗余校验），我不是设置逻辑删除值，我只是假装一个密钥已设置为零字节，过期时间为 1970 年。\n\n```\n// Set 处理 key, expire, value\nerr := logStore.Set(key, 0, []byte(\"\"))\nif err != nil {\n  log.Printf(\"couldn't delete %s: %s\", key, err)\n  w.WriteHeader(500)\n  return\n}\n```\n\n我对我走的捷径很满意。到目前为止，我的“玩具”数据库一直运转良好。\n\n当然，将 SQLite 与单个表一起使用会更快。但我主要是为了好玩写这个数据库。我确实想好奇 [bitcask-lite](https://github.com/healeycodes/bitcask-lite) 和 SQLite + server 之间的性能变化。当我无法弄清楚是否可以将单个 SQLite 值流式传输到客户端时，我准备设置一些基准。如果你知道，请[告诉我](mailto:healeycodes@gmail.com)！\n\n> 如果发现译文存在错误或其他需要改进的地方，欢迎到 [掘金翻译计划](https://github.com/xitu/gold-miner) 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 **本文永久链接** 即为本文在 GitHub 上的 MarkDown 链接。\n\n---\n\n> [掘金翻译计划](https://github.com/xitu/gold-miner) 是一个翻译优质互联网技术文章的社区，文章来源为 [掘金](https://juejin.im) 上的英文分享文章。内容覆盖 [Android](https://github.com/xitu/gold-miner#android)、[iOS](https://github.com/xitu/gold-miner#ios)、[前端](https://github.com/xitu/gold-miner#前端)、[后端](https://github.com/xitu/gold-miner#后端)、[区块链](https://github.com/xitu/gold-miner#区块链)、[产品](https://github.com/xitu/gold-miner#产品)、[设计](https://github.com/xitu/gold-miner#设计)、[人工智能](https://github.com/xitu/gold-miner#人工智能)等领域，想要查看更多优质译文请持续关注 [掘金翻译计划](https://github.com/xitu/gold-miner)、[官方微博](http://weibo.com/juejinfanyi)、[知乎专栏](https://zhuanlan.zhihu.com/juejinfanyi)。\n","slug":"implementing-bitcask-a-log-structured-hash-table","published":1,"updated":"2022-12-08T10:24:32.333Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qk5000hw9rp4ppa1jdu","content":"<blockquote>\n<ul>\n<li>我翻译的这篇文章参与了掘金翻译计划，选自英语优秀技术文章。</li>\n<li>原文地址：<a href=\"https://healeycodes.com/implementing-bitcask-a-log-structured-hash-table\" target=\"_blank\" rel=\"noopener\">Implementing Bitcask, a Log-Structured Hash Table</a></li>\n<li>原文作者：<a href=\"https://healeycodes.com/\" target=\"_blank\" rel=\"noopener\">Andrew Healey</a></li>\n<li>译文出自：<a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a></li>\n<li>本文永久链接：<a href=\"https://github.com/xitu/gold-miner/blob/master/article/2022/implementing-bitcask-a-log-structured-hash-table.md\" target=\"_blank\" rel=\"noopener\">https://github.com/xitu/gold-miner/blob/master/article/2022/implementing-bitcask-a-log-structured-hash-table.md</a></li>\n<li>译者：<a href=\"https://github.com/wangxuanni\" target=\"_blank\" rel=\"noopener\">wangxuanni</a></li>\n<li>校对者：<a href=\"https://github.com/Quincy-Ye\" target=\"_blank\" rel=\"noopener\">Quincy_Ye</a> ,<a href=\"https://github.com/CompetitiveLin\" target=\"_blank\" rel=\"noopener\">CompetitiveLin</a></li>\n</ul>\n</blockquote>\n<h1 id=\"实现-Bitcask-，一种日志结构的哈希表\"><a href=\"#实现-Bitcask-，一种日志结构的哈希表\" class=\"headerlink\" title=\"实现 Bitcask ，一种日志结构的哈希表\"></a>实现 Bitcask ，一种日志结构的哈希表</h1><p><a href=\"https://en.wikipedia.org/wiki/Bitcask\" target=\"_blank\" rel=\"noopener\">Bitcask</a> 是一种使用日志结构哈希表，用于存储和检索数据的应用。它将键和元数据存储在内存里，将值存储在磁盘里。检索值的速度很快，因为它只需要一次磁盘寻址。</p>\n<p>主要的好处是：</p>\n<ul>\n<li>每一个数据低延时的读取或写入</li>\n<li>一致的性能</li>\n<li>能处理大于 RAM 的数据集</li>\n<li>设计规格小</li>\n</ul>\n<p>主要的缺点是：</p>\n<ul>\n<li>所有的键都必须放进 RAM</li>\n</ul>\n<p>周末，我在一个名为 <a href=\"https://github.com/healeycodes/bitcask-lite\" target=\"_blank\" rel=\"noopener\">bitcask-lite</a> 的项目（一个使用 Go 标准库的键/值数据库和服务器）中实现了 Bitcask 的部分<a href=\"https://riak.com/assets/bitcask-intro.pdf\" target=\"_blank\" rel=\"noopener\">设计规范</a>。</p>\n<p>我需要为一个其他项目提供一些值较大的数据，而不是使用 SQLite 之类的东西构建最小可行产品，我<a href=\"https://seths.blog/2005/03/dont_shave_that/\" target=\"_blank\" rel=\"noopener\">在前人的基础上修补了</a>一个数据库。</p>\n<p>在 bitcask-lite 中，键和元数据存在于基于 <a href=\"https://github.com/orcaman/concurrent-map\" target=\"_blank\" rel=\"noopener\">orcaman/concurrent-map</a> 的并发映射中 —— 映射分片的映射。Go 不允许并发地读取和写入映射 —— 因此每个映射分片都需要独立锁定，以避免将 bitcask-lite 的并发限制为单个请求。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type ConcurrentMap[V any] []*MapShard[V]</span><br><span class=\"line\"></span><br><span class=\"line\">type MapShard[V any] struct &#123;</span><br><span class=\"line\">  items map[string]V</span><br><span class=\"line\">  mu    *sync.Mutex</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个数据库是包含一个或者多个日志文件的目录。数据使用 schema 写入活跃日志文件：<code>expire, keySize, valueSize, key, value,</code>（我是人类可读数据的忠实拥护者）。</p>\n<p>键为<code>a</code>，值为<code>b</code>，于 2022 年 8 月 10 日到期的数据如下所示：<a href></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1759300313415,1,1,a,b,</span><br></pre></td></tr></table></figure>\n<p>日志文件是 append-only （只许追加），所以不需要为<strong>获取</strong>值而上锁，但是当<strong>设置</strong>值时，会为活跃日志文件上一个锁，以确保数据库相对于传入请求的顺序是正确的。不幸地是，这意味着大量写的负载将比大量读的负载表现更差。</p>\n<p>我真的很喜欢 Go 用于读取/写入文件的 API。对我来说，这是明智的、一致的和显而易见的。它可以是很冗长的（尤其是错误处理），但我认为那是个特点。有时候表达清晰会更好。</p>\n<p>以下代码段详细说明了处理<code>/get</code>请求的热路径。我添加了一些额外的注释并减少了错误处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// StreamGet 从一个日志存储里获取一个值</span><br><span class=\"line\">func (logStore *LogStore) StreamGet(key string, w io.Writer) (bool, error) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 锁住这个 map 分片</span><br><span class=\"line\">  access := logStore.keys.AccessShard(key)</span><br><span class=\"line\">  defer access.Unlock()</span><br><span class=\"line\">  item, found := logStore.keys.Get(key)</span><br><span class=\"line\"></span><br><span class=\"line\">  if !found &#123;</span><br><span class=\"line\">    // Key 没找到</span><br><span class=\"line\">    return false, nil</span><br><span class=\"line\">  &#125; else if int(time.Now().UnixMilli()) &gt;= item.expire &#123;</span><br><span class=\"line\">    // Key 找到了但是过期了</span><br><span class=\"line\">    // so we can clean it up (aka lazy garbage collection!)</span><br><span class=\"line\">    logStore.keys.Delete(key)</span><br><span class=\"line\">    return false, nil</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  f, err := os.Open(item.file)</span><br><span class=\"line\">  // ..</span><br><span class=\"line\">  defer f.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">  // Set the offset for the upcoming read</span><br><span class=\"line\">  _, err = f.Seek(int64(item.valuePos), 0)</span><br><span class=\"line\">  // ..</span><br><span class=\"line\"></span><br><span class=\"line\">  // Pipe it to the HTTP response</span><br><span class=\"line\">  _, err = io.CopyN(w, f, int64(item.valueSize))</span><br><span class=\"line\">  // .. </span><br><span class=\"line\">  return true, nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个项目最棘手的部分是解析日志文件；主要是由于差一错误。我使用的算法相当幼稚。它进行了太多的系统调用，但我想尽早发布而不是优化。我的直觉是读入缓冲区因此解析速度更快，但真正的性能胜利是并行解析日志文件，所以如果启动时间困扰了我，我会优先解决这个问题！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 解析一个 bitcask-lite 的日志文件</span><br><span class=\"line\"></span><br><span class=\"line\">// Loop:</span><br><span class=\"line\">// - expire    = ReadBytes(COMMA)</span><br><span class=\"line\">//   - EOF error? return</span><br><span class=\"line\">// - keySize   = ReadBytes(COMMA)</span><br><span class=\"line\">// - valueSize = ReadBytes(COMMA)</span><br><span class=\"line\">// - key       = Read(keySize + 1)</span><br><span class=\"line\">// - value     = Discard(valueSize+ 1)</span><br></pre></td></tr></table></figure>\n<h2 id=\"HTTP-API\"><a href=\"#HTTP-API\" class=\"headerlink\" title=\"HTTP API\"></a>HTTP API</h2><p>我在一张便利贴上草拟了一下 API 就开始了这个项目。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/get?key=a</span><br><span class=\"line\">/delete?key=c</span><br><span class=\"line\">/set?key=b&amp;expire=1759300313415</span><br><span class=\"line\">  - HTTP body is read as the value</span><br><span class=\"line\">  - expire is optional (default is infinite)</span><br></pre></td></tr></table></figure>\n<p>完成之后，我看到测试代码的行数超过了其他的代码。这大体上说明了软件的复杂度。我可以一口气描述这个 API，但我花了好几个小时来用测试和修复来覆盖每个边界值用例。</p>\n<p>服务器代码位于<code>func main()</code>并使用普通的旧 <a href=\"https://pkg.go.dev/net/http\" target=\"_blank\" rel=\"noopener\">net/http</a> 。由于无法从 Go 中测试主要功能，我使用了一个我之前在其实项目中使用过的测试模式，它是一个用 Python 编写的端到端的测试脚本，它生成一个服务器进程，点击它，然后可以进行断言测试。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 用 dev 命令去启动服务器</span><br><span class=\"line\">proc = subprocess.Popen(</span><br><span class=\"line\">    [&quot;go&quot;, &quot;run&quot;, &quot;.&quot;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"># 测试获取一个缺失的键</span><br><span class=\"line\">g = requests.get(f&quot;&#123;addr&#125;/get?key=z&quot;)</span><br><span class=\"line\">print(g.status_code, g.text)</span><br><span class=\"line\">assert g.status_code == 404</span><br><span class=\"line\"></span><br><span class=\"line\"># ^ 失败断言以非零退出代码退出</span><br><span class=\"line\"># 导致任何持续集成 (CI) 流程失败</span><br><span class=\"line\"># 或其他测试运行器</span><br></pre></td></tr></table></figure>\n<h2 id=\"缺失的部分\"><a href=\"#缺失的部分\" class=\"headerlink\" title=\"缺失的部分\"></a>缺失的部分</h2><p>Bitcask 的<a href=\"https://riak.com/assets/bitcask-intro.pdf\" target=\"_blank\" rel=\"noopener\">设计规范</a>还描述了如何随着时间的推移清理数据库。现在，bitcask-lite 越来越大。过期的数据们永远存在于磁盘上。</p>\n<p>Bitcask 可以将多个文件合并成更紧凑的形式，并生成提示文件以加快启动时间 —— 在此过程中删除过期的密钥。此合并过程对性能有轻微影响，但可以在低流量期间执行。</p>\n<blockquote>\n<p>为了在白天处理大量写入而不降低性能，您可能希望将合并限制在非高峰期。将合并窗口设置为一天中流量较低的时间会有所帮助。</p>\n</blockquote>\n<p>我还跳过了添加 CRC（循环冗余校验），我不是设置逻辑删除值，我只是假装一个密钥已设置为零字节，过期时间为 1970 年。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Set 处理 key, expire, value</span><br><span class=\"line\">err := logStore.Set(key, 0, []byte(&quot;&quot;))</span><br><span class=\"line\">if err != nil &#123;</span><br><span class=\"line\">  log.Printf(&quot;couldn&apos;t delete %s: %s&quot;, key, err)</span><br><span class=\"line\">  w.WriteHeader(500)</span><br><span class=\"line\">  return</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我对我走的捷径很满意。到目前为止，我的“玩具”数据库一直运转良好。</p>\n<p>当然，将 SQLite 与单个表一起使用会更快。但我主要是为了好玩写这个数据库。我确实想好奇 <a href=\"https://github.com/healeycodes/bitcask-lite\" target=\"_blank\" rel=\"noopener\">bitcask-lite</a> 和 SQLite + server 之间的性能变化。当我无法弄清楚是否可以将单个 SQLite 值流式传输到客户端时，我准备设置一些基准。如果你知道，请<a href=\"mailto:healeycodes@gmail.com\" target=\"_blank\" rel=\"noopener\">告诉我</a>！</p>\n<blockquote>\n<p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href=\"https://juejin.im\" target=\"_blank\" rel=\"noopener\">掘金</a> 上的英文分享文章。内容覆盖 <a href=\"https://github.com/xitu/gold-miner#android\" target=\"_blank\" rel=\"noopener\">Android</a>、<a href=\"https://github.com/xitu/gold-miner#ios\" target=\"_blank\" rel=\"noopener\">iOS</a>、<a href=\"https://github.com/xitu/gold-miner#前端\" target=\"_blank\" rel=\"noopener\">前端</a>、<a href=\"https://github.com/xitu/gold-miner#后端\" target=\"_blank\" rel=\"noopener\">后端</a>、<a href=\"https://github.com/xitu/gold-miner#区块链\" target=\"_blank\" rel=\"noopener\">区块链</a>、<a href=\"https://github.com/xitu/gold-miner#产品\" target=\"_blank\" rel=\"noopener\">产品</a>、<a href=\"https://github.com/xitu/gold-miner#设计\" target=\"_blank\" rel=\"noopener\">设计</a>、<a href=\"https://github.com/xitu/gold-miner#人工智能\" target=\"_blank\" rel=\"noopener\">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a>、<a href=\"http://weibo.com/juejinfanyi\" target=\"_blank\" rel=\"noopener\">官方微博</a>、<a href=\"https://zhuanlan.zhihu.com/juejinfanyi\" target=\"_blank\" rel=\"noopener\">知乎专栏</a>。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ul>\n<li>我翻译的这篇文章参与了掘金翻译计划，选自英语优秀技术文章。</li>\n<li>原文地址：<a href=\"https://healeycodes.com/implementing-bitcask-a-log-structured-hash-table\" target=\"_blank\" rel=\"noopener\">Implementing Bitcask, a Log-Structured Hash Table</a></li>\n<li>原文作者：<a href=\"https://healeycodes.com/\" target=\"_blank\" rel=\"noopener\">Andrew Healey</a></li>\n<li>译文出自：<a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a></li>\n<li>本文永久链接：<a href=\"https://github.com/xitu/gold-miner/blob/master/article/2022/implementing-bitcask-a-log-structured-hash-table.md\" target=\"_blank\" rel=\"noopener\">https://github.com/xitu/gold-miner/blob/master/article/2022/implementing-bitcask-a-log-structured-hash-table.md</a></li>\n<li>译者：<a href=\"https://github.com/wangxuanni\" target=\"_blank\" rel=\"noopener\">wangxuanni</a></li>\n<li>校对者：<a href=\"https://github.com/Quincy-Ye\" target=\"_blank\" rel=\"noopener\">Quincy_Ye</a> ,<a href=\"https://github.com/CompetitiveLin\" target=\"_blank\" rel=\"noopener\">CompetitiveLin</a></li>\n</ul>\n</blockquote>\n<h1 id=\"实现-Bitcask-，一种日志结构的哈希表\"><a href=\"#实现-Bitcask-，一种日志结构的哈希表\" class=\"headerlink\" title=\"实现 Bitcask ，一种日志结构的哈希表\"></a>实现 Bitcask ，一种日志结构的哈希表</h1><p><a href=\"https://en.wikipedia.org/wiki/Bitcask\" target=\"_blank\" rel=\"noopener\">Bitcask</a> 是一种使用日志结构哈希表，用于存储和检索数据的应用。它将键和元数据存储在内存里，将值存储在磁盘里。检索值的速度很快，因为它只需要一次磁盘寻址。</p>\n<p>主要的好处是：</p>\n<ul>\n<li>每一个数据低延时的读取或写入</li>\n<li>一致的性能</li>\n<li>能处理大于 RAM 的数据集</li>\n<li>设计规格小</li>\n</ul>\n<p>主要的缺点是：</p>\n<ul>\n<li>所有的键都必须放进 RAM</li>\n</ul>\n<p>周末，我在一个名为 <a href=\"https://github.com/healeycodes/bitcask-lite\" target=\"_blank\" rel=\"noopener\">bitcask-lite</a> 的项目（一个使用 Go 标准库的键/值数据库和服务器）中实现了 Bitcask 的部分<a href=\"https://riak.com/assets/bitcask-intro.pdf\" target=\"_blank\" rel=\"noopener\">设计规范</a>。</p>\n<p>我需要为一个其他项目提供一些值较大的数据，而不是使用 SQLite 之类的东西构建最小可行产品，我<a href=\"https://seths.blog/2005/03/dont_shave_that/\" target=\"_blank\" rel=\"noopener\">在前人的基础上修补了</a>一个数据库。</p>\n<p>在 bitcask-lite 中，键和元数据存在于基于 <a href=\"https://github.com/orcaman/concurrent-map\" target=\"_blank\" rel=\"noopener\">orcaman/concurrent-map</a> 的并发映射中 —— 映射分片的映射。Go 不允许并发地读取和写入映射 —— 因此每个映射分片都需要独立锁定，以避免将 bitcask-lite 的并发限制为单个请求。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type ConcurrentMap[V any] []*MapShard[V]</span><br><span class=\"line\"></span><br><span class=\"line\">type MapShard[V any] struct &#123;</span><br><span class=\"line\">  items map[string]V</span><br><span class=\"line\">  mu    *sync.Mutex</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个数据库是包含一个或者多个日志文件的目录。数据使用 schema 写入活跃日志文件：<code>expire, keySize, valueSize, key, value,</code>（我是人类可读数据的忠实拥护者）。</p>\n<p>键为<code>a</code>，值为<code>b</code>，于 2022 年 8 月 10 日到期的数据如下所示：<a href></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1759300313415,1,1,a,b,</span><br></pre></td></tr></table></figure>\n<p>日志文件是 append-only （只许追加），所以不需要为<strong>获取</strong>值而上锁，但是当<strong>设置</strong>值时，会为活跃日志文件上一个锁，以确保数据库相对于传入请求的顺序是正确的。不幸地是，这意味着大量写的负载将比大量读的负载表现更差。</p>\n<p>我真的很喜欢 Go 用于读取/写入文件的 API。对我来说，这是明智的、一致的和显而易见的。它可以是很冗长的（尤其是错误处理），但我认为那是个特点。有时候表达清晰会更好。</p>\n<p>以下代码段详细说明了处理<code>/get</code>请求的热路径。我添加了一些额外的注释并减少了错误处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// StreamGet 从一个日志存储里获取一个值</span><br><span class=\"line\">func (logStore *LogStore) StreamGet(key string, w io.Writer) (bool, error) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 锁住这个 map 分片</span><br><span class=\"line\">  access := logStore.keys.AccessShard(key)</span><br><span class=\"line\">  defer access.Unlock()</span><br><span class=\"line\">  item, found := logStore.keys.Get(key)</span><br><span class=\"line\"></span><br><span class=\"line\">  if !found &#123;</span><br><span class=\"line\">    // Key 没找到</span><br><span class=\"line\">    return false, nil</span><br><span class=\"line\">  &#125; else if int(time.Now().UnixMilli()) &gt;= item.expire &#123;</span><br><span class=\"line\">    // Key 找到了但是过期了</span><br><span class=\"line\">    // so we can clean it up (aka lazy garbage collection!)</span><br><span class=\"line\">    logStore.keys.Delete(key)</span><br><span class=\"line\">    return false, nil</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  f, err := os.Open(item.file)</span><br><span class=\"line\">  // ..</span><br><span class=\"line\">  defer f.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">  // Set the offset for the upcoming read</span><br><span class=\"line\">  _, err = f.Seek(int64(item.valuePos), 0)</span><br><span class=\"line\">  // ..</span><br><span class=\"line\"></span><br><span class=\"line\">  // Pipe it to the HTTP response</span><br><span class=\"line\">  _, err = io.CopyN(w, f, int64(item.valueSize))</span><br><span class=\"line\">  // .. </span><br><span class=\"line\">  return true, nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个项目最棘手的部分是解析日志文件；主要是由于差一错误。我使用的算法相当幼稚。它进行了太多的系统调用，但我想尽早发布而不是优化。我的直觉是读入缓冲区因此解析速度更快，但真正的性能胜利是并行解析日志文件，所以如果启动时间困扰了我，我会优先解决这个问题！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 解析一个 bitcask-lite 的日志文件</span><br><span class=\"line\"></span><br><span class=\"line\">// Loop:</span><br><span class=\"line\">// - expire    = ReadBytes(COMMA)</span><br><span class=\"line\">//   - EOF error? return</span><br><span class=\"line\">// - keySize   = ReadBytes(COMMA)</span><br><span class=\"line\">// - valueSize = ReadBytes(COMMA)</span><br><span class=\"line\">// - key       = Read(keySize + 1)</span><br><span class=\"line\">// - value     = Discard(valueSize+ 1)</span><br></pre></td></tr></table></figure>\n<h2 id=\"HTTP-API\"><a href=\"#HTTP-API\" class=\"headerlink\" title=\"HTTP API\"></a>HTTP API</h2><p>我在一张便利贴上草拟了一下 API 就开始了这个项目。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/get?key=a</span><br><span class=\"line\">/delete?key=c</span><br><span class=\"line\">/set?key=b&amp;expire=1759300313415</span><br><span class=\"line\">  - HTTP body is read as the value</span><br><span class=\"line\">  - expire is optional (default is infinite)</span><br></pre></td></tr></table></figure>\n<p>完成之后，我看到测试代码的行数超过了其他的代码。这大体上说明了软件的复杂度。我可以一口气描述这个 API，但我花了好几个小时来用测试和修复来覆盖每个边界值用例。</p>\n<p>服务器代码位于<code>func main()</code>并使用普通的旧 <a href=\"https://pkg.go.dev/net/http\" target=\"_blank\" rel=\"noopener\">net/http</a> 。由于无法从 Go 中测试主要功能，我使用了一个我之前在其实项目中使用过的测试模式，它是一个用 Python 编写的端到端的测试脚本，它生成一个服务器进程，点击它，然后可以进行断言测试。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 用 dev 命令去启动服务器</span><br><span class=\"line\">proc = subprocess.Popen(</span><br><span class=\"line\">    [&quot;go&quot;, &quot;run&quot;, &quot;.&quot;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"># 测试获取一个缺失的键</span><br><span class=\"line\">g = requests.get(f&quot;&#123;addr&#125;/get?key=z&quot;)</span><br><span class=\"line\">print(g.status_code, g.text)</span><br><span class=\"line\">assert g.status_code == 404</span><br><span class=\"line\"></span><br><span class=\"line\"># ^ 失败断言以非零退出代码退出</span><br><span class=\"line\"># 导致任何持续集成 (CI) 流程失败</span><br><span class=\"line\"># 或其他测试运行器</span><br></pre></td></tr></table></figure>\n<h2 id=\"缺失的部分\"><a href=\"#缺失的部分\" class=\"headerlink\" title=\"缺失的部分\"></a>缺失的部分</h2><p>Bitcask 的<a href=\"https://riak.com/assets/bitcask-intro.pdf\" target=\"_blank\" rel=\"noopener\">设计规范</a>还描述了如何随着时间的推移清理数据库。现在，bitcask-lite 越来越大。过期的数据们永远存在于磁盘上。</p>\n<p>Bitcask 可以将多个文件合并成更紧凑的形式，并生成提示文件以加快启动时间 —— 在此过程中删除过期的密钥。此合并过程对性能有轻微影响，但可以在低流量期间执行。</p>\n<blockquote>\n<p>为了在白天处理大量写入而不降低性能，您可能希望将合并限制在非高峰期。将合并窗口设置为一天中流量较低的时间会有所帮助。</p>\n</blockquote>\n<p>我还跳过了添加 CRC（循环冗余校验），我不是设置逻辑删除值，我只是假装一个密钥已设置为零字节，过期时间为 1970 年。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Set 处理 key, expire, value</span><br><span class=\"line\">err := logStore.Set(key, 0, []byte(&quot;&quot;))</span><br><span class=\"line\">if err != nil &#123;</span><br><span class=\"line\">  log.Printf(&quot;couldn&apos;t delete %s: %s&quot;, key, err)</span><br><span class=\"line\">  w.WriteHeader(500)</span><br><span class=\"line\">  return</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我对我走的捷径很满意。到目前为止，我的“玩具”数据库一直运转良好。</p>\n<p>当然，将 SQLite 与单个表一起使用会更快。但我主要是为了好玩写这个数据库。我确实想好奇 <a href=\"https://github.com/healeycodes/bitcask-lite\" target=\"_blank\" rel=\"noopener\">bitcask-lite</a> 和 SQLite + server 之间的性能变化。当我无法弄清楚是否可以将单个 SQLite 值流式传输到客户端时，我准备设置一些基准。如果你知道，请<a href=\"mailto:healeycodes@gmail.com\" target=\"_blank\" rel=\"noopener\">告诉我</a>！</p>\n<blockquote>\n<p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href=\"https://juejin.im\" target=\"_blank\" rel=\"noopener\">掘金</a> 上的英文分享文章。内容覆盖 <a href=\"https://github.com/xitu/gold-miner#android\" target=\"_blank\" rel=\"noopener\">Android</a>、<a href=\"https://github.com/xitu/gold-miner#ios\" target=\"_blank\" rel=\"noopener\">iOS</a>、<a href=\"https://github.com/xitu/gold-miner#前端\" target=\"_blank\" rel=\"noopener\">前端</a>、<a href=\"https://github.com/xitu/gold-miner#后端\" target=\"_blank\" rel=\"noopener\">后端</a>、<a href=\"https://github.com/xitu/gold-miner#区块链\" target=\"_blank\" rel=\"noopener\">区块链</a>、<a href=\"https://github.com/xitu/gold-miner#产品\" target=\"_blank\" rel=\"noopener\">产品</a>、<a href=\"https://github.com/xitu/gold-miner#设计\" target=\"_blank\" rel=\"noopener\">设计</a>、<a href=\"https://github.com/xitu/gold-miner#人工智能\" target=\"_blank\" rel=\"noopener\">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a>、<a href=\"http://weibo.com/juejinfanyi\" target=\"_blank\" rel=\"noopener\">官方微博</a>、<a href=\"https://zhuanlan.zhihu.com/juejinfanyi\" target=\"_blank\" rel=\"noopener\">知乎专栏</a>。</p>\n</blockquote>\n"},{"title":"如何让一个历史包袱重的模块重获新生","date":"2021-07-02T12:12:50.000Z","description":"之前重构了一个历史包袱重，代码多且复杂，性能不好的模块。积累了一些经验，分享给uu们。","_content":"[TOC]\n\n\n\n# 如何让一个历史包袱重的模块重获新生\n\n\n\n之前重构了一个历史包袱重，代码多且复杂，性能不好的模块。积累了一些经验，分享给uu们。\n\n重构的背景是，这个模块是售货袋，也就是直播中的可购买商品列表。当时存在如下几个问题，\n\n1. 严重的贫血领域模型。对象类里只是单纯的getter/setter方法，没有任何行为。所有的查询、处理、组装都是通过service类里的方法堆积出来的，最主要的查询方法有250多行。\n2. 有大量的重复代码和重复调用，根本原因还是代码逻辑不清晰。不知道大家有没有在开发的时候遇到这样的情况：当你需要某个接口的数据在前面已经查过了但藏的比较深，你根本就没看到，或者想获取只能大幅改动代码并回归测试一遍。\n3. 这个模块使用了流程引擎，因为代码是割裂的，可读性差，不方便排查问题。\n\n\n\n针对这三个问题，本文从三个方面展开，一是如何实践DDD的，对系统进行领域拆分后，用能力下沉治理由贫血症引起的失忆症。二是针对售货袋这种读多写少的场景，对接口主流程进行治理，介绍了一些在这个场景下比较常见的手段。三简单介绍了为什么售货袋不需要流程引擎。\n\n\n\n## 一、实践DDD\n\n\n\n### 领域拆分\n\n原本直播是根据技术领域区划分的：直播应用、云服务应用、数据库操作应用。这样划分的问题是，所有业务的代码都堆积在一个大应用里，非核心业务很容易影响到核心业务。\n\n重构后，根据领域去划分为：直播间、主播、商品、云服务，去掉了数据库操作应用这种以技术划分的应用。\n\n这样划分后，对于人，团队的分工会更加明确，一个开发人员可以全身心的投入到相关的一个单独的上下文中。经常听到的话是“商品相关的需求/问题，找xx同学”。\n\n对于事，可以减少系统依赖和耦合关系。\n\n\n\n### 治理贫血模型\n\n为什么贫血模型不好呢？因为它没有对同类代码进行分类和封装，直接表现是贫血模式下的主流程会穿插很多不重要的步骤。当时售货袋模块的查询购物袋基本信息这个主流程就有250行左右的代码，包含了查询逻辑的过滤、RPC接口调用、查询结果处理、返回值组装等。主流程代码意图会渐渐不明确，我们将这种情况称为**由贫血症引起的失忆症。**\n\n#### 能力下沉\n\n对于这种情况，可以通过能力下沉去治理。什么叫能力下沉呢？即将有逻辑的代码封装到合适的实体里。\n\n打个比方，判断一个商品是否在秒杀状态的逻辑：“商品有秒杀促销并且在秒杀状态”。就是一个很好的例子，应当这个逻辑下沉到商品实体里。\n\n坏代码的的味道，随处可见这种代码，\n\n```\n//如果是秒杀状态\nif(dto.getPromotionType() == PromotionType.SEC_KILL.getValue()\n        && dto.getSeckillType() == SecKillType.SEC_KILL.getValue()){\n        do some thing......\n        }\n......\n//如果不是秒杀状态\nif(dto.getPromotionType() != PromotionType.SEC_KILL.getValue()\n        || this.getSeckillType() != SecKillType.SEC_KILL.getValue()){\n        do some thing......\n}\n```\n\n\n\n好代码示例，在商品的实体新增方法，将逻辑下沉。\n\n```\n public boolean isSecKillStatus() {\n        this.getPromotionType() == PromotionType.SEC_KILL.getValue()\n        && this.getSeckillType() == SecKillType.SEC_KILL.getValue();\n}\n```\n\n\n\n主流程里：\n\n```\n//如果是秒杀状态\nif(dto.isSecKillStatus()){\n        do some thing......\n}\n......\n//如果不是秒杀状态\nif(!dto.isSecKillStatus()){\n        do some thing......\n}\n```\n\n\n\n能力下沉后有如下好处：\n\n- 1.抽取了复用代码，从而消除重复代码，如果逻辑变了，只需改动一处代码。\n- 2.用方法的命名增加了代码的可读性。因为你抽取肯定是要抽一个方法的吧，那方法肯定得取一个名字吧，而这个名字会出现在主流程中，起一个易懂名字能极大的提高的可读性。用方法名解释代码方面比注释更直接优雅。\n- 3.封装，看主流程的时候，其实不关心商品是怎么被判断为秒杀商品的，这段逻辑会打断阅读者的思路。\n\n\n\n## 二、主流程治理\n\n将模块进行领域驱动改造后，大部分可复用的能力会沉淀到实体里，售货袋查询的主流程就清晰了很多。我们还可以做的更好一点，用一些读多写少场景的手段，对主流程进行代码改造。\n\n原本主流程是逻辑是：查询十几个下游的信息、对查询处理各种if else判断、对返回实体的组装。\n\n分析一下，在主流程里其实不需要太复杂的模式，把同样的动作放在一层，同层里使用组合方法，尽量保持主流程里的都是重要简单代码。\n\n改造后分为：\n\n#### agg参数组装层\n\n这一层是为了将各入口进行处理，各入口的都能使用统一的查询流程。前面提到之前的主流程有250行代码，但由于没有合并入口，这样的主流程方法有4份，使用agg参数组装层就可以将这4套代码合并成4套。下面具体分析这四套是怎么合并的。\n\n首先是，全量查询和增量查询的合并，全量查询查的全部商品，查询时会先查缓存。另一种是只查5个商品，叫增量精准查询，会调用RPC接口实时计价。原本提供给客户端的是两个接口，两个接口代码各一套，有大量重复代码。改造后，保留两个入口，合并两个接口底层逻辑，对于下层来说，它也不关心是哪个入口的查询。\n\n然后是新人专享商品和普通商品的合并，同样的，在agg层判断用户身份组装待查询的商品，对于下一层来说，它也不关心是商品是否是新人专享。\n\n各入口共享主流程的大部分代码，对于差异化查询，需要各自处理。\n\n```\nif (context.isNesUserItem()) {\n.......\n}\n```\n\n\n\n\n\n#### 线程上下文\n\n\n\n在文章最开始，提到了一种情况“当你需要某个接口的数据在前面已经查过了但藏的比较深，你根本就没看到，或者想获取只能大幅改动代码并回归测试一遍” 尤其是对于售货袋这种读多写少的场景。\n\n解决方法是：在主流程中引进一个上下文的概念，每个请求独享一个上下文。所有下文可能会用到的必要放到这个上下文里。\n\n*注意，这里说的上下文和DDD的限界上下文不一样，这里的上下文相当于一次请求的线程局部变量，DDD的限界上下文是指划分领域模型的边界。*\n\n#### 数据查询层\n\n调用接口查询数据，这一层尽量简单，查数据塞进上下文就好了。\n\n#### 组装层\n\n将数据进行一些逻辑处理，然后返回实体类。\n\n\n\n\n\n## 三、去除流程引擎\n\n首先流程引擎是什么？我们这边的流程引擎是将代码分成一个个节点，每个节点配置化，期望新需求可以通过配置的方式开发。这东西之前被引入到了售货袋，但给这个模块只带来了负担，几乎没有任何好处，我没有见过售货袋的某个需求是通过代码编排实现的。\n\n它最致命的缺点降低了代码的可读性，提高了排查问题的成本，引入了额外的复杂度，使得开发者有学习成本。代码很难阅读，因为他是用配置去把代码连在一起的，也就是说你必须一边看配置一边找代码。阅读尚且如此，更不要说问题排查。\n\n它适用于有流程编排的场景，比如首页，首页经常有需求变更，并且变更的内容大同小异，甚至有周期性。\n\n总之，在这次重构里，我废弃了售货袋模块的流程引擎。\n\n\n\n## 最后\n\n对DDD，我之前也读过关于领域模型的一些书，当时那些书都不太讲人话读也没读懂，各种名词云里雾里，后来被复杂的代码折磨，需要思考怎么去重构，带着问题再去找解决方案，很多概念就明朗起来了，变得对我有帮助了。\n\n本文主要介绍了，在一个历史包袱重的模块，如何使用DDD进行治理代码的一些经验。其实对这个模块的重构，还有很多性能方面的改造，也许下次再写一篇“如何提高接口性能50%以上”，这篇就只放关于代码风格的内容吧。\n\n\n\n","source":"_posts/DDD.md","raw":"---\ntitle: 如何让一个历史包袱重的模块重获新生\ndate: 2021-07-02 20:12:50\ncategories: 设计模式\ndescription: 之前重构了一个历史包袱重，代码多且复杂，性能不好的模块。积累了一些经验，分享给uu们。\n---\n[TOC]\n\n\n\n# 如何让一个历史包袱重的模块重获新生\n\n\n\n之前重构了一个历史包袱重，代码多且复杂，性能不好的模块。积累了一些经验，分享给uu们。\n\n重构的背景是，这个模块是售货袋，也就是直播中的可购买商品列表。当时存在如下几个问题，\n\n1. 严重的贫血领域模型。对象类里只是单纯的getter/setter方法，没有任何行为。所有的查询、处理、组装都是通过service类里的方法堆积出来的，最主要的查询方法有250多行。\n2. 有大量的重复代码和重复调用，根本原因还是代码逻辑不清晰。不知道大家有没有在开发的时候遇到这样的情况：当你需要某个接口的数据在前面已经查过了但藏的比较深，你根本就没看到，或者想获取只能大幅改动代码并回归测试一遍。\n3. 这个模块使用了流程引擎，因为代码是割裂的，可读性差，不方便排查问题。\n\n\n\n针对这三个问题，本文从三个方面展开，一是如何实践DDD的，对系统进行领域拆分后，用能力下沉治理由贫血症引起的失忆症。二是针对售货袋这种读多写少的场景，对接口主流程进行治理，介绍了一些在这个场景下比较常见的手段。三简单介绍了为什么售货袋不需要流程引擎。\n\n\n\n## 一、实践DDD\n\n\n\n### 领域拆分\n\n原本直播是根据技术领域区划分的：直播应用、云服务应用、数据库操作应用。这样划分的问题是，所有业务的代码都堆积在一个大应用里，非核心业务很容易影响到核心业务。\n\n重构后，根据领域去划分为：直播间、主播、商品、云服务，去掉了数据库操作应用这种以技术划分的应用。\n\n这样划分后，对于人，团队的分工会更加明确，一个开发人员可以全身心的投入到相关的一个单独的上下文中。经常听到的话是“商品相关的需求/问题，找xx同学”。\n\n对于事，可以减少系统依赖和耦合关系。\n\n\n\n### 治理贫血模型\n\n为什么贫血模型不好呢？因为它没有对同类代码进行分类和封装，直接表现是贫血模式下的主流程会穿插很多不重要的步骤。当时售货袋模块的查询购物袋基本信息这个主流程就有250行左右的代码，包含了查询逻辑的过滤、RPC接口调用、查询结果处理、返回值组装等。主流程代码意图会渐渐不明确，我们将这种情况称为**由贫血症引起的失忆症。**\n\n#### 能力下沉\n\n对于这种情况，可以通过能力下沉去治理。什么叫能力下沉呢？即将有逻辑的代码封装到合适的实体里。\n\n打个比方，判断一个商品是否在秒杀状态的逻辑：“商品有秒杀促销并且在秒杀状态”。就是一个很好的例子，应当这个逻辑下沉到商品实体里。\n\n坏代码的的味道，随处可见这种代码，\n\n```\n//如果是秒杀状态\nif(dto.getPromotionType() == PromotionType.SEC_KILL.getValue()\n        && dto.getSeckillType() == SecKillType.SEC_KILL.getValue()){\n        do some thing......\n        }\n......\n//如果不是秒杀状态\nif(dto.getPromotionType() != PromotionType.SEC_KILL.getValue()\n        || this.getSeckillType() != SecKillType.SEC_KILL.getValue()){\n        do some thing......\n}\n```\n\n\n\n好代码示例，在商品的实体新增方法，将逻辑下沉。\n\n```\n public boolean isSecKillStatus() {\n        this.getPromotionType() == PromotionType.SEC_KILL.getValue()\n        && this.getSeckillType() == SecKillType.SEC_KILL.getValue();\n}\n```\n\n\n\n主流程里：\n\n```\n//如果是秒杀状态\nif(dto.isSecKillStatus()){\n        do some thing......\n}\n......\n//如果不是秒杀状态\nif(!dto.isSecKillStatus()){\n        do some thing......\n}\n```\n\n\n\n能力下沉后有如下好处：\n\n- 1.抽取了复用代码，从而消除重复代码，如果逻辑变了，只需改动一处代码。\n- 2.用方法的命名增加了代码的可读性。因为你抽取肯定是要抽一个方法的吧，那方法肯定得取一个名字吧，而这个名字会出现在主流程中，起一个易懂名字能极大的提高的可读性。用方法名解释代码方面比注释更直接优雅。\n- 3.封装，看主流程的时候，其实不关心商品是怎么被判断为秒杀商品的，这段逻辑会打断阅读者的思路。\n\n\n\n## 二、主流程治理\n\n将模块进行领域驱动改造后，大部分可复用的能力会沉淀到实体里，售货袋查询的主流程就清晰了很多。我们还可以做的更好一点，用一些读多写少场景的手段，对主流程进行代码改造。\n\n原本主流程是逻辑是：查询十几个下游的信息、对查询处理各种if else判断、对返回实体的组装。\n\n分析一下，在主流程里其实不需要太复杂的模式，把同样的动作放在一层，同层里使用组合方法，尽量保持主流程里的都是重要简单代码。\n\n改造后分为：\n\n#### agg参数组装层\n\n这一层是为了将各入口进行处理，各入口的都能使用统一的查询流程。前面提到之前的主流程有250行代码，但由于没有合并入口，这样的主流程方法有4份，使用agg参数组装层就可以将这4套代码合并成4套。下面具体分析这四套是怎么合并的。\n\n首先是，全量查询和增量查询的合并，全量查询查的全部商品，查询时会先查缓存。另一种是只查5个商品，叫增量精准查询，会调用RPC接口实时计价。原本提供给客户端的是两个接口，两个接口代码各一套，有大量重复代码。改造后，保留两个入口，合并两个接口底层逻辑，对于下层来说，它也不关心是哪个入口的查询。\n\n然后是新人专享商品和普通商品的合并，同样的，在agg层判断用户身份组装待查询的商品，对于下一层来说，它也不关心是商品是否是新人专享。\n\n各入口共享主流程的大部分代码，对于差异化查询，需要各自处理。\n\n```\nif (context.isNesUserItem()) {\n.......\n}\n```\n\n\n\n\n\n#### 线程上下文\n\n\n\n在文章最开始，提到了一种情况“当你需要某个接口的数据在前面已经查过了但藏的比较深，你根本就没看到，或者想获取只能大幅改动代码并回归测试一遍” 尤其是对于售货袋这种读多写少的场景。\n\n解决方法是：在主流程中引进一个上下文的概念，每个请求独享一个上下文。所有下文可能会用到的必要放到这个上下文里。\n\n*注意，这里说的上下文和DDD的限界上下文不一样，这里的上下文相当于一次请求的线程局部变量，DDD的限界上下文是指划分领域模型的边界。*\n\n#### 数据查询层\n\n调用接口查询数据，这一层尽量简单，查数据塞进上下文就好了。\n\n#### 组装层\n\n将数据进行一些逻辑处理，然后返回实体类。\n\n\n\n\n\n## 三、去除流程引擎\n\n首先流程引擎是什么？我们这边的流程引擎是将代码分成一个个节点，每个节点配置化，期望新需求可以通过配置的方式开发。这东西之前被引入到了售货袋，但给这个模块只带来了负担，几乎没有任何好处，我没有见过售货袋的某个需求是通过代码编排实现的。\n\n它最致命的缺点降低了代码的可读性，提高了排查问题的成本，引入了额外的复杂度，使得开发者有学习成本。代码很难阅读，因为他是用配置去把代码连在一起的，也就是说你必须一边看配置一边找代码。阅读尚且如此，更不要说问题排查。\n\n它适用于有流程编排的场景，比如首页，首页经常有需求变更，并且变更的内容大同小异，甚至有周期性。\n\n总之，在这次重构里，我废弃了售货袋模块的流程引擎。\n\n\n\n## 最后\n\n对DDD，我之前也读过关于领域模型的一些书，当时那些书都不太讲人话读也没读懂，各种名词云里雾里，后来被复杂的代码折磨，需要思考怎么去重构，带着问题再去找解决方案，很多概念就明朗起来了，变得对我有帮助了。\n\n本文主要介绍了，在一个历史包袱重的模块，如何使用DDD进行治理代码的一些经验。其实对这个模块的重构，还有很多性能方面的改造，也许下次再写一篇“如何提高接口性能50%以上”，这篇就只放关于代码风格的内容吧。\n\n\n\n","slug":"DDD","published":1,"updated":"2022-07-07T12:23:08.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qk7000kw9rpa0m0l2bi","content":"<p>[TOC]</p>\n<h1 id=\"如何让一个历史包袱重的模块重获新生\"><a href=\"#如何让一个历史包袱重的模块重获新生\" class=\"headerlink\" title=\"如何让一个历史包袱重的模块重获新生\"></a>如何让一个历史包袱重的模块重获新生</h1><p>之前重构了一个历史包袱重，代码多且复杂，性能不好的模块。积累了一些经验，分享给uu们。</p>\n<p>重构的背景是，这个模块是售货袋，也就是直播中的可购买商品列表。当时存在如下几个问题，</p>\n<ol>\n<li>严重的贫血领域模型。对象类里只是单纯的getter/setter方法，没有任何行为。所有的查询、处理、组装都是通过service类里的方法堆积出来的，最主要的查询方法有250多行。</li>\n<li>有大量的重复代码和重复调用，根本原因还是代码逻辑不清晰。不知道大家有没有在开发的时候遇到这样的情况：当你需要某个接口的数据在前面已经查过了但藏的比较深，你根本就没看到，或者想获取只能大幅改动代码并回归测试一遍。</li>\n<li>这个模块使用了流程引擎，因为代码是割裂的，可读性差，不方便排查问题。</li>\n</ol>\n<p>针对这三个问题，本文从三个方面展开，一是如何实践DDD的，对系统进行领域拆分后，用能力下沉治理由贫血症引起的失忆症。二是针对售货袋这种读多写少的场景，对接口主流程进行治理，介绍了一些在这个场景下比较常见的手段。三简单介绍了为什么售货袋不需要流程引擎。</p>\n<h2 id=\"一、实践DDD\"><a href=\"#一、实践DDD\" class=\"headerlink\" title=\"一、实践DDD\"></a>一、实践DDD</h2><h3 id=\"领域拆分\"><a href=\"#领域拆分\" class=\"headerlink\" title=\"领域拆分\"></a>领域拆分</h3><p>原本直播是根据技术领域区划分的：直播应用、云服务应用、数据库操作应用。这样划分的问题是，所有业务的代码都堆积在一个大应用里，非核心业务很容易影响到核心业务。</p>\n<p>重构后，根据领域去划分为：直播间、主播、商品、云服务，去掉了数据库操作应用这种以技术划分的应用。</p>\n<p>这样划分后，对于人，团队的分工会更加明确，一个开发人员可以全身心的投入到相关的一个单独的上下文中。经常听到的话是“商品相关的需求/问题，找xx同学”。</p>\n<p>对于事，可以减少系统依赖和耦合关系。</p>\n<h3 id=\"治理贫血模型\"><a href=\"#治理贫血模型\" class=\"headerlink\" title=\"治理贫血模型\"></a>治理贫血模型</h3><p>为什么贫血模型不好呢？因为它没有对同类代码进行分类和封装，直接表现是贫血模式下的主流程会穿插很多不重要的步骤。当时售货袋模块的查询购物袋基本信息这个主流程就有250行左右的代码，包含了查询逻辑的过滤、RPC接口调用、查询结果处理、返回值组装等。主流程代码意图会渐渐不明确，我们将这种情况称为<strong>由贫血症引起的失忆症。</strong></p>\n<h4 id=\"能力下沉\"><a href=\"#能力下沉\" class=\"headerlink\" title=\"能力下沉\"></a>能力下沉</h4><p>对于这种情况，可以通过能力下沉去治理。什么叫能力下沉呢？即将有逻辑的代码封装到合适的实体里。</p>\n<p>打个比方，判断一个商品是否在秒杀状态的逻辑：“商品有秒杀促销并且在秒杀状态”。就是一个很好的例子，应当这个逻辑下沉到商品实体里。</p>\n<p>坏代码的的味道，随处可见这种代码，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//如果是秒杀状态</span><br><span class=\"line\">if(dto.getPromotionType() == PromotionType.SEC_KILL.getValue()</span><br><span class=\"line\">        &amp;&amp; dto.getSeckillType() == SecKillType.SEC_KILL.getValue())&#123;</span><br><span class=\"line\">        do some thing......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">......</span><br><span class=\"line\">//如果不是秒杀状态</span><br><span class=\"line\">if(dto.getPromotionType() != PromotionType.SEC_KILL.getValue()</span><br><span class=\"line\">        || this.getSeckillType() != SecKillType.SEC_KILL.getValue())&#123;</span><br><span class=\"line\">        do some thing......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好代码示例，在商品的实体新增方法，将逻辑下沉。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public boolean isSecKillStatus() &#123;</span><br><span class=\"line\">        this.getPromotionType() == PromotionType.SEC_KILL.getValue()</span><br><span class=\"line\">        &amp;&amp; this.getSeckillType() == SecKillType.SEC_KILL.getValue();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主流程里：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//如果是秒杀状态</span><br><span class=\"line\">if(dto.isSecKillStatus())&#123;</span><br><span class=\"line\">        do some thing......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">......</span><br><span class=\"line\">//如果不是秒杀状态</span><br><span class=\"line\">if(!dto.isSecKillStatus())&#123;</span><br><span class=\"line\">        do some thing......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>能力下沉后有如下好处：</p>\n<ul>\n<li>1.抽取了复用代码，从而消除重复代码，如果逻辑变了，只需改动一处代码。</li>\n<li>2.用方法的命名增加了代码的可读性。因为你抽取肯定是要抽一个方法的吧，那方法肯定得取一个名字吧，而这个名字会出现在主流程中，起一个易懂名字能极大的提高的可读性。用方法名解释代码方面比注释更直接优雅。</li>\n<li>3.封装，看主流程的时候，其实不关心商品是怎么被判断为秒杀商品的，这段逻辑会打断阅读者的思路。</li>\n</ul>\n<h2 id=\"二、主流程治理\"><a href=\"#二、主流程治理\" class=\"headerlink\" title=\"二、主流程治理\"></a>二、主流程治理</h2><p>将模块进行领域驱动改造后，大部分可复用的能力会沉淀到实体里，售货袋查询的主流程就清晰了很多。我们还可以做的更好一点，用一些读多写少场景的手段，对主流程进行代码改造。</p>\n<p>原本主流程是逻辑是：查询十几个下游的信息、对查询处理各种if else判断、对返回实体的组装。</p>\n<p>分析一下，在主流程里其实不需要太复杂的模式，把同样的动作放在一层，同层里使用组合方法，尽量保持主流程里的都是重要简单代码。</p>\n<p>改造后分为：</p>\n<h4 id=\"agg参数组装层\"><a href=\"#agg参数组装层\" class=\"headerlink\" title=\"agg参数组装层\"></a>agg参数组装层</h4><p>这一层是为了将各入口进行处理，各入口的都能使用统一的查询流程。前面提到之前的主流程有250行代码，但由于没有合并入口，这样的主流程方法有4份，使用agg参数组装层就可以将这4套代码合并成4套。下面具体分析这四套是怎么合并的。</p>\n<p>首先是，全量查询和增量查询的合并，全量查询查的全部商品，查询时会先查缓存。另一种是只查5个商品，叫增量精准查询，会调用RPC接口实时计价。原本提供给客户端的是两个接口，两个接口代码各一套，有大量重复代码。改造后，保留两个入口，合并两个接口底层逻辑，对于下层来说，它也不关心是哪个入口的查询。</p>\n<p>然后是新人专享商品和普通商品的合并，同样的，在agg层判断用户身份组装待查询的商品，对于下一层来说，它也不关心是商品是否是新人专享。</p>\n<p>各入口共享主流程的大部分代码，对于差异化查询，需要各自处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (context.isNesUserItem()) &#123;</span><br><span class=\"line\">.......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"线程上下文\"><a href=\"#线程上下文\" class=\"headerlink\" title=\"线程上下文\"></a>线程上下文</h4><p>在文章最开始，提到了一种情况“当你需要某个接口的数据在前面已经查过了但藏的比较深，你根本就没看到，或者想获取只能大幅改动代码并回归测试一遍” 尤其是对于售货袋这种读多写少的场景。</p>\n<p>解决方法是：在主流程中引进一个上下文的概念，每个请求独享一个上下文。所有下文可能会用到的必要放到这个上下文里。</p>\n<p><em>注意，这里说的上下文和DDD的限界上下文不一样，这里的上下文相当于一次请求的线程局部变量，DDD的限界上下文是指划分领域模型的边界。</em></p>\n<h4 id=\"数据查询层\"><a href=\"#数据查询层\" class=\"headerlink\" title=\"数据查询层\"></a>数据查询层</h4><p>调用接口查询数据，这一层尽量简单，查数据塞进上下文就好了。</p>\n<h4 id=\"组装层\"><a href=\"#组装层\" class=\"headerlink\" title=\"组装层\"></a>组装层</h4><p>将数据进行一些逻辑处理，然后返回实体类。</p>\n<h2 id=\"三、去除流程引擎\"><a href=\"#三、去除流程引擎\" class=\"headerlink\" title=\"三、去除流程引擎\"></a>三、去除流程引擎</h2><p>首先流程引擎是什么？我们这边的流程引擎是将代码分成一个个节点，每个节点配置化，期望新需求可以通过配置的方式开发。这东西之前被引入到了售货袋，但给这个模块只带来了负担，几乎没有任何好处，我没有见过售货袋的某个需求是通过代码编排实现的。</p>\n<p>它最致命的缺点降低了代码的可读性，提高了排查问题的成本，引入了额外的复杂度，使得开发者有学习成本。代码很难阅读，因为他是用配置去把代码连在一起的，也就是说你必须一边看配置一边找代码。阅读尚且如此，更不要说问题排查。</p>\n<p>它适用于有流程编排的场景，比如首页，首页经常有需求变更，并且变更的内容大同小异，甚至有周期性。</p>\n<p>总之，在这次重构里，我废弃了售货袋模块的流程引擎。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>对DDD，我之前也读过关于领域模型的一些书，当时那些书都不太讲人话读也没读懂，各种名词云里雾里，后来被复杂的代码折磨，需要思考怎么去重构，带着问题再去找解决方案，很多概念就明朗起来了，变得对我有帮助了。</p>\n<p>本文主要介绍了，在一个历史包袱重的模块，如何使用DDD进行治理代码的一些经验。其实对这个模块的重构，还有很多性能方面的改造，也许下次再写一篇“如何提高接口性能50%以上”，这篇就只放关于代码风格的内容吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"如何让一个历史包袱重的模块重获新生\"><a href=\"#如何让一个历史包袱重的模块重获新生\" class=\"headerlink\" title=\"如何让一个历史包袱重的模块重获新生\"></a>如何让一个历史包袱重的模块重获新生</h1><p>之前重构了一个历史包袱重，代码多且复杂，性能不好的模块。积累了一些经验，分享给uu们。</p>\n<p>重构的背景是，这个模块是售货袋，也就是直播中的可购买商品列表。当时存在如下几个问题，</p>\n<ol>\n<li>严重的贫血领域模型。对象类里只是单纯的getter/setter方法，没有任何行为。所有的查询、处理、组装都是通过service类里的方法堆积出来的，最主要的查询方法有250多行。</li>\n<li>有大量的重复代码和重复调用，根本原因还是代码逻辑不清晰。不知道大家有没有在开发的时候遇到这样的情况：当你需要某个接口的数据在前面已经查过了但藏的比较深，你根本就没看到，或者想获取只能大幅改动代码并回归测试一遍。</li>\n<li>这个模块使用了流程引擎，因为代码是割裂的，可读性差，不方便排查问题。</li>\n</ol>\n<p>针对这三个问题，本文从三个方面展开，一是如何实践DDD的，对系统进行领域拆分后，用能力下沉治理由贫血症引起的失忆症。二是针对售货袋这种读多写少的场景，对接口主流程进行治理，介绍了一些在这个场景下比较常见的手段。三简单介绍了为什么售货袋不需要流程引擎。</p>\n<h2 id=\"一、实践DDD\"><a href=\"#一、实践DDD\" class=\"headerlink\" title=\"一、实践DDD\"></a>一、实践DDD</h2><h3 id=\"领域拆分\"><a href=\"#领域拆分\" class=\"headerlink\" title=\"领域拆分\"></a>领域拆分</h3><p>原本直播是根据技术领域区划分的：直播应用、云服务应用、数据库操作应用。这样划分的问题是，所有业务的代码都堆积在一个大应用里，非核心业务很容易影响到核心业务。</p>\n<p>重构后，根据领域去划分为：直播间、主播、商品、云服务，去掉了数据库操作应用这种以技术划分的应用。</p>\n<p>这样划分后，对于人，团队的分工会更加明确，一个开发人员可以全身心的投入到相关的一个单独的上下文中。经常听到的话是“商品相关的需求/问题，找xx同学”。</p>\n<p>对于事，可以减少系统依赖和耦合关系。</p>\n<h3 id=\"治理贫血模型\"><a href=\"#治理贫血模型\" class=\"headerlink\" title=\"治理贫血模型\"></a>治理贫血模型</h3><p>为什么贫血模型不好呢？因为它没有对同类代码进行分类和封装，直接表现是贫血模式下的主流程会穿插很多不重要的步骤。当时售货袋模块的查询购物袋基本信息这个主流程就有250行左右的代码，包含了查询逻辑的过滤、RPC接口调用、查询结果处理、返回值组装等。主流程代码意图会渐渐不明确，我们将这种情况称为<strong>由贫血症引起的失忆症。</strong></p>\n<h4 id=\"能力下沉\"><a href=\"#能力下沉\" class=\"headerlink\" title=\"能力下沉\"></a>能力下沉</h4><p>对于这种情况，可以通过能力下沉去治理。什么叫能力下沉呢？即将有逻辑的代码封装到合适的实体里。</p>\n<p>打个比方，判断一个商品是否在秒杀状态的逻辑：“商品有秒杀促销并且在秒杀状态”。就是一个很好的例子，应当这个逻辑下沉到商品实体里。</p>\n<p>坏代码的的味道，随处可见这种代码，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//如果是秒杀状态</span><br><span class=\"line\">if(dto.getPromotionType() == PromotionType.SEC_KILL.getValue()</span><br><span class=\"line\">        &amp;&amp; dto.getSeckillType() == SecKillType.SEC_KILL.getValue())&#123;</span><br><span class=\"line\">        do some thing......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">......</span><br><span class=\"line\">//如果不是秒杀状态</span><br><span class=\"line\">if(dto.getPromotionType() != PromotionType.SEC_KILL.getValue()</span><br><span class=\"line\">        || this.getSeckillType() != SecKillType.SEC_KILL.getValue())&#123;</span><br><span class=\"line\">        do some thing......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好代码示例，在商品的实体新增方法，将逻辑下沉。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public boolean isSecKillStatus() &#123;</span><br><span class=\"line\">        this.getPromotionType() == PromotionType.SEC_KILL.getValue()</span><br><span class=\"line\">        &amp;&amp; this.getSeckillType() == SecKillType.SEC_KILL.getValue();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主流程里：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//如果是秒杀状态</span><br><span class=\"line\">if(dto.isSecKillStatus())&#123;</span><br><span class=\"line\">        do some thing......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">......</span><br><span class=\"line\">//如果不是秒杀状态</span><br><span class=\"line\">if(!dto.isSecKillStatus())&#123;</span><br><span class=\"line\">        do some thing......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>能力下沉后有如下好处：</p>\n<ul>\n<li>1.抽取了复用代码，从而消除重复代码，如果逻辑变了，只需改动一处代码。</li>\n<li>2.用方法的命名增加了代码的可读性。因为你抽取肯定是要抽一个方法的吧，那方法肯定得取一个名字吧，而这个名字会出现在主流程中，起一个易懂名字能极大的提高的可读性。用方法名解释代码方面比注释更直接优雅。</li>\n<li>3.封装，看主流程的时候，其实不关心商品是怎么被判断为秒杀商品的，这段逻辑会打断阅读者的思路。</li>\n</ul>\n<h2 id=\"二、主流程治理\"><a href=\"#二、主流程治理\" class=\"headerlink\" title=\"二、主流程治理\"></a>二、主流程治理</h2><p>将模块进行领域驱动改造后，大部分可复用的能力会沉淀到实体里，售货袋查询的主流程就清晰了很多。我们还可以做的更好一点，用一些读多写少场景的手段，对主流程进行代码改造。</p>\n<p>原本主流程是逻辑是：查询十几个下游的信息、对查询处理各种if else判断、对返回实体的组装。</p>\n<p>分析一下，在主流程里其实不需要太复杂的模式，把同样的动作放在一层，同层里使用组合方法，尽量保持主流程里的都是重要简单代码。</p>\n<p>改造后分为：</p>\n<h4 id=\"agg参数组装层\"><a href=\"#agg参数组装层\" class=\"headerlink\" title=\"agg参数组装层\"></a>agg参数组装层</h4><p>这一层是为了将各入口进行处理，各入口的都能使用统一的查询流程。前面提到之前的主流程有250行代码，但由于没有合并入口，这样的主流程方法有4份，使用agg参数组装层就可以将这4套代码合并成4套。下面具体分析这四套是怎么合并的。</p>\n<p>首先是，全量查询和增量查询的合并，全量查询查的全部商品，查询时会先查缓存。另一种是只查5个商品，叫增量精准查询，会调用RPC接口实时计价。原本提供给客户端的是两个接口，两个接口代码各一套，有大量重复代码。改造后，保留两个入口，合并两个接口底层逻辑，对于下层来说，它也不关心是哪个入口的查询。</p>\n<p>然后是新人专享商品和普通商品的合并，同样的，在agg层判断用户身份组装待查询的商品，对于下一层来说，它也不关心是商品是否是新人专享。</p>\n<p>各入口共享主流程的大部分代码，对于差异化查询，需要各自处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (context.isNesUserItem()) &#123;</span><br><span class=\"line\">.......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"线程上下文\"><a href=\"#线程上下文\" class=\"headerlink\" title=\"线程上下文\"></a>线程上下文</h4><p>在文章最开始，提到了一种情况“当你需要某个接口的数据在前面已经查过了但藏的比较深，你根本就没看到，或者想获取只能大幅改动代码并回归测试一遍” 尤其是对于售货袋这种读多写少的场景。</p>\n<p>解决方法是：在主流程中引进一个上下文的概念，每个请求独享一个上下文。所有下文可能会用到的必要放到这个上下文里。</p>\n<p><em>注意，这里说的上下文和DDD的限界上下文不一样，这里的上下文相当于一次请求的线程局部变量，DDD的限界上下文是指划分领域模型的边界。</em></p>\n<h4 id=\"数据查询层\"><a href=\"#数据查询层\" class=\"headerlink\" title=\"数据查询层\"></a>数据查询层</h4><p>调用接口查询数据，这一层尽量简单，查数据塞进上下文就好了。</p>\n<h4 id=\"组装层\"><a href=\"#组装层\" class=\"headerlink\" title=\"组装层\"></a>组装层</h4><p>将数据进行一些逻辑处理，然后返回实体类。</p>\n<h2 id=\"三、去除流程引擎\"><a href=\"#三、去除流程引擎\" class=\"headerlink\" title=\"三、去除流程引擎\"></a>三、去除流程引擎</h2><p>首先流程引擎是什么？我们这边的流程引擎是将代码分成一个个节点，每个节点配置化，期望新需求可以通过配置的方式开发。这东西之前被引入到了售货袋，但给这个模块只带来了负担，几乎没有任何好处，我没有见过售货袋的某个需求是通过代码编排实现的。</p>\n<p>它最致命的缺点降低了代码的可读性，提高了排查问题的成本，引入了额外的复杂度，使得开发者有学习成本。代码很难阅读，因为他是用配置去把代码连在一起的，也就是说你必须一边看配置一边找代码。阅读尚且如此，更不要说问题排查。</p>\n<p>它适用于有流程编排的场景，比如首页，首页经常有需求变更，并且变更的内容大同小异，甚至有周期性。</p>\n<p>总之，在这次重构里，我废弃了售货袋模块的流程引擎。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>对DDD，我之前也读过关于领域模型的一些书，当时那些书都不太讲人话读也没读懂，各种名词云里雾里，后来被复杂的代码折磨，需要思考怎么去重构，带着问题再去找解决方案，很多概念就明朗起来了，变得对我有帮助了。</p>\n<p>本文主要介绍了，在一个历史包袱重的模块，如何使用DDD进行治理代码的一些经验。其实对这个模块的重构，还有很多性能方面的改造，也许下次再写一篇“如何提高接口性能50%以上”，这篇就只放关于代码风格的内容吧。</p>\n"},{"title":"javaSE（下）","date":"2018-10-10T13:00:50.000Z","description":"关于java异常，IO，集合。","_content":"# 异常\n## 当finally中有返回语句\n当try和finally中都有有返回语句会执行哪一个？\n请看下面代码，猜猜程序的运行结果是？\n```\npublic class Test {\n    public static int testFinally() {\n        try {\n            return 1;\n        } catch (Exception ex) {\n            return 2;\n        } finally {\n            System.out.println(\"execute finally\");\n            return 3;\n        }\n    }\n    public static void main(String[] args) {\n        int result = testFinally();\n        System.out.println(result);\n    }\n}\n```\n\n程序在执行try中遇到return语句时，会先将返回值储存到一个指定位置，然后执行finally代码块。（除非碰到exit(0)函数，就直接结束不执行finally）\n如果finally里面有返回语句将会覆盖其它返回语句，最终执行finally的return语句，储存中的return语句被回收。\n如果finally 没有返回语句，则执行完finally按储存中的return来。\n因此运行结果是:execute finally 3\n\n## 常见的runtime exception(运行时异常)：\n(不是必须进行try catch的异常 )\nNullPointerException 空指针异常\nArithmeticException 算术异常，比如除数为零\nClassCastException 类型转换异常\nConcurrentModificationException 同步修改异常，遍历一个集合的时候，删除集合的元素，就会抛出该异常 \nIndexOutOfBoundsException 数组下标越界异常\nNegativeArraySizeException 为数组分配的空间是负数异常\n\n## throw和throws的区别\n举个栗子\nthrow是语句抛出一个异常  \n```\n    String s = \"abc\"; \n    if(s.equals(\"abc\")) { \n      throw new NumberFormatException(); \n    }\n```\n\nthrows是方法可能抛出异常的声明\n`public static void function() throws NumberFormatException{ `\n\n\n \n# 集合\n## 基础概念\n- Java容器类类库的用途是\"保存对象\"，并将其划分为两个不同的概念：\n1) Collection\n一组\"对立\"的元素，通常这些元素都服从某种规则\n　　1.1) List必须保持元素特定的顺序\n　　1.2) Set不能有重复元素\n　　1.3) Queue保持一个队列(先进先出)的顺序\n2) Map\n一组成对的\"键值对\"对象\n\n\n- Collection与Collections\nCollection是所有集合类的根接口；\nCollections是提供集合操作的工具类；常用方法如下\nreverse\t反转\t\nshuffle\t混淆\nsort\t排序\t\nswap\t交换（交换0和5下标的数据后）` Collections.swap(numbers,0,5);`\nrotate\t滚动(把集合中的数据向右滚动2个单位)\t `Collections.rotate(numbers,2);`\nsynchronizedList\t线程安全化\n\n## 常用集合\n### ArrayList\n代码展示ArrayList常用方法\n```\npublic static void main(String[] args) {\n    List<String> animal = new ArrayList<String>();\n    //增\n    animal.add(\"松鼠\");\n    animal.add(1, \"花猪\");\n    //删\n    animal.remove(0);\n    animal.remove(\"花猪\");\n    //查\n    System.out.println(animal.get(1));//根据位置获取对象\n    System.out.println(animal.indexOf(\"松鼠\"));//查对象的位置\n    //改\n    animal.set(0, \"猫\");\n    \n    \n    //获取大小\n    System.out.println(animal.size());\n    \n    //判断是否包含\n    System.out.println(animal.contains(\"小狗\"));\n    \n    //把另一个容器所有对象都加进来\n    ArrayList human = new ArrayList();\n    animal.addAll(human);\n    \n    //转为数组，类型要是一样的哦\n    String[] array = new String[animal.size()];\n    animal.toArray(array);\n}\n```\n\n# IO流（待完善）\n","source":"_posts/javaSE下.md","raw":"---\ntitle: javaSE（下）\ndate: 2018-10-10 21:00:50\ncategories: java\ndescription: 关于java异常，IO，集合。\n---\n# 异常\n## 当finally中有返回语句\n当try和finally中都有有返回语句会执行哪一个？\n请看下面代码，猜猜程序的运行结果是？\n```\npublic class Test {\n    public static int testFinally() {\n        try {\n            return 1;\n        } catch (Exception ex) {\n            return 2;\n        } finally {\n            System.out.println(\"execute finally\");\n            return 3;\n        }\n    }\n    public static void main(String[] args) {\n        int result = testFinally();\n        System.out.println(result);\n    }\n}\n```\n\n程序在执行try中遇到return语句时，会先将返回值储存到一个指定位置，然后执行finally代码块。（除非碰到exit(0)函数，就直接结束不执行finally）\n如果finally里面有返回语句将会覆盖其它返回语句，最终执行finally的return语句，储存中的return语句被回收。\n如果finally 没有返回语句，则执行完finally按储存中的return来。\n因此运行结果是:execute finally 3\n\n## 常见的runtime exception(运行时异常)：\n(不是必须进行try catch的异常 )\nNullPointerException 空指针异常\nArithmeticException 算术异常，比如除数为零\nClassCastException 类型转换异常\nConcurrentModificationException 同步修改异常，遍历一个集合的时候，删除集合的元素，就会抛出该异常 \nIndexOutOfBoundsException 数组下标越界异常\nNegativeArraySizeException 为数组分配的空间是负数异常\n\n## throw和throws的区别\n举个栗子\nthrow是语句抛出一个异常  \n```\n    String s = \"abc\"; \n    if(s.equals(\"abc\")) { \n      throw new NumberFormatException(); \n    }\n```\n\nthrows是方法可能抛出异常的声明\n`public static void function() throws NumberFormatException{ `\n\n\n \n# 集合\n## 基础概念\n- Java容器类类库的用途是\"保存对象\"，并将其划分为两个不同的概念：\n1) Collection\n一组\"对立\"的元素，通常这些元素都服从某种规则\n　　1.1) List必须保持元素特定的顺序\n　　1.2) Set不能有重复元素\n　　1.3) Queue保持一个队列(先进先出)的顺序\n2) Map\n一组成对的\"键值对\"对象\n\n\n- Collection与Collections\nCollection是所有集合类的根接口；\nCollections是提供集合操作的工具类；常用方法如下\nreverse\t反转\t\nshuffle\t混淆\nsort\t排序\t\nswap\t交换（交换0和5下标的数据后）` Collections.swap(numbers,0,5);`\nrotate\t滚动(把集合中的数据向右滚动2个单位)\t `Collections.rotate(numbers,2);`\nsynchronizedList\t线程安全化\n\n## 常用集合\n### ArrayList\n代码展示ArrayList常用方法\n```\npublic static void main(String[] args) {\n    List<String> animal = new ArrayList<String>();\n    //增\n    animal.add(\"松鼠\");\n    animal.add(1, \"花猪\");\n    //删\n    animal.remove(0);\n    animal.remove(\"花猪\");\n    //查\n    System.out.println(animal.get(1));//根据位置获取对象\n    System.out.println(animal.indexOf(\"松鼠\"));//查对象的位置\n    //改\n    animal.set(0, \"猫\");\n    \n    \n    //获取大小\n    System.out.println(animal.size());\n    \n    //判断是否包含\n    System.out.println(animal.contains(\"小狗\"));\n    \n    //把另一个容器所有对象都加进来\n    ArrayList human = new ArrayList();\n    animal.addAll(human);\n    \n    //转为数组，类型要是一样的哦\n    String[] array = new String[animal.size()];\n    animal.toArray(array);\n}\n```\n\n# IO流（待完善）\n","slug":"javaSE下","published":1,"updated":"2022-02-08T07:09:41.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qk8000mw9rp3v0vnd49","content":"<h1 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h1><h2 id=\"当finally中有返回语句\"><a href=\"#当finally中有返回语句\" class=\"headerlink\" title=\"当finally中有返回语句\"></a>当finally中有返回语句</h2><p>当try和finally中都有有返回语句会执行哪一个？<br>请看下面代码，猜猜程序的运行结果是？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    public static int testFinally() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            return 1;</span><br><span class=\"line\">        &#125; catch (Exception ex) &#123;</span><br><span class=\"line\">            return 2;</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            System.out.println(&quot;execute finally&quot;);</span><br><span class=\"line\">            return 3;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int result = testFinally();</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>程序在执行try中遇到return语句时，会先将返回值储存到一个指定位置，然后执行finally代码块。（除非碰到exit(0)函数，就直接结束不执行finally）<br>如果finally里面有返回语句将会覆盖其它返回语句，最终执行finally的return语句，储存中的return语句被回收。<br>如果finally 没有返回语句，则执行完finally按储存中的return来。<br>因此运行结果是:execute finally 3</p>\n<h2 id=\"常见的runtime-exception-运行时异常-：\"><a href=\"#常见的runtime-exception-运行时异常-：\" class=\"headerlink\" title=\"常见的runtime exception(运行时异常)：\"></a>常见的runtime exception(运行时异常)：</h2><p>(不是必须进行try catch的异常 )<br>NullPointerException 空指针异常<br>ArithmeticException 算术异常，比如除数为零<br>ClassCastException 类型转换异常<br>ConcurrentModificationException 同步修改异常，遍历一个集合的时候，删除集合的元素，就会抛出该异常<br>IndexOutOfBoundsException 数组下标越界异常<br>NegativeArraySizeException 为数组分配的空间是负数异常</p>\n<h2 id=\"throw和throws的区别\"><a href=\"#throw和throws的区别\" class=\"headerlink\" title=\"throw和throws的区别\"></a>throw和throws的区别</h2><p>举个栗子<br>throw是语句抛出一个异常<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = &quot;abc&quot;; </span><br><span class=\"line\">if(s.equals(&quot;abc&quot;)) &#123; </span><br><span class=\"line\">  throw new NumberFormatException(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>throws是方法可能抛出异常的声明<br><code>public static void function() throws NumberFormatException{</code></p>\n<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><ul>\n<li>Java容器类类库的用途是”保存对象”，并将其划分为两个不同的概念：<br>1) Collection<br>一组”对立”的元素，通常这些元素都服从某种规则<br>　　1.1) List必须保持元素特定的顺序<br>　　1.2) Set不能有重复元素<br>　　1.3) Queue保持一个队列(先进先出)的顺序<br>2) Map<br>一组成对的”键值对”对象</li>\n</ul>\n<ul>\n<li>Collection与Collections<br>Collection是所有集合类的根接口；<br>Collections是提供集合操作的工具类；常用方法如下<br>reverse    反转<br>shuffle    混淆<br>sort    排序<br>swap    交换（交换0和5下标的数据后）<code>Collections.swap(numbers,0,5);</code><br>rotate    滚动(把集合中的数据向右滚动2个单位)     <code>Collections.rotate(numbers,2);</code><br>synchronizedList    线程安全化</li>\n</ul>\n<h2 id=\"常用集合\"><a href=\"#常用集合\" class=\"headerlink\" title=\"常用集合\"></a>常用集合</h2><h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><p>代码展示ArrayList常用方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    List&lt;String&gt; animal = new ArrayList&lt;String&gt;();</span><br><span class=\"line\">    //增</span><br><span class=\"line\">    animal.add(&quot;松鼠&quot;);</span><br><span class=\"line\">    animal.add(1, &quot;花猪&quot;);</span><br><span class=\"line\">    //删</span><br><span class=\"line\">    animal.remove(0);</span><br><span class=\"line\">    animal.remove(&quot;花猪&quot;);</span><br><span class=\"line\">    //查</span><br><span class=\"line\">    System.out.println(animal.get(1));//根据位置获取对象</span><br><span class=\"line\">    System.out.println(animal.indexOf(&quot;松鼠&quot;));//查对象的位置</span><br><span class=\"line\">    //改</span><br><span class=\"line\">    animal.set(0, &quot;猫&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    //获取大小</span><br><span class=\"line\">    System.out.println(animal.size());</span><br><span class=\"line\">    </span><br><span class=\"line\">    //判断是否包含</span><br><span class=\"line\">    System.out.println(animal.contains(&quot;小狗&quot;));</span><br><span class=\"line\">    </span><br><span class=\"line\">    //把另一个容器所有对象都加进来</span><br><span class=\"line\">    ArrayList human = new ArrayList();</span><br><span class=\"line\">    animal.addAll(human);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //转为数组，类型要是一样的哦</span><br><span class=\"line\">    String[] array = new String[animal.size()];</span><br><span class=\"line\">    animal.toArray(array);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"IO流（待完善）\"><a href=\"#IO流（待完善）\" class=\"headerlink\" title=\"IO流（待完善）\"></a>IO流（待完善）</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h1><h2 id=\"当finally中有返回语句\"><a href=\"#当finally中有返回语句\" class=\"headerlink\" title=\"当finally中有返回语句\"></a>当finally中有返回语句</h2><p>当try和finally中都有有返回语句会执行哪一个？<br>请看下面代码，猜猜程序的运行结果是？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    public static int testFinally() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            return 1;</span><br><span class=\"line\">        &#125; catch (Exception ex) &#123;</span><br><span class=\"line\">            return 2;</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            System.out.println(&quot;execute finally&quot;);</span><br><span class=\"line\">            return 3;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int result = testFinally();</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>程序在执行try中遇到return语句时，会先将返回值储存到一个指定位置，然后执行finally代码块。（除非碰到exit(0)函数，就直接结束不执行finally）<br>如果finally里面有返回语句将会覆盖其它返回语句，最终执行finally的return语句，储存中的return语句被回收。<br>如果finally 没有返回语句，则执行完finally按储存中的return来。<br>因此运行结果是:execute finally 3</p>\n<h2 id=\"常见的runtime-exception-运行时异常-：\"><a href=\"#常见的runtime-exception-运行时异常-：\" class=\"headerlink\" title=\"常见的runtime exception(运行时异常)：\"></a>常见的runtime exception(运行时异常)：</h2><p>(不是必须进行try catch的异常 )<br>NullPointerException 空指针异常<br>ArithmeticException 算术异常，比如除数为零<br>ClassCastException 类型转换异常<br>ConcurrentModificationException 同步修改异常，遍历一个集合的时候，删除集合的元素，就会抛出该异常<br>IndexOutOfBoundsException 数组下标越界异常<br>NegativeArraySizeException 为数组分配的空间是负数异常</p>\n<h2 id=\"throw和throws的区别\"><a href=\"#throw和throws的区别\" class=\"headerlink\" title=\"throw和throws的区别\"></a>throw和throws的区别</h2><p>举个栗子<br>throw是语句抛出一个异常<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = &quot;abc&quot;; </span><br><span class=\"line\">if(s.equals(&quot;abc&quot;)) &#123; </span><br><span class=\"line\">  throw new NumberFormatException(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>throws是方法可能抛出异常的声明<br><code>public static void function() throws NumberFormatException{</code></p>\n<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><ul>\n<li>Java容器类类库的用途是”保存对象”，并将其划分为两个不同的概念：<br>1) Collection<br>一组”对立”的元素，通常这些元素都服从某种规则<br>　　1.1) List必须保持元素特定的顺序<br>　　1.2) Set不能有重复元素<br>　　1.3) Queue保持一个队列(先进先出)的顺序<br>2) Map<br>一组成对的”键值对”对象</li>\n</ul>\n<ul>\n<li>Collection与Collections<br>Collection是所有集合类的根接口；<br>Collections是提供集合操作的工具类；常用方法如下<br>reverse    反转<br>shuffle    混淆<br>sort    排序<br>swap    交换（交换0和5下标的数据后）<code>Collections.swap(numbers,0,5);</code><br>rotate    滚动(把集合中的数据向右滚动2个单位)     <code>Collections.rotate(numbers,2);</code><br>synchronizedList    线程安全化</li>\n</ul>\n<h2 id=\"常用集合\"><a href=\"#常用集合\" class=\"headerlink\" title=\"常用集合\"></a>常用集合</h2><h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><p>代码展示ArrayList常用方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    List&lt;String&gt; animal = new ArrayList&lt;String&gt;();</span><br><span class=\"line\">    //增</span><br><span class=\"line\">    animal.add(&quot;松鼠&quot;);</span><br><span class=\"line\">    animal.add(1, &quot;花猪&quot;);</span><br><span class=\"line\">    //删</span><br><span class=\"line\">    animal.remove(0);</span><br><span class=\"line\">    animal.remove(&quot;花猪&quot;);</span><br><span class=\"line\">    //查</span><br><span class=\"line\">    System.out.println(animal.get(1));//根据位置获取对象</span><br><span class=\"line\">    System.out.println(animal.indexOf(&quot;松鼠&quot;));//查对象的位置</span><br><span class=\"line\">    //改</span><br><span class=\"line\">    animal.set(0, &quot;猫&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    //获取大小</span><br><span class=\"line\">    System.out.println(animal.size());</span><br><span class=\"line\">    </span><br><span class=\"line\">    //判断是否包含</span><br><span class=\"line\">    System.out.println(animal.contains(&quot;小狗&quot;));</span><br><span class=\"line\">    </span><br><span class=\"line\">    //把另一个容器所有对象都加进来</span><br><span class=\"line\">    ArrayList human = new ArrayList();</span><br><span class=\"line\">    animal.addAll(human);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //转为数组，类型要是一样的哦</span><br><span class=\"line\">    String[] array = new String[animal.size()];</span><br><span class=\"line\">    animal.toArray(array);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"IO流（待完善）\"><a href=\"#IO流（待完善）\" class=\"headerlink\" title=\"IO流（待完善）\"></a>IO流（待完善）</h1>"},{"title":"javaEE","date":"2018-10-04T14:20:50.000Z","description":"javabean、servlet、jsp","_content":"\n# javabean\n三要素\n1.一个无参的构造函数\n2.属性私有化。\n3.get、set的方法。私有化的属性必须通过public类型的方法给其它程序，并且方法的命名也必须遵守一定的命名规范。\n\n# servlet\n## 写一个servlet\n第一步：html表单提交请求\n`<form action=\"login\" method=\"post\">`\n\n第二步：servlet类中的请求处理\n```\npublic class LoginServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n```\n\n第三步：配置web.xml\n```\n<servlet-name>L1</servlet-name>//类的缩写\n    <servlet-class>Myservlet.LoginServlet</servlet-class>//类的名称\n</servlet>\n\n<servlet-mapping>\n    <servlet-name>L1</servlet-name>//类的缩写，和上面一致就行\n    <url-pattern>/login</url-pattern>//映射为的url地址，注意有“/”。对应<form action=\"login\"\n</servlet-mapping>\n```\n## 处理请求的三种方法\n1、dopost、doget、service\ndoget：是默认方法，比如超链访问、地址栏直接输入某个地址。\n特点：1.不安全，提交数据会在浏览器地址栏显示出来\n2.不可以上传文件\n3.有大小的限制\n\ndopost：一般用于注册、修改请求\n特点：1.安全\n2.可以上传文件\n3.没有限制\n\n\n## request和reponse常用方法\n### request\n\n\n**request.getParameter(): 是常见的方法，用于获取单值的参数**\nrequest.getParameterValues(): 用于获取具有多值得参数，比如注册的时候提交的爱好，可以使多选的。\nrequest.getParameterMap(): 用于遍历所有的参数，并返回Map类型。\n\nrequest.getRequestURL(): 浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)\" +\nrequest.getRequestURI(): 浏览器发出请求的资源名部分，去掉了协议和主机名\" +\nrequest.getQueryString(): 请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到\nrequest.getRemoteAddr(): 浏览器所处于的客户机的IP地址\nrequest.getRemoteHost(): 浏览器所处于的客户机的主机名\nrequest.getRemotePort(): 浏览器所处于的客户机使用的网络端口\nrequest.getLocalAddr(): 服务器的IP地址\nrequest.getLocalName(): 服务器的主机名\nrequest.getMethod(): 得到客户机请求方式一般是GET或者POST\n\nrequest.getHeader() 获取浏览器传递过来的头信息。比如getHeader(\"user-agent\") 可以获取浏览器的基本资料，这样就能判断是firefox、IE、chrome、或者是safari浏览器\nrequest.getHeaderNames() 获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息\n\n\n### reponse(待完善)\n用于提供给浏览器的响应信息\n\n## 服务端跳转和客户端跳转\n\n服务端跳转\n`request.getRequestDispatcher(\"success.html\").forward(request, response);`\n\n客户端跳转\n`response.sendRedirect(\"fail.html\");`\n\n区别在于**客户端跳转时**候浏览器地址发生了变化\n\n\n## 中文问题\n### 获取中文参数，只需三步\n1. login.html中加上\n \n`<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">`\n \n这句话的目的是告诉浏览器，等下发消息给服务器的时候，使用UTF-8编码\n\n2. login.html\nform的method修改为post\n\n3. 在servlet进行解码和编码\n 把下面这句代码放在request.getParameter()之前\n`request.setCharacterEncoding(\"UTF-8\"); `\n这句话的目的UTF-8解码，然后用UTF-8编码\n\n###  返回中文的响应\n在Servlet中，加上\n`response.setContentType(\"text/html; charset=UTF-8\");`\n\n\n## servlet的一些概念\n### 生命周期\nservlet生命周期有5步：实例化，初始化，提供服务，销毁，被回收 \n初始化：（ init(ServletConfig) 实例方法，只会执行一次）\nLoginSerlvet构造方法 只会执行一次，所以Serlvet是单实例的\n\n## servlet和jsp\njsp就是在html里面写java代码，servlet就是在java里面写html代码\n\njsp更注重前端显示，servlet更注重模型和业务逻辑\n\njsp经过容器解释之后就是一个servlet类.\n我们说HelloServlet是一个Servlet，不是因为它的类名里有一个\"Servlet\"，而是因为它继承了 HttpServlet\n打开转译hello.jsp 后得到的hello_jsp.java，可以发现它继承了类HttpJspBase，而HttpJspBase 继承了HttpServlet\n所以我们说hello_.jsp.java 是一个Servlet\n\n# JSP\n\n## 页面元素\n```\n1. 静态内容\n就是html,css,javascript等内容\n2. 指令\n以<%@开始 %> 结尾，比如<%@page import=\"java.util.*\"%>\n3. 表达式 <%=%>\n4. Scriptlet\n在<%%> 之间，可以写任何java 代码\n5. 声明\n在<%!%> 之间可以声明字段或者方法。但是不建议这么做。\n6. 动作\n<jsp:include page=\"Filename\" > 在jsp页面中包含另一个页面。在包含的章节有详细的讲解\n7. 注释 <%-- -- %>\n不同于 html的注释 <!-- --> 通过jsp的注释，浏览器也看不到相应的代码，相当于在servlet中注释掉了\n\n8. 表达式\n用于输出一段html，比如<%=\"hello jsp\"%>相当于<%out.println(\"hello jsp\");%>\n再比如\n<%for (String word : words) {%>\n<tr>\n    <td><%=word%></td>\n</tr>\n<%}%>\n```\n## 九大内置对象\n\nrequest,response,out\n\npageContext, session,application作用域：页面、用户、全局\n\npage,config,exception\n\n使用javabean\n\n# session\n设置\n`session.getAttribute(\"name\");`\n取得\n`String name = (String)session.getAttribute(\"name\");`\n\n# Cookie\n```\n//创健\nCookie u= new Cookie(\"username\",username);键，值对的关系存储`\n//设置生存时间\nu.setMaxAge(864000);`\n//保存 \nresponse.addCookie(u);`\n\n//把所有cookie取出来装入数组 Cookie[] cookies = request.getCookies();\nif(c.getName().equals(\"username\")||c.getName().equals(\"password\"))\n  {c.setMaxAge(0); //设置Cookie失效\n  response.addCookie(c); //重新保存。\n\n//取键 \nif(c.getName().equals(\"username\"))\n \n//取值\nusername = URLDecoder.decode(c.getValue(),\"utf-8\");\n  ```","source":"_posts/javaweb.md","raw":"---\ntitle: javaEE\ndate: 2018-10-04 22:20:50\ncategories: java\ndescription: javabean、servlet、jsp\n---\n\n# javabean\n三要素\n1.一个无参的构造函数\n2.属性私有化。\n3.get、set的方法。私有化的属性必须通过public类型的方法给其它程序，并且方法的命名也必须遵守一定的命名规范。\n\n# servlet\n## 写一个servlet\n第一步：html表单提交请求\n`<form action=\"login\" method=\"post\">`\n\n第二步：servlet类中的请求处理\n```\npublic class LoginServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n```\n\n第三步：配置web.xml\n```\n<servlet-name>L1</servlet-name>//类的缩写\n    <servlet-class>Myservlet.LoginServlet</servlet-class>//类的名称\n</servlet>\n\n<servlet-mapping>\n    <servlet-name>L1</servlet-name>//类的缩写，和上面一致就行\n    <url-pattern>/login</url-pattern>//映射为的url地址，注意有“/”。对应<form action=\"login\"\n</servlet-mapping>\n```\n## 处理请求的三种方法\n1、dopost、doget、service\ndoget：是默认方法，比如超链访问、地址栏直接输入某个地址。\n特点：1.不安全，提交数据会在浏览器地址栏显示出来\n2.不可以上传文件\n3.有大小的限制\n\ndopost：一般用于注册、修改请求\n特点：1.安全\n2.可以上传文件\n3.没有限制\n\n\n## request和reponse常用方法\n### request\n\n\n**request.getParameter(): 是常见的方法，用于获取单值的参数**\nrequest.getParameterValues(): 用于获取具有多值得参数，比如注册的时候提交的爱好，可以使多选的。\nrequest.getParameterMap(): 用于遍历所有的参数，并返回Map类型。\n\nrequest.getRequestURL(): 浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)\" +\nrequest.getRequestURI(): 浏览器发出请求的资源名部分，去掉了协议和主机名\" +\nrequest.getQueryString(): 请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到\nrequest.getRemoteAddr(): 浏览器所处于的客户机的IP地址\nrequest.getRemoteHost(): 浏览器所处于的客户机的主机名\nrequest.getRemotePort(): 浏览器所处于的客户机使用的网络端口\nrequest.getLocalAddr(): 服务器的IP地址\nrequest.getLocalName(): 服务器的主机名\nrequest.getMethod(): 得到客户机请求方式一般是GET或者POST\n\nrequest.getHeader() 获取浏览器传递过来的头信息。比如getHeader(\"user-agent\") 可以获取浏览器的基本资料，这样就能判断是firefox、IE、chrome、或者是safari浏览器\nrequest.getHeaderNames() 获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息\n\n\n### reponse(待完善)\n用于提供给浏览器的响应信息\n\n## 服务端跳转和客户端跳转\n\n服务端跳转\n`request.getRequestDispatcher(\"success.html\").forward(request, response);`\n\n客户端跳转\n`response.sendRedirect(\"fail.html\");`\n\n区别在于**客户端跳转时**候浏览器地址发生了变化\n\n\n## 中文问题\n### 获取中文参数，只需三步\n1. login.html中加上\n \n`<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">`\n \n这句话的目的是告诉浏览器，等下发消息给服务器的时候，使用UTF-8编码\n\n2. login.html\nform的method修改为post\n\n3. 在servlet进行解码和编码\n 把下面这句代码放在request.getParameter()之前\n`request.setCharacterEncoding(\"UTF-8\"); `\n这句话的目的UTF-8解码，然后用UTF-8编码\n\n###  返回中文的响应\n在Servlet中，加上\n`response.setContentType(\"text/html; charset=UTF-8\");`\n\n\n## servlet的一些概念\n### 生命周期\nservlet生命周期有5步：实例化，初始化，提供服务，销毁，被回收 \n初始化：（ init(ServletConfig) 实例方法，只会执行一次）\nLoginSerlvet构造方法 只会执行一次，所以Serlvet是单实例的\n\n## servlet和jsp\njsp就是在html里面写java代码，servlet就是在java里面写html代码\n\njsp更注重前端显示，servlet更注重模型和业务逻辑\n\njsp经过容器解释之后就是一个servlet类.\n我们说HelloServlet是一个Servlet，不是因为它的类名里有一个\"Servlet\"，而是因为它继承了 HttpServlet\n打开转译hello.jsp 后得到的hello_jsp.java，可以发现它继承了类HttpJspBase，而HttpJspBase 继承了HttpServlet\n所以我们说hello_.jsp.java 是一个Servlet\n\n# JSP\n\n## 页面元素\n```\n1. 静态内容\n就是html,css,javascript等内容\n2. 指令\n以<%@开始 %> 结尾，比如<%@page import=\"java.util.*\"%>\n3. 表达式 <%=%>\n4. Scriptlet\n在<%%> 之间，可以写任何java 代码\n5. 声明\n在<%!%> 之间可以声明字段或者方法。但是不建议这么做。\n6. 动作\n<jsp:include page=\"Filename\" > 在jsp页面中包含另一个页面。在包含的章节有详细的讲解\n7. 注释 <%-- -- %>\n不同于 html的注释 <!-- --> 通过jsp的注释，浏览器也看不到相应的代码，相当于在servlet中注释掉了\n\n8. 表达式\n用于输出一段html，比如<%=\"hello jsp\"%>相当于<%out.println(\"hello jsp\");%>\n再比如\n<%for (String word : words) {%>\n<tr>\n    <td><%=word%></td>\n</tr>\n<%}%>\n```\n## 九大内置对象\n\nrequest,response,out\n\npageContext, session,application作用域：页面、用户、全局\n\npage,config,exception\n\n使用javabean\n\n# session\n设置\n`session.getAttribute(\"name\");`\n取得\n`String name = (String)session.getAttribute(\"name\");`\n\n# Cookie\n```\n//创健\nCookie u= new Cookie(\"username\",username);键，值对的关系存储`\n//设置生存时间\nu.setMaxAge(864000);`\n//保存 \nresponse.addCookie(u);`\n\n//把所有cookie取出来装入数组 Cookie[] cookies = request.getCookies();\nif(c.getName().equals(\"username\")||c.getName().equals(\"password\"))\n  {c.setMaxAge(0); //设置Cookie失效\n  response.addCookie(c); //重新保存。\n\n//取键 \nif(c.getName().equals(\"username\"))\n \n//取值\nusername = URLDecoder.decode(c.getValue(),\"utf-8\");\n  ```","slug":"javaweb","published":1,"updated":"2022-02-08T07:09:41.227Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qk9000pw9rp3rzfs10w","content":"<h1 id=\"javabean\"><a href=\"#javabean\" class=\"headerlink\" title=\"javabean\"></a>javabean</h1><p>三要素<br>1.一个无参的构造函数<br>2.属性私有化。<br>3.get、set的方法。私有化的属性必须通过public类型的方法给其它程序，并且方法的命名也必须遵守一定的命名规范。</p>\n<h1 id=\"servlet\"><a href=\"#servlet\" class=\"headerlink\" title=\"servlet\"></a>servlet</h1><h2 id=\"写一个servlet\"><a href=\"#写一个servlet\" class=\"headerlink\" title=\"写一个servlet\"></a>写一个servlet</h2><p>第一步：html表单提交请求<br><code>&lt;form action=&quot;login&quot; method=&quot;post&quot;&gt;</code></p>\n<p>第二步：servlet类中的请求处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class LoginServlet extends HttpServlet &#123;</span><br><span class=\"line\">    protected void doPost(HttpServletRequest request, HttpServletResponse response)</span><br></pre></td></tr></table></figure></p>\n<p>第三步：配置web.xml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;servlet-name&gt;L1&lt;/servlet-name&gt;//类的缩写</span><br><span class=\"line\">    &lt;servlet-class&gt;Myservlet.LoginServlet&lt;/servlet-class&gt;//类的名称</span><br><span class=\"line\">&lt;/servlet&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;servlet-mapping&gt;</span><br><span class=\"line\">    &lt;servlet-name&gt;L1&lt;/servlet-name&gt;//类的缩写，和上面一致就行</span><br><span class=\"line\">    &lt;url-pattern&gt;/login&lt;/url-pattern&gt;//映射为的url地址，注意有“/”。对应&lt;form action=&quot;login&quot;</span><br><span class=\"line\">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"处理请求的三种方法\"><a href=\"#处理请求的三种方法\" class=\"headerlink\" title=\"处理请求的三种方法\"></a>处理请求的三种方法</h2><p>1、dopost、doget、service<br>doget：是默认方法，比如超链访问、地址栏直接输入某个地址。<br>特点：1.不安全，提交数据会在浏览器地址栏显示出来<br>2.不可以上传文件<br>3.有大小的限制</p>\n<p>dopost：一般用于注册、修改请求<br>特点：1.安全<br>2.可以上传文件<br>3.没有限制</p>\n<h2 id=\"request和reponse常用方法\"><a href=\"#request和reponse常用方法\" class=\"headerlink\" title=\"request和reponse常用方法\"></a>request和reponse常用方法</h2><h3 id=\"request\"><a href=\"#request\" class=\"headerlink\" title=\"request\"></a>request</h3><p><strong>request.getParameter(): 是常见的方法，用于获取单值的参数</strong><br>request.getParameterValues(): 用于获取具有多值得参数，比如注册的时候提交的爱好，可以使多选的。<br>request.getParameterMap(): 用于遍历所有的参数，并返回Map类型。</p>\n<p>request.getRequestURL(): 浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)” +<br>request.getRequestURI(): 浏览器发出请求的资源名部分，去掉了协议和主机名” +<br>request.getQueryString(): 请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到<br>request.getRemoteAddr(): 浏览器所处于的客户机的IP地址<br>request.getRemoteHost(): 浏览器所处于的客户机的主机名<br>request.getRemotePort(): 浏览器所处于的客户机使用的网络端口<br>request.getLocalAddr(): 服务器的IP地址<br>request.getLocalName(): 服务器的主机名<br>request.getMethod(): 得到客户机请求方式一般是GET或者POST</p>\n<p>request.getHeader() 获取浏览器传递过来的头信息。比如getHeader(“user-agent”) 可以获取浏览器的基本资料，这样就能判断是firefox、IE、chrome、或者是safari浏览器<br>request.getHeaderNames() 获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息</p>\n<h3 id=\"reponse-待完善\"><a href=\"#reponse-待完善\" class=\"headerlink\" title=\"reponse(待完善)\"></a>reponse(待完善)</h3><p>用于提供给浏览器的响应信息</p>\n<h2 id=\"服务端跳转和客户端跳转\"><a href=\"#服务端跳转和客户端跳转\" class=\"headerlink\" title=\"服务端跳转和客户端跳转\"></a>服务端跳转和客户端跳转</h2><p>服务端跳转<br><code>request.getRequestDispatcher(&quot;success.html&quot;).forward(request, response);</code></p>\n<p>客户端跳转<br><code>response.sendRedirect(&quot;fail.html&quot;);</code></p>\n<p>区别在于<strong>客户端跳转时</strong>候浏览器地址发生了变化</p>\n<h2 id=\"中文问题\"><a href=\"#中文问题\" class=\"headerlink\" title=\"中文问题\"></a>中文问题</h2><h3 id=\"获取中文参数，只需三步\"><a href=\"#获取中文参数，只需三步\" class=\"headerlink\" title=\"获取中文参数，只需三步\"></a>获取中文参数，只需三步</h3><ol>\n<li>login.html中加上</li>\n</ol>\n<p><code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</code></p>\n<p>这句话的目的是告诉浏览器，等下发消息给服务器的时候，使用UTF-8编码</p>\n<ol start=\"2\">\n<li><p>login.html<br>form的method修改为post</p>\n</li>\n<li><p>在servlet进行解码和编码<br>把下面这句代码放在request.getParameter()之前<br><code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code><br>这句话的目的UTF-8解码，然后用UTF-8编码</p>\n</li>\n</ol>\n<h3 id=\"返回中文的响应\"><a href=\"#返回中文的响应\" class=\"headerlink\" title=\"返回中文的响应\"></a>返回中文的响应</h3><p>在Servlet中，加上<br><code>response.setContentType(&quot;text/html; charset=UTF-8&quot;);</code></p>\n<h2 id=\"servlet的一些概念\"><a href=\"#servlet的一些概念\" class=\"headerlink\" title=\"servlet的一些概念\"></a>servlet的一些概念</h2><h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><p>servlet生命周期有5步：实例化，初始化，提供服务，销毁，被回收<br>初始化：（ init(ServletConfig) 实例方法，只会执行一次）<br>LoginSerlvet构造方法 只会执行一次，所以Serlvet是单实例的</p>\n<h2 id=\"servlet和jsp\"><a href=\"#servlet和jsp\" class=\"headerlink\" title=\"servlet和jsp\"></a>servlet和jsp</h2><p>jsp就是在html里面写java代码，servlet就是在java里面写html代码</p>\n<p>jsp更注重前端显示，servlet更注重模型和业务逻辑</p>\n<p>jsp经过容器解释之后就是一个servlet类.<br>我们说HelloServlet是一个Servlet，不是因为它的类名里有一个”Servlet”，而是因为它继承了 HttpServlet<br>打开转译hello.jsp 后得到的hello_jsp.java，可以发现它继承了类HttpJspBase，而HttpJspBase 继承了HttpServlet<br>所以我们说hello_.jsp.java 是一个Servlet</p>\n<h1 id=\"JSP\"><a href=\"#JSP\" class=\"headerlink\" title=\"JSP\"></a>JSP</h1><h2 id=\"页面元素\"><a href=\"#页面元素\" class=\"headerlink\" title=\"页面元素\"></a>页面元素</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 静态内容</span><br><span class=\"line\">就是html,css,javascript等内容</span><br><span class=\"line\">2. 指令</span><br><span class=\"line\">以&lt;%@开始 %&gt; 结尾，比如&lt;%@page import=&quot;java.util.*&quot;%&gt;</span><br><span class=\"line\">3. 表达式 &lt;%=%&gt;</span><br><span class=\"line\">4. Scriptlet</span><br><span class=\"line\">在&lt;%%&gt; 之间，可以写任何java 代码</span><br><span class=\"line\">5. 声明</span><br><span class=\"line\">在&lt;%!%&gt; 之间可以声明字段或者方法。但是不建议这么做。</span><br><span class=\"line\">6. 动作</span><br><span class=\"line\">&lt;jsp:include page=&quot;Filename&quot; &gt; 在jsp页面中包含另一个页面。在包含的章节有详细的讲解</span><br><span class=\"line\">7. 注释 &lt;%-- -- %&gt;</span><br><span class=\"line\">不同于 html的注释 &lt;!-- --&gt; 通过jsp的注释，浏览器也看不到相应的代码，相当于在servlet中注释掉了</span><br><span class=\"line\"></span><br><span class=\"line\">8. 表达式</span><br><span class=\"line\">用于输出一段html，比如&lt;%=&quot;hello jsp&quot;%&gt;相当于&lt;%out.println(&quot;hello jsp&quot;);%&gt;</span><br><span class=\"line\">再比如</span><br><span class=\"line\">&lt;%for (String word : words) &#123;%&gt;</span><br><span class=\"line\">&lt;tr&gt;</span><br><span class=\"line\">    &lt;td&gt;&lt;%=word%&gt;&lt;/td&gt;</span><br><span class=\"line\">&lt;/tr&gt;</span><br><span class=\"line\">&lt;%&#125;%&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"九大内置对象\"><a href=\"#九大内置对象\" class=\"headerlink\" title=\"九大内置对象\"></a>九大内置对象</h2><p>request,response,out</p>\n<p>pageContext, session,application作用域：页面、用户、全局</p>\n<p>page,config,exception</p>\n<p>使用javabean</p>\n<h1 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h1><p>设置<br><code>session.getAttribute(&quot;name&quot;);</code><br>取得<br><code>String name = (String)session.getAttribute(&quot;name&quot;);</code></p>\n<h1 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创健</span><br><span class=\"line\">Cookie u= new Cookie(&quot;username&quot;,username);键，值对的关系存储`</span><br><span class=\"line\">//设置生存时间</span><br><span class=\"line\">u.setMaxAge(864000);`</span><br><span class=\"line\">//保存 </span><br><span class=\"line\">response.addCookie(u);`</span><br><span class=\"line\"></span><br><span class=\"line\">//把所有cookie取出来装入数组 Cookie[] cookies = request.getCookies();</span><br><span class=\"line\">if(c.getName().equals(&quot;username&quot;)||c.getName().equals(&quot;password&quot;))</span><br><span class=\"line\">  &#123;c.setMaxAge(0); //设置Cookie失效</span><br><span class=\"line\">  response.addCookie(c); //重新保存。</span><br><span class=\"line\"></span><br><span class=\"line\">//取键 </span><br><span class=\"line\">if(c.getName().equals(&quot;username&quot;))</span><br><span class=\"line\"> </span><br><span class=\"line\">//取值</span><br><span class=\"line\">username = URLDecoder.decode(c.getValue(),&quot;utf-8&quot;);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"javabean\"><a href=\"#javabean\" class=\"headerlink\" title=\"javabean\"></a>javabean</h1><p>三要素<br>1.一个无参的构造函数<br>2.属性私有化。<br>3.get、set的方法。私有化的属性必须通过public类型的方法给其它程序，并且方法的命名也必须遵守一定的命名规范。</p>\n<h1 id=\"servlet\"><a href=\"#servlet\" class=\"headerlink\" title=\"servlet\"></a>servlet</h1><h2 id=\"写一个servlet\"><a href=\"#写一个servlet\" class=\"headerlink\" title=\"写一个servlet\"></a>写一个servlet</h2><p>第一步：html表单提交请求<br><code>&lt;form action=&quot;login&quot; method=&quot;post&quot;&gt;</code></p>\n<p>第二步：servlet类中的请求处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class LoginServlet extends HttpServlet &#123;</span><br><span class=\"line\">    protected void doPost(HttpServletRequest request, HttpServletResponse response)</span><br></pre></td></tr></table></figure></p>\n<p>第三步：配置web.xml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;servlet-name&gt;L1&lt;/servlet-name&gt;//类的缩写</span><br><span class=\"line\">    &lt;servlet-class&gt;Myservlet.LoginServlet&lt;/servlet-class&gt;//类的名称</span><br><span class=\"line\">&lt;/servlet&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;servlet-mapping&gt;</span><br><span class=\"line\">    &lt;servlet-name&gt;L1&lt;/servlet-name&gt;//类的缩写，和上面一致就行</span><br><span class=\"line\">    &lt;url-pattern&gt;/login&lt;/url-pattern&gt;//映射为的url地址，注意有“/”。对应&lt;form action=&quot;login&quot;</span><br><span class=\"line\">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"处理请求的三种方法\"><a href=\"#处理请求的三种方法\" class=\"headerlink\" title=\"处理请求的三种方法\"></a>处理请求的三种方法</h2><p>1、dopost、doget、service<br>doget：是默认方法，比如超链访问、地址栏直接输入某个地址。<br>特点：1.不安全，提交数据会在浏览器地址栏显示出来<br>2.不可以上传文件<br>3.有大小的限制</p>\n<p>dopost：一般用于注册、修改请求<br>特点：1.安全<br>2.可以上传文件<br>3.没有限制</p>\n<h2 id=\"request和reponse常用方法\"><a href=\"#request和reponse常用方法\" class=\"headerlink\" title=\"request和reponse常用方法\"></a>request和reponse常用方法</h2><h3 id=\"request\"><a href=\"#request\" class=\"headerlink\" title=\"request\"></a>request</h3><p><strong>request.getParameter(): 是常见的方法，用于获取单值的参数</strong><br>request.getParameterValues(): 用于获取具有多值得参数，比如注册的时候提交的爱好，可以使多选的。<br>request.getParameterMap(): 用于遍历所有的参数，并返回Map类型。</p>\n<p>request.getRequestURL(): 浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)” +<br>request.getRequestURI(): 浏览器发出请求的资源名部分，去掉了协议和主机名” +<br>request.getQueryString(): 请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到<br>request.getRemoteAddr(): 浏览器所处于的客户机的IP地址<br>request.getRemoteHost(): 浏览器所处于的客户机的主机名<br>request.getRemotePort(): 浏览器所处于的客户机使用的网络端口<br>request.getLocalAddr(): 服务器的IP地址<br>request.getLocalName(): 服务器的主机名<br>request.getMethod(): 得到客户机请求方式一般是GET或者POST</p>\n<p>request.getHeader() 获取浏览器传递过来的头信息。比如getHeader(“user-agent”) 可以获取浏览器的基本资料，这样就能判断是firefox、IE、chrome、或者是safari浏览器<br>request.getHeaderNames() 获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息</p>\n<h3 id=\"reponse-待完善\"><a href=\"#reponse-待完善\" class=\"headerlink\" title=\"reponse(待完善)\"></a>reponse(待完善)</h3><p>用于提供给浏览器的响应信息</p>\n<h2 id=\"服务端跳转和客户端跳转\"><a href=\"#服务端跳转和客户端跳转\" class=\"headerlink\" title=\"服务端跳转和客户端跳转\"></a>服务端跳转和客户端跳转</h2><p>服务端跳转<br><code>request.getRequestDispatcher(&quot;success.html&quot;).forward(request, response);</code></p>\n<p>客户端跳转<br><code>response.sendRedirect(&quot;fail.html&quot;);</code></p>\n<p>区别在于<strong>客户端跳转时</strong>候浏览器地址发生了变化</p>\n<h2 id=\"中文问题\"><a href=\"#中文问题\" class=\"headerlink\" title=\"中文问题\"></a>中文问题</h2><h3 id=\"获取中文参数，只需三步\"><a href=\"#获取中文参数，只需三步\" class=\"headerlink\" title=\"获取中文参数，只需三步\"></a>获取中文参数，只需三步</h3><ol>\n<li>login.html中加上</li>\n</ol>\n<p><code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</code></p>\n<p>这句话的目的是告诉浏览器，等下发消息给服务器的时候，使用UTF-8编码</p>\n<ol start=\"2\">\n<li><p>login.html<br>form的method修改为post</p>\n</li>\n<li><p>在servlet进行解码和编码<br>把下面这句代码放在request.getParameter()之前<br><code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code><br>这句话的目的UTF-8解码，然后用UTF-8编码</p>\n</li>\n</ol>\n<h3 id=\"返回中文的响应\"><a href=\"#返回中文的响应\" class=\"headerlink\" title=\"返回中文的响应\"></a>返回中文的响应</h3><p>在Servlet中，加上<br><code>response.setContentType(&quot;text/html; charset=UTF-8&quot;);</code></p>\n<h2 id=\"servlet的一些概念\"><a href=\"#servlet的一些概念\" class=\"headerlink\" title=\"servlet的一些概念\"></a>servlet的一些概念</h2><h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><p>servlet生命周期有5步：实例化，初始化，提供服务，销毁，被回收<br>初始化：（ init(ServletConfig) 实例方法，只会执行一次）<br>LoginSerlvet构造方法 只会执行一次，所以Serlvet是单实例的</p>\n<h2 id=\"servlet和jsp\"><a href=\"#servlet和jsp\" class=\"headerlink\" title=\"servlet和jsp\"></a>servlet和jsp</h2><p>jsp就是在html里面写java代码，servlet就是在java里面写html代码</p>\n<p>jsp更注重前端显示，servlet更注重模型和业务逻辑</p>\n<p>jsp经过容器解释之后就是一个servlet类.<br>我们说HelloServlet是一个Servlet，不是因为它的类名里有一个”Servlet”，而是因为它继承了 HttpServlet<br>打开转译hello.jsp 后得到的hello_jsp.java，可以发现它继承了类HttpJspBase，而HttpJspBase 继承了HttpServlet<br>所以我们说hello_.jsp.java 是一个Servlet</p>\n<h1 id=\"JSP\"><a href=\"#JSP\" class=\"headerlink\" title=\"JSP\"></a>JSP</h1><h2 id=\"页面元素\"><a href=\"#页面元素\" class=\"headerlink\" title=\"页面元素\"></a>页面元素</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 静态内容</span><br><span class=\"line\">就是html,css,javascript等内容</span><br><span class=\"line\">2. 指令</span><br><span class=\"line\">以&lt;%@开始 %&gt; 结尾，比如&lt;%@page import=&quot;java.util.*&quot;%&gt;</span><br><span class=\"line\">3. 表达式 &lt;%=%&gt;</span><br><span class=\"line\">4. Scriptlet</span><br><span class=\"line\">在&lt;%%&gt; 之间，可以写任何java 代码</span><br><span class=\"line\">5. 声明</span><br><span class=\"line\">在&lt;%!%&gt; 之间可以声明字段或者方法。但是不建议这么做。</span><br><span class=\"line\">6. 动作</span><br><span class=\"line\">&lt;jsp:include page=&quot;Filename&quot; &gt; 在jsp页面中包含另一个页面。在包含的章节有详细的讲解</span><br><span class=\"line\">7. 注释 &lt;%-- -- %&gt;</span><br><span class=\"line\">不同于 html的注释 &lt;!-- --&gt; 通过jsp的注释，浏览器也看不到相应的代码，相当于在servlet中注释掉了</span><br><span class=\"line\"></span><br><span class=\"line\">8. 表达式</span><br><span class=\"line\">用于输出一段html，比如&lt;%=&quot;hello jsp&quot;%&gt;相当于&lt;%out.println(&quot;hello jsp&quot;);%&gt;</span><br><span class=\"line\">再比如</span><br><span class=\"line\">&lt;%for (String word : words) &#123;%&gt;</span><br><span class=\"line\">&lt;tr&gt;</span><br><span class=\"line\">    &lt;td&gt;&lt;%=word%&gt;&lt;/td&gt;</span><br><span class=\"line\">&lt;/tr&gt;</span><br><span class=\"line\">&lt;%&#125;%&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"九大内置对象\"><a href=\"#九大内置对象\" class=\"headerlink\" title=\"九大内置对象\"></a>九大内置对象</h2><p>request,response,out</p>\n<p>pageContext, session,application作用域：页面、用户、全局</p>\n<p>page,config,exception</p>\n<p>使用javabean</p>\n<h1 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h1><p>设置<br><code>session.getAttribute(&quot;name&quot;);</code><br>取得<br><code>String name = (String)session.getAttribute(&quot;name&quot;);</code></p>\n<h1 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创健</span><br><span class=\"line\">Cookie u= new Cookie(&quot;username&quot;,username);键，值对的关系存储`</span><br><span class=\"line\">//设置生存时间</span><br><span class=\"line\">u.setMaxAge(864000);`</span><br><span class=\"line\">//保存 </span><br><span class=\"line\">response.addCookie(u);`</span><br><span class=\"line\"></span><br><span class=\"line\">//把所有cookie取出来装入数组 Cookie[] cookies = request.getCookies();</span><br><span class=\"line\">if(c.getName().equals(&quot;username&quot;)||c.getName().equals(&quot;password&quot;))</span><br><span class=\"line\">  &#123;c.setMaxAge(0); //设置Cookie失效</span><br><span class=\"line\">  response.addCookie(c); //重新保存。</span><br><span class=\"line\"></span><br><span class=\"line\">//取键 </span><br><span class=\"line\">if(c.getName().equals(&quot;username&quot;))</span><br><span class=\"line\"> </span><br><span class=\"line\">//取值</span><br><span class=\"line\">username = URLDecoder.decode(c.getValue(),&quot;utf-8&quot;);</span><br></pre></td></tr></table></figure>"},{"title":"Raft协议解读与实践","date":"2022-07-07T11:12:50.000Z","description":"待完善...","_content":"[TOC]\nz\n# 用Redis故障转移实践理解raft协议\n\n\n\n\n\n本文分为三个部分\n\n第一部分，尽可能以简明的语言阐述raft协议。\n\n第二部分，通过kill掉Redis集群的主节点，以观察集群overfail的全过程，通过实践进一步理解raft协议。\n\n第三部分，探讨raft论文的细节，针对原论文提出一些问题，并自问自答。\n\n最后附上原论文链接，以及有帮助的参考资料。\n\n\n\n## 一、raft解决了什么问题？怎么解决的？\n\nRaft是分布式一致性协议，它是对分布式系统达成共识的一种解决方案，那么什么是分布式系统的共识问题呢？\n\n### 拜占庭将军问题\n\n这是Lamport（图灵奖得主）在其论文中提出的一个假设故事：\n\n几个拜占庭将军准备攻城。将军们只有两种行动策略：进攻或撤离。将军们需要达成行动共识，因为只有绝大部分将军同时进攻/撤退，行动才能成功，将军可以彼此通信（但没法聚在一起开会）。棘手的是，这其中有不定数量的叛徒将军，叛徒将军将给出完全错误的信息阻碍达成共识。因此我们需要一种策略，使得将军们在叛徒们干扰的情况下，仍能达成共识。\n\n如果将军根据最简单的策略:收到的多数投票行动，将会导致达成共识失败。假设有9位将军投票，其中1名叛徒。一半将军投票进攻，另一半投票撤退，这时候叛徒给4名投进攻的将军投票进攻，而给4名投撤退的将军投票撤退。这样一来在4名投进攻的将军看来，投票结果是5人投进攻，从而发起进攻；而在4名投撤退的将军看来则是5人投撤退。军队达成错误的共识，导致行动失败。\n\n**这个假设故事，映射到现实计算机，将军即分布式节点，每个节点可以彼此通信，但无法聚在一起“开会”，并且某节点或者某条通信网路可能出现错误（fault-tolerant），在这种情况下，分布式系统如何达成一致（consensus）？**\n\nRaft协议提供的解决方案简单来说是这样的：\n\nRaft 通过首先从节点里选举一个leader，让它有最高权力，比如决定进攻还是撤退，来实现分布式系统的一致性，从节点的唯一任务就是备份主节点的数据。如果leader 宕机或失联，就选举出一个新的leader代替它，参加选举的节点叫candidate。之后如果老的leader重新上线，它会退化成普通节点，接受新leader的命令。\n\n这里我们可知，在raft协议里每个节点有三个状态：leader、follower 或者 candidate 。\n\n**那么怎么进行选举呢？这不又回到了拜占庭将军问题吗，没错，这就是raft协议的重点之一，领导选举。下面简述选举过程：**\n\nRaft 使用一种心跳机制来触发 leader 选举，节点之间会用心跳保持联系。如果一个 follower 在一段选举超时时间内没有接收到任何消息，它会开始进行选举。首先，follower 先增加自己的当前任期号并且转换到 candidate 状态。然后投票给自己，并且让其他服务器节点投票给它。之后会有三种情况\n\n第一种情况：当一个 candidate 获得集群中过半服务器节点针对同一个任期的投票，它就赢得了这次选举并成为 leader 。要求获得过半投票的规则确保了最多只有一个 candidate 赢得此次选举。\n\n第二种情况：candidate 可能会收到另一个声称自己是 leader 的服务器节点发来的 AppendEntries RPC 。如果这个 leader 的任期号大于 candidate 当前的任期号，那么 candidate 会承认该 leader 的合法地位并回到 follower 状态。 如果 RPC 中的任期号比自己的小，那么 candidate 就会拒绝这次的 RPC 并且继续保持 candidate 状态。\n\n第三种情况： candidate 既没有赢得选举也没有输：如果有多个 follower 同时成为 candidate ，那么选票可能会被瓜分以至于没有 candidate 赢得过半的投票。当这种情况发生时，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，如果没有其他机制的话，该情况可能会无限重复。我将在第三部分细节探讨raft提供了哪些解决方案避免无限重复选举发生。\n\n这里提到了任期（term）的概念，任期在 Raft 算法中充当逻辑时钟的作用，每一个服务器节点存储一个当前任期号，该编号随着时间单调递增。\n\n\n\n\n\n## 二、实践Redis的故障转移\n\nRedis的分布式设计大部分都参考了Raft协议。网上虽然也有Raft协议的动画演示，但我认为以观察Redis的故障转移更能深刻理解Raft协议，毕竟Raft只是学术论文，Redis的分布式设计才是真正落地了的解决方案。\n\n\n\n接下来就通过一次模拟Redis故障转移去观察raft协议的整个过程。\n\n### 建立节点\n\n首先需要租一个云服务器，在云服务器上分别设立Redis主节点、2个从节点和3个哨兵节点 。\n\n| 哨兵  | 主节点 | 从节点 |\n| ----- | ------ | ------ |\n| 26379 | 6379   | 6380   |\n| 26380 |        | 6381   |\n| 26381 |        |        |\n\n建立节点的过程因为和本文主题无关就不帖了。（如果读者有兴趣实践，一个小技巧是：只用租一台服务器，每个节点不同端口，就不用每个节点都租一台服务器了，而且方便查看日志。）\n\n\n\n### 杀掉主节点\n\n开始进入正题，首先干掉主节点，手动制造故障。先.查一下master的进程id  `ps -ef | grep Redis-server` 进程id是22284，然后直接杀掉进程  `kill -9 22284` \n\n哨兵和各节点之间用用**流言协议**来监控节点情况，哨兵会持续做如下3件事。\n\n（1）每隔10s确认主从关系。\n\n（2）每隔两秒，哨兵都会通过master节点内部的channel来交换信息（基于发布订阅）。\n\n（3） 每隔一秒每个哨兵对其他的Redis节点（master，slave，哨兵）执行ping操作。\n\n**所以当我们kill掉主节点后，哨兵很快就会发现主节点挂掉了。**\n\n\n\n### 主观下线和客观下线\n\n什么是主观下线和 客观下线呢？\n\n- sdown 是主观宕机，就一个哨兵如果自己觉得一个 master 宕机了，那么就是主观宕机\n- odown 是客观宕机，如果 quorum 数量的哨兵都觉得一个 master 宕机了，那么就是客观宕机\n\nsdown 达成的条件很简单，如果一个哨兵 ping 一个 master，超过了 `is-master-down-after-milliseconds` 指定的毫秒数之后，就主观认为 master 宕机了；如果一个哨兵在指定时间内，收到了 quorum 数量的其它哨兵也认为那个 master 是 sdown 的，那么就认为是 odown 了。\n\n什么是法定人数（quorum）？法定人数即哨兵决定表决的同意比，可以在sentinel的conf里配置，如下，后面的2就是法定人数\n\n```\nsentinel monitor mymaster 127.0.0.1 6379 2\n```\n\n法定人数需要比一般的哨兵数还大，如果小于，法定人数为一半以上的哨兵数。\n\n\n\n回到实践中，让我们来查看哨兵26379的日志 `cat 哨兵 26379.conf | grep -v \"#\" | grep -v \"^$\"`，会观察到几条关键日志\n\n首先是哨兵的主观下线（sdown）日志，哨兵26379观察到了主节点6379失联。\n\n`22522:X 21 Aug 16:40:38.162 # +sdown master mymaster 127.0.0.1 6379`\n\n哨兵们进行通信后，出现了客观下线（odown）日志，表面超过法定人数的哨兵都认为主节点挂了。\n\n`1002:X 21 Aug 19:20:43.517 # +odown master mymaster 127.0.0.1 6379 #quorum 3/2`\n\n\n\n\n\n### 哨兵选举\n\n这个哨兵尝试成为代表哨兵/领导者，为什么要选举呢？因为需要选举出一个哨兵去做故障转移。\n\n哨兵选举的过程如下 ：\n\n1.    每个做主观下线的哨兵节点向其他哨兵节点发送命令,要求将它设置为领导者。\n2.    收到命令的哨兵节点如果没有同意通过其他哨兵节点发送命令,那么将同意该请求，否则拒绝。\n3.    如果该哨兵节点发现自己的票数已经超过哨兵集合半数且超过quorum,那么它将成为领导者。\n4.    如果此过程有多个哨兵节点成为了领导者,那么将等待一段时间重新进行选举。\n\n\n\n回到实践中，让我们来看看竞选者哨兵的日志，try-failover表示哨兵们确认master下线，要进行故障转移了。其中一个哨兵去竞选，接着它收到了两个哨兵的投票，成功成为领导者。\n\n```\n998:X 21 Aug 19:20:42.514 # +try-failover master mymaster 127.0.0.1 6379\n998:X 21 Aug 19:20:42.515 # +vote-for-leader d192c1ac24df230470e06666d30414c1298e7479 1\n998:X 21 Aug 19:20:42.517 # （哨兵一）450f7f7ea410c39d41e974affc83cda0113994f7 voted for d192c1ac24df230470e06666d30414c1298e7479 1\n998:X 21 Aug 19:20:42.517 # （哨兵二）4cc8249091cded4f2eedeacc91fd42881c3a8f42 voted for d192c1ac24df230470e06666d30414c1298e7479 1\n```\n\n\n\n### 主节点的故障转移\n\n哨兵的选举基本是根据raft协议的，代表哨兵只需要集群达成共识就行，其实哪个哨兵都可以去做。但是新主节点的选举是有条件的，会选举出一个最有“能力”的节点。、\n\n首先如果一个 slave 跟 master 断开连接的时间已经超过了 `down-after-milliseconds` 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。在剩余的 slave里排序：\n\n1. 按照 slave 优先级进行排序，slave priority 越低，优先级就越高。\n2. 如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。\n3. 如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。\n\n\n\n回到实践中，从日志上可以看到，哨兵成为领导者后开始干活，它选择了6381节点作为新的主节点，进行故障转移\n\n```\n998:X 21 Aug 19:20:42.573 # +elected-leader master mymaster 127.0.0.1 6379\n998:X 21 Aug 19:20:42.573 # +failover-state-select-slave master mymaster 127.0.0.1 6379\n998:X 21 Aug 19:20:42.673 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379\n998:X 21 Aug 19:20:42.673 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379\n```\n\n\n\n### slave 配置的自动纠正\n\n哨兵会负责自动纠正 slave 的一些配置，比如 slave 如果要成为潜在的 master 候选人，哨兵会确保 slave 复制现有 master 的数据；如果 slave 连接到了一个错误的 master 上，比如故障转移之后，那么哨兵会确保它们连接到正确的 master 上。\n\nslave上升为master日志中可以发现，这一条配置重写的日志\n\n```\n989:M 21 Aug 19:20:42.729 # CONFIG REWRITE executed with success.\n```\n\n## \n\n最后的一条日志标志，master切换完成。\n\n`1002:X 21 Aug 19:20:43.759 # +switch-master mymaster 127.0.0.1 6379 127.0.0.1 6381 `\n\n\n\n## 三、细节探讨\n\nRedis的分布式设计和Raft协议有哪些不同？\n\n虽然本文是用Redis故障转移实践理解raft协议，redis并不是完全基于raft实现的，两者还是有区别的。\n\n两者的一致性级别要求不同：Raft中采用的是QUORUM， 即确保至少大部分节点都接收到写操作之后才会返回结果给Client， 而Redis默认采用的实际上是ANY/ONE, 即只要Master节点写入成功后，就立刻返回给Client，然后该写入命令被异步的发送给所有的slave节点。\n\n### Raft怎么避免多个condidate竞争导致的无限重复选举？\n\n当follower判定当前的leader节点故障之后，follower会首先**随机休眠一段时间**，比如我们设置所有的节点休眠时间为150-300ms之间，即rand(150, 300)，每个节点休眠结束后，便向其他的节点发起拉票。比如A节点先唤醒，唤醒后向B、C节点发起拉票。每个Term期间，每个节点只能至多投一票给别人。\n\n\n\n\n\n## 参考资料\n\n\n\n拜占庭将军问题：https://www.youtube.com/watch?v=e9KVmyI1eCg&t=303s\n\nRedis与raft相同与不同之处：https://zhuanlan.zhihu.com/p/112651338\n\n\n\n","source":"_posts/Raft协议解读与实践.md","raw":"---\ntitle: Raft协议解读与实践\ndate: 2022-07-07 19:12:50\ncategories: 分布式\n\ndescription: 待完善...\n---\n[TOC]\nz\n# 用Redis故障转移实践理解raft协议\n\n\n\n\n\n本文分为三个部分\n\n第一部分，尽可能以简明的语言阐述raft协议。\n\n第二部分，通过kill掉Redis集群的主节点，以观察集群overfail的全过程，通过实践进一步理解raft协议。\n\n第三部分，探讨raft论文的细节，针对原论文提出一些问题，并自问自答。\n\n最后附上原论文链接，以及有帮助的参考资料。\n\n\n\n## 一、raft解决了什么问题？怎么解决的？\n\nRaft是分布式一致性协议，它是对分布式系统达成共识的一种解决方案，那么什么是分布式系统的共识问题呢？\n\n### 拜占庭将军问题\n\n这是Lamport（图灵奖得主）在其论文中提出的一个假设故事：\n\n几个拜占庭将军准备攻城。将军们只有两种行动策略：进攻或撤离。将军们需要达成行动共识，因为只有绝大部分将军同时进攻/撤退，行动才能成功，将军可以彼此通信（但没法聚在一起开会）。棘手的是，这其中有不定数量的叛徒将军，叛徒将军将给出完全错误的信息阻碍达成共识。因此我们需要一种策略，使得将军们在叛徒们干扰的情况下，仍能达成共识。\n\n如果将军根据最简单的策略:收到的多数投票行动，将会导致达成共识失败。假设有9位将军投票，其中1名叛徒。一半将军投票进攻，另一半投票撤退，这时候叛徒给4名投进攻的将军投票进攻，而给4名投撤退的将军投票撤退。这样一来在4名投进攻的将军看来，投票结果是5人投进攻，从而发起进攻；而在4名投撤退的将军看来则是5人投撤退。军队达成错误的共识，导致行动失败。\n\n**这个假设故事，映射到现实计算机，将军即分布式节点，每个节点可以彼此通信，但无法聚在一起“开会”，并且某节点或者某条通信网路可能出现错误（fault-tolerant），在这种情况下，分布式系统如何达成一致（consensus）？**\n\nRaft协议提供的解决方案简单来说是这样的：\n\nRaft 通过首先从节点里选举一个leader，让它有最高权力，比如决定进攻还是撤退，来实现分布式系统的一致性，从节点的唯一任务就是备份主节点的数据。如果leader 宕机或失联，就选举出一个新的leader代替它，参加选举的节点叫candidate。之后如果老的leader重新上线，它会退化成普通节点，接受新leader的命令。\n\n这里我们可知，在raft协议里每个节点有三个状态：leader、follower 或者 candidate 。\n\n**那么怎么进行选举呢？这不又回到了拜占庭将军问题吗，没错，这就是raft协议的重点之一，领导选举。下面简述选举过程：**\n\nRaft 使用一种心跳机制来触发 leader 选举，节点之间会用心跳保持联系。如果一个 follower 在一段选举超时时间内没有接收到任何消息，它会开始进行选举。首先，follower 先增加自己的当前任期号并且转换到 candidate 状态。然后投票给自己，并且让其他服务器节点投票给它。之后会有三种情况\n\n第一种情况：当一个 candidate 获得集群中过半服务器节点针对同一个任期的投票，它就赢得了这次选举并成为 leader 。要求获得过半投票的规则确保了最多只有一个 candidate 赢得此次选举。\n\n第二种情况：candidate 可能会收到另一个声称自己是 leader 的服务器节点发来的 AppendEntries RPC 。如果这个 leader 的任期号大于 candidate 当前的任期号，那么 candidate 会承认该 leader 的合法地位并回到 follower 状态。 如果 RPC 中的任期号比自己的小，那么 candidate 就会拒绝这次的 RPC 并且继续保持 candidate 状态。\n\n第三种情况： candidate 既没有赢得选举也没有输：如果有多个 follower 同时成为 candidate ，那么选票可能会被瓜分以至于没有 candidate 赢得过半的投票。当这种情况发生时，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，如果没有其他机制的话，该情况可能会无限重复。我将在第三部分细节探讨raft提供了哪些解决方案避免无限重复选举发生。\n\n这里提到了任期（term）的概念，任期在 Raft 算法中充当逻辑时钟的作用，每一个服务器节点存储一个当前任期号，该编号随着时间单调递增。\n\n\n\n\n\n## 二、实践Redis的故障转移\n\nRedis的分布式设计大部分都参考了Raft协议。网上虽然也有Raft协议的动画演示，但我认为以观察Redis的故障转移更能深刻理解Raft协议，毕竟Raft只是学术论文，Redis的分布式设计才是真正落地了的解决方案。\n\n\n\n接下来就通过一次模拟Redis故障转移去观察raft协议的整个过程。\n\n### 建立节点\n\n首先需要租一个云服务器，在云服务器上分别设立Redis主节点、2个从节点和3个哨兵节点 。\n\n| 哨兵  | 主节点 | 从节点 |\n| ----- | ------ | ------ |\n| 26379 | 6379   | 6380   |\n| 26380 |        | 6381   |\n| 26381 |        |        |\n\n建立节点的过程因为和本文主题无关就不帖了。（如果读者有兴趣实践，一个小技巧是：只用租一台服务器，每个节点不同端口，就不用每个节点都租一台服务器了，而且方便查看日志。）\n\n\n\n### 杀掉主节点\n\n开始进入正题，首先干掉主节点，手动制造故障。先.查一下master的进程id  `ps -ef | grep Redis-server` 进程id是22284，然后直接杀掉进程  `kill -9 22284` \n\n哨兵和各节点之间用用**流言协议**来监控节点情况，哨兵会持续做如下3件事。\n\n（1）每隔10s确认主从关系。\n\n（2）每隔两秒，哨兵都会通过master节点内部的channel来交换信息（基于发布订阅）。\n\n（3） 每隔一秒每个哨兵对其他的Redis节点（master，slave，哨兵）执行ping操作。\n\n**所以当我们kill掉主节点后，哨兵很快就会发现主节点挂掉了。**\n\n\n\n### 主观下线和客观下线\n\n什么是主观下线和 客观下线呢？\n\n- sdown 是主观宕机，就一个哨兵如果自己觉得一个 master 宕机了，那么就是主观宕机\n- odown 是客观宕机，如果 quorum 数量的哨兵都觉得一个 master 宕机了，那么就是客观宕机\n\nsdown 达成的条件很简单，如果一个哨兵 ping 一个 master，超过了 `is-master-down-after-milliseconds` 指定的毫秒数之后，就主观认为 master 宕机了；如果一个哨兵在指定时间内，收到了 quorum 数量的其它哨兵也认为那个 master 是 sdown 的，那么就认为是 odown 了。\n\n什么是法定人数（quorum）？法定人数即哨兵决定表决的同意比，可以在sentinel的conf里配置，如下，后面的2就是法定人数\n\n```\nsentinel monitor mymaster 127.0.0.1 6379 2\n```\n\n法定人数需要比一般的哨兵数还大，如果小于，法定人数为一半以上的哨兵数。\n\n\n\n回到实践中，让我们来查看哨兵26379的日志 `cat 哨兵 26379.conf | grep -v \"#\" | grep -v \"^$\"`，会观察到几条关键日志\n\n首先是哨兵的主观下线（sdown）日志，哨兵26379观察到了主节点6379失联。\n\n`22522:X 21 Aug 16:40:38.162 # +sdown master mymaster 127.0.0.1 6379`\n\n哨兵们进行通信后，出现了客观下线（odown）日志，表面超过法定人数的哨兵都认为主节点挂了。\n\n`1002:X 21 Aug 19:20:43.517 # +odown master mymaster 127.0.0.1 6379 #quorum 3/2`\n\n\n\n\n\n### 哨兵选举\n\n这个哨兵尝试成为代表哨兵/领导者，为什么要选举呢？因为需要选举出一个哨兵去做故障转移。\n\n哨兵选举的过程如下 ：\n\n1.    每个做主观下线的哨兵节点向其他哨兵节点发送命令,要求将它设置为领导者。\n2.    收到命令的哨兵节点如果没有同意通过其他哨兵节点发送命令,那么将同意该请求，否则拒绝。\n3.    如果该哨兵节点发现自己的票数已经超过哨兵集合半数且超过quorum,那么它将成为领导者。\n4.    如果此过程有多个哨兵节点成为了领导者,那么将等待一段时间重新进行选举。\n\n\n\n回到实践中，让我们来看看竞选者哨兵的日志，try-failover表示哨兵们确认master下线，要进行故障转移了。其中一个哨兵去竞选，接着它收到了两个哨兵的投票，成功成为领导者。\n\n```\n998:X 21 Aug 19:20:42.514 # +try-failover master mymaster 127.0.0.1 6379\n998:X 21 Aug 19:20:42.515 # +vote-for-leader d192c1ac24df230470e06666d30414c1298e7479 1\n998:X 21 Aug 19:20:42.517 # （哨兵一）450f7f7ea410c39d41e974affc83cda0113994f7 voted for d192c1ac24df230470e06666d30414c1298e7479 1\n998:X 21 Aug 19:20:42.517 # （哨兵二）4cc8249091cded4f2eedeacc91fd42881c3a8f42 voted for d192c1ac24df230470e06666d30414c1298e7479 1\n```\n\n\n\n### 主节点的故障转移\n\n哨兵的选举基本是根据raft协议的，代表哨兵只需要集群达成共识就行，其实哪个哨兵都可以去做。但是新主节点的选举是有条件的，会选举出一个最有“能力”的节点。、\n\n首先如果一个 slave 跟 master 断开连接的时间已经超过了 `down-after-milliseconds` 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。在剩余的 slave里排序：\n\n1. 按照 slave 优先级进行排序，slave priority 越低，优先级就越高。\n2. 如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。\n3. 如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。\n\n\n\n回到实践中，从日志上可以看到，哨兵成为领导者后开始干活，它选择了6381节点作为新的主节点，进行故障转移\n\n```\n998:X 21 Aug 19:20:42.573 # +elected-leader master mymaster 127.0.0.1 6379\n998:X 21 Aug 19:20:42.573 # +failover-state-select-slave master mymaster 127.0.0.1 6379\n998:X 21 Aug 19:20:42.673 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379\n998:X 21 Aug 19:20:42.673 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379\n```\n\n\n\n### slave 配置的自动纠正\n\n哨兵会负责自动纠正 slave 的一些配置，比如 slave 如果要成为潜在的 master 候选人，哨兵会确保 slave 复制现有 master 的数据；如果 slave 连接到了一个错误的 master 上，比如故障转移之后，那么哨兵会确保它们连接到正确的 master 上。\n\nslave上升为master日志中可以发现，这一条配置重写的日志\n\n```\n989:M 21 Aug 19:20:42.729 # CONFIG REWRITE executed with success.\n```\n\n## \n\n最后的一条日志标志，master切换完成。\n\n`1002:X 21 Aug 19:20:43.759 # +switch-master mymaster 127.0.0.1 6379 127.0.0.1 6381 `\n\n\n\n## 三、细节探讨\n\nRedis的分布式设计和Raft协议有哪些不同？\n\n虽然本文是用Redis故障转移实践理解raft协议，redis并不是完全基于raft实现的，两者还是有区别的。\n\n两者的一致性级别要求不同：Raft中采用的是QUORUM， 即确保至少大部分节点都接收到写操作之后才会返回结果给Client， 而Redis默认采用的实际上是ANY/ONE, 即只要Master节点写入成功后，就立刻返回给Client，然后该写入命令被异步的发送给所有的slave节点。\n\n### Raft怎么避免多个condidate竞争导致的无限重复选举？\n\n当follower判定当前的leader节点故障之后，follower会首先**随机休眠一段时间**，比如我们设置所有的节点休眠时间为150-300ms之间，即rand(150, 300)，每个节点休眠结束后，便向其他的节点发起拉票。比如A节点先唤醒，唤醒后向B、C节点发起拉票。每个Term期间，每个节点只能至多投一票给别人。\n\n\n\n\n\n## 参考资料\n\n\n\n拜占庭将军问题：https://www.youtube.com/watch?v=e9KVmyI1eCg&t=303s\n\nRedis与raft相同与不同之处：https://zhuanlan.zhihu.com/p/112651338\n\n\n\n","slug":"Raft协议解读与实践","published":1,"updated":"2022-09-01T08:45:15.160Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qkc000rw9rps9wgvbs7","content":"<p>[TOC]<br>z</p>\n<h1 id=\"用Redis故障转移实践理解raft协议\"><a href=\"#用Redis故障转移实践理解raft协议\" class=\"headerlink\" title=\"用Redis故障转移实践理解raft协议\"></a>用Redis故障转移实践理解raft协议</h1><p>本文分为三个部分</p>\n<p>第一部分，尽可能以简明的语言阐述raft协议。</p>\n<p>第二部分，通过kill掉Redis集群的主节点，以观察集群overfail的全过程，通过实践进一步理解raft协议。</p>\n<p>第三部分，探讨raft论文的细节，针对原论文提出一些问题，并自问自答。</p>\n<p>最后附上原论文链接，以及有帮助的参考资料。</p>\n<h2 id=\"一、raft解决了什么问题？怎么解决的？\"><a href=\"#一、raft解决了什么问题？怎么解决的？\" class=\"headerlink\" title=\"一、raft解决了什么问题？怎么解决的？\"></a>一、raft解决了什么问题？怎么解决的？</h2><p>Raft是分布式一致性协议，它是对分布式系统达成共识的一种解决方案，那么什么是分布式系统的共识问题呢？</p>\n<h3 id=\"拜占庭将军问题\"><a href=\"#拜占庭将军问题\" class=\"headerlink\" title=\"拜占庭将军问题\"></a>拜占庭将军问题</h3><p>这是Lamport（图灵奖得主）在其论文中提出的一个假设故事：</p>\n<p>几个拜占庭将军准备攻城。将军们只有两种行动策略：进攻或撤离。将军们需要达成行动共识，因为只有绝大部分将军同时进攻/撤退，行动才能成功，将军可以彼此通信（但没法聚在一起开会）。棘手的是，这其中有不定数量的叛徒将军，叛徒将军将给出完全错误的信息阻碍达成共识。因此我们需要一种策略，使得将军们在叛徒们干扰的情况下，仍能达成共识。</p>\n<p>如果将军根据最简单的策略:收到的多数投票行动，将会导致达成共识失败。假设有9位将军投票，其中1名叛徒。一半将军投票进攻，另一半投票撤退，这时候叛徒给4名投进攻的将军投票进攻，而给4名投撤退的将军投票撤退。这样一来在4名投进攻的将军看来，投票结果是5人投进攻，从而发起进攻；而在4名投撤退的将军看来则是5人投撤退。军队达成错误的共识，导致行动失败。</p>\n<p><strong>这个假设故事，映射到现实计算机，将军即分布式节点，每个节点可以彼此通信，但无法聚在一起“开会”，并且某节点或者某条通信网路可能出现错误（fault-tolerant），在这种情况下，分布式系统如何达成一致（consensus）？</strong></p>\n<p>Raft协议提供的解决方案简单来说是这样的：</p>\n<p>Raft 通过首先从节点里选举一个leader，让它有最高权力，比如决定进攻还是撤退，来实现分布式系统的一致性，从节点的唯一任务就是备份主节点的数据。如果leader 宕机或失联，就选举出一个新的leader代替它，参加选举的节点叫candidate。之后如果老的leader重新上线，它会退化成普通节点，接受新leader的命令。</p>\n<p>这里我们可知，在raft协议里每个节点有三个状态：leader、follower 或者 candidate 。</p>\n<p><strong>那么怎么进行选举呢？这不又回到了拜占庭将军问题吗，没错，这就是raft协议的重点之一，领导选举。下面简述选举过程：</strong></p>\n<p>Raft 使用一种心跳机制来触发 leader 选举，节点之间会用心跳保持联系。如果一个 follower 在一段选举超时时间内没有接收到任何消息，它会开始进行选举。首先，follower 先增加自己的当前任期号并且转换到 candidate 状态。然后投票给自己，并且让其他服务器节点投票给它。之后会有三种情况</p>\n<p>第一种情况：当一个 candidate 获得集群中过半服务器节点针对同一个任期的投票，它就赢得了这次选举并成为 leader 。要求获得过半投票的规则确保了最多只有一个 candidate 赢得此次选举。</p>\n<p>第二种情况：candidate 可能会收到另一个声称自己是 leader 的服务器节点发来的 AppendEntries RPC 。如果这个 leader 的任期号大于 candidate 当前的任期号，那么 candidate 会承认该 leader 的合法地位并回到 follower 状态。 如果 RPC 中的任期号比自己的小，那么 candidate 就会拒绝这次的 RPC 并且继续保持 candidate 状态。</p>\n<p>第三种情况： candidate 既没有赢得选举也没有输：如果有多个 follower 同时成为 candidate ，那么选票可能会被瓜分以至于没有 candidate 赢得过半的投票。当这种情况发生时，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，如果没有其他机制的话，该情况可能会无限重复。我将在第三部分细节探讨raft提供了哪些解决方案避免无限重复选举发生。</p>\n<p>这里提到了任期（term）的概念，任期在 Raft 算法中充当逻辑时钟的作用，每一个服务器节点存储一个当前任期号，该编号随着时间单调递增。</p>\n<h2 id=\"二、实践Redis的故障转移\"><a href=\"#二、实践Redis的故障转移\" class=\"headerlink\" title=\"二、实践Redis的故障转移\"></a>二、实践Redis的故障转移</h2><p>Redis的分布式设计大部分都参考了Raft协议。网上虽然也有Raft协议的动画演示，但我认为以观察Redis的故障转移更能深刻理解Raft协议，毕竟Raft只是学术论文，Redis的分布式设计才是真正落地了的解决方案。</p>\n<p>接下来就通过一次模拟Redis故障转移去观察raft协议的整个过程。</p>\n<h3 id=\"建立节点\"><a href=\"#建立节点\" class=\"headerlink\" title=\"建立节点\"></a>建立节点</h3><p>首先需要租一个云服务器，在云服务器上分别设立Redis主节点、2个从节点和3个哨兵节点 。</p>\n<table>\n<thead>\n<tr>\n<th>哨兵</th>\n<th>主节点</th>\n<th>从节点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>26379</td>\n<td>6379</td>\n<td>6380</td>\n</tr>\n<tr>\n<td>26380</td>\n<td></td>\n<td>6381</td>\n</tr>\n<tr>\n<td>26381</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>建立节点的过程因为和本文主题无关就不帖了。（如果读者有兴趣实践，一个小技巧是：只用租一台服务器，每个节点不同端口，就不用每个节点都租一台服务器了，而且方便查看日志。）</p>\n<h3 id=\"杀掉主节点\"><a href=\"#杀掉主节点\" class=\"headerlink\" title=\"杀掉主节点\"></a>杀掉主节点</h3><p>开始进入正题，首先干掉主节点，手动制造故障。先.查一下master的进程id  <code>ps -ef | grep Redis-server</code> 进程id是22284，然后直接杀掉进程  <code>kill -9 22284</code> </p>\n<p>哨兵和各节点之间用用<strong>流言协议</strong>来监控节点情况，哨兵会持续做如下3件事。</p>\n<p>（1）每隔10s确认主从关系。</p>\n<p>（2）每隔两秒，哨兵都会通过master节点内部的channel来交换信息（基于发布订阅）。</p>\n<p>（3） 每隔一秒每个哨兵对其他的Redis节点（master，slave，哨兵）执行ping操作。</p>\n<p><strong>所以当我们kill掉主节点后，哨兵很快就会发现主节点挂掉了。</strong></p>\n<h3 id=\"主观下线和客观下线\"><a href=\"#主观下线和客观下线\" class=\"headerlink\" title=\"主观下线和客观下线\"></a>主观下线和客观下线</h3><p>什么是主观下线和 客观下线呢？</p>\n<ul>\n<li>sdown 是主观宕机，就一个哨兵如果自己觉得一个 master 宕机了，那么就是主观宕机</li>\n<li>odown 是客观宕机，如果 quorum 数量的哨兵都觉得一个 master 宕机了，那么就是客观宕机</li>\n</ul>\n<p>sdown 达成的条件很简单，如果一个哨兵 ping 一个 master，超过了 <code>is-master-down-after-milliseconds</code> 指定的毫秒数之后，就主观认为 master 宕机了；如果一个哨兵在指定时间内，收到了 quorum 数量的其它哨兵也认为那个 master 是 sdown 的，那么就认为是 odown 了。</p>\n<p>什么是法定人数（quorum）？法定人数即哨兵决定表决的同意比，可以在sentinel的conf里配置，如下，后面的2就是法定人数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sentinel monitor mymaster 127.0.0.1 6379 2</span><br></pre></td></tr></table></figure>\n<p>法定人数需要比一般的哨兵数还大，如果小于，法定人数为一半以上的哨兵数。</p>\n<p>回到实践中，让我们来查看哨兵26379的日志 <code>cat 哨兵 26379.conf | grep -v &quot;#&quot; | grep -v &quot;^$&quot;</code>，会观察到几条关键日志</p>\n<p>首先是哨兵的主观下线（sdown）日志，哨兵26379观察到了主节点6379失联。</p>\n<p><code>22522:X 21 Aug 16:40:38.162 # +sdown master mymaster 127.0.0.1 6379</code></p>\n<p>哨兵们进行通信后，出现了客观下线（odown）日志，表面超过法定人数的哨兵都认为主节点挂了。</p>\n<p><code>1002:X 21 Aug 19:20:43.517 # +odown master mymaster 127.0.0.1 6379 #quorum 3/2</code></p>\n<h3 id=\"哨兵选举\"><a href=\"#哨兵选举\" class=\"headerlink\" title=\"哨兵选举\"></a>哨兵选举</h3><p>这个哨兵尝试成为代表哨兵/领导者，为什么要选举呢？因为需要选举出一个哨兵去做故障转移。</p>\n<p>哨兵选举的过程如下 ：</p>\n<ol>\n<li>每个做主观下线的哨兵节点向其他哨兵节点发送命令,要求将它设置为领导者。</li>\n<li>收到命令的哨兵节点如果没有同意通过其他哨兵节点发送命令,那么将同意该请求，否则拒绝。</li>\n<li>如果该哨兵节点发现自己的票数已经超过哨兵集合半数且超过quorum,那么它将成为领导者。</li>\n<li>如果此过程有多个哨兵节点成为了领导者,那么将等待一段时间重新进行选举。</li>\n</ol>\n<p>回到实践中，让我们来看看竞选者哨兵的日志，try-failover表示哨兵们确认master下线，要进行故障转移了。其中一个哨兵去竞选，接着它收到了两个哨兵的投票，成功成为领导者。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">998:X 21 Aug 19:20:42.514 # +try-failover master mymaster 127.0.0.1 6379</span><br><span class=\"line\">998:X 21 Aug 19:20:42.515 # +vote-for-leader d192c1ac24df230470e06666d30414c1298e7479 1</span><br><span class=\"line\">998:X 21 Aug 19:20:42.517 # （哨兵一）450f7f7ea410c39d41e974affc83cda0113994f7 voted for d192c1ac24df230470e06666d30414c1298e7479 1</span><br><span class=\"line\">998:X 21 Aug 19:20:42.517 # （哨兵二）4cc8249091cded4f2eedeacc91fd42881c3a8f42 voted for d192c1ac24df230470e06666d30414c1298e7479 1</span><br></pre></td></tr></table></figure>\n<h3 id=\"主节点的故障转移\"><a href=\"#主节点的故障转移\" class=\"headerlink\" title=\"主节点的故障转移\"></a>主节点的故障转移</h3><p>哨兵的选举基本是根据raft协议的，代表哨兵只需要集群达成共识就行，其实哪个哨兵都可以去做。但是新主节点的选举是有条件的，会选举出一个最有“能力”的节点。、</p>\n<p>首先如果一个 slave 跟 master 断开连接的时间已经超过了 <code>down-after-milliseconds</code> 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。在剩余的 slave里排序：</p>\n<ol>\n<li>按照 slave 优先级进行排序，slave priority 越低，优先级就越高。</li>\n<li>如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。</li>\n<li>如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。</li>\n</ol>\n<p>回到实践中，从日志上可以看到，哨兵成为领导者后开始干活，它选择了6381节点作为新的主节点，进行故障转移</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">998:X 21 Aug 19:20:42.573 # +elected-leader master mymaster 127.0.0.1 6379</span><br><span class=\"line\">998:X 21 Aug 19:20:42.573 # +failover-state-select-slave master mymaster 127.0.0.1 6379</span><br><span class=\"line\">998:X 21 Aug 19:20:42.673 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379</span><br><span class=\"line\">998:X 21 Aug 19:20:42.673 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379</span><br></pre></td></tr></table></figure>\n<h3 id=\"slave-配置的自动纠正\"><a href=\"#slave-配置的自动纠正\" class=\"headerlink\" title=\"slave 配置的自动纠正\"></a>slave 配置的自动纠正</h3><p>哨兵会负责自动纠正 slave 的一些配置，比如 slave 如果要成为潜在的 master 候选人，哨兵会确保 slave 复制现有 master 的数据；如果 slave 连接到了一个错误的 master 上，比如故障转移之后，那么哨兵会确保它们连接到正确的 master 上。</p>\n<p>slave上升为master日志中可以发现，这一条配置重写的日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">989:M 21 Aug 19:20:42.729 # CONFIG REWRITE executed with success.</span><br></pre></td></tr></table></figure>\n<p>## </p>\n<p>最后的一条日志标志，master切换完成。</p>\n<p><code>1002:X 21 Aug 19:20:43.759 # +switch-master mymaster 127.0.0.1 6379 127.0.0.1 6381</code></p>\n<h2 id=\"三、细节探讨\"><a href=\"#三、细节探讨\" class=\"headerlink\" title=\"三、细节探讨\"></a>三、细节探讨</h2><p>Redis的分布式设计和Raft协议有哪些不同？</p>\n<p>虽然本文是用Redis故障转移实践理解raft协议，redis并不是完全基于raft实现的，两者还是有区别的。</p>\n<p>两者的一致性级别要求不同：Raft中采用的是QUORUM， 即确保至少大部分节点都接收到写操作之后才会返回结果给Client， 而Redis默认采用的实际上是ANY/ONE, 即只要Master节点写入成功后，就立刻返回给Client，然后该写入命令被异步的发送给所有的slave节点。</p>\n<h3 id=\"Raft怎么避免多个condidate竞争导致的无限重复选举？\"><a href=\"#Raft怎么避免多个condidate竞争导致的无限重复选举？\" class=\"headerlink\" title=\"Raft怎么避免多个condidate竞争导致的无限重复选举？\"></a>Raft怎么避免多个condidate竞争导致的无限重复选举？</h3><p>当follower判定当前的leader节点故障之后，follower会首先<strong>随机休眠一段时间</strong>，比如我们设置所有的节点休眠时间为150-300ms之间，即rand(150, 300)，每个节点休眠结束后，便向其他的节点发起拉票。比如A节点先唤醒，唤醒后向B、C节点发起拉票。每个Term期间，每个节点只能至多投一票给别人。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>拜占庭将军问题：<a href=\"https://www.youtube.com/watch?v=e9KVmyI1eCg&amp;t=303s\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=e9KVmyI1eCg&amp;t=303s</a></p>\n<p>Redis与raft相同与不同之处：<a href=\"https://zhuanlan.zhihu.com/p/112651338\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/112651338</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]<br>z</p>\n<h1 id=\"用Redis故障转移实践理解raft协议\"><a href=\"#用Redis故障转移实践理解raft协议\" class=\"headerlink\" title=\"用Redis故障转移实践理解raft协议\"></a>用Redis故障转移实践理解raft协议</h1><p>本文分为三个部分</p>\n<p>第一部分，尽可能以简明的语言阐述raft协议。</p>\n<p>第二部分，通过kill掉Redis集群的主节点，以观察集群overfail的全过程，通过实践进一步理解raft协议。</p>\n<p>第三部分，探讨raft论文的细节，针对原论文提出一些问题，并自问自答。</p>\n<p>最后附上原论文链接，以及有帮助的参考资料。</p>\n<h2 id=\"一、raft解决了什么问题？怎么解决的？\"><a href=\"#一、raft解决了什么问题？怎么解决的？\" class=\"headerlink\" title=\"一、raft解决了什么问题？怎么解决的？\"></a>一、raft解决了什么问题？怎么解决的？</h2><p>Raft是分布式一致性协议，它是对分布式系统达成共识的一种解决方案，那么什么是分布式系统的共识问题呢？</p>\n<h3 id=\"拜占庭将军问题\"><a href=\"#拜占庭将军问题\" class=\"headerlink\" title=\"拜占庭将军问题\"></a>拜占庭将军问题</h3><p>这是Lamport（图灵奖得主）在其论文中提出的一个假设故事：</p>\n<p>几个拜占庭将军准备攻城。将军们只有两种行动策略：进攻或撤离。将军们需要达成行动共识，因为只有绝大部分将军同时进攻/撤退，行动才能成功，将军可以彼此通信（但没法聚在一起开会）。棘手的是，这其中有不定数量的叛徒将军，叛徒将军将给出完全错误的信息阻碍达成共识。因此我们需要一种策略，使得将军们在叛徒们干扰的情况下，仍能达成共识。</p>\n<p>如果将军根据最简单的策略:收到的多数投票行动，将会导致达成共识失败。假设有9位将军投票，其中1名叛徒。一半将军投票进攻，另一半投票撤退，这时候叛徒给4名投进攻的将军投票进攻，而给4名投撤退的将军投票撤退。这样一来在4名投进攻的将军看来，投票结果是5人投进攻，从而发起进攻；而在4名投撤退的将军看来则是5人投撤退。军队达成错误的共识，导致行动失败。</p>\n<p><strong>这个假设故事，映射到现实计算机，将军即分布式节点，每个节点可以彼此通信，但无法聚在一起“开会”，并且某节点或者某条通信网路可能出现错误（fault-tolerant），在这种情况下，分布式系统如何达成一致（consensus）？</strong></p>\n<p>Raft协议提供的解决方案简单来说是这样的：</p>\n<p>Raft 通过首先从节点里选举一个leader，让它有最高权力，比如决定进攻还是撤退，来实现分布式系统的一致性，从节点的唯一任务就是备份主节点的数据。如果leader 宕机或失联，就选举出一个新的leader代替它，参加选举的节点叫candidate。之后如果老的leader重新上线，它会退化成普通节点，接受新leader的命令。</p>\n<p>这里我们可知，在raft协议里每个节点有三个状态：leader、follower 或者 candidate 。</p>\n<p><strong>那么怎么进行选举呢？这不又回到了拜占庭将军问题吗，没错，这就是raft协议的重点之一，领导选举。下面简述选举过程：</strong></p>\n<p>Raft 使用一种心跳机制来触发 leader 选举，节点之间会用心跳保持联系。如果一个 follower 在一段选举超时时间内没有接收到任何消息，它会开始进行选举。首先，follower 先增加自己的当前任期号并且转换到 candidate 状态。然后投票给自己，并且让其他服务器节点投票给它。之后会有三种情况</p>\n<p>第一种情况：当一个 candidate 获得集群中过半服务器节点针对同一个任期的投票，它就赢得了这次选举并成为 leader 。要求获得过半投票的规则确保了最多只有一个 candidate 赢得此次选举。</p>\n<p>第二种情况：candidate 可能会收到另一个声称自己是 leader 的服务器节点发来的 AppendEntries RPC 。如果这个 leader 的任期号大于 candidate 当前的任期号，那么 candidate 会承认该 leader 的合法地位并回到 follower 状态。 如果 RPC 中的任期号比自己的小，那么 candidate 就会拒绝这次的 RPC 并且继续保持 candidate 状态。</p>\n<p>第三种情况： candidate 既没有赢得选举也没有输：如果有多个 follower 同时成为 candidate ，那么选票可能会被瓜分以至于没有 candidate 赢得过半的投票。当这种情况发生时，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，如果没有其他机制的话，该情况可能会无限重复。我将在第三部分细节探讨raft提供了哪些解决方案避免无限重复选举发生。</p>\n<p>这里提到了任期（term）的概念，任期在 Raft 算法中充当逻辑时钟的作用，每一个服务器节点存储一个当前任期号，该编号随着时间单调递增。</p>\n<h2 id=\"二、实践Redis的故障转移\"><a href=\"#二、实践Redis的故障转移\" class=\"headerlink\" title=\"二、实践Redis的故障转移\"></a>二、实践Redis的故障转移</h2><p>Redis的分布式设计大部分都参考了Raft协议。网上虽然也有Raft协议的动画演示，但我认为以观察Redis的故障转移更能深刻理解Raft协议，毕竟Raft只是学术论文，Redis的分布式设计才是真正落地了的解决方案。</p>\n<p>接下来就通过一次模拟Redis故障转移去观察raft协议的整个过程。</p>\n<h3 id=\"建立节点\"><a href=\"#建立节点\" class=\"headerlink\" title=\"建立节点\"></a>建立节点</h3><p>首先需要租一个云服务器，在云服务器上分别设立Redis主节点、2个从节点和3个哨兵节点 。</p>\n<table>\n<thead>\n<tr>\n<th>哨兵</th>\n<th>主节点</th>\n<th>从节点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>26379</td>\n<td>6379</td>\n<td>6380</td>\n</tr>\n<tr>\n<td>26380</td>\n<td></td>\n<td>6381</td>\n</tr>\n<tr>\n<td>26381</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>建立节点的过程因为和本文主题无关就不帖了。（如果读者有兴趣实践，一个小技巧是：只用租一台服务器，每个节点不同端口，就不用每个节点都租一台服务器了，而且方便查看日志。）</p>\n<h3 id=\"杀掉主节点\"><a href=\"#杀掉主节点\" class=\"headerlink\" title=\"杀掉主节点\"></a>杀掉主节点</h3><p>开始进入正题，首先干掉主节点，手动制造故障。先.查一下master的进程id  <code>ps -ef | grep Redis-server</code> 进程id是22284，然后直接杀掉进程  <code>kill -9 22284</code> </p>\n<p>哨兵和各节点之间用用<strong>流言协议</strong>来监控节点情况，哨兵会持续做如下3件事。</p>\n<p>（1）每隔10s确认主从关系。</p>\n<p>（2）每隔两秒，哨兵都会通过master节点内部的channel来交换信息（基于发布订阅）。</p>\n<p>（3） 每隔一秒每个哨兵对其他的Redis节点（master，slave，哨兵）执行ping操作。</p>\n<p><strong>所以当我们kill掉主节点后，哨兵很快就会发现主节点挂掉了。</strong></p>\n<h3 id=\"主观下线和客观下线\"><a href=\"#主观下线和客观下线\" class=\"headerlink\" title=\"主观下线和客观下线\"></a>主观下线和客观下线</h3><p>什么是主观下线和 客观下线呢？</p>\n<ul>\n<li>sdown 是主观宕机，就一个哨兵如果自己觉得一个 master 宕机了，那么就是主观宕机</li>\n<li>odown 是客观宕机，如果 quorum 数量的哨兵都觉得一个 master 宕机了，那么就是客观宕机</li>\n</ul>\n<p>sdown 达成的条件很简单，如果一个哨兵 ping 一个 master，超过了 <code>is-master-down-after-milliseconds</code> 指定的毫秒数之后，就主观认为 master 宕机了；如果一个哨兵在指定时间内，收到了 quorum 数量的其它哨兵也认为那个 master 是 sdown 的，那么就认为是 odown 了。</p>\n<p>什么是法定人数（quorum）？法定人数即哨兵决定表决的同意比，可以在sentinel的conf里配置，如下，后面的2就是法定人数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sentinel monitor mymaster 127.0.0.1 6379 2</span><br></pre></td></tr></table></figure>\n<p>法定人数需要比一般的哨兵数还大，如果小于，法定人数为一半以上的哨兵数。</p>\n<p>回到实践中，让我们来查看哨兵26379的日志 <code>cat 哨兵 26379.conf | grep -v &quot;#&quot; | grep -v &quot;^$&quot;</code>，会观察到几条关键日志</p>\n<p>首先是哨兵的主观下线（sdown）日志，哨兵26379观察到了主节点6379失联。</p>\n<p><code>22522:X 21 Aug 16:40:38.162 # +sdown master mymaster 127.0.0.1 6379</code></p>\n<p>哨兵们进行通信后，出现了客观下线（odown）日志，表面超过法定人数的哨兵都认为主节点挂了。</p>\n<p><code>1002:X 21 Aug 19:20:43.517 # +odown master mymaster 127.0.0.1 6379 #quorum 3/2</code></p>\n<h3 id=\"哨兵选举\"><a href=\"#哨兵选举\" class=\"headerlink\" title=\"哨兵选举\"></a>哨兵选举</h3><p>这个哨兵尝试成为代表哨兵/领导者，为什么要选举呢？因为需要选举出一个哨兵去做故障转移。</p>\n<p>哨兵选举的过程如下 ：</p>\n<ol>\n<li>每个做主观下线的哨兵节点向其他哨兵节点发送命令,要求将它设置为领导者。</li>\n<li>收到命令的哨兵节点如果没有同意通过其他哨兵节点发送命令,那么将同意该请求，否则拒绝。</li>\n<li>如果该哨兵节点发现自己的票数已经超过哨兵集合半数且超过quorum,那么它将成为领导者。</li>\n<li>如果此过程有多个哨兵节点成为了领导者,那么将等待一段时间重新进行选举。</li>\n</ol>\n<p>回到实践中，让我们来看看竞选者哨兵的日志，try-failover表示哨兵们确认master下线，要进行故障转移了。其中一个哨兵去竞选，接着它收到了两个哨兵的投票，成功成为领导者。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">998:X 21 Aug 19:20:42.514 # +try-failover master mymaster 127.0.0.1 6379</span><br><span class=\"line\">998:X 21 Aug 19:20:42.515 # +vote-for-leader d192c1ac24df230470e06666d30414c1298e7479 1</span><br><span class=\"line\">998:X 21 Aug 19:20:42.517 # （哨兵一）450f7f7ea410c39d41e974affc83cda0113994f7 voted for d192c1ac24df230470e06666d30414c1298e7479 1</span><br><span class=\"line\">998:X 21 Aug 19:20:42.517 # （哨兵二）4cc8249091cded4f2eedeacc91fd42881c3a8f42 voted for d192c1ac24df230470e06666d30414c1298e7479 1</span><br></pre></td></tr></table></figure>\n<h3 id=\"主节点的故障转移\"><a href=\"#主节点的故障转移\" class=\"headerlink\" title=\"主节点的故障转移\"></a>主节点的故障转移</h3><p>哨兵的选举基本是根据raft协议的，代表哨兵只需要集群达成共识就行，其实哪个哨兵都可以去做。但是新主节点的选举是有条件的，会选举出一个最有“能力”的节点。、</p>\n<p>首先如果一个 slave 跟 master 断开连接的时间已经超过了 <code>down-after-milliseconds</code> 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。在剩余的 slave里排序：</p>\n<ol>\n<li>按照 slave 优先级进行排序，slave priority 越低，优先级就越高。</li>\n<li>如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。</li>\n<li>如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。</li>\n</ol>\n<p>回到实践中，从日志上可以看到，哨兵成为领导者后开始干活，它选择了6381节点作为新的主节点，进行故障转移</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">998:X 21 Aug 19:20:42.573 # +elected-leader master mymaster 127.0.0.1 6379</span><br><span class=\"line\">998:X 21 Aug 19:20:42.573 # +failover-state-select-slave master mymaster 127.0.0.1 6379</span><br><span class=\"line\">998:X 21 Aug 19:20:42.673 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379</span><br><span class=\"line\">998:X 21 Aug 19:20:42.673 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379</span><br></pre></td></tr></table></figure>\n<h3 id=\"slave-配置的自动纠正\"><a href=\"#slave-配置的自动纠正\" class=\"headerlink\" title=\"slave 配置的自动纠正\"></a>slave 配置的自动纠正</h3><p>哨兵会负责自动纠正 slave 的一些配置，比如 slave 如果要成为潜在的 master 候选人，哨兵会确保 slave 复制现有 master 的数据；如果 slave 连接到了一个错误的 master 上，比如故障转移之后，那么哨兵会确保它们连接到正确的 master 上。</p>\n<p>slave上升为master日志中可以发现，这一条配置重写的日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">989:M 21 Aug 19:20:42.729 # CONFIG REWRITE executed with success.</span><br></pre></td></tr></table></figure>\n<p>## </p>\n<p>最后的一条日志标志，master切换完成。</p>\n<p><code>1002:X 21 Aug 19:20:43.759 # +switch-master mymaster 127.0.0.1 6379 127.0.0.1 6381</code></p>\n<h2 id=\"三、细节探讨\"><a href=\"#三、细节探讨\" class=\"headerlink\" title=\"三、细节探讨\"></a>三、细节探讨</h2><p>Redis的分布式设计和Raft协议有哪些不同？</p>\n<p>虽然本文是用Redis故障转移实践理解raft协议，redis并不是完全基于raft实现的，两者还是有区别的。</p>\n<p>两者的一致性级别要求不同：Raft中采用的是QUORUM， 即确保至少大部分节点都接收到写操作之后才会返回结果给Client， 而Redis默认采用的实际上是ANY/ONE, 即只要Master节点写入成功后，就立刻返回给Client，然后该写入命令被异步的发送给所有的slave节点。</p>\n<h3 id=\"Raft怎么避免多个condidate竞争导致的无限重复选举？\"><a href=\"#Raft怎么避免多个condidate竞争导致的无限重复选举？\" class=\"headerlink\" title=\"Raft怎么避免多个condidate竞争导致的无限重复选举？\"></a>Raft怎么避免多个condidate竞争导致的无限重复选举？</h3><p>当follower判定当前的leader节点故障之后，follower会首先<strong>随机休眠一段时间</strong>，比如我们设置所有的节点休眠时间为150-300ms之间，即rand(150, 300)，每个节点休眠结束后，便向其他的节点发起拉票。比如A节点先唤醒，唤醒后向B、C节点发起拉票。每个Term期间，每个节点只能至多投一票给别人。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>拜占庭将军问题：<a href=\"https://www.youtube.com/watch?v=e9KVmyI1eCg&amp;t=303s\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=e9KVmyI1eCg&amp;t=303s</a></p>\n<p>Redis与raft相同与不同之处：<a href=\"https://zhuanlan.zhihu.com/p/112651338\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/112651338</a></p>\n"},{"title":"synchronized与volatile原理解析","date":"2019-10-01T15:53:50.000Z","description":"synchronized与volatile原理解析","_content":"\n# 线程安全\n\n在学synchronized和volatile之前，我们先来了解一个概念——什么是线程安全？\n线程安全简单来说就在多线程的情况下也不会有问题，看似一句废话，要怎么理解呢\n比如ArrayList不是线程安全的就是一个线程不安全的类，\n如果两个线程对可以同一个ArrayList进行add操作会出现什么结果？请看下面代码\n\n```\npublic class MyTest {\n            static List<Integer> list = new ArrayList<>();\n\n            static class BB implements Runnable {\n                @Override\n                public void run() {\n                    for (int j = 0; j < 10000; j++) {\n                        list.add(j);\n                    } } }\n\npublic static void main(String[] args) throws InterruptedException{\n\n                BB b = new BB();\n                Thread t1 = new Thread(b);\n                Thread t2 = new Thread(b);\n                t1.start();\n                t2.start();\n                t1.join();\n                t2.join();\n\n                System.out.println(list.size());\n            }\n        }\n```\n\n问题出在add方法\n\n```\npublic boolean add(E e) {   ensureCapacityInternal(size + 1);   \nelementData[size++] = e;  \nreturn true;}\n```\n\n上面的程序，可能有三种情况发生：\n\n- 数组下标越界。首先要检查容量，必要时进行扩容。每当在数组边界处，如果A线程和B线程同时进入并检查容量，也就是它们都执行完ensureCapacityInternal方法，因为还有一个空间，所以不进行扩容，此时如果A暂停下来，B成功自增；然后接着A从 elementData[size++]=e开始执行，由于A之前已经检查过没有扩容，而B成功自增使得现在没有空余空间了，此时A就会发生数组下标越界。\n- 小于20000。size++可以看成是 size=size+1，这一行代码包括三个步骤，先读取size，然后将size加1，最后将这个新值写回到size。此时若A和B线程同时读取到size假设为10，B先自增成功size变11，然后回来A因为它读到的size也是10，所以自增后写入size被更新成11，也就是说两次自增，实际上size只增大了1。因此最后的size会小于200。\n- 等于20000 很幸运，没有发生上面情况\n  顺便说一句，线程越多，或者加的数越大越可能出现不安全的问题\n\n# synchronized：“这条桥上一次只能过一个人”\n\n\n\n## 关键词\n\n互斥、JVM内置锁、对象锁、可重入(避免死锁)\n\n## 有什么用\n\n- **原子性**：确保线程互斥的访问同步代码；\n- **可见性**：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的 **“对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值”** 来保证的；\n- **有序性**：有效解决重排序问题，即 **“一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”**；\n\n\n\n## 怎么用\n\n当synchronized作用在实例方法时，监视器锁（monitor）便是**对象实例（this）**；\n\n当synchronized作用在静态方法时，监视器锁（monitor）便是对象的**Class实例**，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个**全局锁**；\n\n当synchronized作用在某一个对象实例时，监视器锁（monitor）便是**括号括起来的对象实例**；\n\n\n\n## 为什么\n\n想了解synchronized的原理，首先要了解两个东西：对象头中的Mark Word和Monitor，说白了，前者是资源的锁，后者是拥有者线程的锁记录。加锁要修改拥有者和资源的锁记录才行。\n\n加锁的时候**首先要添加拥有者线程的锁记录**，虚拟机会在当前线程的栈帧中建立一个名为锁记录( Lock Record)的空间,用于存储锁对象目前的Mark Word的拷贝\n\n**然后要修改资源的锁记录**,虚拟机将使用**CAS**操作尝试将对象的 Mark Word更新为指向 Lock record的指针。如果这个更新动作成功了,那么这个线程就拥有了该对象的锁,并且对象 Mark Word的锁标志位将转变为“00”,即表示此对象处于轻量级锁定状态。\n\n### Monitor\n\nMonitor是**线程私有**的数据结构，每一个线程都有一个可用monitor record列表，它依赖于底层的操作系统的**Mutex Lock（互斥锁）**来实现的线程同步。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。\n\n\n\n\n\n### 对象头中的Mark Word![多线程概念](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5.png)\n\n\n\n**对象头**：Mark Word（标记字段）、Klass Pointer（类型指针）、数组长度数据（可选）\n\n**实例数据**：存放**类的属性**数据信息，包括父类的属性信息；\n\n**对齐填充**：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据**不是必须的**，仅仅是为了字节对齐；\n\n\n\n**Mark Word中四种锁状态标识**\n\n| 锁状态   | 存储内容                                                | 存储内容 |\n| :------- | :------------------------------------------------------ | :------- |\n| 无锁     | 对象的hashCode、对象分代年龄、是否是偏向锁（0）         | 01       |\n| 偏向锁   | 偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1） | 01       |\n| 轻量级锁 | 指向栈中锁记录的指针                                    | 00       |\n| 重量级锁 | 指向互斥量（重量级锁）的指针                            | 10       |\n\n*注意：无锁和偏向锁使用的是一个标志位，但偏向锁还有是否是偏向锁标志位、线程ID、Epoch等*\n\n接下来我将顺着标识位来讲synchronized的四种锁状态。\n\n### 四种锁状态\n\nJDK 6之前synchronized效率低，是因为依赖于操作系统Mutex Lock，即“重量级锁”，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。\n\nJDK 6之后的synchronized锁级别从低到高依次是：**无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。**\n\n| **锁**   | 消耗                                                         | **缺点**                                       | **适用场景**                       |\n| -------- | ------------------------------------------------------------ | ---------------------------------------------- | ---------------------------------- |\n| 偏向锁   | 加锁和解锁时对比Mark Word，只需一次CAS原子指令               | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景   |\n| 轻量级锁 | 将Mark word拷贝到栈帧的锁记录中，再将Mark Word替换为锁记录的指针。多个CAS操作和自旋。 | 自旋会消耗**CPU**，但相应时间快                | 追求响应速度，同步块执行速度非常快 |\n| 重量级锁 | 依赖于操作系统Mutex Lock，等待线程被阻塞挂起                 | 线程阻塞**响应时间缓慢**，但不会消耗CPU        | 追求吞吐量，同步块执行速度较长     |\n\n#### **偏向锁**\n\nHotSpot发现：在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。\n\n当一个线程访问同步代码块并获取锁时，会在Mark Word里存储**锁偏向的线程ID**。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在**无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径**，因为轻量级锁的获取及释放依赖**多次**CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖**一次**CAS原子指令即可。\n\n偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待**全局安全点**（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。\n\n偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。\n\n#### **轻量级锁**\n\n是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，**其他线程会通过自旋**的形式尝试获取锁，不会阻塞，从而提高性能。\n\n虚拟机会在当前线程的栈帧中建立一个名为锁记录( Lock Record)的空间,用于存储锁对象目前的Mark Word的拷贝。\n然后虚拟机将使用**CAS**操作尝试将对象的 Mark Word更新为指向 Lock record的指针。如果这个更新动作成功了,那么这个线程就拥有了该对象的锁,并且对象 Mark Word的锁标志位将转变为“00”,即表示此对象处于轻量级锁定状态。即上面说的加锁要修改拥有者和资源的锁记录才行。\n\n如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。\n\n若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有**第三个**来访时，轻量级锁升级为重量级锁。\n\n#### **重量级锁**\n\n升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时**等待锁的线程都会进入阻塞状态。**\n\n\n\n# volatile\n\n## 有什么用\n\nvolatile是一个关键字，用于修饰变量。被其修饰的变量具有可见性和有序性。\n\n- **可见性**，当一条线程修改了这个变量的值，新值能被其他线程立刻观察到。其实这里要结合Java内存结构来说：在缓存在本CPU对变量的修改直接写入主内存中，同时这个写操作使得其他CPU中对应变量的缓存行无效，这样其他线程在读取这个变量时候必须从主内存中读取，所以读取到的是最新的，这就是上面说得能被立即“看到”。\n- **有序性**，即volatile可以**禁止指令重排**。volatile在其汇编代码中有一个lock操作，这个操作相当于一个**内存屏障**，指令重排不能越过内存屏障。具体来说在执行到volatile变量时，内存屏障之前的语句一定被执行过了且结果对后面是已知的，而内存屏障后面的语句一定还没执行到；在volatile变量之前的语句不能被重排后其之后，相反其后的语句也不能被重排到之前。\n\n## 原理\n\n加入volatile关键字时，会多出一个**lock前缀指令**。lock前缀指令其实就相当于一个内存屏障。**内存屏障是一组处理指令，用来实现对内存操作的顺序限制。**volatile的底层就是通过内存屏障来实现的。\n\nlock前缀会做两件事情：\n\n- **将当前处理器缓存行的数据会写回到系统内存。**这可以保证写操作强制被更新到处理器，处理器的值是最新的。\n- 这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。**这可以保证每个线程总是去处理器读，而不是使用自己可能过期的缓存数据。**以实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。\n\n也就符合了happens-before原则中——同一时间对volatile变量的写操作总先于读操作，实现了程序的有序性。（如果两个操作的执行顺序无法从happens-before原则中推到出来，那么他们就不能保证有序性，可以随意进行重排序。）\n\n\n\n## 经典场景\n\nchm的get方法是**不加锁的**，因为get方法里的共享变量都定义成volatile类型，保证能被多线程的读，但只能被单线程的写。即使一个线程在读一个线程同时在写，根据happen before原则，对volatile字段的写入先于读操作，所以get总能拿到最新的值。这是用volatile替换锁的经典场景。\n\n# 其他\n\n### 为什么wait,notify在Object类里，而把sleep放在Thread类里面？\n\nsleep和wait的区别在于：sleep方法没有释放锁，而wait方法释放了锁。\n\n一个线程可以拥有多个对象锁，wait，notify，notifyAll跟对象锁之间是有一个绑定关系的，假如用Thread.wait()，Thread.notify()，Thread.notifyAll()来调用，虚拟机根本就不知道需要操作的对象锁是哪一个。\n\n","source":"_posts/synchronized与volatile.md","raw":"---\ntitle: synchronized与volatile原理解析\ndate: 2019-10-01 23:53:50\ncategories: 并发\ndescription: synchronized与volatile原理解析\n\n---\n\n# 线程安全\n\n在学synchronized和volatile之前，我们先来了解一个概念——什么是线程安全？\n线程安全简单来说就在多线程的情况下也不会有问题，看似一句废话，要怎么理解呢\n比如ArrayList不是线程安全的就是一个线程不安全的类，\n如果两个线程对可以同一个ArrayList进行add操作会出现什么结果？请看下面代码\n\n```\npublic class MyTest {\n            static List<Integer> list = new ArrayList<>();\n\n            static class BB implements Runnable {\n                @Override\n                public void run() {\n                    for (int j = 0; j < 10000; j++) {\n                        list.add(j);\n                    } } }\n\npublic static void main(String[] args) throws InterruptedException{\n\n                BB b = new BB();\n                Thread t1 = new Thread(b);\n                Thread t2 = new Thread(b);\n                t1.start();\n                t2.start();\n                t1.join();\n                t2.join();\n\n                System.out.println(list.size());\n            }\n        }\n```\n\n问题出在add方法\n\n```\npublic boolean add(E e) {   ensureCapacityInternal(size + 1);   \nelementData[size++] = e;  \nreturn true;}\n```\n\n上面的程序，可能有三种情况发生：\n\n- 数组下标越界。首先要检查容量，必要时进行扩容。每当在数组边界处，如果A线程和B线程同时进入并检查容量，也就是它们都执行完ensureCapacityInternal方法，因为还有一个空间，所以不进行扩容，此时如果A暂停下来，B成功自增；然后接着A从 elementData[size++]=e开始执行，由于A之前已经检查过没有扩容，而B成功自增使得现在没有空余空间了，此时A就会发生数组下标越界。\n- 小于20000。size++可以看成是 size=size+1，这一行代码包括三个步骤，先读取size，然后将size加1，最后将这个新值写回到size。此时若A和B线程同时读取到size假设为10，B先自增成功size变11，然后回来A因为它读到的size也是10，所以自增后写入size被更新成11，也就是说两次自增，实际上size只增大了1。因此最后的size会小于200。\n- 等于20000 很幸运，没有发生上面情况\n  顺便说一句，线程越多，或者加的数越大越可能出现不安全的问题\n\n# synchronized：“这条桥上一次只能过一个人”\n\n\n\n## 关键词\n\n互斥、JVM内置锁、对象锁、可重入(避免死锁)\n\n## 有什么用\n\n- **原子性**：确保线程互斥的访问同步代码；\n- **可见性**：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的 **“对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值”** 来保证的；\n- **有序性**：有效解决重排序问题，即 **“一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”**；\n\n\n\n## 怎么用\n\n当synchronized作用在实例方法时，监视器锁（monitor）便是**对象实例（this）**；\n\n当synchronized作用在静态方法时，监视器锁（monitor）便是对象的**Class实例**，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个**全局锁**；\n\n当synchronized作用在某一个对象实例时，监视器锁（monitor）便是**括号括起来的对象实例**；\n\n\n\n## 为什么\n\n想了解synchronized的原理，首先要了解两个东西：对象头中的Mark Word和Monitor，说白了，前者是资源的锁，后者是拥有者线程的锁记录。加锁要修改拥有者和资源的锁记录才行。\n\n加锁的时候**首先要添加拥有者线程的锁记录**，虚拟机会在当前线程的栈帧中建立一个名为锁记录( Lock Record)的空间,用于存储锁对象目前的Mark Word的拷贝\n\n**然后要修改资源的锁记录**,虚拟机将使用**CAS**操作尝试将对象的 Mark Word更新为指向 Lock record的指针。如果这个更新动作成功了,那么这个线程就拥有了该对象的锁,并且对象 Mark Word的锁标志位将转变为“00”,即表示此对象处于轻量级锁定状态。\n\n### Monitor\n\nMonitor是**线程私有**的数据结构，每一个线程都有一个可用monitor record列表，它依赖于底层的操作系统的**Mutex Lock（互斥锁）**来实现的线程同步。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。\n\n\n\n\n\n### 对象头中的Mark Word![多线程概念](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5.png)\n\n\n\n**对象头**：Mark Word（标记字段）、Klass Pointer（类型指针）、数组长度数据（可选）\n\n**实例数据**：存放**类的属性**数据信息，包括父类的属性信息；\n\n**对齐填充**：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据**不是必须的**，仅仅是为了字节对齐；\n\n\n\n**Mark Word中四种锁状态标识**\n\n| 锁状态   | 存储内容                                                | 存储内容 |\n| :------- | :------------------------------------------------------ | :------- |\n| 无锁     | 对象的hashCode、对象分代年龄、是否是偏向锁（0）         | 01       |\n| 偏向锁   | 偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1） | 01       |\n| 轻量级锁 | 指向栈中锁记录的指针                                    | 00       |\n| 重量级锁 | 指向互斥量（重量级锁）的指针                            | 10       |\n\n*注意：无锁和偏向锁使用的是一个标志位，但偏向锁还有是否是偏向锁标志位、线程ID、Epoch等*\n\n接下来我将顺着标识位来讲synchronized的四种锁状态。\n\n### 四种锁状态\n\nJDK 6之前synchronized效率低，是因为依赖于操作系统Mutex Lock，即“重量级锁”，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。\n\nJDK 6之后的synchronized锁级别从低到高依次是：**无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。**\n\n| **锁**   | 消耗                                                         | **缺点**                                       | **适用场景**                       |\n| -------- | ------------------------------------------------------------ | ---------------------------------------------- | ---------------------------------- |\n| 偏向锁   | 加锁和解锁时对比Mark Word，只需一次CAS原子指令               | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景   |\n| 轻量级锁 | 将Mark word拷贝到栈帧的锁记录中，再将Mark Word替换为锁记录的指针。多个CAS操作和自旋。 | 自旋会消耗**CPU**，但相应时间快                | 追求响应速度，同步块执行速度非常快 |\n| 重量级锁 | 依赖于操作系统Mutex Lock，等待线程被阻塞挂起                 | 线程阻塞**响应时间缓慢**，但不会消耗CPU        | 追求吞吐量，同步块执行速度较长     |\n\n#### **偏向锁**\n\nHotSpot发现：在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。\n\n当一个线程访问同步代码块并获取锁时，会在Mark Word里存储**锁偏向的线程ID**。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在**无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径**，因为轻量级锁的获取及释放依赖**多次**CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖**一次**CAS原子指令即可。\n\n偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待**全局安全点**（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。\n\n偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。\n\n#### **轻量级锁**\n\n是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，**其他线程会通过自旋**的形式尝试获取锁，不会阻塞，从而提高性能。\n\n虚拟机会在当前线程的栈帧中建立一个名为锁记录( Lock Record)的空间,用于存储锁对象目前的Mark Word的拷贝。\n然后虚拟机将使用**CAS**操作尝试将对象的 Mark Word更新为指向 Lock record的指针。如果这个更新动作成功了,那么这个线程就拥有了该对象的锁,并且对象 Mark Word的锁标志位将转变为“00”,即表示此对象处于轻量级锁定状态。即上面说的加锁要修改拥有者和资源的锁记录才行。\n\n如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。\n\n若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有**第三个**来访时，轻量级锁升级为重量级锁。\n\n#### **重量级锁**\n\n升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时**等待锁的线程都会进入阻塞状态。**\n\n\n\n# volatile\n\n## 有什么用\n\nvolatile是一个关键字，用于修饰变量。被其修饰的变量具有可见性和有序性。\n\n- **可见性**，当一条线程修改了这个变量的值，新值能被其他线程立刻观察到。其实这里要结合Java内存结构来说：在缓存在本CPU对变量的修改直接写入主内存中，同时这个写操作使得其他CPU中对应变量的缓存行无效，这样其他线程在读取这个变量时候必须从主内存中读取，所以读取到的是最新的，这就是上面说得能被立即“看到”。\n- **有序性**，即volatile可以**禁止指令重排**。volatile在其汇编代码中有一个lock操作，这个操作相当于一个**内存屏障**，指令重排不能越过内存屏障。具体来说在执行到volatile变量时，内存屏障之前的语句一定被执行过了且结果对后面是已知的，而内存屏障后面的语句一定还没执行到；在volatile变量之前的语句不能被重排后其之后，相反其后的语句也不能被重排到之前。\n\n## 原理\n\n加入volatile关键字时，会多出一个**lock前缀指令**。lock前缀指令其实就相当于一个内存屏障。**内存屏障是一组处理指令，用来实现对内存操作的顺序限制。**volatile的底层就是通过内存屏障来实现的。\n\nlock前缀会做两件事情：\n\n- **将当前处理器缓存行的数据会写回到系统内存。**这可以保证写操作强制被更新到处理器，处理器的值是最新的。\n- 这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。**这可以保证每个线程总是去处理器读，而不是使用自己可能过期的缓存数据。**以实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。\n\n也就符合了happens-before原则中——同一时间对volatile变量的写操作总先于读操作，实现了程序的有序性。（如果两个操作的执行顺序无法从happens-before原则中推到出来，那么他们就不能保证有序性，可以随意进行重排序。）\n\n\n\n## 经典场景\n\nchm的get方法是**不加锁的**，因为get方法里的共享变量都定义成volatile类型，保证能被多线程的读，但只能被单线程的写。即使一个线程在读一个线程同时在写，根据happen before原则，对volatile字段的写入先于读操作，所以get总能拿到最新的值。这是用volatile替换锁的经典场景。\n\n# 其他\n\n### 为什么wait,notify在Object类里，而把sleep放在Thread类里面？\n\nsleep和wait的区别在于：sleep方法没有释放锁，而wait方法释放了锁。\n\n一个线程可以拥有多个对象锁，wait，notify，notifyAll跟对象锁之间是有一个绑定关系的，假如用Thread.wait()，Thread.notify()，Thread.notifyAll()来调用，虚拟机根本就不知道需要操作的对象锁是哪一个。\n\n","slug":"synchronized与volatile","published":1,"updated":"2022-02-08T07:09:41.227Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qkd000uw9rpyzys1laa","content":"<h1 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h1><p>在学synchronized和volatile之前，我们先来了解一个概念——什么是线程安全？<br>线程安全简单来说就在多线程的情况下也不会有问题，看似一句废话，要怎么理解呢<br>比如ArrayList不是线程安全的就是一个线程不安全的类，<br>如果两个线程对可以同一个ArrayList进行add操作会出现什么结果？请看下面代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyTest &#123;</span><br><span class=\"line\">            static List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">            static class BB implements Runnable &#123;</span><br><span class=\"line\">                @Override</span><br><span class=\"line\">                public void run() &#123;</span><br><span class=\"line\">                    for (int j = 0; j &lt; 10000; j++) &#123;</span><br><span class=\"line\">                        list.add(j);</span><br><span class=\"line\">                    &#125; &#125; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void main(String[] args) throws InterruptedException&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                BB b = new BB();</span><br><span class=\"line\">                Thread t1 = new Thread(b);</span><br><span class=\"line\">                Thread t2 = new Thread(b);</span><br><span class=\"line\">                t1.start();</span><br><span class=\"line\">                t2.start();</span><br><span class=\"line\">                t1.join();</span><br><span class=\"line\">                t2.join();</span><br><span class=\"line\"></span><br><span class=\"line\">                System.out.println(list.size());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>问题出在add方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean add(E e) &#123;   ensureCapacityInternal(size + 1);   </span><br><span class=\"line\">elementData[size++] = e;  </span><br><span class=\"line\">return true;&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的程序，可能有三种情况发生：</p>\n<ul>\n<li>数组下标越界。首先要检查容量，必要时进行扩容。每当在数组边界处，如果A线程和B线程同时进入并检查容量，也就是它们都执行完ensureCapacityInternal方法，因为还有一个空间，所以不进行扩容，此时如果A暂停下来，B成功自增；然后接着A从 elementData[size++]=e开始执行，由于A之前已经检查过没有扩容，而B成功自增使得现在没有空余空间了，此时A就会发生数组下标越界。</li>\n<li>小于20000。size++可以看成是 size=size+1，这一行代码包括三个步骤，先读取size，然后将size加1，最后将这个新值写回到size。此时若A和B线程同时读取到size假设为10，B先自增成功size变11，然后回来A因为它读到的size也是10，所以自增后写入size被更新成11，也就是说两次自增，实际上size只增大了1。因此最后的size会小于200。</li>\n<li>等于20000 很幸运，没有发生上面情况<br>顺便说一句，线程越多，或者加的数越大越可能出现不安全的问题</li>\n</ul>\n<h1 id=\"synchronized：“这条桥上一次只能过一个人”\"><a href=\"#synchronized：“这条桥上一次只能过一个人”\" class=\"headerlink\" title=\"synchronized：“这条桥上一次只能过一个人”\"></a>synchronized：“这条桥上一次只能过一个人”</h1><h2 id=\"关键词\"><a href=\"#关键词\" class=\"headerlink\" title=\"关键词\"></a>关键词</h2><p>互斥、JVM内置锁、对象锁、可重入(避免死锁)</p>\n<h2 id=\"有什么用\"><a href=\"#有什么用\" class=\"headerlink\" title=\"有什么用\"></a>有什么用</h2><ul>\n<li><strong>原子性</strong>：确保线程互斥的访问同步代码；</li>\n<li><strong>可见性</strong>：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的 <strong>“对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值”</strong> 来保证的；</li>\n<li><strong>有序性</strong>：有效解决重排序问题，即 <strong>“一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”</strong>；</li>\n</ul>\n<h2 id=\"怎么用\"><a href=\"#怎么用\" class=\"headerlink\" title=\"怎么用\"></a>怎么用</h2><p>当synchronized作用在实例方法时，监视器锁（monitor）便是<strong>对象实例（this）</strong>；</p>\n<p>当synchronized作用在静态方法时，监视器锁（monitor）便是对象的<strong>Class实例</strong>，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个<strong>全局锁</strong>；</p>\n<p>当synchronized作用在某一个对象实例时，监视器锁（monitor）便是<strong>括号括起来的对象实例</strong>；</p>\n<h2 id=\"为什么\"><a href=\"#为什么\" class=\"headerlink\" title=\"为什么\"></a>为什么</h2><p>想了解synchronized的原理，首先要了解两个东西：对象头中的Mark Word和Monitor，说白了，前者是资源的锁，后者是拥有者线程的锁记录。加锁要修改拥有者和资源的锁记录才行。</p>\n<p>加锁的时候<strong>首先要添加拥有者线程的锁记录</strong>，虚拟机会在当前线程的栈帧中建立一个名为锁记录( Lock Record)的空间,用于存储锁对象目前的Mark Word的拷贝</p>\n<p><strong>然后要修改资源的锁记录</strong>,虚拟机将使用<strong>CAS</strong>操作尝试将对象的 Mark Word更新为指向 Lock record的指针。如果这个更新动作成功了,那么这个线程就拥有了该对象的锁,并且对象 Mark Word的锁标志位将转变为“00”,即表示此对象处于轻量级锁定状态。</p>\n<h3 id=\"Monitor\"><a href=\"#Monitor\" class=\"headerlink\" title=\"Monitor\"></a>Monitor</h3><p>Monitor是<strong>线程私有</strong>的数据结构，每一个线程都有一个可用monitor record列表，它依赖于底层的操作系统的<strong>Mutex Lock（互斥锁）</strong>来实现的线程同步。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p>\n<h3 id=\"对象头中的Mark-Word\"><a href=\"#对象头中的Mark-Word\" class=\"headerlink\" title=\"对象头中的Mark Word\"></a>对象头中的Mark Word<img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5.png\" alt=\"多线程概念\"></h3><p><strong>对象头</strong>：Mark Word（标记字段）、Klass Pointer（类型指针）、数组长度数据（可选）</p>\n<p><strong>实例数据</strong>：存放<strong>类的属性</strong>数据信息，包括父类的属性信息；</p>\n<p><strong>对齐填充</strong>：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据<strong>不是必须的</strong>，仅仅是为了字节对齐；</p>\n<p><strong>Mark Word中四种锁状态标识</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">锁状态</th>\n<th style=\"text-align:left\">存储内容</th>\n<th style=\"text-align:left\">存储内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">无锁</td>\n<td style=\"text-align:left\">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td>\n<td style=\"text-align:left\">01</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">偏向锁</td>\n<td style=\"text-align:left\">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td>\n<td style=\"text-align:left\">01</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">轻量级锁</td>\n<td style=\"text-align:left\">指向栈中锁记录的指针</td>\n<td style=\"text-align:left\">00</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">重量级锁</td>\n<td style=\"text-align:left\">指向互斥量（重量级锁）的指针</td>\n<td style=\"text-align:left\">10</td>\n</tr>\n</tbody>\n</table>\n<p><em>注意：无锁和偏向锁使用的是一个标志位，但偏向锁还有是否是偏向锁标志位、线程ID、Epoch等</em></p>\n<p>接下来我将顺着标识位来讲synchronized的四种锁状态。</p>\n<h3 id=\"四种锁状态\"><a href=\"#四种锁状态\" class=\"headerlink\" title=\"四种锁状态\"></a>四种锁状态</h3><p>JDK 6之前synchronized效率低，是因为依赖于操作系统Mutex Lock，即“重量级锁”，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p>\n<p>JDK 6之后的synchronized锁级别从低到高依次是：<strong>无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>锁</strong></th>\n<th>消耗</th>\n<th><strong>缺点</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>偏向锁</td>\n<td>加锁和解锁时对比Mark Word，只需一次CAS原子指令</td>\n<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>\n<td>适用于只有一个线程访问同步块场景</td>\n</tr>\n<tr>\n<td>轻量级锁</td>\n<td>将Mark word拷贝到栈帧的锁记录中，再将Mark Word替换为锁记录的指针。多个CAS操作和自旋。</td>\n<td>自旋会消耗<strong>CPU</strong>，但相应时间快</td>\n<td>追求响应速度，同步块执行速度非常快</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td>依赖于操作系统Mutex Lock，等待线程被阻塞挂起</td>\n<td>线程阻塞<strong>响应时间缓慢</strong>，但不会消耗CPU</td>\n<td>追求吞吐量，同步块执行速度较长</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a><strong>偏向锁</strong></h4><p>HotSpot发现：在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>\n<p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储<strong>锁偏向的线程ID</strong>。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在<strong>无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径</strong>，因为轻量级锁的获取及释放依赖<strong>多次</strong>CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖<strong>一次</strong>CAS原子指令即可。</p>\n<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待<strong>全局安全点</strong>（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>\n<p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p>\n<h4 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a><strong>轻量级锁</strong></h4><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，<strong>其他线程会通过自旋</strong>的形式尝试获取锁，不会阻塞，从而提高性能。</p>\n<p>虚拟机会在当前线程的栈帧中建立一个名为锁记录( Lock Record)的空间,用于存储锁对象目前的Mark Word的拷贝。<br>然后虚拟机将使用<strong>CAS</strong>操作尝试将对象的 Mark Word更新为指向 Lock record的指针。如果这个更新动作成功了,那么这个线程就拥有了该对象的锁,并且对象 Mark Word的锁标志位将转变为“00”,即表示此对象处于轻量级锁定状态。即上面说的加锁要修改拥有者和资源的锁记录才行。</p>\n<p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p>\n<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有<strong>第三个</strong>来访时，轻量级锁升级为重量级锁。</p>\n<h4 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a><strong>重量级锁</strong></h4><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时<strong>等待锁的线程都会进入阻塞状态。</strong></p>\n<h1 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h1><h2 id=\"有什么用-1\"><a href=\"#有什么用-1\" class=\"headerlink\" title=\"有什么用\"></a>有什么用</h2><p>volatile是一个关键字，用于修饰变量。被其修饰的变量具有可见性和有序性。</p>\n<ul>\n<li><strong>可见性</strong>，当一条线程修改了这个变量的值，新值能被其他线程立刻观察到。其实这里要结合Java内存结构来说：在缓存在本CPU对变量的修改直接写入主内存中，同时这个写操作使得其他CPU中对应变量的缓存行无效，这样其他线程在读取这个变量时候必须从主内存中读取，所以读取到的是最新的，这就是上面说得能被立即“看到”。</li>\n<li><strong>有序性</strong>，即volatile可以<strong>禁止指令重排</strong>。volatile在其汇编代码中有一个lock操作，这个操作相当于一个<strong>内存屏障</strong>，指令重排不能越过内存屏障。具体来说在执行到volatile变量时，内存屏障之前的语句一定被执行过了且结果对后面是已知的，而内存屏障后面的语句一定还没执行到；在volatile变量之前的语句不能被重排后其之后，相反其后的语句也不能被重排到之前。</li>\n</ul>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>加入volatile关键字时，会多出一个<strong>lock前缀指令</strong>。lock前缀指令其实就相当于一个内存屏障。<strong>内存屏障是一组处理指令，用来实现对内存操作的顺序限制。</strong>volatile的底层就是通过内存屏障来实现的。</p>\n<p>lock前缀会做两件事情：</p>\n<ul>\n<li><strong>将当前处理器缓存行的数据会写回到系统内存。</strong>这可以保证写操作强制被更新到处理器，处理器的值是最新的。</li>\n<li>这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。<strong>这可以保证每个线程总是去处理器读，而不是使用自己可能过期的缓存数据。</strong>以实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</li>\n</ul>\n<p>也就符合了happens-before原则中——同一时间对volatile变量的写操作总先于读操作，实现了程序的有序性。（如果两个操作的执行顺序无法从happens-before原则中推到出来，那么他们就不能保证有序性，可以随意进行重排序。）</p>\n<h2 id=\"经典场景\"><a href=\"#经典场景\" class=\"headerlink\" title=\"经典场景\"></a>经典场景</h2><p>chm的get方法是<strong>不加锁的</strong>，因为get方法里的共享变量都定义成volatile类型，保证能被多线程的读，但只能被单线程的写。即使一个线程在读一个线程同时在写，根据happen before原则，对volatile字段的写入先于读操作，所以get总能拿到最新的值。这是用volatile替换锁的经典场景。</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h3 id=\"为什么wait-notify在Object类里，而把sleep放在Thread类里面？\"><a href=\"#为什么wait-notify在Object类里，而把sleep放在Thread类里面？\" class=\"headerlink\" title=\"为什么wait,notify在Object类里，而把sleep放在Thread类里面？\"></a>为什么wait,notify在Object类里，而把sleep放在Thread类里面？</h3><p>sleep和wait的区别在于：sleep方法没有释放锁，而wait方法释放了锁。</p>\n<p>一个线程可以拥有多个对象锁，wait，notify，notifyAll跟对象锁之间是有一个绑定关系的，假如用Thread.wait()，Thread.notify()，Thread.notifyAll()来调用，虚拟机根本就不知道需要操作的对象锁是哪一个。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h1><p>在学synchronized和volatile之前，我们先来了解一个概念——什么是线程安全？<br>线程安全简单来说就在多线程的情况下也不会有问题，看似一句废话，要怎么理解呢<br>比如ArrayList不是线程安全的就是一个线程不安全的类，<br>如果两个线程对可以同一个ArrayList进行add操作会出现什么结果？请看下面代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyTest &#123;</span><br><span class=\"line\">            static List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">            static class BB implements Runnable &#123;</span><br><span class=\"line\">                @Override</span><br><span class=\"line\">                public void run() &#123;</span><br><span class=\"line\">                    for (int j = 0; j &lt; 10000; j++) &#123;</span><br><span class=\"line\">                        list.add(j);</span><br><span class=\"line\">                    &#125; &#125; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void main(String[] args) throws InterruptedException&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                BB b = new BB();</span><br><span class=\"line\">                Thread t1 = new Thread(b);</span><br><span class=\"line\">                Thread t2 = new Thread(b);</span><br><span class=\"line\">                t1.start();</span><br><span class=\"line\">                t2.start();</span><br><span class=\"line\">                t1.join();</span><br><span class=\"line\">                t2.join();</span><br><span class=\"line\"></span><br><span class=\"line\">                System.out.println(list.size());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>问题出在add方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean add(E e) &#123;   ensureCapacityInternal(size + 1);   </span><br><span class=\"line\">elementData[size++] = e;  </span><br><span class=\"line\">return true;&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的程序，可能有三种情况发生：</p>\n<ul>\n<li>数组下标越界。首先要检查容量，必要时进行扩容。每当在数组边界处，如果A线程和B线程同时进入并检查容量，也就是它们都执行完ensureCapacityInternal方法，因为还有一个空间，所以不进行扩容，此时如果A暂停下来，B成功自增；然后接着A从 elementData[size++]=e开始执行，由于A之前已经检查过没有扩容，而B成功自增使得现在没有空余空间了，此时A就会发生数组下标越界。</li>\n<li>小于20000。size++可以看成是 size=size+1，这一行代码包括三个步骤，先读取size，然后将size加1，最后将这个新值写回到size。此时若A和B线程同时读取到size假设为10，B先自增成功size变11，然后回来A因为它读到的size也是10，所以自增后写入size被更新成11，也就是说两次自增，实际上size只增大了1。因此最后的size会小于200。</li>\n<li>等于20000 很幸运，没有发生上面情况<br>顺便说一句，线程越多，或者加的数越大越可能出现不安全的问题</li>\n</ul>\n<h1 id=\"synchronized：“这条桥上一次只能过一个人”\"><a href=\"#synchronized：“这条桥上一次只能过一个人”\" class=\"headerlink\" title=\"synchronized：“这条桥上一次只能过一个人”\"></a>synchronized：“这条桥上一次只能过一个人”</h1><h2 id=\"关键词\"><a href=\"#关键词\" class=\"headerlink\" title=\"关键词\"></a>关键词</h2><p>互斥、JVM内置锁、对象锁、可重入(避免死锁)</p>\n<h2 id=\"有什么用\"><a href=\"#有什么用\" class=\"headerlink\" title=\"有什么用\"></a>有什么用</h2><ul>\n<li><strong>原子性</strong>：确保线程互斥的访问同步代码；</li>\n<li><strong>可见性</strong>：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的 <strong>“对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值”</strong> 来保证的；</li>\n<li><strong>有序性</strong>：有效解决重排序问题，即 <strong>“一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”</strong>；</li>\n</ul>\n<h2 id=\"怎么用\"><a href=\"#怎么用\" class=\"headerlink\" title=\"怎么用\"></a>怎么用</h2><p>当synchronized作用在实例方法时，监视器锁（monitor）便是<strong>对象实例（this）</strong>；</p>\n<p>当synchronized作用在静态方法时，监视器锁（monitor）便是对象的<strong>Class实例</strong>，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个<strong>全局锁</strong>；</p>\n<p>当synchronized作用在某一个对象实例时，监视器锁（monitor）便是<strong>括号括起来的对象实例</strong>；</p>\n<h2 id=\"为什么\"><a href=\"#为什么\" class=\"headerlink\" title=\"为什么\"></a>为什么</h2><p>想了解synchronized的原理，首先要了解两个东西：对象头中的Mark Word和Monitor，说白了，前者是资源的锁，后者是拥有者线程的锁记录。加锁要修改拥有者和资源的锁记录才行。</p>\n<p>加锁的时候<strong>首先要添加拥有者线程的锁记录</strong>，虚拟机会在当前线程的栈帧中建立一个名为锁记录( Lock Record)的空间,用于存储锁对象目前的Mark Word的拷贝</p>\n<p><strong>然后要修改资源的锁记录</strong>,虚拟机将使用<strong>CAS</strong>操作尝试将对象的 Mark Word更新为指向 Lock record的指针。如果这个更新动作成功了,那么这个线程就拥有了该对象的锁,并且对象 Mark Word的锁标志位将转变为“00”,即表示此对象处于轻量级锁定状态。</p>\n<h3 id=\"Monitor\"><a href=\"#Monitor\" class=\"headerlink\" title=\"Monitor\"></a>Monitor</h3><p>Monitor是<strong>线程私有</strong>的数据结构，每一个线程都有一个可用monitor record列表，它依赖于底层的操作系统的<strong>Mutex Lock（互斥锁）</strong>来实现的线程同步。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p>\n<h3 id=\"对象头中的Mark-Word\"><a href=\"#对象头中的Mark-Word\" class=\"headerlink\" title=\"对象头中的Mark Word\"></a>对象头中的Mark Word<img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5.png\" alt=\"多线程概念\"></h3><p><strong>对象头</strong>：Mark Word（标记字段）、Klass Pointer（类型指针）、数组长度数据（可选）</p>\n<p><strong>实例数据</strong>：存放<strong>类的属性</strong>数据信息，包括父类的属性信息；</p>\n<p><strong>对齐填充</strong>：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据<strong>不是必须的</strong>，仅仅是为了字节对齐；</p>\n<p><strong>Mark Word中四种锁状态标识</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">锁状态</th>\n<th style=\"text-align:left\">存储内容</th>\n<th style=\"text-align:left\">存储内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">无锁</td>\n<td style=\"text-align:left\">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td>\n<td style=\"text-align:left\">01</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">偏向锁</td>\n<td style=\"text-align:left\">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td>\n<td style=\"text-align:left\">01</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">轻量级锁</td>\n<td style=\"text-align:left\">指向栈中锁记录的指针</td>\n<td style=\"text-align:left\">00</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">重量级锁</td>\n<td style=\"text-align:left\">指向互斥量（重量级锁）的指针</td>\n<td style=\"text-align:left\">10</td>\n</tr>\n</tbody>\n</table>\n<p><em>注意：无锁和偏向锁使用的是一个标志位，但偏向锁还有是否是偏向锁标志位、线程ID、Epoch等</em></p>\n<p>接下来我将顺着标识位来讲synchronized的四种锁状态。</p>\n<h3 id=\"四种锁状态\"><a href=\"#四种锁状态\" class=\"headerlink\" title=\"四种锁状态\"></a>四种锁状态</h3><p>JDK 6之前synchronized效率低，是因为依赖于操作系统Mutex Lock，即“重量级锁”，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p>\n<p>JDK 6之后的synchronized锁级别从低到高依次是：<strong>无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>锁</strong></th>\n<th>消耗</th>\n<th><strong>缺点</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>偏向锁</td>\n<td>加锁和解锁时对比Mark Word，只需一次CAS原子指令</td>\n<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>\n<td>适用于只有一个线程访问同步块场景</td>\n</tr>\n<tr>\n<td>轻量级锁</td>\n<td>将Mark word拷贝到栈帧的锁记录中，再将Mark Word替换为锁记录的指针。多个CAS操作和自旋。</td>\n<td>自旋会消耗<strong>CPU</strong>，但相应时间快</td>\n<td>追求响应速度，同步块执行速度非常快</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td>依赖于操作系统Mutex Lock，等待线程被阻塞挂起</td>\n<td>线程阻塞<strong>响应时间缓慢</strong>，但不会消耗CPU</td>\n<td>追求吞吐量，同步块执行速度较长</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a><strong>偏向锁</strong></h4><p>HotSpot发现：在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>\n<p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储<strong>锁偏向的线程ID</strong>。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在<strong>无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径</strong>，因为轻量级锁的获取及释放依赖<strong>多次</strong>CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖<strong>一次</strong>CAS原子指令即可。</p>\n<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待<strong>全局安全点</strong>（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>\n<p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p>\n<h4 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a><strong>轻量级锁</strong></h4><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，<strong>其他线程会通过自旋</strong>的形式尝试获取锁，不会阻塞，从而提高性能。</p>\n<p>虚拟机会在当前线程的栈帧中建立一个名为锁记录( Lock Record)的空间,用于存储锁对象目前的Mark Word的拷贝。<br>然后虚拟机将使用<strong>CAS</strong>操作尝试将对象的 Mark Word更新为指向 Lock record的指针。如果这个更新动作成功了,那么这个线程就拥有了该对象的锁,并且对象 Mark Word的锁标志位将转变为“00”,即表示此对象处于轻量级锁定状态。即上面说的加锁要修改拥有者和资源的锁记录才行。</p>\n<p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p>\n<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有<strong>第三个</strong>来访时，轻量级锁升级为重量级锁。</p>\n<h4 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a><strong>重量级锁</strong></h4><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时<strong>等待锁的线程都会进入阻塞状态。</strong></p>\n<h1 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h1><h2 id=\"有什么用-1\"><a href=\"#有什么用-1\" class=\"headerlink\" title=\"有什么用\"></a>有什么用</h2><p>volatile是一个关键字，用于修饰变量。被其修饰的变量具有可见性和有序性。</p>\n<ul>\n<li><strong>可见性</strong>，当一条线程修改了这个变量的值，新值能被其他线程立刻观察到。其实这里要结合Java内存结构来说：在缓存在本CPU对变量的修改直接写入主内存中，同时这个写操作使得其他CPU中对应变量的缓存行无效，这样其他线程在读取这个变量时候必须从主内存中读取，所以读取到的是最新的，这就是上面说得能被立即“看到”。</li>\n<li><strong>有序性</strong>，即volatile可以<strong>禁止指令重排</strong>。volatile在其汇编代码中有一个lock操作，这个操作相当于一个<strong>内存屏障</strong>，指令重排不能越过内存屏障。具体来说在执行到volatile变量时，内存屏障之前的语句一定被执行过了且结果对后面是已知的，而内存屏障后面的语句一定还没执行到；在volatile变量之前的语句不能被重排后其之后，相反其后的语句也不能被重排到之前。</li>\n</ul>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>加入volatile关键字时，会多出一个<strong>lock前缀指令</strong>。lock前缀指令其实就相当于一个内存屏障。<strong>内存屏障是一组处理指令，用来实现对内存操作的顺序限制。</strong>volatile的底层就是通过内存屏障来实现的。</p>\n<p>lock前缀会做两件事情：</p>\n<ul>\n<li><strong>将当前处理器缓存行的数据会写回到系统内存。</strong>这可以保证写操作强制被更新到处理器，处理器的值是最新的。</li>\n<li>这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。<strong>这可以保证每个线程总是去处理器读，而不是使用自己可能过期的缓存数据。</strong>以实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</li>\n</ul>\n<p>也就符合了happens-before原则中——同一时间对volatile变量的写操作总先于读操作，实现了程序的有序性。（如果两个操作的执行顺序无法从happens-before原则中推到出来，那么他们就不能保证有序性，可以随意进行重排序。）</p>\n<h2 id=\"经典场景\"><a href=\"#经典场景\" class=\"headerlink\" title=\"经典场景\"></a>经典场景</h2><p>chm的get方法是<strong>不加锁的</strong>，因为get方法里的共享变量都定义成volatile类型，保证能被多线程的读，但只能被单线程的写。即使一个线程在读一个线程同时在写，根据happen before原则，对volatile字段的写入先于读操作，所以get总能拿到最新的值。这是用volatile替换锁的经典场景。</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h3 id=\"为什么wait-notify在Object类里，而把sleep放在Thread类里面？\"><a href=\"#为什么wait-notify在Object类里，而把sleep放在Thread类里面？\" class=\"headerlink\" title=\"为什么wait,notify在Object类里，而把sleep放在Thread类里面？\"></a>为什么wait,notify在Object类里，而把sleep放在Thread类里面？</h3><p>sleep和wait的区别在于：sleep方法没有释放锁，而wait方法释放了锁。</p>\n<p>一个线程可以拥有多个对象锁，wait，notify，notifyAll跟对象锁之间是有一个绑定关系的，假如用Thread.wait()，Thread.notify()，Thread.notifyAll()来调用，虚拟机根本就不知道需要操作的对象锁是哪一个。</p>\n"},{"title":"《java web开发与应用》笔记","date":"2018-12-17T15:00:50.000Z","description":"实战类的一本书。目录上几乎每章都有“为什么”的字眼，这是它最好的地方，它会跟你说在什么需求场景下要用到这个技术，这个技术可以用来干什么，从需求去理解技术。","_content":"# 从C/S从到B/S\nC/S即客户机/服务器，比如qq电脑版。B/S即浏览器/服务器，比如京东网页版。\n◆问:C/S有哪些不足?\n答:qq客户端有丰富的功能,网络上传递的一般只是数据本身,客户端收到数据之后,负责处理这些数据并进行显示。不过如果qq更新了一个钱包功能,必须通知客户端更新，就是我们平时经常跳出的更新提示。\n◆问:如何解决这个间题?\n解决办法实际上很简单:让界面的显示效果在服务器端生成,传给客户端;服务器传什么,客户端就显示什么,客户端不要参与太多数据处理。这样,管理员如果想内容修改了,也不需要通知客户端升级,客户端只需要安装负责显示的软件（浏览器）,就可以了。\n◆问:如何实现?\nB/S模式。也分为客户机和服务器两层,但是客户机上不用安装软件,只需要使用浏览器即可,网络上传输的也不再是普通数据,而是将这些数据用HTML等技术进行处理之后的结果。\n而Web网站最基本的要求是:必须使客户能够通过HTTP访问网站中的网页。比如,输人http://www.google.com,可以打开Google页面,说明Google就是Web网站。\n怎样让用户能通过HTTP访问网页呢?很简单,只需将网页放在服务器中运行。当然,此处所讲的服务器是软件服务器（比如Tomcat）,不是硬件服务器。\n\nCookie原理\nCookie翻译成中文是“小甜饼”的意思,它能够使客户在登录过程中摆脱烦琐的输入账号和密码的过程。 Cookie的原理如下\n(1)当用户登录成功后,服务器将其登录信息(如账号、密码)保存在客户端硬盘上的一个小文件内。\n(2)下次用户访问该网站,浏览器读取该小文件(即 Cookie)中的信息(如账号、密码)传给服务器。\n(3)服务器对这些信息进行验证,如果验证通过,跳转到登录成功的页面。\n注意：cookie是保存在客户端。并且下次登录不需要输入账号、密码,并不代表账号、密码不需要在服务器端验证。\n\n\n\n# MVC思想\n\n想象一下，你用jsp为学校做好了一个学校教务系统。\n有一天，学校突然决定,选课表单显示应该更美观一些,要改变显示方法。\n由于计算机犯罪越来越多,要求在验证信息的时候多一些功能,如安全密钥等。\n数据库迁移,数据库变成了不同的名字,表结构也改变了,查询时需要修改代码。\n要解决这些问题,就必须把JSP的某一部分改掉。但是,编写代码时最忌讳的就是在很长的一段程序中修改很小的一部分,这样做代价很高,并且在开发过程中分工也很不方便。如:因此,该方案中,将页面设计和商业逻辑混合在一起,在修改时必须读懂所有代码。从网页编写者的角度讲，希望看到的是大量的标签而不是java。而编程人员也需要知道数据库的结构。美工人员修改显示方法时,需要面对大量数据库访问代码。，开发时bu便于分工。\n基于该问题,可以将该JSP拆成三个模块来实现。\n首先,编写JSP,负责输入查询代码,提交到 Servlet,。Servlet进行安全验证,调用DAO来访问数据库,得到结果,跳转到JSP显示这种方法。\n虽然前期设计比较复杂,但有如下特点\n1、适合分工,每一个程序员只需要关心他自己所需要关心的那个模块。\n2、维护方便,比如需要修改其中的一个部分,就对相应的模块进行修改就可以了。\n对比这两种方案,可以发现,第二种方案把程序分为不同的模块,显示、业务逻辑、过程控制都独立起来,使得软件在可伸缩性和可维护性方面有了很大的优势。如要改变外观显示,只需要修改JSP就可以了;修改验证方法,只需要修改 Servlet就可以了;数据库迁移,只需要修改DAO就可以了。这种思想就是MVC思想。\n\n# 获取单选、双选、下拉菜单数据\n\n## 单选\n```\n性别：\n男 <input type=\"radio\" name=\"sex\" value=\"boy\" >\n女<input type=\"radio\" name=\"sex\" value=\"girl\">\n```\n获取数据代码略\n\n## 多选\n```\n唱歌<input name=\"fav\" type=\"checkbox\" value=\"singing\">\n跳舞<input name=\"fav\" type=\"checkbox\" value=\"dance\">\n打球<input name=\"fav\" type=\"checkbox\" value=\"ball\">\n打游戏<input name=\"fav\" type=\"checkbox\" value=\"game\">\n//注意4个多选input的name都为“fav”\n获取数据代码:\n<%String [] fav=request.getParameterValues(\"fav\");\nfor (String s : fav) {\n%>\n<%=s%>\n<% }%>\n```\n## 下拉菜单\n```\n<select name=\"home\">\n<option value=\"beijing\">北京</option>\n<option value=\"\">上海</option>\n<option value=\"\">广州</option>\n</select>\n```\n获取数据代码略\n\n# jsp有些功能用 JavaScript也能够实现,那有何区别?\n答:最大的区别是, Java Script源代码是被服务器发送到客户端,由客户端执行,因此,客户端可以看到 JavaScript源代码;而Java代码却不会。你在开发者工具查看代码是看不到jsp页面中的Java代码的。\n\n# 为什么需要url传值？\n比如教务系统中，每个学生信息后面的删除按钮。点击之后会跳转到删除操作页面。但如何知道要删除哪个学生呢？这就需要在url跳转的时候顺便把要删除的学生学号传过去。当然，也可以传给本页面。\n<a href=\"delete.jsp?sno=1\">删除</a>\n<a href=\"delete.jsp?sno=2\">删除</a>\n再比如说，让你写一个页面，上有10个链接，分别是1 2 3 4 5 6 7 8 9 10，单击相应的链接，在底部打印相应的乘法表。如点击4打印四四乘法表。url传值就派上用场了。\n如果传值是中文会出现乱码问题，传值和取值支付URLEncoder.encode()和URLEncoder.decode()分别进行编码和解码\n\n# 为什么需要include指令？\n比如版权信息，你不可能每个页面每个页面的复制吧，如果有变动岂不是每个都要改？\n\n# include指令和include动作的区别\n<%@include file=\"info.jsp\"%>include指令不会实时更新\n<jsp:include page=\"info.jsp\" />include动作会实时更新\ninclude指令在JSP编译时就将对应的文件包含进来。而 include动作则不同,其会在客户端对JSP文件发出请求的时候将对应包含文件的输出包含进来。include动作还会自动检查被包含文件的变化。也就是说,当被包含资源的内容发生\n变化的时候,使用 include指令的话,服务器可能不会检测到,所以不会对其进行重新的编译,这给维护带来了巨大的麻烦。include动作则可以在每次客户端发出请求时重新把资源包含进来,进行实时的更新。\n\n# 其他\nURL传值会在浏览器的地址栏中看到传递的信息;\n隐藏表单会在客户端页面的源代码中看到传递的信息;\nCookie会在客户端页面的文本文件中看到传递的信息。\n\n检查用户提交的信息是否为空，可以用javascript实现。比如验证是否包含非法字符%，只要客户端检查输入就好了。\n问：那如何检查用户**所有**输入是否有非法字符？\n答：用循环获得所有表单数据。\n\njsp内置对象是自动载入的，因此它们不需要直接实例化。\n\n请求服务器的端口号的方法，可以做类似“检查IP以220开头的用户是非法用户”的事情。\n\nweb.xml可以设置欢迎页<welcome-file-list>\n\nservlet为了实现控制者这一角色，必须要能够实现跳转。\n\n过滤器可以判断用户类型，管理员、普通用户。\n\n\n\n\n\n\n","source":"_posts/《java web开发与应用》笔记.md","raw":"---\ntitle: 《java web开发与应用》笔记\ndate: 2018-12-17 23:00:50\ncategories: 读书笔记\ndescription: 实战类的一本书。目录上几乎每章都有“为什么”的字眼，这是它最好的地方，它会跟你说在什么需求场景下要用到这个技术，这个技术可以用来干什么，从需求去理解技术。\n---\n# 从C/S从到B/S\nC/S即客户机/服务器，比如qq电脑版。B/S即浏览器/服务器，比如京东网页版。\n◆问:C/S有哪些不足?\n答:qq客户端有丰富的功能,网络上传递的一般只是数据本身,客户端收到数据之后,负责处理这些数据并进行显示。不过如果qq更新了一个钱包功能,必须通知客户端更新，就是我们平时经常跳出的更新提示。\n◆问:如何解决这个间题?\n解决办法实际上很简单:让界面的显示效果在服务器端生成,传给客户端;服务器传什么,客户端就显示什么,客户端不要参与太多数据处理。这样,管理员如果想内容修改了,也不需要通知客户端升级,客户端只需要安装负责显示的软件（浏览器）,就可以了。\n◆问:如何实现?\nB/S模式。也分为客户机和服务器两层,但是客户机上不用安装软件,只需要使用浏览器即可,网络上传输的也不再是普通数据,而是将这些数据用HTML等技术进行处理之后的结果。\n而Web网站最基本的要求是:必须使客户能够通过HTTP访问网站中的网页。比如,输人http://www.google.com,可以打开Google页面,说明Google就是Web网站。\n怎样让用户能通过HTTP访问网页呢?很简单,只需将网页放在服务器中运行。当然,此处所讲的服务器是软件服务器（比如Tomcat）,不是硬件服务器。\n\nCookie原理\nCookie翻译成中文是“小甜饼”的意思,它能够使客户在登录过程中摆脱烦琐的输入账号和密码的过程。 Cookie的原理如下\n(1)当用户登录成功后,服务器将其登录信息(如账号、密码)保存在客户端硬盘上的一个小文件内。\n(2)下次用户访问该网站,浏览器读取该小文件(即 Cookie)中的信息(如账号、密码)传给服务器。\n(3)服务器对这些信息进行验证,如果验证通过,跳转到登录成功的页面。\n注意：cookie是保存在客户端。并且下次登录不需要输入账号、密码,并不代表账号、密码不需要在服务器端验证。\n\n\n\n# MVC思想\n\n想象一下，你用jsp为学校做好了一个学校教务系统。\n有一天，学校突然决定,选课表单显示应该更美观一些,要改变显示方法。\n由于计算机犯罪越来越多,要求在验证信息的时候多一些功能,如安全密钥等。\n数据库迁移,数据库变成了不同的名字,表结构也改变了,查询时需要修改代码。\n要解决这些问题,就必须把JSP的某一部分改掉。但是,编写代码时最忌讳的就是在很长的一段程序中修改很小的一部分,这样做代价很高,并且在开发过程中分工也很不方便。如:因此,该方案中,将页面设计和商业逻辑混合在一起,在修改时必须读懂所有代码。从网页编写者的角度讲，希望看到的是大量的标签而不是java。而编程人员也需要知道数据库的结构。美工人员修改显示方法时,需要面对大量数据库访问代码。，开发时bu便于分工。\n基于该问题,可以将该JSP拆成三个模块来实现。\n首先,编写JSP,负责输入查询代码,提交到 Servlet,。Servlet进行安全验证,调用DAO来访问数据库,得到结果,跳转到JSP显示这种方法。\n虽然前期设计比较复杂,但有如下特点\n1、适合分工,每一个程序员只需要关心他自己所需要关心的那个模块。\n2、维护方便,比如需要修改其中的一个部分,就对相应的模块进行修改就可以了。\n对比这两种方案,可以发现,第二种方案把程序分为不同的模块,显示、业务逻辑、过程控制都独立起来,使得软件在可伸缩性和可维护性方面有了很大的优势。如要改变外观显示,只需要修改JSP就可以了;修改验证方法,只需要修改 Servlet就可以了;数据库迁移,只需要修改DAO就可以了。这种思想就是MVC思想。\n\n# 获取单选、双选、下拉菜单数据\n\n## 单选\n```\n性别：\n男 <input type=\"radio\" name=\"sex\" value=\"boy\" >\n女<input type=\"radio\" name=\"sex\" value=\"girl\">\n```\n获取数据代码略\n\n## 多选\n```\n唱歌<input name=\"fav\" type=\"checkbox\" value=\"singing\">\n跳舞<input name=\"fav\" type=\"checkbox\" value=\"dance\">\n打球<input name=\"fav\" type=\"checkbox\" value=\"ball\">\n打游戏<input name=\"fav\" type=\"checkbox\" value=\"game\">\n//注意4个多选input的name都为“fav”\n获取数据代码:\n<%String [] fav=request.getParameterValues(\"fav\");\nfor (String s : fav) {\n%>\n<%=s%>\n<% }%>\n```\n## 下拉菜单\n```\n<select name=\"home\">\n<option value=\"beijing\">北京</option>\n<option value=\"\">上海</option>\n<option value=\"\">广州</option>\n</select>\n```\n获取数据代码略\n\n# jsp有些功能用 JavaScript也能够实现,那有何区别?\n答:最大的区别是, Java Script源代码是被服务器发送到客户端,由客户端执行,因此,客户端可以看到 JavaScript源代码;而Java代码却不会。你在开发者工具查看代码是看不到jsp页面中的Java代码的。\n\n# 为什么需要url传值？\n比如教务系统中，每个学生信息后面的删除按钮。点击之后会跳转到删除操作页面。但如何知道要删除哪个学生呢？这就需要在url跳转的时候顺便把要删除的学生学号传过去。当然，也可以传给本页面。\n<a href=\"delete.jsp?sno=1\">删除</a>\n<a href=\"delete.jsp?sno=2\">删除</a>\n再比如说，让你写一个页面，上有10个链接，分别是1 2 3 4 5 6 7 8 9 10，单击相应的链接，在底部打印相应的乘法表。如点击4打印四四乘法表。url传值就派上用场了。\n如果传值是中文会出现乱码问题，传值和取值支付URLEncoder.encode()和URLEncoder.decode()分别进行编码和解码\n\n# 为什么需要include指令？\n比如版权信息，你不可能每个页面每个页面的复制吧，如果有变动岂不是每个都要改？\n\n# include指令和include动作的区别\n<%@include file=\"info.jsp\"%>include指令不会实时更新\n<jsp:include page=\"info.jsp\" />include动作会实时更新\ninclude指令在JSP编译时就将对应的文件包含进来。而 include动作则不同,其会在客户端对JSP文件发出请求的时候将对应包含文件的输出包含进来。include动作还会自动检查被包含文件的变化。也就是说,当被包含资源的内容发生\n变化的时候,使用 include指令的话,服务器可能不会检测到,所以不会对其进行重新的编译,这给维护带来了巨大的麻烦。include动作则可以在每次客户端发出请求时重新把资源包含进来,进行实时的更新。\n\n# 其他\nURL传值会在浏览器的地址栏中看到传递的信息;\n隐藏表单会在客户端页面的源代码中看到传递的信息;\nCookie会在客户端页面的文本文件中看到传递的信息。\n\n检查用户提交的信息是否为空，可以用javascript实现。比如验证是否包含非法字符%，只要客户端检查输入就好了。\n问：那如何检查用户**所有**输入是否有非法字符？\n答：用循环获得所有表单数据。\n\njsp内置对象是自动载入的，因此它们不需要直接实例化。\n\n请求服务器的端口号的方法，可以做类似“检查IP以220开头的用户是非法用户”的事情。\n\nweb.xml可以设置欢迎页<welcome-file-list>\n\nservlet为了实现控制者这一角色，必须要能够实现跳转。\n\n过滤器可以判断用户类型，管理员、普通用户。\n\n\n\n\n\n\n","slug":"《java web开发与应用》笔记","published":1,"updated":"2022-02-08T07:09:41.227Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qkf000ww9rpz8bkpm6f","content":"<h1 id=\"从C-S从到B-S\"><a href=\"#从C-S从到B-S\" class=\"headerlink\" title=\"从C/S从到B/S\"></a>从C/S从到B/S</h1><p>C/S即客户机/服务器，比如qq电脑版。B/S即浏览器/服务器，比如京东网页版。<br>◆问:C/S有哪些不足?<br>答:qq客户端有丰富的功能,网络上传递的一般只是数据本身,客户端收到数据之后,负责处理这些数据并进行显示。不过如果qq更新了一个钱包功能,必须通知客户端更新，就是我们平时经常跳出的更新提示。<br>◆问:如何解决这个间题?<br>解决办法实际上很简单:让界面的显示效果在服务器端生成,传给客户端;服务器传什么,客户端就显示什么,客户端不要参与太多数据处理。这样,管理员如果想内容修改了,也不需要通知客户端升级,客户端只需要安装负责显示的软件（浏览器）,就可以了。<br>◆问:如何实现?<br>B/S模式。也分为客户机和服务器两层,但是客户机上不用安装软件,只需要使用浏览器即可,网络上传输的也不再是普通数据,而是将这些数据用HTML等技术进行处理之后的结果。<br>而Web网站最基本的要求是:必须使客户能够通过HTTP访问网站中的网页。比如,输人<a href=\"http://www.google.com,可以打开Google页面,说明Google就是Web网站。\" target=\"_blank\" rel=\"noopener\">http://www.google.com,可以打开Google页面,说明Google就是Web网站。</a><br>怎样让用户能通过HTTP访问网页呢?很简单,只需将网页放在服务器中运行。当然,此处所讲的服务器是软件服务器（比如Tomcat）,不是硬件服务器。</p>\n<p>Cookie原理<br>Cookie翻译成中文是“小甜饼”的意思,它能够使客户在登录过程中摆脱烦琐的输入账号和密码的过程。 Cookie的原理如下<br>(1)当用户登录成功后,服务器将其登录信息(如账号、密码)保存在客户端硬盘上的一个小文件内。<br>(2)下次用户访问该网站,浏览器读取该小文件(即 Cookie)中的信息(如账号、密码)传给服务器。<br>(3)服务器对这些信息进行验证,如果验证通过,跳转到登录成功的页面。<br>注意：cookie是保存在客户端。并且下次登录不需要输入账号、密码,并不代表账号、密码不需要在服务器端验证。</p>\n<h1 id=\"MVC思想\"><a href=\"#MVC思想\" class=\"headerlink\" title=\"MVC思想\"></a>MVC思想</h1><p>想象一下，你用jsp为学校做好了一个学校教务系统。<br>有一天，学校突然决定,选课表单显示应该更美观一些,要改变显示方法。<br>由于计算机犯罪越来越多,要求在验证信息的时候多一些功能,如安全密钥等。<br>数据库迁移,数据库变成了不同的名字,表结构也改变了,查询时需要修改代码。<br>要解决这些问题,就必须把JSP的某一部分改掉。但是,编写代码时最忌讳的就是在很长的一段程序中修改很小的一部分,这样做代价很高,并且在开发过程中分工也很不方便。如:因此,该方案中,将页面设计和商业逻辑混合在一起,在修改时必须读懂所有代码。从网页编写者的角度讲，希望看到的是大量的标签而不是java。而编程人员也需要知道数据库的结构。美工人员修改显示方法时,需要面对大量数据库访问代码。，开发时bu便于分工。<br>基于该问题,可以将该JSP拆成三个模块来实现。<br>首先,编写JSP,负责输入查询代码,提交到 Servlet,。Servlet进行安全验证,调用DAO来访问数据库,得到结果,跳转到JSP显示这种方法。<br>虽然前期设计比较复杂,但有如下特点<br>1、适合分工,每一个程序员只需要关心他自己所需要关心的那个模块。<br>2、维护方便,比如需要修改其中的一个部分,就对相应的模块进行修改就可以了。<br>对比这两种方案,可以发现,第二种方案把程序分为不同的模块,显示、业务逻辑、过程控制都独立起来,使得软件在可伸缩性和可维护性方面有了很大的优势。如要改变外观显示,只需要修改JSP就可以了;修改验证方法,只需要修改 Servlet就可以了;数据库迁移,只需要修改DAO就可以了。这种思想就是MVC思想。</p>\n<h1 id=\"获取单选、双选、下拉菜单数据\"><a href=\"#获取单选、双选、下拉菜单数据\" class=\"headerlink\" title=\"获取单选、双选、下拉菜单数据\"></a>获取单选、双选、下拉菜单数据</h1><h2 id=\"单选\"><a href=\"#单选\" class=\"headerlink\" title=\"单选\"></a>单选</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">性别：</span><br><span class=\"line\">男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;boy&quot; &gt;</span><br><span class=\"line\">女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;girl&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>获取数据代码略</p>\n<h2 id=\"多选\"><a href=\"#多选\" class=\"headerlink\" title=\"多选\"></a>多选</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">唱歌&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;singing&quot;&gt;</span><br><span class=\"line\">跳舞&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;dance&quot;&gt;</span><br><span class=\"line\">打球&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;ball&quot;&gt;</span><br><span class=\"line\">打游戏&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;game&quot;&gt;</span><br><span class=\"line\">//注意4个多选input的name都为“fav”</span><br><span class=\"line\">获取数据代码:</span><br><span class=\"line\">&lt;%String [] fav=request.getParameterValues(&quot;fav&quot;);</span><br><span class=\"line\">for (String s : fav) &#123;</span><br><span class=\"line\">%&gt;</span><br><span class=\"line\">&lt;%=s%&gt;</span><br><span class=\"line\">&lt;% &#125;%&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"下拉菜单\"><a href=\"#下拉菜单\" class=\"headerlink\" title=\"下拉菜单\"></a>下拉菜单</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;select name=&quot;home&quot;&gt;</span><br><span class=\"line\">&lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;</span><br><span class=\"line\">&lt;option value=&quot;&quot;&gt;上海&lt;/option&gt;</span><br><span class=\"line\">&lt;option value=&quot;&quot;&gt;广州&lt;/option&gt;</span><br><span class=\"line\">&lt;/select&gt;</span><br></pre></td></tr></table></figure>\n<p>获取数据代码略</p>\n<h1 id=\"jsp有些功能用-JavaScript也能够实现-那有何区别\"><a href=\"#jsp有些功能用-JavaScript也能够实现-那有何区别\" class=\"headerlink\" title=\"jsp有些功能用 JavaScript也能够实现,那有何区别?\"></a>jsp有些功能用 JavaScript也能够实现,那有何区别?</h1><p>答:最大的区别是, Java Script源代码是被服务器发送到客户端,由客户端执行,因此,客户端可以看到 JavaScript源代码;而Java代码却不会。你在开发者工具查看代码是看不到jsp页面中的Java代码的。</p>\n<h1 id=\"为什么需要url传值？\"><a href=\"#为什么需要url传值？\" class=\"headerlink\" title=\"为什么需要url传值？\"></a>为什么需要url传值？</h1><p>比如教务系统中，每个学生信息后面的删除按钮。点击之后会跳转到删除操作页面。但如何知道要删除哪个学生呢？这就需要在url跳转的时候顺便把要删除的学生学号传过去。当然，也可以传给本页面。<br><a href=\"delete.jsp?sno=1\">删除</a><br><a href=\"delete.jsp?sno=2\">删除</a><br>再比如说，让你写一个页面，上有10个链接，分别是1 2 3 4 5 6 7 8 9 10，单击相应的链接，在底部打印相应的乘法表。如点击4打印四四乘法表。url传值就派上用场了。<br>如果传值是中文会出现乱码问题，传值和取值支付URLEncoder.encode()和URLEncoder.decode()分别进行编码和解码</p>\n<h1 id=\"为什么需要include指令？\"><a href=\"#为什么需要include指令？\" class=\"headerlink\" title=\"为什么需要include指令？\"></a>为什么需要include指令？</h1><p>比如版权信息，你不可能每个页面每个页面的复制吧，如果有变动岂不是每个都要改？</p>\n<h1 id=\"include指令和include动作的区别\"><a href=\"#include指令和include动作的区别\" class=\"headerlink\" title=\"include指令和include动作的区别\"></a>include指令和include动作的区别</h1><p>&lt;%@include file=”info.jsp”%&gt;include指令不会实时更新<br>&lt;jsp:include page=”info.jsp” /&gt;include动作会实时更新<br>include指令在JSP编译时就将对应的文件包含进来。而 include动作则不同,其会在客户端对JSP文件发出请求的时候将对应包含文件的输出包含进来。include动作还会自动检查被包含文件的变化。也就是说,当被包含资源的内容发生<br>变化的时候,使用 include指令的话,服务器可能不会检测到,所以不会对其进行重新的编译,这给维护带来了巨大的麻烦。include动作则可以在每次客户端发出请求时重新把资源包含进来,进行实时的更新。</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><p>URL传值会在浏览器的地址栏中看到传递的信息;<br>隐藏表单会在客户端页面的源代码中看到传递的信息;<br>Cookie会在客户端页面的文本文件中看到传递的信息。</p>\n<p>检查用户提交的信息是否为空，可以用javascript实现。比如验证是否包含非法字符%，只要客户端检查输入就好了。<br>问：那如何检查用户<strong>所有</strong>输入是否有非法字符？<br>答：用循环获得所有表单数据。</p>\n<p>jsp内置对象是自动载入的，因此它们不需要直接实例化。</p>\n<p>请求服务器的端口号的方法，可以做类似“检查IP以220开头的用户是非法用户”的事情。</p>\n<p>web.xml可以设置欢迎页<welcome-file-list></welcome-file-list></p>\n<p>servlet为了实现控制者这一角色，必须要能够实现跳转。</p>\n<p>过滤器可以判断用户类型，管理员、普通用户。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"从C-S从到B-S\"><a href=\"#从C-S从到B-S\" class=\"headerlink\" title=\"从C/S从到B/S\"></a>从C/S从到B/S</h1><p>C/S即客户机/服务器，比如qq电脑版。B/S即浏览器/服务器，比如京东网页版。<br>◆问:C/S有哪些不足?<br>答:qq客户端有丰富的功能,网络上传递的一般只是数据本身,客户端收到数据之后,负责处理这些数据并进行显示。不过如果qq更新了一个钱包功能,必须通知客户端更新，就是我们平时经常跳出的更新提示。<br>◆问:如何解决这个间题?<br>解决办法实际上很简单:让界面的显示效果在服务器端生成,传给客户端;服务器传什么,客户端就显示什么,客户端不要参与太多数据处理。这样,管理员如果想内容修改了,也不需要通知客户端升级,客户端只需要安装负责显示的软件（浏览器）,就可以了。<br>◆问:如何实现?<br>B/S模式。也分为客户机和服务器两层,但是客户机上不用安装软件,只需要使用浏览器即可,网络上传输的也不再是普通数据,而是将这些数据用HTML等技术进行处理之后的结果。<br>而Web网站最基本的要求是:必须使客户能够通过HTTP访问网站中的网页。比如,输人<a href=\"http://www.google.com,可以打开Google页面,说明Google就是Web网站。\" target=\"_blank\" rel=\"noopener\">http://www.google.com,可以打开Google页面,说明Google就是Web网站。</a><br>怎样让用户能通过HTTP访问网页呢?很简单,只需将网页放在服务器中运行。当然,此处所讲的服务器是软件服务器（比如Tomcat）,不是硬件服务器。</p>\n<p>Cookie原理<br>Cookie翻译成中文是“小甜饼”的意思,它能够使客户在登录过程中摆脱烦琐的输入账号和密码的过程。 Cookie的原理如下<br>(1)当用户登录成功后,服务器将其登录信息(如账号、密码)保存在客户端硬盘上的一个小文件内。<br>(2)下次用户访问该网站,浏览器读取该小文件(即 Cookie)中的信息(如账号、密码)传给服务器。<br>(3)服务器对这些信息进行验证,如果验证通过,跳转到登录成功的页面。<br>注意：cookie是保存在客户端。并且下次登录不需要输入账号、密码,并不代表账号、密码不需要在服务器端验证。</p>\n<h1 id=\"MVC思想\"><a href=\"#MVC思想\" class=\"headerlink\" title=\"MVC思想\"></a>MVC思想</h1><p>想象一下，你用jsp为学校做好了一个学校教务系统。<br>有一天，学校突然决定,选课表单显示应该更美观一些,要改变显示方法。<br>由于计算机犯罪越来越多,要求在验证信息的时候多一些功能,如安全密钥等。<br>数据库迁移,数据库变成了不同的名字,表结构也改变了,查询时需要修改代码。<br>要解决这些问题,就必须把JSP的某一部分改掉。但是,编写代码时最忌讳的就是在很长的一段程序中修改很小的一部分,这样做代价很高,并且在开发过程中分工也很不方便。如:因此,该方案中,将页面设计和商业逻辑混合在一起,在修改时必须读懂所有代码。从网页编写者的角度讲，希望看到的是大量的标签而不是java。而编程人员也需要知道数据库的结构。美工人员修改显示方法时,需要面对大量数据库访问代码。，开发时bu便于分工。<br>基于该问题,可以将该JSP拆成三个模块来实现。<br>首先,编写JSP,负责输入查询代码,提交到 Servlet,。Servlet进行安全验证,调用DAO来访问数据库,得到结果,跳转到JSP显示这种方法。<br>虽然前期设计比较复杂,但有如下特点<br>1、适合分工,每一个程序员只需要关心他自己所需要关心的那个模块。<br>2、维护方便,比如需要修改其中的一个部分,就对相应的模块进行修改就可以了。<br>对比这两种方案,可以发现,第二种方案把程序分为不同的模块,显示、业务逻辑、过程控制都独立起来,使得软件在可伸缩性和可维护性方面有了很大的优势。如要改变外观显示,只需要修改JSP就可以了;修改验证方法,只需要修改 Servlet就可以了;数据库迁移,只需要修改DAO就可以了。这种思想就是MVC思想。</p>\n<h1 id=\"获取单选、双选、下拉菜单数据\"><a href=\"#获取单选、双选、下拉菜单数据\" class=\"headerlink\" title=\"获取单选、双选、下拉菜单数据\"></a>获取单选、双选、下拉菜单数据</h1><h2 id=\"单选\"><a href=\"#单选\" class=\"headerlink\" title=\"单选\"></a>单选</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">性别：</span><br><span class=\"line\">男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;boy&quot; &gt;</span><br><span class=\"line\">女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;girl&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>获取数据代码略</p>\n<h2 id=\"多选\"><a href=\"#多选\" class=\"headerlink\" title=\"多选\"></a>多选</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">唱歌&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;singing&quot;&gt;</span><br><span class=\"line\">跳舞&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;dance&quot;&gt;</span><br><span class=\"line\">打球&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;ball&quot;&gt;</span><br><span class=\"line\">打游戏&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;game&quot;&gt;</span><br><span class=\"line\">//注意4个多选input的name都为“fav”</span><br><span class=\"line\">获取数据代码:</span><br><span class=\"line\">&lt;%String [] fav=request.getParameterValues(&quot;fav&quot;);</span><br><span class=\"line\">for (String s : fav) &#123;</span><br><span class=\"line\">%&gt;</span><br><span class=\"line\">&lt;%=s%&gt;</span><br><span class=\"line\">&lt;% &#125;%&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"下拉菜单\"><a href=\"#下拉菜单\" class=\"headerlink\" title=\"下拉菜单\"></a>下拉菜单</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;select name=&quot;home&quot;&gt;</span><br><span class=\"line\">&lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;</span><br><span class=\"line\">&lt;option value=&quot;&quot;&gt;上海&lt;/option&gt;</span><br><span class=\"line\">&lt;option value=&quot;&quot;&gt;广州&lt;/option&gt;</span><br><span class=\"line\">&lt;/select&gt;</span><br></pre></td></tr></table></figure>\n<p>获取数据代码略</p>\n<h1 id=\"jsp有些功能用-JavaScript也能够实现-那有何区别\"><a href=\"#jsp有些功能用-JavaScript也能够实现-那有何区别\" class=\"headerlink\" title=\"jsp有些功能用 JavaScript也能够实现,那有何区别?\"></a>jsp有些功能用 JavaScript也能够实现,那有何区别?</h1><p>答:最大的区别是, Java Script源代码是被服务器发送到客户端,由客户端执行,因此,客户端可以看到 JavaScript源代码;而Java代码却不会。你在开发者工具查看代码是看不到jsp页面中的Java代码的。</p>\n<h1 id=\"为什么需要url传值？\"><a href=\"#为什么需要url传值？\" class=\"headerlink\" title=\"为什么需要url传值？\"></a>为什么需要url传值？</h1><p>比如教务系统中，每个学生信息后面的删除按钮。点击之后会跳转到删除操作页面。但如何知道要删除哪个学生呢？这就需要在url跳转的时候顺便把要删除的学生学号传过去。当然，也可以传给本页面。<br><a href=\"delete.jsp?sno=1\">删除</a><br><a href=\"delete.jsp?sno=2\">删除</a><br>再比如说，让你写一个页面，上有10个链接，分别是1 2 3 4 5 6 7 8 9 10，单击相应的链接，在底部打印相应的乘法表。如点击4打印四四乘法表。url传值就派上用场了。<br>如果传值是中文会出现乱码问题，传值和取值支付URLEncoder.encode()和URLEncoder.decode()分别进行编码和解码</p>\n<h1 id=\"为什么需要include指令？\"><a href=\"#为什么需要include指令？\" class=\"headerlink\" title=\"为什么需要include指令？\"></a>为什么需要include指令？</h1><p>比如版权信息，你不可能每个页面每个页面的复制吧，如果有变动岂不是每个都要改？</p>\n<h1 id=\"include指令和include动作的区别\"><a href=\"#include指令和include动作的区别\" class=\"headerlink\" title=\"include指令和include动作的区别\"></a>include指令和include动作的区别</h1><p>&lt;%@include file=”info.jsp”%&gt;include指令不会实时更新<br>&lt;jsp:include page=”info.jsp” /&gt;include动作会实时更新<br>include指令在JSP编译时就将对应的文件包含进来。而 include动作则不同,其会在客户端对JSP文件发出请求的时候将对应包含文件的输出包含进来。include动作还会自动检查被包含文件的变化。也就是说,当被包含资源的内容发生<br>变化的时候,使用 include指令的话,服务器可能不会检测到,所以不会对其进行重新的编译,这给维护带来了巨大的麻烦。include动作则可以在每次客户端发出请求时重新把资源包含进来,进行实时的更新。</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><p>URL传值会在浏览器的地址栏中看到传递的信息;<br>隐藏表单会在客户端页面的源代码中看到传递的信息;<br>Cookie会在客户端页面的文本文件中看到传递的信息。</p>\n<p>检查用户提交的信息是否为空，可以用javascript实现。比如验证是否包含非法字符%，只要客户端检查输入就好了。<br>问：那如何检查用户<strong>所有</strong>输入是否有非法字符？<br>答：用循环获得所有表单数据。</p>\n<p>jsp内置对象是自动载入的，因此它们不需要直接实例化。</p>\n<p>请求服务器的端口号的方法，可以做类似“检查IP以220开头的用户是非法用户”的事情。</p>\n<p>web.xml可以设置欢迎页<welcome-file-list></welcome-file-list></p>\n<p>servlet为了实现控制者这一角色，必须要能够实现跳转。</p>\n<p>过滤器可以判断用户类型，管理员、普通用户。</p>\n"},{"title":"小记","date":"2019-06-26T14:24:50.000Z","_content":"\n最近在牛客在线编程题里刷了一遍剑指offer，有十来道做不出的。接下来的计划是刷leetcode，八月份再二刷这本书。","source":"_posts/一刷剑指offer.md","raw":"---\ntitle: 小记\ndate: 2019-06-26 22:24:50\ncategories: 生活\n---\n\n最近在牛客在线编程题里刷了一遍剑指offer，有十来道做不出的。接下来的计划是刷leetcode，八月份再二刷这本书。","slug":"一刷剑指offer","published":1,"updated":"2022-02-08T07:09:41.228Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qkh000zw9rps1o3mcvt","content":"<p>最近在牛客在线编程题里刷了一遍剑指offer，有十来道做不出的。接下来的计划是刷leetcode，八月份再二刷这本书。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在牛客在线编程题里刷了一遍剑指offer，有十来道做不出的。接下来的计划是刷leetcode，八月份再二刷这本书。</p>\n"},{"title":"(译)用 Isabelle/HOL 验证分布式系统","date":"2022-11-15T15:53:50.000Z","description":"众所周知，分布式系统很难推理，正确性的正式证明对于分布式算法很有价值。","_content":"\n\n> * 我翻译的这篇文章参与了掘金翻译计划，选自英语优秀技术文章。 \n> * 原文地址：[Verifying distributed systems with Isabelle/HOL](https://martin.kleppmann.com/2022/10/12/verifying-distributed-systems-isabelle.html)\n> * 原文作者：[Martin Kleppmann](https://martin.kleppmann.com/)\n> * 译文出自：[掘金翻译计划](https://github.com/xitu/gold-miner)\n> * 本文永久链接：[https://github.com/xitu/gold-miner/blob/master/article/2022/verifying-distributed-systems-isabelle.md](https://github.com/xitu/gold-miner/blob/master/article/2022/verifying-distributed-systems-isabelle.md)\n> * 译者：[wangxuanni](https://github.com/wangxuanni)\n> * 校对者：[Quincy-Ye](https://github.com/Quincy-Ye) 、[vuuihc](https://github.com/vuuihc)\n\n# 用 Isabelle/HOL 验证分布式系统 \n\n我们每天都以互联网服务的形式使用分布式系统。这些系统很有用，但实现起来也很有挑战性，因为网络是不可预料的。每当你发送一条网络消息的时候，它有可能很快到达，也有可能延迟很久，或者永远不会达到，又或者多次到达。\n\n当你向另一个进程发送请求但没有收到响应时，你完全不知道发生了什么：是这个请求丢失了，还是另一个进程崩溃了，或者是响应丢失了？或者可能没有任何东西丢失，消息只是延迟了，还没有到达。没有办法知道发生了什么，因为进程通信的唯一方式是不可靠的消息传递。\n\n分布式算法在这个不可靠的交流模型之上建立了一个更强大的保证。这种更强大的保证的例子包括数据库的事务和复制（在多台机器上维护一些数据的副本，以便当其中一个机器宕机时，数据不会丢失）。\n\n不幸的是，众所周知，分布式系统很难推理。因为不论消息到达的顺序如何，他们都必须维护他们的保证，甚至是在一些消息丢失，或者一些进程奔溃的时候也如此。。许多算法非常微妙，非正式的推理不足以确保它们是正确的。此外，并发活动可能出现的排列和交织的数量，很快就变得太多，以至于模型检查器无法进行详尽的测试。出于这个原因，正确性的正式证明对于分布式算法很有价值。\n\n## 在 Isabelle/HOL 中建模一个分布式系统\n\n在这篇博文里，我们将会探索怎么样使用 Isabelle/HOL 辅助证明，去正式地验证一些分布式算法。Isabelle/HOL 没有对分布式计算有任何内置的支持，不过幸运的是，可以十分简单的使用 Isabelle/HOL 提供的结构：方法，列表和集合，去建模一个分布式系统。\n\n首先，我们假设在系统里每一个进程（或**节点**）都有一个唯一的标识符，它可以简单的是一个整数或是一个字符串。根据算法，系统中一组进程 ID 可能是固定的和已知的，或者是未知的和不固定的（后者适用于进程们随时可以加入或离开的系统）。\n\n然后算法的执行以离散的时间步长进行。在每个时间步长中，一个事件发生在其中一个进程上。这个事件可能是这三件事中的一个：接收一个其他进程发送过来的消息，接收用户的输入或者是超时。\n\n```ml\ndatatype ('proc, 'msg, 'val) event\n  = Receive (msg_sender: 'proc) (recv_msg: 'msg)\n  | Request 'val\n  | Timeout\n```\n\n被这些事件之一触发，进程会执行一个方法，可能会更新自己的状态并向其他进程发送信息。在一个时间步长发送的消息，可能会被在未来任何的时间步长接收到，或者可能完全不会被接收到。\n\n每个进程都有一个不与任何其他进程共享的本地状态，这个状态在执行开始的时候是固定的初始值，并且只有当进程执行的时候更新。一个进程无法读取另一个进程的状态，但我们可以将整个系统的状态描述为所有进程的各个状态的集合：\n\n![图片](https://cdn.staticaly.com/gh/wangxuanni/wangxuanni_blo@masterg_img/img/time-steps.png)\n\n## 为什么线性的时间步长序列就足够了？\n\n尽管真实的进程可能是并发运行的，我们不需要对并发进行建模，因为进程之间的交流只有发送和接收消息，并且我们可以假设一个进程在开始处理下一个事件之前完成了一个事件的处理。因此，每个并行执行都等价于一些线性的执行步骤序列。分布式系统的其他规范，例如 [TLA+ 语言](https://lamport.azurewebsites.net/tla/tla.html) ，也使用这种线性的步骤序列。\n\n我们不对哪个时间步由哪个进程执行任何假设。进程可以公平地轮流运行，但同样有可能一个进程执行一百万次，而另一个进程什么也不做。通过避免对进程活动的假设，我们确保算法无论系统中的时间如何都能正常工作。例如，一个暂时与网络断开连接的进程仅由一个没有经历任何接收消息事件的进程建模，即使其他进程继续发送和接收消息也是如此。\n\n在这个模型里面，一个进程的宕机只表示它在某个时间步长后不会再执行更多的步骤了；没有必要明确表示宕机。如果我们想让进程从宕机中恢复，我们可以添加第四种类型的事件来模拟崩溃后重新启动的进程。一个进程可以在崩溃后重新启动。当执行这样的崩溃恢复事件时，进程会删除其本地状态中存储在不稳定的内存中的任何部分，但保留其状态中稳定存储（在磁盘上）中的那些部分，在宕机中会幸存下来。\n\n当推理算法安全属性时，最好不要假设哪个进程在哪个时间步执行，因为这样可以确保算法可以容忍任意消息延迟。如果我们想要推理存活（比如，算法最终终止），我们将不得不做出一些公平假设，比如说每一个未崩溃的进程最终会执行一个步骤。然而，在我们的证明里面，我们只聚焦在安全属性上。\n\n![System model: linear sequence of time steps; at each step, one process handles an event](https://martin.kleppmann.com/2022/10/system-model.png)\n\n现在我们可以将一个分布式的算法表示为 **step function** ，它接受三个参数：执行当前时间步长的进程的 ID、该进程的当前本地状态和已发生的事件（消息接收、用户输入、超时，或崩溃恢复）。返回值包含该进程的新状态，以及一组要发送到其他进程的消息（每条消息都标记有接收进程的 ID ）。\n\n```isabelle\ntype_synonym ('proc, 'state, 'msg, 'val) step_func =\n  ‹'proc ⇒ 'state ⇒ ('proc, 'msg, 'val) event ⇒\n  ('state × ('proc × 'msg) set)›\n```\n\n进程在一个时间步骤的当前状态等于它在前一步骤之后的新状态（或者如果没有前一步骤，则为初始状态）。进程在一个时间步的当前状态等于同一进程在前一步之后的新状态（就是初始的状态）。假设 step 函数是确定性的，我们现在可以把系统里任何一个执行编码为（进程 ID ，事件）键值对的集合，表示发生的一系列事件，以及它们发生在哪个进程。系统的最终状态是通过一次调用一个事件的阶跃函数来获得的。\n\n## 去定义可能发生了什么\n\n为了证明分布式算法的正确性，我们需要证明它在每次可能的执行中产生正确的结果，也就是说对于每一个可能的（进程ID，事件）键值对集合。但哪一种执行是可能的？只有一件事是我们可以安全地假设的：如果一个进程接收到一条消息，那么该消息一定已经发送到该进程。换句话来说，我们假设网络不会凭空捏造消息，并且一个进程不能模拟另一个进程。（在攻击者可以注入虚假数据包的公共网络中，我们必须对消息进行加密验证以确保此属性，但现在让我们将其排除在范围之外。）\n\n因此，我们将做出的唯一假设是，如果在某个时间步长接收到消息，那么它一定是在前一个时间步长发送的。然而，我们会允许消息丢失、乱序或者是接收多次，让我们在 Isabelle/HOL 中编码这个假设。\n\n首先，我们定义一个函数来告诉我们单个事件是否可能发生：如果事件 evt 被允许在系统中的进程 `proc` 中发生，`(valid_event evt proc msgs)` 会返回 true ，`msgs`  是迄今为止已发送的所有消息的集合。 `msgs` 是（发件人、收件人、消息）的三元组。在整个系统里。我们定义一个接受事件是允许出现的，如果接收的消息是在 msgs 和 Request 或者 Timeout 事件中，则允许事件发生，或者允许事件随时发生。\n\n```isabelle\nfun valid_event :: ‹('proc, 'msg, 'val) event ⇒ 'proc ⇒\n                    ('proc × 'proc × 'msg) set ⇒ bool›\nwhere\n  ‹valid_event (Receive sender msg) recpt msgs =\n    ((sender, recpt, msg) ∈ msgs)› |\n  ‹valid_event (Request _) _ _ = True› |\n  ‹valid_event Timeout _ _ = True›\n```\n\n接下来，我们定义所有可能的事件序列集合。为此，我们在 Isabelle 中使用了一个归纳断言：如果 `events`是算法执行中的有效事件集合，`step`是阶跃函数， `init` 是每个进程的初始状态，`proc`是系统中所有进程的集合（如果我们希望允许任意数量的进程，这可能是无限的），那么 `(execute step init procs events msgs states)` 返回 true 。最后两个参数跟踪执行状态：`msgs` 是迄今为止发送的所有消息的集合，`states` 是从进程 ID 到该进程状态的映射。\n\n```isabelle\ninductive execute ::\n  ‹('proc, 'state, 'msg, 'val) step_func ⇒ ('proc ⇒ 'state) ⇒\n   'proc set ⇒ ('proc × ('proc, 'msg, 'val) event) list ⇒\n   ('proc × 'proc × 'msg) set ⇒ ('proc ⇒ 'state) ⇒ bool›\nwhere\n  ‹execute step init procs [] {} init› |\n  ‹⟦execute step init procs events msgs states;\n    proc ∈ procs;\n    valid_event event proc msgs;\n    step proc (states proc) event = (new_state, sent);\n    events' = events @ [(proc, event)];\n    msgs' = msgs ∪ {m. ∃(recpt, msg) ∈ sent.\n                       m = (proc, recpt, msg)};\n    states' = states (proc := new_state)\n   ⟧ ⟹ execute step init procs events' msgs' states'›\n```\n\n该定义规定，当系统处于初始状态且未发送任何消息时，空事件列表有效。此外，如果 `events` 是迄今为止有效的事件序列，并且 `event` 在当前状态下是允许的，那么我们可以调用 step 函数，添加它发送到 `msgs` 的任何消息，更新相应进程的状态，其返回值是另一个有效的事件序列。\n\n这就是我们建模一个分布式系统所需要的全部！\n\n## 证明一个算法正确性\n\n现在我们可以用一些算法（由它的阶跃函数和初始状态定义），并证明对于所有可能的事件列表，某些属性 **P** 成立。由于我们没有规定时间步长的最大值，因此可能的事件列表是无限的。但这不是问题，因为我们可以对列表使用归纳法来证明 **P** 。\n\n![The Isabelle/HOL induction principle over lists](https://martin.kleppmann.com/2022/10/induction.png)\n\n我们使用在 Isabelle/HOL 里 `List.rev_induct` 里的归纳规则。它要求证明：\n\n1. 对于空集合，属性 **P** 的值为真 (比如系统处于初始化状态，还没有执行任何节点); \n2. 如果属性 **P** 对于某些执行为真，我们在执行结束时再添加一个时间步长，那么 **P** 在该时间步长之后仍然成立。\n\n换句话说，我们证明 **P** 在整个系统所有可能的状态中是一个不变量。在 Isabelle 里，这证明看起来是粗糙的像这个 ( `step`、 `init`、和  `procs`  被适当地定义过):\n\n```isabelle\ntheorem prove_invariant:\n  assumes ‹execute step init procs events msgs states›\n  shows ‹some_invariant states›\nusing assms proof (induction events arbitrary: msgs states\n                   rule: List.rev_induct)\n  case Nil\n  then show ‹some_invariant states› sorry\nnext\n  case (snoc event events)\n  then show ?case sorry\nqed\n```\n\n验证分布式算法的真正挑战是提出正确的不变量，它既是值为真又暗示了你希望算法具有的属性。不幸的是，必须手动设计这个不变量。然而，一旦你有了一个不变量作为候选，Isabelle 对检查它是否正确，以及它是否强大到可以满足你的目标非常有帮助。\n\n有关如何在此模型中证明简单共识算法的正确性的更多详细信息，我录制了一个[2 小时的视频讲座](https://www.youtube.com/watch?v=Uav5jWHNghY) ，该讲座贯穿了第一原理的演示（无需之前有 Isabelle 的经验）。这个[演示的 Isabelle 代码](https://gist.github.com/ept/b6872fc541a68a321a26198b53b3896b)也是可用的。\n\n> 如果发现译文存在错误或其他需要改进的地方，欢迎到 [掘金翻译计划](https://github.com/xitu/gold-miner) 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 **本文永久链接** 即为本文在 GitHub 上的 MarkDown 链接。\n\n---\n\n> [掘金翻译计划](https://github.com/xitu/gold-miner) 是一个翻译优质互联网技术文章的社区，文章来源为 [掘金](https://juejin.im) 上的英文分享文章。内容覆盖 [Android](https://github.com/xitu/gold-miner#android)、[iOS](https://github.com/xitu/gold-miner#ios)、[前端](https://github.com/xitu/gold-miner#前端)、[后端](https://github.com/xitu/gold-miner#后端)、[区块链](https://github.com/xitu/gold-miner#区块链)、[产品](https://github.com/xitu/gold-miner#产品)、[设计](https://github.com/xitu/gold-miner#设计)、[人工智能](https://github.com/xitu/gold-miner#人工智能)等领域，想要查看更多优质译文请持续关注 [掘金翻译计划](https://github.com/xitu/gold-miner)、[官方微博](http://weibo.com/juejinfanyi)、[知乎专栏](https://zhuanlan.zhihu.com/juejinfanyi)。\n","source":"_posts/verifying-distributed-systems-isabelle.md","raw":"---\ntitle: (译)用 Isabelle/HOL 验证分布式系统\ndate: 2022-11-15 23:53:50\ncategories: 翻译\ndescription: 众所周知，分布式系统很难推理，正确性的正式证明对于分布式算法很有价值。\n\n---\n\n\n> * 我翻译的这篇文章参与了掘金翻译计划，选自英语优秀技术文章。 \n> * 原文地址：[Verifying distributed systems with Isabelle/HOL](https://martin.kleppmann.com/2022/10/12/verifying-distributed-systems-isabelle.html)\n> * 原文作者：[Martin Kleppmann](https://martin.kleppmann.com/)\n> * 译文出自：[掘金翻译计划](https://github.com/xitu/gold-miner)\n> * 本文永久链接：[https://github.com/xitu/gold-miner/blob/master/article/2022/verifying-distributed-systems-isabelle.md](https://github.com/xitu/gold-miner/blob/master/article/2022/verifying-distributed-systems-isabelle.md)\n> * 译者：[wangxuanni](https://github.com/wangxuanni)\n> * 校对者：[Quincy-Ye](https://github.com/Quincy-Ye) 、[vuuihc](https://github.com/vuuihc)\n\n# 用 Isabelle/HOL 验证分布式系统 \n\n我们每天都以互联网服务的形式使用分布式系统。这些系统很有用，但实现起来也很有挑战性，因为网络是不可预料的。每当你发送一条网络消息的时候，它有可能很快到达，也有可能延迟很久，或者永远不会达到，又或者多次到达。\n\n当你向另一个进程发送请求但没有收到响应时，你完全不知道发生了什么：是这个请求丢失了，还是另一个进程崩溃了，或者是响应丢失了？或者可能没有任何东西丢失，消息只是延迟了，还没有到达。没有办法知道发生了什么，因为进程通信的唯一方式是不可靠的消息传递。\n\n分布式算法在这个不可靠的交流模型之上建立了一个更强大的保证。这种更强大的保证的例子包括数据库的事务和复制（在多台机器上维护一些数据的副本，以便当其中一个机器宕机时，数据不会丢失）。\n\n不幸的是，众所周知，分布式系统很难推理。因为不论消息到达的顺序如何，他们都必须维护他们的保证，甚至是在一些消息丢失，或者一些进程奔溃的时候也如此。。许多算法非常微妙，非正式的推理不足以确保它们是正确的。此外，并发活动可能出现的排列和交织的数量，很快就变得太多，以至于模型检查器无法进行详尽的测试。出于这个原因，正确性的正式证明对于分布式算法很有价值。\n\n## 在 Isabelle/HOL 中建模一个分布式系统\n\n在这篇博文里，我们将会探索怎么样使用 Isabelle/HOL 辅助证明，去正式地验证一些分布式算法。Isabelle/HOL 没有对分布式计算有任何内置的支持，不过幸运的是，可以十分简单的使用 Isabelle/HOL 提供的结构：方法，列表和集合，去建模一个分布式系统。\n\n首先，我们假设在系统里每一个进程（或**节点**）都有一个唯一的标识符，它可以简单的是一个整数或是一个字符串。根据算法，系统中一组进程 ID 可能是固定的和已知的，或者是未知的和不固定的（后者适用于进程们随时可以加入或离开的系统）。\n\n然后算法的执行以离散的时间步长进行。在每个时间步长中，一个事件发生在其中一个进程上。这个事件可能是这三件事中的一个：接收一个其他进程发送过来的消息，接收用户的输入或者是超时。\n\n```ml\ndatatype ('proc, 'msg, 'val) event\n  = Receive (msg_sender: 'proc) (recv_msg: 'msg)\n  | Request 'val\n  | Timeout\n```\n\n被这些事件之一触发，进程会执行一个方法，可能会更新自己的状态并向其他进程发送信息。在一个时间步长发送的消息，可能会被在未来任何的时间步长接收到，或者可能完全不会被接收到。\n\n每个进程都有一个不与任何其他进程共享的本地状态，这个状态在执行开始的时候是固定的初始值，并且只有当进程执行的时候更新。一个进程无法读取另一个进程的状态，但我们可以将整个系统的状态描述为所有进程的各个状态的集合：\n\n![图片](https://cdn.staticaly.com/gh/wangxuanni/wangxuanni_blo@masterg_img/img/time-steps.png)\n\n## 为什么线性的时间步长序列就足够了？\n\n尽管真实的进程可能是并发运行的，我们不需要对并发进行建模，因为进程之间的交流只有发送和接收消息，并且我们可以假设一个进程在开始处理下一个事件之前完成了一个事件的处理。因此，每个并行执行都等价于一些线性的执行步骤序列。分布式系统的其他规范，例如 [TLA+ 语言](https://lamport.azurewebsites.net/tla/tla.html) ，也使用这种线性的步骤序列。\n\n我们不对哪个时间步由哪个进程执行任何假设。进程可以公平地轮流运行，但同样有可能一个进程执行一百万次，而另一个进程什么也不做。通过避免对进程活动的假设，我们确保算法无论系统中的时间如何都能正常工作。例如，一个暂时与网络断开连接的进程仅由一个没有经历任何接收消息事件的进程建模，即使其他进程继续发送和接收消息也是如此。\n\n在这个模型里面，一个进程的宕机只表示它在某个时间步长后不会再执行更多的步骤了；没有必要明确表示宕机。如果我们想让进程从宕机中恢复，我们可以添加第四种类型的事件来模拟崩溃后重新启动的进程。一个进程可以在崩溃后重新启动。当执行这样的崩溃恢复事件时，进程会删除其本地状态中存储在不稳定的内存中的任何部分，但保留其状态中稳定存储（在磁盘上）中的那些部分，在宕机中会幸存下来。\n\n当推理算法安全属性时，最好不要假设哪个进程在哪个时间步执行，因为这样可以确保算法可以容忍任意消息延迟。如果我们想要推理存活（比如，算法最终终止），我们将不得不做出一些公平假设，比如说每一个未崩溃的进程最终会执行一个步骤。然而，在我们的证明里面，我们只聚焦在安全属性上。\n\n![System model: linear sequence of time steps; at each step, one process handles an event](https://martin.kleppmann.com/2022/10/system-model.png)\n\n现在我们可以将一个分布式的算法表示为 **step function** ，它接受三个参数：执行当前时间步长的进程的 ID、该进程的当前本地状态和已发生的事件（消息接收、用户输入、超时，或崩溃恢复）。返回值包含该进程的新状态，以及一组要发送到其他进程的消息（每条消息都标记有接收进程的 ID ）。\n\n```isabelle\ntype_synonym ('proc, 'state, 'msg, 'val) step_func =\n  ‹'proc ⇒ 'state ⇒ ('proc, 'msg, 'val) event ⇒\n  ('state × ('proc × 'msg) set)›\n```\n\n进程在一个时间步骤的当前状态等于它在前一步骤之后的新状态（或者如果没有前一步骤，则为初始状态）。进程在一个时间步的当前状态等于同一进程在前一步之后的新状态（就是初始的状态）。假设 step 函数是确定性的，我们现在可以把系统里任何一个执行编码为（进程 ID ，事件）键值对的集合，表示发生的一系列事件，以及它们发生在哪个进程。系统的最终状态是通过一次调用一个事件的阶跃函数来获得的。\n\n## 去定义可能发生了什么\n\n为了证明分布式算法的正确性，我们需要证明它在每次可能的执行中产生正确的结果，也就是说对于每一个可能的（进程ID，事件）键值对集合。但哪一种执行是可能的？只有一件事是我们可以安全地假设的：如果一个进程接收到一条消息，那么该消息一定已经发送到该进程。换句话来说，我们假设网络不会凭空捏造消息，并且一个进程不能模拟另一个进程。（在攻击者可以注入虚假数据包的公共网络中，我们必须对消息进行加密验证以确保此属性，但现在让我们将其排除在范围之外。）\n\n因此，我们将做出的唯一假设是，如果在某个时间步长接收到消息，那么它一定是在前一个时间步长发送的。然而，我们会允许消息丢失、乱序或者是接收多次，让我们在 Isabelle/HOL 中编码这个假设。\n\n首先，我们定义一个函数来告诉我们单个事件是否可能发生：如果事件 evt 被允许在系统中的进程 `proc` 中发生，`(valid_event evt proc msgs)` 会返回 true ，`msgs`  是迄今为止已发送的所有消息的集合。 `msgs` 是（发件人、收件人、消息）的三元组。在整个系统里。我们定义一个接受事件是允许出现的，如果接收的消息是在 msgs 和 Request 或者 Timeout 事件中，则允许事件发生，或者允许事件随时发生。\n\n```isabelle\nfun valid_event :: ‹('proc, 'msg, 'val) event ⇒ 'proc ⇒\n                    ('proc × 'proc × 'msg) set ⇒ bool›\nwhere\n  ‹valid_event (Receive sender msg) recpt msgs =\n    ((sender, recpt, msg) ∈ msgs)› |\n  ‹valid_event (Request _) _ _ = True› |\n  ‹valid_event Timeout _ _ = True›\n```\n\n接下来，我们定义所有可能的事件序列集合。为此，我们在 Isabelle 中使用了一个归纳断言：如果 `events`是算法执行中的有效事件集合，`step`是阶跃函数， `init` 是每个进程的初始状态，`proc`是系统中所有进程的集合（如果我们希望允许任意数量的进程，这可能是无限的），那么 `(execute step init procs events msgs states)` 返回 true 。最后两个参数跟踪执行状态：`msgs` 是迄今为止发送的所有消息的集合，`states` 是从进程 ID 到该进程状态的映射。\n\n```isabelle\ninductive execute ::\n  ‹('proc, 'state, 'msg, 'val) step_func ⇒ ('proc ⇒ 'state) ⇒\n   'proc set ⇒ ('proc × ('proc, 'msg, 'val) event) list ⇒\n   ('proc × 'proc × 'msg) set ⇒ ('proc ⇒ 'state) ⇒ bool›\nwhere\n  ‹execute step init procs [] {} init› |\n  ‹⟦execute step init procs events msgs states;\n    proc ∈ procs;\n    valid_event event proc msgs;\n    step proc (states proc) event = (new_state, sent);\n    events' = events @ [(proc, event)];\n    msgs' = msgs ∪ {m. ∃(recpt, msg) ∈ sent.\n                       m = (proc, recpt, msg)};\n    states' = states (proc := new_state)\n   ⟧ ⟹ execute step init procs events' msgs' states'›\n```\n\n该定义规定，当系统处于初始状态且未发送任何消息时，空事件列表有效。此外，如果 `events` 是迄今为止有效的事件序列，并且 `event` 在当前状态下是允许的，那么我们可以调用 step 函数，添加它发送到 `msgs` 的任何消息，更新相应进程的状态，其返回值是另一个有效的事件序列。\n\n这就是我们建模一个分布式系统所需要的全部！\n\n## 证明一个算法正确性\n\n现在我们可以用一些算法（由它的阶跃函数和初始状态定义），并证明对于所有可能的事件列表，某些属性 **P** 成立。由于我们没有规定时间步长的最大值，因此可能的事件列表是无限的。但这不是问题，因为我们可以对列表使用归纳法来证明 **P** 。\n\n![The Isabelle/HOL induction principle over lists](https://martin.kleppmann.com/2022/10/induction.png)\n\n我们使用在 Isabelle/HOL 里 `List.rev_induct` 里的归纳规则。它要求证明：\n\n1. 对于空集合，属性 **P** 的值为真 (比如系统处于初始化状态，还没有执行任何节点); \n2. 如果属性 **P** 对于某些执行为真，我们在执行结束时再添加一个时间步长，那么 **P** 在该时间步长之后仍然成立。\n\n换句话说，我们证明 **P** 在整个系统所有可能的状态中是一个不变量。在 Isabelle 里，这证明看起来是粗糙的像这个 ( `step`、 `init`、和  `procs`  被适当地定义过):\n\n```isabelle\ntheorem prove_invariant:\n  assumes ‹execute step init procs events msgs states›\n  shows ‹some_invariant states›\nusing assms proof (induction events arbitrary: msgs states\n                   rule: List.rev_induct)\n  case Nil\n  then show ‹some_invariant states› sorry\nnext\n  case (snoc event events)\n  then show ?case sorry\nqed\n```\n\n验证分布式算法的真正挑战是提出正确的不变量，它既是值为真又暗示了你希望算法具有的属性。不幸的是，必须手动设计这个不变量。然而，一旦你有了一个不变量作为候选，Isabelle 对检查它是否正确，以及它是否强大到可以满足你的目标非常有帮助。\n\n有关如何在此模型中证明简单共识算法的正确性的更多详细信息，我录制了一个[2 小时的视频讲座](https://www.youtube.com/watch?v=Uav5jWHNghY) ，该讲座贯穿了第一原理的演示（无需之前有 Isabelle 的经验）。这个[演示的 Isabelle 代码](https://gist.github.com/ept/b6872fc541a68a321a26198b53b3896b)也是可用的。\n\n> 如果发现译文存在错误或其他需要改进的地方，欢迎到 [掘金翻译计划](https://github.com/xitu/gold-miner) 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 **本文永久链接** 即为本文在 GitHub 上的 MarkDown 链接。\n\n---\n\n> [掘金翻译计划](https://github.com/xitu/gold-miner) 是一个翻译优质互联网技术文章的社区，文章来源为 [掘金](https://juejin.im) 上的英文分享文章。内容覆盖 [Android](https://github.com/xitu/gold-miner#android)、[iOS](https://github.com/xitu/gold-miner#ios)、[前端](https://github.com/xitu/gold-miner#前端)、[后端](https://github.com/xitu/gold-miner#后端)、[区块链](https://github.com/xitu/gold-miner#区块链)、[产品](https://github.com/xitu/gold-miner#产品)、[设计](https://github.com/xitu/gold-miner#设计)、[人工智能](https://github.com/xitu/gold-miner#人工智能)等领域，想要查看更多优质译文请持续关注 [掘金翻译计划](https://github.com/xitu/gold-miner)、[官方微博](http://weibo.com/juejinfanyi)、[知乎专栏](https://zhuanlan.zhihu.com/juejinfanyi)。\n","slug":"verifying-distributed-systems-isabelle","published":1,"updated":"2022-12-09T16:55:35.379Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qki0011w9rp5p1omh9g","content":"<blockquote>\n<ul>\n<li>我翻译的这篇文章参与了掘金翻译计划，选自英语优秀技术文章。 </li>\n<li>原文地址：<a href=\"https://martin.kleppmann.com/2022/10/12/verifying-distributed-systems-isabelle.html\" target=\"_blank\" rel=\"noopener\">Verifying distributed systems with Isabelle/HOL</a></li>\n<li>原文作者：<a href=\"https://martin.kleppmann.com/\" target=\"_blank\" rel=\"noopener\">Martin Kleppmann</a></li>\n<li>译文出自：<a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a></li>\n<li>本文永久链接：<a href=\"https://github.com/xitu/gold-miner/blob/master/article/2022/verifying-distributed-systems-isabelle.md\" target=\"_blank\" rel=\"noopener\">https://github.com/xitu/gold-miner/blob/master/article/2022/verifying-distributed-systems-isabelle.md</a></li>\n<li>译者：<a href=\"https://github.com/wangxuanni\" target=\"_blank\" rel=\"noopener\">wangxuanni</a></li>\n<li>校对者：<a href=\"https://github.com/Quincy-Ye\" target=\"_blank\" rel=\"noopener\">Quincy-Ye</a> 、<a href=\"https://github.com/vuuihc\" target=\"_blank\" rel=\"noopener\">vuuihc</a></li>\n</ul>\n</blockquote>\n<h1 id=\"用-Isabelle-HOL-验证分布式系统\"><a href=\"#用-Isabelle-HOL-验证分布式系统\" class=\"headerlink\" title=\"用 Isabelle/HOL 验证分布式系统\"></a>用 Isabelle/HOL 验证分布式系统</h1><p>我们每天都以互联网服务的形式使用分布式系统。这些系统很有用，但实现起来也很有挑战性，因为网络是不可预料的。每当你发送一条网络消息的时候，它有可能很快到达，也有可能延迟很久，或者永远不会达到，又或者多次到达。</p>\n<p>当你向另一个进程发送请求但没有收到响应时，你完全不知道发生了什么：是这个请求丢失了，还是另一个进程崩溃了，或者是响应丢失了？或者可能没有任何东西丢失，消息只是延迟了，还没有到达。没有办法知道发生了什么，因为进程通信的唯一方式是不可靠的消息传递。</p>\n<p>分布式算法在这个不可靠的交流模型之上建立了一个更强大的保证。这种更强大的保证的例子包括数据库的事务和复制（在多台机器上维护一些数据的副本，以便当其中一个机器宕机时，数据不会丢失）。</p>\n<p>不幸的是，众所周知，分布式系统很难推理。因为不论消息到达的顺序如何，他们都必须维护他们的保证，甚至是在一些消息丢失，或者一些进程奔溃的时候也如此。。许多算法非常微妙，非正式的推理不足以确保它们是正确的。此外，并发活动可能出现的排列和交织的数量，很快就变得太多，以至于模型检查器无法进行详尽的测试。出于这个原因，正确性的正式证明对于分布式算法很有价值。</p>\n<h2 id=\"在-Isabelle-HOL-中建模一个分布式系统\"><a href=\"#在-Isabelle-HOL-中建模一个分布式系统\" class=\"headerlink\" title=\"在 Isabelle/HOL 中建模一个分布式系统\"></a>在 Isabelle/HOL 中建模一个分布式系统</h2><p>在这篇博文里，我们将会探索怎么样使用 Isabelle/HOL 辅助证明，去正式地验证一些分布式算法。Isabelle/HOL 没有对分布式计算有任何内置的支持，不过幸运的是，可以十分简单的使用 Isabelle/HOL 提供的结构：方法，列表和集合，去建模一个分布式系统。</p>\n<p>首先，我们假设在系统里每一个进程（或<strong>节点</strong>）都有一个唯一的标识符，它可以简单的是一个整数或是一个字符串。根据算法，系统中一组进程 ID 可能是固定的和已知的，或者是未知的和不固定的（后者适用于进程们随时可以加入或离开的系统）。</p>\n<p>然后算法的执行以离散的时间步长进行。在每个时间步长中，一个事件发生在其中一个进程上。这个事件可能是这三件事中的一个：接收一个其他进程发送过来的消息，接收用户的输入或者是超时。</p>\n<figure class=\"highlight ml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">datatype</span> (<span class=\"symbol\">'proc</span>, <span class=\"symbol\">'msg</span>, <span class=\"symbol\">'val</span>) event</span><br><span class=\"line\">  = <span class=\"type\">Receive</span> (msg_sender: <span class=\"symbol\">'proc</span>) (recv_msg: <span class=\"symbol\">'msg</span>)</span><br><span class=\"line\">  | <span class=\"type\">Request</span> <span class=\"symbol\">'val</span></span><br><span class=\"line\">  | <span class=\"type\">Timeout</span></span><br></pre></td></tr></table></figure>\n<p>被这些事件之一触发，进程会执行一个方法，可能会更新自己的状态并向其他进程发送信息。在一个时间步长发送的消息，可能会被在未来任何的时间步长接收到，或者可能完全不会被接收到。</p>\n<p>每个进程都有一个不与任何其他进程共享的本地状态，这个状态在执行开始的时候是固定的初始值，并且只有当进程执行的时候更新。一个进程无法读取另一个进程的状态，但我们可以将整个系统的状态描述为所有进程的各个状态的集合：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/wangxuanni/wangxuanni_blo@masterg_img/img/time-steps.png\" alt=\"图片\"></p>\n<h2 id=\"为什么线性的时间步长序列就足够了？\"><a href=\"#为什么线性的时间步长序列就足够了？\" class=\"headerlink\" title=\"为什么线性的时间步长序列就足够了？\"></a>为什么线性的时间步长序列就足够了？</h2><p>尽管真实的进程可能是并发运行的，我们不需要对并发进行建模，因为进程之间的交流只有发送和接收消息，并且我们可以假设一个进程在开始处理下一个事件之前完成了一个事件的处理。因此，每个并行执行都等价于一些线性的执行步骤序列。分布式系统的其他规范，例如 <a href=\"https://lamport.azurewebsites.net/tla/tla.html\" target=\"_blank\" rel=\"noopener\">TLA+ 语言</a> ，也使用这种线性的步骤序列。</p>\n<p>我们不对哪个时间步由哪个进程执行任何假设。进程可以公平地轮流运行，但同样有可能一个进程执行一百万次，而另一个进程什么也不做。通过避免对进程活动的假设，我们确保算法无论系统中的时间如何都能正常工作。例如，一个暂时与网络断开连接的进程仅由一个没有经历任何接收消息事件的进程建模，即使其他进程继续发送和接收消息也是如此。</p>\n<p>在这个模型里面，一个进程的宕机只表示它在某个时间步长后不会再执行更多的步骤了；没有必要明确表示宕机。如果我们想让进程从宕机中恢复，我们可以添加第四种类型的事件来模拟崩溃后重新启动的进程。一个进程可以在崩溃后重新启动。当执行这样的崩溃恢复事件时，进程会删除其本地状态中存储在不稳定的内存中的任何部分，但保留其状态中稳定存储（在磁盘上）中的那些部分，在宕机中会幸存下来。</p>\n<p>当推理算法安全属性时，最好不要假设哪个进程在哪个时间步执行，因为这样可以确保算法可以容忍任意消息延迟。如果我们想要推理存活（比如，算法最终终止），我们将不得不做出一些公平假设，比如说每一个未崩溃的进程最终会执行一个步骤。然而，在我们的证明里面，我们只聚焦在安全属性上。</p>\n<p><img src=\"https://martin.kleppmann.com/2022/10/system-model.png\" alt=\"System model: linear sequence of time steps; at each step, one process handles an event\"></p>\n<p>现在我们可以将一个分布式的算法表示为 <strong>step function</strong> ，它接受三个参数：执行当前时间步长的进程的 ID、该进程的当前本地状态和已发生的事件（消息接收、用户输入、超时，或崩溃恢复）。返回值包含该进程的新状态，以及一组要发送到其他进程的消息（每条消息都标记有接收进程的 ID ）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type_synonym (&apos;proc, &apos;state, &apos;msg, &apos;val) step_func =</span><br><span class=\"line\">  ‹&apos;proc ⇒ &apos;state ⇒ (&apos;proc, &apos;msg, &apos;val) event ⇒</span><br><span class=\"line\">  (&apos;state × (&apos;proc × &apos;msg) set)›</span><br></pre></td></tr></table></figure>\n<p>进程在一个时间步骤的当前状态等于它在前一步骤之后的新状态（或者如果没有前一步骤，则为初始状态）。进程在一个时间步的当前状态等于同一进程在前一步之后的新状态（就是初始的状态）。假设 step 函数是确定性的，我们现在可以把系统里任何一个执行编码为（进程 ID ，事件）键值对的集合，表示发生的一系列事件，以及它们发生在哪个进程。系统的最终状态是通过一次调用一个事件的阶跃函数来获得的。</p>\n<h2 id=\"去定义可能发生了什么\"><a href=\"#去定义可能发生了什么\" class=\"headerlink\" title=\"去定义可能发生了什么\"></a>去定义可能发生了什么</h2><p>为了证明分布式算法的正确性，我们需要证明它在每次可能的执行中产生正确的结果，也就是说对于每一个可能的（进程ID，事件）键值对集合。但哪一种执行是可能的？只有一件事是我们可以安全地假设的：如果一个进程接收到一条消息，那么该消息一定已经发送到该进程。换句话来说，我们假设网络不会凭空捏造消息，并且一个进程不能模拟另一个进程。（在攻击者可以注入虚假数据包的公共网络中，我们必须对消息进行加密验证以确保此属性，但现在让我们将其排除在范围之外。）</p>\n<p>因此，我们将做出的唯一假设是，如果在某个时间步长接收到消息，那么它一定是在前一个时间步长发送的。然而，我们会允许消息丢失、乱序或者是接收多次，让我们在 Isabelle/HOL 中编码这个假设。</p>\n<p>首先，我们定义一个函数来告诉我们单个事件是否可能发生：如果事件 evt 被允许在系统中的进程 <code>proc</code> 中发生，<code>(valid_event evt proc msgs)</code> 会返回 true ，<code>msgs</code>  是迄今为止已发送的所有消息的集合。 <code>msgs</code> 是（发件人、收件人、消息）的三元组。在整个系统里。我们定义一个接受事件是允许出现的，如果接收的消息是在 msgs 和 Request 或者 Timeout 事件中，则允许事件发生，或者允许事件随时发生。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun valid_event :: ‹(&apos;proc, &apos;msg, &apos;val) event ⇒ &apos;proc ⇒</span><br><span class=\"line\">                    (&apos;proc × &apos;proc × &apos;msg) set ⇒ bool›</span><br><span class=\"line\">where</span><br><span class=\"line\">  ‹valid_event (Receive sender msg) recpt msgs =</span><br><span class=\"line\">    ((sender, recpt, msg) ∈ msgs)› |</span><br><span class=\"line\">  ‹valid_event (Request _) _ _ = True› |</span><br><span class=\"line\">  ‹valid_event Timeout _ _ = True›</span><br></pre></td></tr></table></figure>\n<p>接下来，我们定义所有可能的事件序列集合。为此，我们在 Isabelle 中使用了一个归纳断言：如果 <code>events</code>是算法执行中的有效事件集合，<code>step</code>是阶跃函数， <code>init</code> 是每个进程的初始状态，<code>proc</code>是系统中所有进程的集合（如果我们希望允许任意数量的进程，这可能是无限的），那么 <code>(execute step init procs events msgs states)</code> 返回 true 。最后两个参数跟踪执行状态：<code>msgs</code> 是迄今为止发送的所有消息的集合，<code>states</code> 是从进程 ID 到该进程状态的映射。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inductive execute ::</span><br><span class=\"line\">  ‹(&apos;proc, &apos;state, &apos;msg, &apos;val) step_func ⇒ (&apos;proc ⇒ &apos;state) ⇒</span><br><span class=\"line\">   &apos;proc set ⇒ (&apos;proc × (&apos;proc, &apos;msg, &apos;val) event) list ⇒</span><br><span class=\"line\">   (&apos;proc × &apos;proc × &apos;msg) set ⇒ (&apos;proc ⇒ &apos;state) ⇒ bool›</span><br><span class=\"line\">where</span><br><span class=\"line\">  ‹execute step init procs [] &#123;&#125; init› |</span><br><span class=\"line\">  ‹⟦execute step init procs events msgs states;</span><br><span class=\"line\">    proc ∈ procs;</span><br><span class=\"line\">    valid_event event proc msgs;</span><br><span class=\"line\">    step proc (states proc) event = (new_state, sent);</span><br><span class=\"line\">    events&apos; = events @ [(proc, event)];</span><br><span class=\"line\">    msgs&apos; = msgs ∪ &#123;m. ∃(recpt, msg) ∈ sent.</span><br><span class=\"line\">                       m = (proc, recpt, msg)&#125;;</span><br><span class=\"line\">    states&apos; = states (proc := new_state)</span><br><span class=\"line\">   ⟧ ⟹ execute step init procs events&apos; msgs&apos; states&apos;›</span><br></pre></td></tr></table></figure>\n<p>该定义规定，当系统处于初始状态且未发送任何消息时，空事件列表有效。此外，如果 <code>events</code> 是迄今为止有效的事件序列，并且 <code>event</code> 在当前状态下是允许的，那么我们可以调用 step 函数，添加它发送到 <code>msgs</code> 的任何消息，更新相应进程的状态，其返回值是另一个有效的事件序列。</p>\n<p>这就是我们建模一个分布式系统所需要的全部！</p>\n<h2 id=\"证明一个算法正确性\"><a href=\"#证明一个算法正确性\" class=\"headerlink\" title=\"证明一个算法正确性\"></a>证明一个算法正确性</h2><p>现在我们可以用一些算法（由它的阶跃函数和初始状态定义），并证明对于所有可能的事件列表，某些属性 <strong>P</strong> 成立。由于我们没有规定时间步长的最大值，因此可能的事件列表是无限的。但这不是问题，因为我们可以对列表使用归纳法来证明 <strong>P</strong> 。</p>\n<p><img src=\"https://martin.kleppmann.com/2022/10/induction.png\" alt=\"The Isabelle/HOL induction principle over lists\"></p>\n<p>我们使用在 Isabelle/HOL 里 <code>List.rev_induct</code> 里的归纳规则。它要求证明：</p>\n<ol>\n<li>对于空集合，属性 <strong>P</strong> 的值为真 (比如系统处于初始化状态，还没有执行任何节点); </li>\n<li>如果属性 <strong>P</strong> 对于某些执行为真，我们在执行结束时再添加一个时间步长，那么 <strong>P</strong> 在该时间步长之后仍然成立。</li>\n</ol>\n<p>换句话说，我们证明 <strong>P</strong> 在整个系统所有可能的状态中是一个不变量。在 Isabelle 里，这证明看起来是粗糙的像这个 ( <code>step</code>、 <code>init</code>、和  <code>procs</code>  被适当地定义过):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theorem prove_invariant:</span><br><span class=\"line\">  assumes ‹execute step init procs events msgs states›</span><br><span class=\"line\">  shows ‹some_invariant states›</span><br><span class=\"line\">using assms proof (induction events arbitrary: msgs states</span><br><span class=\"line\">                   rule: List.rev_induct)</span><br><span class=\"line\">  case Nil</span><br><span class=\"line\">  then show ‹some_invariant states› sorry</span><br><span class=\"line\">next</span><br><span class=\"line\">  case (snoc event events)</span><br><span class=\"line\">  then show ?case sorry</span><br><span class=\"line\">qed</span><br></pre></td></tr></table></figure>\n<p>验证分布式算法的真正挑战是提出正确的不变量，它既是值为真又暗示了你希望算法具有的属性。不幸的是，必须手动设计这个不变量。然而，一旦你有了一个不变量作为候选，Isabelle 对检查它是否正确，以及它是否强大到可以满足你的目标非常有帮助。</p>\n<p>有关如何在此模型中证明简单共识算法的正确性的更多详细信息，我录制了一个<a href=\"https://www.youtube.com/watch?v=Uav5jWHNghY\" target=\"_blank\" rel=\"noopener\">2 小时的视频讲座</a> ，该讲座贯穿了第一原理的演示（无需之前有 Isabelle 的经验）。这个<a href=\"https://gist.github.com/ept/b6872fc541a68a321a26198b53b3896b\" target=\"_blank\" rel=\"noopener\">演示的 Isabelle 代码</a>也是可用的。</p>\n<blockquote>\n<p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href=\"https://juejin.im\" target=\"_blank\" rel=\"noopener\">掘金</a> 上的英文分享文章。内容覆盖 <a href=\"https://github.com/xitu/gold-miner#android\" target=\"_blank\" rel=\"noopener\">Android</a>、<a href=\"https://github.com/xitu/gold-miner#ios\" target=\"_blank\" rel=\"noopener\">iOS</a>、<a href=\"https://github.com/xitu/gold-miner#前端\" target=\"_blank\" rel=\"noopener\">前端</a>、<a href=\"https://github.com/xitu/gold-miner#后端\" target=\"_blank\" rel=\"noopener\">后端</a>、<a href=\"https://github.com/xitu/gold-miner#区块链\" target=\"_blank\" rel=\"noopener\">区块链</a>、<a href=\"https://github.com/xitu/gold-miner#产品\" target=\"_blank\" rel=\"noopener\">产品</a>、<a href=\"https://github.com/xitu/gold-miner#设计\" target=\"_blank\" rel=\"noopener\">设计</a>、<a href=\"https://github.com/xitu/gold-miner#人工智能\" target=\"_blank\" rel=\"noopener\">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a>、<a href=\"http://weibo.com/juejinfanyi\" target=\"_blank\" rel=\"noopener\">官方微博</a>、<a href=\"https://zhuanlan.zhihu.com/juejinfanyi\" target=\"_blank\" rel=\"noopener\">知乎专栏</a>。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ul>\n<li>我翻译的这篇文章参与了掘金翻译计划，选自英语优秀技术文章。 </li>\n<li>原文地址：<a href=\"https://martin.kleppmann.com/2022/10/12/verifying-distributed-systems-isabelle.html\" target=\"_blank\" rel=\"noopener\">Verifying distributed systems with Isabelle/HOL</a></li>\n<li>原文作者：<a href=\"https://martin.kleppmann.com/\" target=\"_blank\" rel=\"noopener\">Martin Kleppmann</a></li>\n<li>译文出自：<a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a></li>\n<li>本文永久链接：<a href=\"https://github.com/xitu/gold-miner/blob/master/article/2022/verifying-distributed-systems-isabelle.md\" target=\"_blank\" rel=\"noopener\">https://github.com/xitu/gold-miner/blob/master/article/2022/verifying-distributed-systems-isabelle.md</a></li>\n<li>译者：<a href=\"https://github.com/wangxuanni\" target=\"_blank\" rel=\"noopener\">wangxuanni</a></li>\n<li>校对者：<a href=\"https://github.com/Quincy-Ye\" target=\"_blank\" rel=\"noopener\">Quincy-Ye</a> 、<a href=\"https://github.com/vuuihc\" target=\"_blank\" rel=\"noopener\">vuuihc</a></li>\n</ul>\n</blockquote>\n<h1 id=\"用-Isabelle-HOL-验证分布式系统\"><a href=\"#用-Isabelle-HOL-验证分布式系统\" class=\"headerlink\" title=\"用 Isabelle/HOL 验证分布式系统\"></a>用 Isabelle/HOL 验证分布式系统</h1><p>我们每天都以互联网服务的形式使用分布式系统。这些系统很有用，但实现起来也很有挑战性，因为网络是不可预料的。每当你发送一条网络消息的时候，它有可能很快到达，也有可能延迟很久，或者永远不会达到，又或者多次到达。</p>\n<p>当你向另一个进程发送请求但没有收到响应时，你完全不知道发生了什么：是这个请求丢失了，还是另一个进程崩溃了，或者是响应丢失了？或者可能没有任何东西丢失，消息只是延迟了，还没有到达。没有办法知道发生了什么，因为进程通信的唯一方式是不可靠的消息传递。</p>\n<p>分布式算法在这个不可靠的交流模型之上建立了一个更强大的保证。这种更强大的保证的例子包括数据库的事务和复制（在多台机器上维护一些数据的副本，以便当其中一个机器宕机时，数据不会丢失）。</p>\n<p>不幸的是，众所周知，分布式系统很难推理。因为不论消息到达的顺序如何，他们都必须维护他们的保证，甚至是在一些消息丢失，或者一些进程奔溃的时候也如此。。许多算法非常微妙，非正式的推理不足以确保它们是正确的。此外，并发活动可能出现的排列和交织的数量，很快就变得太多，以至于模型检查器无法进行详尽的测试。出于这个原因，正确性的正式证明对于分布式算法很有价值。</p>\n<h2 id=\"在-Isabelle-HOL-中建模一个分布式系统\"><a href=\"#在-Isabelle-HOL-中建模一个分布式系统\" class=\"headerlink\" title=\"在 Isabelle/HOL 中建模一个分布式系统\"></a>在 Isabelle/HOL 中建模一个分布式系统</h2><p>在这篇博文里，我们将会探索怎么样使用 Isabelle/HOL 辅助证明，去正式地验证一些分布式算法。Isabelle/HOL 没有对分布式计算有任何内置的支持，不过幸运的是，可以十分简单的使用 Isabelle/HOL 提供的结构：方法，列表和集合，去建模一个分布式系统。</p>\n<p>首先，我们假设在系统里每一个进程（或<strong>节点</strong>）都有一个唯一的标识符，它可以简单的是一个整数或是一个字符串。根据算法，系统中一组进程 ID 可能是固定的和已知的，或者是未知的和不固定的（后者适用于进程们随时可以加入或离开的系统）。</p>\n<p>然后算法的执行以离散的时间步长进行。在每个时间步长中，一个事件发生在其中一个进程上。这个事件可能是这三件事中的一个：接收一个其他进程发送过来的消息，接收用户的输入或者是超时。</p>\n<figure class=\"highlight ml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">datatype</span> (<span class=\"symbol\">'proc</span>, <span class=\"symbol\">'msg</span>, <span class=\"symbol\">'val</span>) event</span><br><span class=\"line\">  = <span class=\"type\">Receive</span> (msg_sender: <span class=\"symbol\">'proc</span>) (recv_msg: <span class=\"symbol\">'msg</span>)</span><br><span class=\"line\">  | <span class=\"type\">Request</span> <span class=\"symbol\">'val</span></span><br><span class=\"line\">  | <span class=\"type\">Timeout</span></span><br></pre></td></tr></table></figure>\n<p>被这些事件之一触发，进程会执行一个方法，可能会更新自己的状态并向其他进程发送信息。在一个时间步长发送的消息，可能会被在未来任何的时间步长接收到，或者可能完全不会被接收到。</p>\n<p>每个进程都有一个不与任何其他进程共享的本地状态，这个状态在执行开始的时候是固定的初始值，并且只有当进程执行的时候更新。一个进程无法读取另一个进程的状态，但我们可以将整个系统的状态描述为所有进程的各个状态的集合：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/wangxuanni/wangxuanni_blo@masterg_img/img/time-steps.png\" alt=\"图片\"></p>\n<h2 id=\"为什么线性的时间步长序列就足够了？\"><a href=\"#为什么线性的时间步长序列就足够了？\" class=\"headerlink\" title=\"为什么线性的时间步长序列就足够了？\"></a>为什么线性的时间步长序列就足够了？</h2><p>尽管真实的进程可能是并发运行的，我们不需要对并发进行建模，因为进程之间的交流只有发送和接收消息，并且我们可以假设一个进程在开始处理下一个事件之前完成了一个事件的处理。因此，每个并行执行都等价于一些线性的执行步骤序列。分布式系统的其他规范，例如 <a href=\"https://lamport.azurewebsites.net/tla/tla.html\" target=\"_blank\" rel=\"noopener\">TLA+ 语言</a> ，也使用这种线性的步骤序列。</p>\n<p>我们不对哪个时间步由哪个进程执行任何假设。进程可以公平地轮流运行，但同样有可能一个进程执行一百万次，而另一个进程什么也不做。通过避免对进程活动的假设，我们确保算法无论系统中的时间如何都能正常工作。例如，一个暂时与网络断开连接的进程仅由一个没有经历任何接收消息事件的进程建模，即使其他进程继续发送和接收消息也是如此。</p>\n<p>在这个模型里面，一个进程的宕机只表示它在某个时间步长后不会再执行更多的步骤了；没有必要明确表示宕机。如果我们想让进程从宕机中恢复，我们可以添加第四种类型的事件来模拟崩溃后重新启动的进程。一个进程可以在崩溃后重新启动。当执行这样的崩溃恢复事件时，进程会删除其本地状态中存储在不稳定的内存中的任何部分，但保留其状态中稳定存储（在磁盘上）中的那些部分，在宕机中会幸存下来。</p>\n<p>当推理算法安全属性时，最好不要假设哪个进程在哪个时间步执行，因为这样可以确保算法可以容忍任意消息延迟。如果我们想要推理存活（比如，算法最终终止），我们将不得不做出一些公平假设，比如说每一个未崩溃的进程最终会执行一个步骤。然而，在我们的证明里面，我们只聚焦在安全属性上。</p>\n<p><img src=\"https://martin.kleppmann.com/2022/10/system-model.png\" alt=\"System model: linear sequence of time steps; at each step, one process handles an event\"></p>\n<p>现在我们可以将一个分布式的算法表示为 <strong>step function</strong> ，它接受三个参数：执行当前时间步长的进程的 ID、该进程的当前本地状态和已发生的事件（消息接收、用户输入、超时，或崩溃恢复）。返回值包含该进程的新状态，以及一组要发送到其他进程的消息（每条消息都标记有接收进程的 ID ）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type_synonym (&apos;proc, &apos;state, &apos;msg, &apos;val) step_func =</span><br><span class=\"line\">  ‹&apos;proc ⇒ &apos;state ⇒ (&apos;proc, &apos;msg, &apos;val) event ⇒</span><br><span class=\"line\">  (&apos;state × (&apos;proc × &apos;msg) set)›</span><br></pre></td></tr></table></figure>\n<p>进程在一个时间步骤的当前状态等于它在前一步骤之后的新状态（或者如果没有前一步骤，则为初始状态）。进程在一个时间步的当前状态等于同一进程在前一步之后的新状态（就是初始的状态）。假设 step 函数是确定性的，我们现在可以把系统里任何一个执行编码为（进程 ID ，事件）键值对的集合，表示发生的一系列事件，以及它们发生在哪个进程。系统的最终状态是通过一次调用一个事件的阶跃函数来获得的。</p>\n<h2 id=\"去定义可能发生了什么\"><a href=\"#去定义可能发生了什么\" class=\"headerlink\" title=\"去定义可能发生了什么\"></a>去定义可能发生了什么</h2><p>为了证明分布式算法的正确性，我们需要证明它在每次可能的执行中产生正确的结果，也就是说对于每一个可能的（进程ID，事件）键值对集合。但哪一种执行是可能的？只有一件事是我们可以安全地假设的：如果一个进程接收到一条消息，那么该消息一定已经发送到该进程。换句话来说，我们假设网络不会凭空捏造消息，并且一个进程不能模拟另一个进程。（在攻击者可以注入虚假数据包的公共网络中，我们必须对消息进行加密验证以确保此属性，但现在让我们将其排除在范围之外。）</p>\n<p>因此，我们将做出的唯一假设是，如果在某个时间步长接收到消息，那么它一定是在前一个时间步长发送的。然而，我们会允许消息丢失、乱序或者是接收多次，让我们在 Isabelle/HOL 中编码这个假设。</p>\n<p>首先，我们定义一个函数来告诉我们单个事件是否可能发生：如果事件 evt 被允许在系统中的进程 <code>proc</code> 中发生，<code>(valid_event evt proc msgs)</code> 会返回 true ，<code>msgs</code>  是迄今为止已发送的所有消息的集合。 <code>msgs</code> 是（发件人、收件人、消息）的三元组。在整个系统里。我们定义一个接受事件是允许出现的，如果接收的消息是在 msgs 和 Request 或者 Timeout 事件中，则允许事件发生，或者允许事件随时发生。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun valid_event :: ‹(&apos;proc, &apos;msg, &apos;val) event ⇒ &apos;proc ⇒</span><br><span class=\"line\">                    (&apos;proc × &apos;proc × &apos;msg) set ⇒ bool›</span><br><span class=\"line\">where</span><br><span class=\"line\">  ‹valid_event (Receive sender msg) recpt msgs =</span><br><span class=\"line\">    ((sender, recpt, msg) ∈ msgs)› |</span><br><span class=\"line\">  ‹valid_event (Request _) _ _ = True› |</span><br><span class=\"line\">  ‹valid_event Timeout _ _ = True›</span><br></pre></td></tr></table></figure>\n<p>接下来，我们定义所有可能的事件序列集合。为此，我们在 Isabelle 中使用了一个归纳断言：如果 <code>events</code>是算法执行中的有效事件集合，<code>step</code>是阶跃函数， <code>init</code> 是每个进程的初始状态，<code>proc</code>是系统中所有进程的集合（如果我们希望允许任意数量的进程，这可能是无限的），那么 <code>(execute step init procs events msgs states)</code> 返回 true 。最后两个参数跟踪执行状态：<code>msgs</code> 是迄今为止发送的所有消息的集合，<code>states</code> 是从进程 ID 到该进程状态的映射。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inductive execute ::</span><br><span class=\"line\">  ‹(&apos;proc, &apos;state, &apos;msg, &apos;val) step_func ⇒ (&apos;proc ⇒ &apos;state) ⇒</span><br><span class=\"line\">   &apos;proc set ⇒ (&apos;proc × (&apos;proc, &apos;msg, &apos;val) event) list ⇒</span><br><span class=\"line\">   (&apos;proc × &apos;proc × &apos;msg) set ⇒ (&apos;proc ⇒ &apos;state) ⇒ bool›</span><br><span class=\"line\">where</span><br><span class=\"line\">  ‹execute step init procs [] &#123;&#125; init› |</span><br><span class=\"line\">  ‹⟦execute step init procs events msgs states;</span><br><span class=\"line\">    proc ∈ procs;</span><br><span class=\"line\">    valid_event event proc msgs;</span><br><span class=\"line\">    step proc (states proc) event = (new_state, sent);</span><br><span class=\"line\">    events&apos; = events @ [(proc, event)];</span><br><span class=\"line\">    msgs&apos; = msgs ∪ &#123;m. ∃(recpt, msg) ∈ sent.</span><br><span class=\"line\">                       m = (proc, recpt, msg)&#125;;</span><br><span class=\"line\">    states&apos; = states (proc := new_state)</span><br><span class=\"line\">   ⟧ ⟹ execute step init procs events&apos; msgs&apos; states&apos;›</span><br></pre></td></tr></table></figure>\n<p>该定义规定，当系统处于初始状态且未发送任何消息时，空事件列表有效。此外，如果 <code>events</code> 是迄今为止有效的事件序列，并且 <code>event</code> 在当前状态下是允许的，那么我们可以调用 step 函数，添加它发送到 <code>msgs</code> 的任何消息，更新相应进程的状态，其返回值是另一个有效的事件序列。</p>\n<p>这就是我们建模一个分布式系统所需要的全部！</p>\n<h2 id=\"证明一个算法正确性\"><a href=\"#证明一个算法正确性\" class=\"headerlink\" title=\"证明一个算法正确性\"></a>证明一个算法正确性</h2><p>现在我们可以用一些算法（由它的阶跃函数和初始状态定义），并证明对于所有可能的事件列表，某些属性 <strong>P</strong> 成立。由于我们没有规定时间步长的最大值，因此可能的事件列表是无限的。但这不是问题，因为我们可以对列表使用归纳法来证明 <strong>P</strong> 。</p>\n<p><img src=\"https://martin.kleppmann.com/2022/10/induction.png\" alt=\"The Isabelle/HOL induction principle over lists\"></p>\n<p>我们使用在 Isabelle/HOL 里 <code>List.rev_induct</code> 里的归纳规则。它要求证明：</p>\n<ol>\n<li>对于空集合，属性 <strong>P</strong> 的值为真 (比如系统处于初始化状态，还没有执行任何节点); </li>\n<li>如果属性 <strong>P</strong> 对于某些执行为真，我们在执行结束时再添加一个时间步长，那么 <strong>P</strong> 在该时间步长之后仍然成立。</li>\n</ol>\n<p>换句话说，我们证明 <strong>P</strong> 在整个系统所有可能的状态中是一个不变量。在 Isabelle 里，这证明看起来是粗糙的像这个 ( <code>step</code>、 <code>init</code>、和  <code>procs</code>  被适当地定义过):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theorem prove_invariant:</span><br><span class=\"line\">  assumes ‹execute step init procs events msgs states›</span><br><span class=\"line\">  shows ‹some_invariant states›</span><br><span class=\"line\">using assms proof (induction events arbitrary: msgs states</span><br><span class=\"line\">                   rule: List.rev_induct)</span><br><span class=\"line\">  case Nil</span><br><span class=\"line\">  then show ‹some_invariant states› sorry</span><br><span class=\"line\">next</span><br><span class=\"line\">  case (snoc event events)</span><br><span class=\"line\">  then show ?case sorry</span><br><span class=\"line\">qed</span><br></pre></td></tr></table></figure>\n<p>验证分布式算法的真正挑战是提出正确的不变量，它既是值为真又暗示了你希望算法具有的属性。不幸的是，必须手动设计这个不变量。然而，一旦你有了一个不变量作为候选，Isabelle 对检查它是否正确，以及它是否强大到可以满足你的目标非常有帮助。</p>\n<p>有关如何在此模型中证明简单共识算法的正确性的更多详细信息，我录制了一个<a href=\"https://www.youtube.com/watch?v=Uav5jWHNghY\" target=\"_blank\" rel=\"noopener\">2 小时的视频讲座</a> ，该讲座贯穿了第一原理的演示（无需之前有 Isabelle 的经验）。这个<a href=\"https://gist.github.com/ept/b6872fc541a68a321a26198b53b3896b\" target=\"_blank\" rel=\"noopener\">演示的 Isabelle 代码</a>也是可用的。</p>\n<blockquote>\n<p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href=\"https://juejin.im\" target=\"_blank\" rel=\"noopener\">掘金</a> 上的英文分享文章。内容覆盖 <a href=\"https://github.com/xitu/gold-miner#android\" target=\"_blank\" rel=\"noopener\">Android</a>、<a href=\"https://github.com/xitu/gold-miner#ios\" target=\"_blank\" rel=\"noopener\">iOS</a>、<a href=\"https://github.com/xitu/gold-miner#前端\" target=\"_blank\" rel=\"noopener\">前端</a>、<a href=\"https://github.com/xitu/gold-miner#后端\" target=\"_blank\" rel=\"noopener\">后端</a>、<a href=\"https://github.com/xitu/gold-miner#区块链\" target=\"_blank\" rel=\"noopener\">区块链</a>、<a href=\"https://github.com/xitu/gold-miner#产品\" target=\"_blank\" rel=\"noopener\">产品</a>、<a href=\"https://github.com/xitu/gold-miner#设计\" target=\"_blank\" rel=\"noopener\">设计</a>、<a href=\"https://github.com/xitu/gold-miner#人工智能\" target=\"_blank\" rel=\"noopener\">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a>、<a href=\"http://weibo.com/juejinfanyi\" target=\"_blank\" rel=\"noopener\">官方微博</a>、<a href=\"https://zhuanlan.zhihu.com/juejinfanyi\" target=\"_blank\" rel=\"noopener\">知乎专栏</a>。</p>\n</blockquote>\n"},{"title":"(译)使用令牌桶和熔断器进行重试","date":"2022-10-01T15:53:50.000Z","description":"使用令牌桶和熔断器进行重试","_content":"\n\n> * 我翻译的这篇文章参与了掘金翻译计划，选自英语优秀技术文章。\n> * 原文地址：[Fixing retries with token buckets and circuit breakers](https://brooker.co.za/blog/2022/02/28/retries.html)\n> * 原文作者：[Marc Brooker](https://brooker.co.za/blog/publications.html)\n> * 译文出自：[掘金翻译计划](https://github.com/xitu/gold-miner)\n> * 本文永久链接：[https://github.com/xitu/gold-miner/blob/master/article/2022/retries.md](https://github.com/xitu/gold-miner/blob/master/article/2022/retries.md)\n> * 译者：[wangxuanni](https://github.com/wangxuanni)\n> * 校对者：[Quincy-Ye](https://github.com/Quincy-Ye) [timerring](https://github.com/timerring)\n\n# 使用令牌桶和熔断器进行重试\n\n在我发表上一篇关于[熔断](https://brooker.co.za/blog/2022/02/16/circuit-breakers.html)的文章之后，有人推荐我在中断重试只使用熔断，并且不管失败率仍然发送一次正常的尝试请求。这是一个不错的方法。在客户端熔断（可能会造成资源的浪费）和重试（重试会给已经过载的下游应用增加负担）的关键问题上，这提供了一些可能解决的方案。为了看看效果如何，我们可以将它和我最喜欢的**更好重试**方法：令牌桶做比较。\n\n首先，正式介绍一下待比较的对象：\n\n* **不重试** 。当客户端想发起一个请求的时候，它照常发起一个请求。如果请求失败，客户端不重试并且继续执行。\n* **N 次重试。**当客户端想发起一个请求的时候，它照常发起一个请求。如果请求失败，客户端最多重试 N 次。\n* **自适应重试** （又称**令牌桶重试**）。当客户端想发起一个请求的时候，它照常发起一个请求。如果请求成功，它将一部分令牌放进有大小有限的[令牌桶](https://en.wikipedia.org/wiki/Token_bucket)。如果请求失败，只有当桶里有完整的令牌时就重试 N 次（ N 为完整令牌的数量）。例如，每次成功请求会存储 0.1 个令牌，每次重试会消耗 1 个令牌。\n* **熔断重试**。 客户端想发起一个请求的时候，它照常发起一个请求。在成功或者失败时，它会更新（最近）用于记录失败率的数据。如果失败率低于阈值，则最多重试 N 次。如果它高于阈值，不进行重试。\n\n**思考**\n\n首先，来试着思考一下每种的表现。\n\n不重试是最简单的，如果下游的失败率是 x%，失败率实际就是 x%。\n\nN 次重试次之，如果下游的失败率是 x%，失败率实际是(1-x)N，但是会产生许多额外的工作。当失败率达到100%时，系统的工作量将是原来的 1+N 倍。\n\n分析自适应策略有点困难，但一个大致的想法是：当失败率较低的时候，它会表现的像N次重试；当失败率较高的时候，它表现地类似于“按一定百分比的重试”。例如，如果每个成功的调用都将 10% 的令牌放入桶中，则低于 10% 的失败率的时候自适应行为像N次重试，远高于 10% 的失败率时它就像“ 0.1 次重试”。\n\n熔断策略有些地方是相似的。低失败率（低于阈值）时，它表现的像 **N 次重试**。高于阈值时，它表现的像**不重试**。这有点复杂，因为每个客户端都不知道真实的故障率，而是根据对失败率的本地采样（可能与小型客户端的真实失败率有很大差异）做出决定。\n\n由于整个过程是动态的，因此封闭式推理很困难。我们可以通过对服务和客户端的小型事件驱动模拟来观察效果，而不是尝试推理它。我之后会写更多关于模拟的方法，但先从一些结果开始吧。\n\n**性能模拟分析**\n\n让我们考虑一个具有单个抽象服务的模型，它处理的请求会以一定的比率随机失败。这个服务被 100 个依赖的客户端调用，每一个客户端都以某种速率开始新的尝试。我们关心两种结果：客户端看到的成功率，还有服务器从客户端看见的负载。特别是，我们关注它们如何随失败率变化。\n\n![四种重试策略的失败率和负载率图](https://mbrooker-blog-images.s3.amazonaws.com/retry_simulation_results.png)\n\n我们可以立刻看到一些符合预期的事，和一些有意思的事。正如预期，**不重试**不会做额外的工作，并提供随失败率线性下降的可用性。**三次重试**做了很多额外的工作，提供了最佳的鲁棒性以对抗失败。熔断策略做了额外的工作，在低失败率时提供了额外的鲁棒性，但是超过阈值后下降到和**不重试**一样。\n\n让我们放大一点到较低的失败率：\n\n![四种重试策略的失败率和负载率图](https://mbrooker-blog-images.s3.amazonaws.com/retry_simulation_results_zoomed.png)\n\n我们可以看到策略出现的分叉。第一个有趣的观察结果是，熔断策略比较早开始分叉，大约是预期比率的一半。这是因为每个客户端都是独立熔断的。在低失败率的情况下，**自适应**策略非常像**三次重试**，但是慢慢开始出现分叉。\n\n**客户端数量的影响**\n\n**自适应**和熔断器方法都依赖于每一个客户端估算的失败率。要么用熔断器失败阈值显式表示，要么用令牌桶的内容隐式表示。当客户端的数量不多的时候，针对每个客户端，可以合理地预估真实的失败率。随着大量客户端发送少量流量，估计值的差异会更大。这在云服务和基于容器的架构中尤其重要，在这种架构中，客户端可能很多但存活时间较短，每个客户端所做的工作相对较少（与多线程实例相比，单个客户端可能会看到大量线程的工作）。\n\n我们可以模拟出在自适应和熔断器策略下客户端数量的影响。在这里，我们会在 10，100 和 1000 台客户端之间分配相同总数的请求。\n\n![不同客户端数量下失败率和负载的图片](https://mbrooker-blog-images.s3.amazonaws.com/retry_simulation_results_clients.png)\n\n有趣的是这两种方式有着截然相反的表现。**熔断器**策略会早早分叉，并接近**不重试**方法的表现。**令牌桶**策略（从有一个完整的桶开始）没有足够快地耗尽它的桶，接近 **n 次重试**的曲线。显然，在每个客户端所知有限的情况下解决重试问题是不完美的。在客户端之间共享状态的模型会改变这些结果。也会明显的增长系统的复杂度（因为客户端需要彼此发现并交流）。\n\n**哪一个更好？**\n\n选择正确的重试策略取决于我们想要实现的目标。理想的解决方案是无论服务失败率是多少，都不增加额外的负担并且达到成功率 100 %。但这显然是无法实现的，原因很简单：客户端无法知道哪些请求会成功，它们唯一的机制就是不断重试。\n\n除了这样的理想方案，我们能做到什么？大多数应用程序想要的是在服务器失败率较低的情况下具有较高的成功率，而不是过多的额外负载。不重试达不到第一条标准，n 次重试达不到第二条标准。自适应和熔断策略在不同程度上达标。熔断器可以做到在高失败率时不增加额外的负担，但它受到某种形式的影响（它要么重试，要么不重试，并且可能在两者之间来回切换）。自适应策略不是同一种模式，它在低失败率下表现的更好，但是在失败率高的时候会增加额外的（可调节的）负担。\n\n**脚注**\n\n1. 换句话说，每个客户端呈现独立的泊松过程，并且保持它自己的重试状态，这里泊松模型不是非常准确，但也没有关系，因为我们（还）没有对于高负载或者并发情况进行建模。\n\n> 如果发现译文存在错误或其他需要改进的地方，欢迎到 [掘金翻译计划](https://github.com/xitu/gold-miner) 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 **本文永久链接** 即为本文在 GitHub 上的 MarkDown 链接。\n\n---\n\n> [掘金翻译计划](https://github.com/xitu/gold-miner) 是一个翻译优质互联网技术文章的社区，文章来源为 [掘金](https://juejin.im) 上的英文分享文章。内容覆盖 [Android](https://github.com/xitu/gold-miner#android)、[iOS](https://github.com/xitu/gold-miner#ios)、[前端](https://github.com/xitu/gold-miner#前端)、[后端](https://github.com/xitu/gold-miner#后端)、[区块链](https://github.com/xitu/gold-miner#区块链)、[产品](https://github.com/xitu/gold-miner#产品)、[设计](https://github.com/xitu/gold-miner#设计)、[人工智能](https://github.com/xitu/gold-miner#人工智能)等领域，想要查看更多优质译文请持续关注 [掘金翻译计划](https://github.com/xitu/gold-miner)、[官方微博](http://weibo.com/juejinfanyi)、[知乎专栏](https://zhuanlan.zhihu.com/juejinfanyi)。\n","source":"_posts/retries.md","raw":"---\ntitle: (译)使用令牌桶和熔断器进行重试\ndate: 2022-10-01 23:53:50\ncategories: 翻译\ndescription: 使用令牌桶和熔断器进行重试\n\n---\n\n\n> * 我翻译的这篇文章参与了掘金翻译计划，选自英语优秀技术文章。\n> * 原文地址：[Fixing retries with token buckets and circuit breakers](https://brooker.co.za/blog/2022/02/28/retries.html)\n> * 原文作者：[Marc Brooker](https://brooker.co.za/blog/publications.html)\n> * 译文出自：[掘金翻译计划](https://github.com/xitu/gold-miner)\n> * 本文永久链接：[https://github.com/xitu/gold-miner/blob/master/article/2022/retries.md](https://github.com/xitu/gold-miner/blob/master/article/2022/retries.md)\n> * 译者：[wangxuanni](https://github.com/wangxuanni)\n> * 校对者：[Quincy-Ye](https://github.com/Quincy-Ye) [timerring](https://github.com/timerring)\n\n# 使用令牌桶和熔断器进行重试\n\n在我发表上一篇关于[熔断](https://brooker.co.za/blog/2022/02/16/circuit-breakers.html)的文章之后，有人推荐我在中断重试只使用熔断，并且不管失败率仍然发送一次正常的尝试请求。这是一个不错的方法。在客户端熔断（可能会造成资源的浪费）和重试（重试会给已经过载的下游应用增加负担）的关键问题上，这提供了一些可能解决的方案。为了看看效果如何，我们可以将它和我最喜欢的**更好重试**方法：令牌桶做比较。\n\n首先，正式介绍一下待比较的对象：\n\n* **不重试** 。当客户端想发起一个请求的时候，它照常发起一个请求。如果请求失败，客户端不重试并且继续执行。\n* **N 次重试。**当客户端想发起一个请求的时候，它照常发起一个请求。如果请求失败，客户端最多重试 N 次。\n* **自适应重试** （又称**令牌桶重试**）。当客户端想发起一个请求的时候，它照常发起一个请求。如果请求成功，它将一部分令牌放进有大小有限的[令牌桶](https://en.wikipedia.org/wiki/Token_bucket)。如果请求失败，只有当桶里有完整的令牌时就重试 N 次（ N 为完整令牌的数量）。例如，每次成功请求会存储 0.1 个令牌，每次重试会消耗 1 个令牌。\n* **熔断重试**。 客户端想发起一个请求的时候，它照常发起一个请求。在成功或者失败时，它会更新（最近）用于记录失败率的数据。如果失败率低于阈值，则最多重试 N 次。如果它高于阈值，不进行重试。\n\n**思考**\n\n首先，来试着思考一下每种的表现。\n\n不重试是最简单的，如果下游的失败率是 x%，失败率实际就是 x%。\n\nN 次重试次之，如果下游的失败率是 x%，失败率实际是(1-x)N，但是会产生许多额外的工作。当失败率达到100%时，系统的工作量将是原来的 1+N 倍。\n\n分析自适应策略有点困难，但一个大致的想法是：当失败率较低的时候，它会表现的像N次重试；当失败率较高的时候，它表现地类似于“按一定百分比的重试”。例如，如果每个成功的调用都将 10% 的令牌放入桶中，则低于 10% 的失败率的时候自适应行为像N次重试，远高于 10% 的失败率时它就像“ 0.1 次重试”。\n\n熔断策略有些地方是相似的。低失败率（低于阈值）时，它表现的像 **N 次重试**。高于阈值时，它表现的像**不重试**。这有点复杂，因为每个客户端都不知道真实的故障率，而是根据对失败率的本地采样（可能与小型客户端的真实失败率有很大差异）做出决定。\n\n由于整个过程是动态的，因此封闭式推理很困难。我们可以通过对服务和客户端的小型事件驱动模拟来观察效果，而不是尝试推理它。我之后会写更多关于模拟的方法，但先从一些结果开始吧。\n\n**性能模拟分析**\n\n让我们考虑一个具有单个抽象服务的模型，它处理的请求会以一定的比率随机失败。这个服务被 100 个依赖的客户端调用，每一个客户端都以某种速率开始新的尝试。我们关心两种结果：客户端看到的成功率，还有服务器从客户端看见的负载。特别是，我们关注它们如何随失败率变化。\n\n![四种重试策略的失败率和负载率图](https://mbrooker-blog-images.s3.amazonaws.com/retry_simulation_results.png)\n\n我们可以立刻看到一些符合预期的事，和一些有意思的事。正如预期，**不重试**不会做额外的工作，并提供随失败率线性下降的可用性。**三次重试**做了很多额外的工作，提供了最佳的鲁棒性以对抗失败。熔断策略做了额外的工作，在低失败率时提供了额外的鲁棒性，但是超过阈值后下降到和**不重试**一样。\n\n让我们放大一点到较低的失败率：\n\n![四种重试策略的失败率和负载率图](https://mbrooker-blog-images.s3.amazonaws.com/retry_simulation_results_zoomed.png)\n\n我们可以看到策略出现的分叉。第一个有趣的观察结果是，熔断策略比较早开始分叉，大约是预期比率的一半。这是因为每个客户端都是独立熔断的。在低失败率的情况下，**自适应**策略非常像**三次重试**，但是慢慢开始出现分叉。\n\n**客户端数量的影响**\n\n**自适应**和熔断器方法都依赖于每一个客户端估算的失败率。要么用熔断器失败阈值显式表示，要么用令牌桶的内容隐式表示。当客户端的数量不多的时候，针对每个客户端，可以合理地预估真实的失败率。随着大量客户端发送少量流量，估计值的差异会更大。这在云服务和基于容器的架构中尤其重要，在这种架构中，客户端可能很多但存活时间较短，每个客户端所做的工作相对较少（与多线程实例相比，单个客户端可能会看到大量线程的工作）。\n\n我们可以模拟出在自适应和熔断器策略下客户端数量的影响。在这里，我们会在 10，100 和 1000 台客户端之间分配相同总数的请求。\n\n![不同客户端数量下失败率和负载的图片](https://mbrooker-blog-images.s3.amazonaws.com/retry_simulation_results_clients.png)\n\n有趣的是这两种方式有着截然相反的表现。**熔断器**策略会早早分叉，并接近**不重试**方法的表现。**令牌桶**策略（从有一个完整的桶开始）没有足够快地耗尽它的桶，接近 **n 次重试**的曲线。显然，在每个客户端所知有限的情况下解决重试问题是不完美的。在客户端之间共享状态的模型会改变这些结果。也会明显的增长系统的复杂度（因为客户端需要彼此发现并交流）。\n\n**哪一个更好？**\n\n选择正确的重试策略取决于我们想要实现的目标。理想的解决方案是无论服务失败率是多少，都不增加额外的负担并且达到成功率 100 %。但这显然是无法实现的，原因很简单：客户端无法知道哪些请求会成功，它们唯一的机制就是不断重试。\n\n除了这样的理想方案，我们能做到什么？大多数应用程序想要的是在服务器失败率较低的情况下具有较高的成功率，而不是过多的额外负载。不重试达不到第一条标准，n 次重试达不到第二条标准。自适应和熔断策略在不同程度上达标。熔断器可以做到在高失败率时不增加额外的负担，但它受到某种形式的影响（它要么重试，要么不重试，并且可能在两者之间来回切换）。自适应策略不是同一种模式，它在低失败率下表现的更好，但是在失败率高的时候会增加额外的（可调节的）负担。\n\n**脚注**\n\n1. 换句话说，每个客户端呈现独立的泊松过程，并且保持它自己的重试状态，这里泊松模型不是非常准确，但也没有关系，因为我们（还）没有对于高负载或者并发情况进行建模。\n\n> 如果发现译文存在错误或其他需要改进的地方，欢迎到 [掘金翻译计划](https://github.com/xitu/gold-miner) 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 **本文永久链接** 即为本文在 GitHub 上的 MarkDown 链接。\n\n---\n\n> [掘金翻译计划](https://github.com/xitu/gold-miner) 是一个翻译优质互联网技术文章的社区，文章来源为 [掘金](https://juejin.im) 上的英文分享文章。内容覆盖 [Android](https://github.com/xitu/gold-miner#android)、[iOS](https://github.com/xitu/gold-miner#ios)、[前端](https://github.com/xitu/gold-miner#前端)、[后端](https://github.com/xitu/gold-miner#后端)、[区块链](https://github.com/xitu/gold-miner#区块链)、[产品](https://github.com/xitu/gold-miner#产品)、[设计](https://github.com/xitu/gold-miner#设计)、[人工智能](https://github.com/xitu/gold-miner#人工智能)等领域，想要查看更多优质译文请持续关注 [掘金翻译计划](https://github.com/xitu/gold-miner)、[官方微博](http://weibo.com/juejinfanyi)、[知乎专栏](https://zhuanlan.zhihu.com/juejinfanyi)。\n","slug":"retries","published":1,"updated":"2022-12-08T10:26:24.585Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qki0013w9rpvbbj0o9z","content":"<blockquote>\n<ul>\n<li>我翻译的这篇文章参与了掘金翻译计划，选自英语优秀技术文章。</li>\n<li>原文地址：<a href=\"https://brooker.co.za/blog/2022/02/28/retries.html\" target=\"_blank\" rel=\"noopener\">Fixing retries with token buckets and circuit breakers</a></li>\n<li>原文作者：<a href=\"https://brooker.co.za/blog/publications.html\" target=\"_blank\" rel=\"noopener\">Marc Brooker</a></li>\n<li>译文出自：<a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a></li>\n<li>本文永久链接：<a href=\"https://github.com/xitu/gold-miner/blob/master/article/2022/retries.md\" target=\"_blank\" rel=\"noopener\">https://github.com/xitu/gold-miner/blob/master/article/2022/retries.md</a></li>\n<li>译者：<a href=\"https://github.com/wangxuanni\" target=\"_blank\" rel=\"noopener\">wangxuanni</a></li>\n<li>校对者：<a href=\"https://github.com/Quincy-Ye\" target=\"_blank\" rel=\"noopener\">Quincy-Ye</a> <a href=\"https://github.com/timerring\" target=\"_blank\" rel=\"noopener\">timerring</a></li>\n</ul>\n</blockquote>\n<h1 id=\"使用令牌桶和熔断器进行重试\"><a href=\"#使用令牌桶和熔断器进行重试\" class=\"headerlink\" title=\"使用令牌桶和熔断器进行重试\"></a>使用令牌桶和熔断器进行重试</h1><p>在我发表上一篇关于<a href=\"https://brooker.co.za/blog/2022/02/16/circuit-breakers.html\" target=\"_blank\" rel=\"noopener\">熔断</a>的文章之后，有人推荐我在中断重试只使用熔断，并且不管失败率仍然发送一次正常的尝试请求。这是一个不错的方法。在客户端熔断（可能会造成资源的浪费）和重试（重试会给已经过载的下游应用增加负担）的关键问题上，这提供了一些可能解决的方案。为了看看效果如何，我们可以将它和我最喜欢的<strong>更好重试</strong>方法：令牌桶做比较。</p>\n<p>首先，正式介绍一下待比较的对象：</p>\n<ul>\n<li><strong>不重试</strong> 。当客户端想发起一个请求的时候，它照常发起一个请求。如果请求失败，客户端不重试并且继续执行。</li>\n<li><strong>N 次重试。</strong>当客户端想发起一个请求的时候，它照常发起一个请求。如果请求失败，客户端最多重试 N 次。</li>\n<li><strong>自适应重试</strong> （又称<strong>令牌桶重试</strong>）。当客户端想发起一个请求的时候，它照常发起一个请求。如果请求成功，它将一部分令牌放进有大小有限的<a href=\"https://en.wikipedia.org/wiki/Token_bucket\" target=\"_blank\" rel=\"noopener\">令牌桶</a>。如果请求失败，只有当桶里有完整的令牌时就重试 N 次（ N 为完整令牌的数量）。例如，每次成功请求会存储 0.1 个令牌，每次重试会消耗 1 个令牌。</li>\n<li><strong>熔断重试</strong>。 客户端想发起一个请求的时候，它照常发起一个请求。在成功或者失败时，它会更新（最近）用于记录失败率的数据。如果失败率低于阈值，则最多重试 N 次。如果它高于阈值，不进行重试。</li>\n</ul>\n<p><strong>思考</strong></p>\n<p>首先，来试着思考一下每种的表现。</p>\n<p>不重试是最简单的，如果下游的失败率是 x%，失败率实际就是 x%。</p>\n<p>N 次重试次之，如果下游的失败率是 x%，失败率实际是(1-x)N，但是会产生许多额外的工作。当失败率达到100%时，系统的工作量将是原来的 1+N 倍。</p>\n<p>分析自适应策略有点困难，但一个大致的想法是：当失败率较低的时候，它会表现的像N次重试；当失败率较高的时候，它表现地类似于“按一定百分比的重试”。例如，如果每个成功的调用都将 10% 的令牌放入桶中，则低于 10% 的失败率的时候自适应行为像N次重试，远高于 10% 的失败率时它就像“ 0.1 次重试”。</p>\n<p>熔断策略有些地方是相似的。低失败率（低于阈值）时，它表现的像 <strong>N 次重试</strong>。高于阈值时，它表现的像<strong>不重试</strong>。这有点复杂，因为每个客户端都不知道真实的故障率，而是根据对失败率的本地采样（可能与小型客户端的真实失败率有很大差异）做出决定。</p>\n<p>由于整个过程是动态的，因此封闭式推理很困难。我们可以通过对服务和客户端的小型事件驱动模拟来观察效果，而不是尝试推理它。我之后会写更多关于模拟的方法，但先从一些结果开始吧。</p>\n<p><strong>性能模拟分析</strong></p>\n<p>让我们考虑一个具有单个抽象服务的模型，它处理的请求会以一定的比率随机失败。这个服务被 100 个依赖的客户端调用，每一个客户端都以某种速率开始新的尝试。我们关心两种结果：客户端看到的成功率，还有服务器从客户端看见的负载。特别是，我们关注它们如何随失败率变化。</p>\n<p><img src=\"https://mbrooker-blog-images.s3.amazonaws.com/retry_simulation_results.png\" alt=\"四种重试策略的失败率和负载率图\"></p>\n<p>我们可以立刻看到一些符合预期的事，和一些有意思的事。正如预期，<strong>不重试</strong>不会做额外的工作，并提供随失败率线性下降的可用性。<strong>三次重试</strong>做了很多额外的工作，提供了最佳的鲁棒性以对抗失败。熔断策略做了额外的工作，在低失败率时提供了额外的鲁棒性，但是超过阈值后下降到和<strong>不重试</strong>一样。</p>\n<p>让我们放大一点到较低的失败率：</p>\n<p><img src=\"https://mbrooker-blog-images.s3.amazonaws.com/retry_simulation_results_zoomed.png\" alt=\"四种重试策略的失败率和负载率图\"></p>\n<p>我们可以看到策略出现的分叉。第一个有趣的观察结果是，熔断策略比较早开始分叉，大约是预期比率的一半。这是因为每个客户端都是独立熔断的。在低失败率的情况下，<strong>自适应</strong>策略非常像<strong>三次重试</strong>，但是慢慢开始出现分叉。</p>\n<p><strong>客户端数量的影响</strong></p>\n<p><strong>自适应</strong>和熔断器方法都依赖于每一个客户端估算的失败率。要么用熔断器失败阈值显式表示，要么用令牌桶的内容隐式表示。当客户端的数量不多的时候，针对每个客户端，可以合理地预估真实的失败率。随着大量客户端发送少量流量，估计值的差异会更大。这在云服务和基于容器的架构中尤其重要，在这种架构中，客户端可能很多但存活时间较短，每个客户端所做的工作相对较少（与多线程实例相比，单个客户端可能会看到大量线程的工作）。</p>\n<p>我们可以模拟出在自适应和熔断器策略下客户端数量的影响。在这里，我们会在 10，100 和 1000 台客户端之间分配相同总数的请求。</p>\n<p><img src=\"https://mbrooker-blog-images.s3.amazonaws.com/retry_simulation_results_clients.png\" alt=\"不同客户端数量下失败率和负载的图片\"></p>\n<p>有趣的是这两种方式有着截然相反的表现。<strong>熔断器</strong>策略会早早分叉，并接近<strong>不重试</strong>方法的表现。<strong>令牌桶</strong>策略（从有一个完整的桶开始）没有足够快地耗尽它的桶，接近 <strong>n 次重试</strong>的曲线。显然，在每个客户端所知有限的情况下解决重试问题是不完美的。在客户端之间共享状态的模型会改变这些结果。也会明显的增长系统的复杂度（因为客户端需要彼此发现并交流）。</p>\n<p><strong>哪一个更好？</strong></p>\n<p>选择正确的重试策略取决于我们想要实现的目标。理想的解决方案是无论服务失败率是多少，都不增加额外的负担并且达到成功率 100 %。但这显然是无法实现的，原因很简单：客户端无法知道哪些请求会成功，它们唯一的机制就是不断重试。</p>\n<p>除了这样的理想方案，我们能做到什么？大多数应用程序想要的是在服务器失败率较低的情况下具有较高的成功率，而不是过多的额外负载。不重试达不到第一条标准，n 次重试达不到第二条标准。自适应和熔断策略在不同程度上达标。熔断器可以做到在高失败率时不增加额外的负担，但它受到某种形式的影响（它要么重试，要么不重试，并且可能在两者之间来回切换）。自适应策略不是同一种模式，它在低失败率下表现的更好，但是在失败率高的时候会增加额外的（可调节的）负担。</p>\n<p><strong>脚注</strong></p>\n<ol>\n<li>换句话说，每个客户端呈现独立的泊松过程，并且保持它自己的重试状态，这里泊松模型不是非常准确，但也没有关系，因为我们（还）没有对于高负载或者并发情况进行建模。</li>\n</ol>\n<blockquote>\n<p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href=\"https://juejin.im\" target=\"_blank\" rel=\"noopener\">掘金</a> 上的英文分享文章。内容覆盖 <a href=\"https://github.com/xitu/gold-miner#android\" target=\"_blank\" rel=\"noopener\">Android</a>、<a href=\"https://github.com/xitu/gold-miner#ios\" target=\"_blank\" rel=\"noopener\">iOS</a>、<a href=\"https://github.com/xitu/gold-miner#前端\" target=\"_blank\" rel=\"noopener\">前端</a>、<a href=\"https://github.com/xitu/gold-miner#后端\" target=\"_blank\" rel=\"noopener\">后端</a>、<a href=\"https://github.com/xitu/gold-miner#区块链\" target=\"_blank\" rel=\"noopener\">区块链</a>、<a href=\"https://github.com/xitu/gold-miner#产品\" target=\"_blank\" rel=\"noopener\">产品</a>、<a href=\"https://github.com/xitu/gold-miner#设计\" target=\"_blank\" rel=\"noopener\">设计</a>、<a href=\"https://github.com/xitu/gold-miner#人工智能\" target=\"_blank\" rel=\"noopener\">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a>、<a href=\"http://weibo.com/juejinfanyi\" target=\"_blank\" rel=\"noopener\">官方微博</a>、<a href=\"https://zhuanlan.zhihu.com/juejinfanyi\" target=\"_blank\" rel=\"noopener\">知乎专栏</a>。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ul>\n<li>我翻译的这篇文章参与了掘金翻译计划，选自英语优秀技术文章。</li>\n<li>原文地址：<a href=\"https://brooker.co.za/blog/2022/02/28/retries.html\" target=\"_blank\" rel=\"noopener\">Fixing retries with token buckets and circuit breakers</a></li>\n<li>原文作者：<a href=\"https://brooker.co.za/blog/publications.html\" target=\"_blank\" rel=\"noopener\">Marc Brooker</a></li>\n<li>译文出自：<a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a></li>\n<li>本文永久链接：<a href=\"https://github.com/xitu/gold-miner/blob/master/article/2022/retries.md\" target=\"_blank\" rel=\"noopener\">https://github.com/xitu/gold-miner/blob/master/article/2022/retries.md</a></li>\n<li>译者：<a href=\"https://github.com/wangxuanni\" target=\"_blank\" rel=\"noopener\">wangxuanni</a></li>\n<li>校对者：<a href=\"https://github.com/Quincy-Ye\" target=\"_blank\" rel=\"noopener\">Quincy-Ye</a> <a href=\"https://github.com/timerring\" target=\"_blank\" rel=\"noopener\">timerring</a></li>\n</ul>\n</blockquote>\n<h1 id=\"使用令牌桶和熔断器进行重试\"><a href=\"#使用令牌桶和熔断器进行重试\" class=\"headerlink\" title=\"使用令牌桶和熔断器进行重试\"></a>使用令牌桶和熔断器进行重试</h1><p>在我发表上一篇关于<a href=\"https://brooker.co.za/blog/2022/02/16/circuit-breakers.html\" target=\"_blank\" rel=\"noopener\">熔断</a>的文章之后，有人推荐我在中断重试只使用熔断，并且不管失败率仍然发送一次正常的尝试请求。这是一个不错的方法。在客户端熔断（可能会造成资源的浪费）和重试（重试会给已经过载的下游应用增加负担）的关键问题上，这提供了一些可能解决的方案。为了看看效果如何，我们可以将它和我最喜欢的<strong>更好重试</strong>方法：令牌桶做比较。</p>\n<p>首先，正式介绍一下待比较的对象：</p>\n<ul>\n<li><strong>不重试</strong> 。当客户端想发起一个请求的时候，它照常发起一个请求。如果请求失败，客户端不重试并且继续执行。</li>\n<li><strong>N 次重试。</strong>当客户端想发起一个请求的时候，它照常发起一个请求。如果请求失败，客户端最多重试 N 次。</li>\n<li><strong>自适应重试</strong> （又称<strong>令牌桶重试</strong>）。当客户端想发起一个请求的时候，它照常发起一个请求。如果请求成功，它将一部分令牌放进有大小有限的<a href=\"https://en.wikipedia.org/wiki/Token_bucket\" target=\"_blank\" rel=\"noopener\">令牌桶</a>。如果请求失败，只有当桶里有完整的令牌时就重试 N 次（ N 为完整令牌的数量）。例如，每次成功请求会存储 0.1 个令牌，每次重试会消耗 1 个令牌。</li>\n<li><strong>熔断重试</strong>。 客户端想发起一个请求的时候，它照常发起一个请求。在成功或者失败时，它会更新（最近）用于记录失败率的数据。如果失败率低于阈值，则最多重试 N 次。如果它高于阈值，不进行重试。</li>\n</ul>\n<p><strong>思考</strong></p>\n<p>首先，来试着思考一下每种的表现。</p>\n<p>不重试是最简单的，如果下游的失败率是 x%，失败率实际就是 x%。</p>\n<p>N 次重试次之，如果下游的失败率是 x%，失败率实际是(1-x)N，但是会产生许多额外的工作。当失败率达到100%时，系统的工作量将是原来的 1+N 倍。</p>\n<p>分析自适应策略有点困难，但一个大致的想法是：当失败率较低的时候，它会表现的像N次重试；当失败率较高的时候，它表现地类似于“按一定百分比的重试”。例如，如果每个成功的调用都将 10% 的令牌放入桶中，则低于 10% 的失败率的时候自适应行为像N次重试，远高于 10% 的失败率时它就像“ 0.1 次重试”。</p>\n<p>熔断策略有些地方是相似的。低失败率（低于阈值）时，它表现的像 <strong>N 次重试</strong>。高于阈值时，它表现的像<strong>不重试</strong>。这有点复杂，因为每个客户端都不知道真实的故障率，而是根据对失败率的本地采样（可能与小型客户端的真实失败率有很大差异）做出决定。</p>\n<p>由于整个过程是动态的，因此封闭式推理很困难。我们可以通过对服务和客户端的小型事件驱动模拟来观察效果，而不是尝试推理它。我之后会写更多关于模拟的方法，但先从一些结果开始吧。</p>\n<p><strong>性能模拟分析</strong></p>\n<p>让我们考虑一个具有单个抽象服务的模型，它处理的请求会以一定的比率随机失败。这个服务被 100 个依赖的客户端调用，每一个客户端都以某种速率开始新的尝试。我们关心两种结果：客户端看到的成功率，还有服务器从客户端看见的负载。特别是，我们关注它们如何随失败率变化。</p>\n<p><img src=\"https://mbrooker-blog-images.s3.amazonaws.com/retry_simulation_results.png\" alt=\"四种重试策略的失败率和负载率图\"></p>\n<p>我们可以立刻看到一些符合预期的事，和一些有意思的事。正如预期，<strong>不重试</strong>不会做额外的工作，并提供随失败率线性下降的可用性。<strong>三次重试</strong>做了很多额外的工作，提供了最佳的鲁棒性以对抗失败。熔断策略做了额外的工作，在低失败率时提供了额外的鲁棒性，但是超过阈值后下降到和<strong>不重试</strong>一样。</p>\n<p>让我们放大一点到较低的失败率：</p>\n<p><img src=\"https://mbrooker-blog-images.s3.amazonaws.com/retry_simulation_results_zoomed.png\" alt=\"四种重试策略的失败率和负载率图\"></p>\n<p>我们可以看到策略出现的分叉。第一个有趣的观察结果是，熔断策略比较早开始分叉，大约是预期比率的一半。这是因为每个客户端都是独立熔断的。在低失败率的情况下，<strong>自适应</strong>策略非常像<strong>三次重试</strong>，但是慢慢开始出现分叉。</p>\n<p><strong>客户端数量的影响</strong></p>\n<p><strong>自适应</strong>和熔断器方法都依赖于每一个客户端估算的失败率。要么用熔断器失败阈值显式表示，要么用令牌桶的内容隐式表示。当客户端的数量不多的时候，针对每个客户端，可以合理地预估真实的失败率。随着大量客户端发送少量流量，估计值的差异会更大。这在云服务和基于容器的架构中尤其重要，在这种架构中，客户端可能很多但存活时间较短，每个客户端所做的工作相对较少（与多线程实例相比，单个客户端可能会看到大量线程的工作）。</p>\n<p>我们可以模拟出在自适应和熔断器策略下客户端数量的影响。在这里，我们会在 10，100 和 1000 台客户端之间分配相同总数的请求。</p>\n<p><img src=\"https://mbrooker-blog-images.s3.amazonaws.com/retry_simulation_results_clients.png\" alt=\"不同客户端数量下失败率和负载的图片\"></p>\n<p>有趣的是这两种方式有着截然相反的表现。<strong>熔断器</strong>策略会早早分叉，并接近<strong>不重试</strong>方法的表现。<strong>令牌桶</strong>策略（从有一个完整的桶开始）没有足够快地耗尽它的桶，接近 <strong>n 次重试</strong>的曲线。显然，在每个客户端所知有限的情况下解决重试问题是不完美的。在客户端之间共享状态的模型会改变这些结果。也会明显的增长系统的复杂度（因为客户端需要彼此发现并交流）。</p>\n<p><strong>哪一个更好？</strong></p>\n<p>选择正确的重试策略取决于我们想要实现的目标。理想的解决方案是无论服务失败率是多少，都不增加额外的负担并且达到成功率 100 %。但这显然是无法实现的，原因很简单：客户端无法知道哪些请求会成功，它们唯一的机制就是不断重试。</p>\n<p>除了这样的理想方案，我们能做到什么？大多数应用程序想要的是在服务器失败率较低的情况下具有较高的成功率，而不是过多的额外负载。不重试达不到第一条标准，n 次重试达不到第二条标准。自适应和熔断策略在不同程度上达标。熔断器可以做到在高失败率时不增加额外的负担，但它受到某种形式的影响（它要么重试，要么不重试，并且可能在两者之间来回切换）。自适应策略不是同一种模式，它在低失败率下表现的更好，但是在失败率高的时候会增加额外的（可调节的）负担。</p>\n<p><strong>脚注</strong></p>\n<ol>\n<li>换句话说，每个客户端呈现独立的泊松过程，并且保持它自己的重试状态，这里泊松模型不是非常准确，但也没有关系，因为我们（还）没有对于高负载或者并发情况进行建模。</li>\n</ol>\n<blockquote>\n<p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href=\"https://juejin.im\" target=\"_blank\" rel=\"noopener\">掘金</a> 上的英文分享文章。内容覆盖 <a href=\"https://github.com/xitu/gold-miner#android\" target=\"_blank\" rel=\"noopener\">Android</a>、<a href=\"https://github.com/xitu/gold-miner#ios\" target=\"_blank\" rel=\"noopener\">iOS</a>、<a href=\"https://github.com/xitu/gold-miner#前端\" target=\"_blank\" rel=\"noopener\">前端</a>、<a href=\"https://github.com/xitu/gold-miner#后端\" target=\"_blank\" rel=\"noopener\">后端</a>、<a href=\"https://github.com/xitu/gold-miner#区块链\" target=\"_blank\" rel=\"noopener\">区块链</a>、<a href=\"https://github.com/xitu/gold-miner#产品\" target=\"_blank\" rel=\"noopener\">产品</a>、<a href=\"https://github.com/xitu/gold-miner#设计\" target=\"_blank\" rel=\"noopener\">设计</a>、<a href=\"https://github.com/xitu/gold-miner#人工智能\" target=\"_blank\" rel=\"noopener\">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a>、<a href=\"http://weibo.com/juejinfanyi\" target=\"_blank\" rel=\"noopener\">官方微博</a>、<a href=\"https://zhuanlan.zhihu.com/juejinfanyi\" target=\"_blank\" rel=\"noopener\">知乎专栏</a>。</p>\n</blockquote>\n"},{"title":"代理模式","date":"2019-01-20T06:00:50.000Z","description":"静态代理和动态代理","_content":"\n# 静态代理\n>一个场景设定，假设你要结婚了，但你不会为了结婚就要学婚礼布置，拍婚纱照等技术活，这些可以交给婚庆公司做嘛。于是你找了婚庆公司作为你的代理为了做一些准备工作。但最后去结婚的是你而不婚庆公司。这就是代理模式了。\n\n## 静态代理有三个元素：共同接口、代理对象、目标对象。\n\n## 代码\n接口\n```\npublic interface Marry {\n    void marry();\n}\n```\n\n\n\n代理类，把接口当做参数传入构造函数中\n```\npublic class MarryCompany implements Marry {\n    Marry marry;\n\n    public MarryCompany(Marry marry) {\n        this.marry = marry;\n    }\n\n    void proWwork() {\n        System.out.println(\"婚礼前准备\");\n    }\n\n    void afterWwork() {\n        System.out.println(\"婚礼后收拾\");\n    }\n\n    @Override\n    public void marry() {\n        proWwork();\n        marry.marry();\n        afterWwork();\n    }\n}\n```\n\n\n目标对象\n```\npublic class You implements Marry{\n    public void marry(){\n        System.out.println(\"我结婚了\");\n    }\n}\n```\n\n\n\n```\npublic class Test {\n    public static void main(String[] args) {\n        Marry marry=new MarryCompany(new You());\n        marry.marry();\n    }\n}\n```\n\n## 问题\n<u>静态代理不实现接口也能做到，为什么还要实现共同接口？</u>接口的作用是保证了代理对象具有和被代理对象具有一样的契约。\n“代理”是针对相同的接口编程，以达到透明地替换原来的对象。如果添加一个不相干新的类去做这件事，这叫委托模式了。\n\n## 静态代理总结:\n优点：可以做到在不修改目标对象的功能前提下,对目标功能扩展.\n缺点:因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护。此时动态代理闪亮登场！\n\n# 动态代理\n在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建。\n比如这次不是我结婚了，而是我的宠物猫jack和rose要举行婚礼\n\n## 代码\n待完善","source":"_posts/代理模式.md","raw":"---\ntitle: 代理模式\ndate: 2019-01-20 14:00:50\ncategories: 设计模式\ndescription: 静态代理和动态代理\n---\n\n# 静态代理\n>一个场景设定，假设你要结婚了，但你不会为了结婚就要学婚礼布置，拍婚纱照等技术活，这些可以交给婚庆公司做嘛。于是你找了婚庆公司作为你的代理为了做一些准备工作。但最后去结婚的是你而不婚庆公司。这就是代理模式了。\n\n## 静态代理有三个元素：共同接口、代理对象、目标对象。\n\n## 代码\n接口\n```\npublic interface Marry {\n    void marry();\n}\n```\n\n\n\n代理类，把接口当做参数传入构造函数中\n```\npublic class MarryCompany implements Marry {\n    Marry marry;\n\n    public MarryCompany(Marry marry) {\n        this.marry = marry;\n    }\n\n    void proWwork() {\n        System.out.println(\"婚礼前准备\");\n    }\n\n    void afterWwork() {\n        System.out.println(\"婚礼后收拾\");\n    }\n\n    @Override\n    public void marry() {\n        proWwork();\n        marry.marry();\n        afterWwork();\n    }\n}\n```\n\n\n目标对象\n```\npublic class You implements Marry{\n    public void marry(){\n        System.out.println(\"我结婚了\");\n    }\n}\n```\n\n\n\n```\npublic class Test {\n    public static void main(String[] args) {\n        Marry marry=new MarryCompany(new You());\n        marry.marry();\n    }\n}\n```\n\n## 问题\n<u>静态代理不实现接口也能做到，为什么还要实现共同接口？</u>接口的作用是保证了代理对象具有和被代理对象具有一样的契约。\n“代理”是针对相同的接口编程，以达到透明地替换原来的对象。如果添加一个不相干新的类去做这件事，这叫委托模式了。\n\n## 静态代理总结:\n优点：可以做到在不修改目标对象的功能前提下,对目标功能扩展.\n缺点:因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护。此时动态代理闪亮登场！\n\n# 动态代理\n在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建。\n比如这次不是我结婚了，而是我的宠物猫jack和rose要举行婚礼\n\n## 代码\n待完善","slug":"代理模式","published":1,"updated":"2022-02-08T07:09:41.228Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qkj0016w9rpberid1tg","content":"<h1 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h1><blockquote>\n<p>一个场景设定，假设你要结婚了，但你不会为了结婚就要学婚礼布置，拍婚纱照等技术活，这些可以交给婚庆公司做嘛。于是你找了婚庆公司作为你的代理为了做一些准备工作。但最后去结婚的是你而不婚庆公司。这就是代理模式了。</p>\n</blockquote>\n<h2 id=\"静态代理有三个元素：共同接口、代理对象、目标对象。\"><a href=\"#静态代理有三个元素：共同接口、代理对象、目标对象。\" class=\"headerlink\" title=\"静态代理有三个元素：共同接口、代理对象、目标对象。\"></a>静态代理有三个元素：共同接口、代理对象、目标对象。</h2><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>接口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Marry &#123;</span><br><span class=\"line\">    void marry();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代理类，把接口当做参数传入构造函数中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MarryCompany implements Marry &#123;</span><br><span class=\"line\">    Marry marry;</span><br><span class=\"line\"></span><br><span class=\"line\">    public MarryCompany(Marry marry) &#123;</span><br><span class=\"line\">        this.marry = marry;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void proWwork() &#123;</span><br><span class=\"line\">        System.out.println(&quot;婚礼前准备&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void afterWwork() &#123;</span><br><span class=\"line\">        System.out.println(&quot;婚礼后收拾&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void marry() &#123;</span><br><span class=\"line\">        proWwork();</span><br><span class=\"line\">        marry.marry();</span><br><span class=\"line\">        afterWwork();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>目标对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class You implements Marry&#123;</span><br><span class=\"line\">    public void marry()&#123;</span><br><span class=\"line\">        System.out.println(&quot;我结婚了&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Marry marry=new MarryCompany(new You());</span><br><span class=\"line\">        marry.marry();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p><u>静态代理不实现接口也能做到，为什么还要实现共同接口？</u>接口的作用是保证了代理对象具有和被代理对象具有一样的契约。<br>“代理”是针对相同的接口编程，以达到透明地替换原来的对象。如果添加一个不相干新的类去做这件事，这叫委托模式了。</p>\n<h2 id=\"静态代理总结\"><a href=\"#静态代理总结\" class=\"headerlink\" title=\"静态代理总结:\"></a>静态代理总结:</h2><p>优点：可以做到在不修改目标对象的功能前提下,对目标功能扩展.<br>缺点:因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护。此时动态代理闪亮登场！</p>\n<h1 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h1><p>在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建。<br>比如这次不是我结婚了，而是我的宠物猫jack和rose要举行婚礼</p>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>待完善</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h1><blockquote>\n<p>一个场景设定，假设你要结婚了，但你不会为了结婚就要学婚礼布置，拍婚纱照等技术活，这些可以交给婚庆公司做嘛。于是你找了婚庆公司作为你的代理为了做一些准备工作。但最后去结婚的是你而不婚庆公司。这就是代理模式了。</p>\n</blockquote>\n<h2 id=\"静态代理有三个元素：共同接口、代理对象、目标对象。\"><a href=\"#静态代理有三个元素：共同接口、代理对象、目标对象。\" class=\"headerlink\" title=\"静态代理有三个元素：共同接口、代理对象、目标对象。\"></a>静态代理有三个元素：共同接口、代理对象、目标对象。</h2><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>接口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Marry &#123;</span><br><span class=\"line\">    void marry();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代理类，把接口当做参数传入构造函数中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MarryCompany implements Marry &#123;</span><br><span class=\"line\">    Marry marry;</span><br><span class=\"line\"></span><br><span class=\"line\">    public MarryCompany(Marry marry) &#123;</span><br><span class=\"line\">        this.marry = marry;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void proWwork() &#123;</span><br><span class=\"line\">        System.out.println(&quot;婚礼前准备&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void afterWwork() &#123;</span><br><span class=\"line\">        System.out.println(&quot;婚礼后收拾&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void marry() &#123;</span><br><span class=\"line\">        proWwork();</span><br><span class=\"line\">        marry.marry();</span><br><span class=\"line\">        afterWwork();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>目标对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class You implements Marry&#123;</span><br><span class=\"line\">    public void marry()&#123;</span><br><span class=\"line\">        System.out.println(&quot;我结婚了&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Marry marry=new MarryCompany(new You());</span><br><span class=\"line\">        marry.marry();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p><u>静态代理不实现接口也能做到，为什么还要实现共同接口？</u>接口的作用是保证了代理对象具有和被代理对象具有一样的契约。<br>“代理”是针对相同的接口编程，以达到透明地替换原来的对象。如果添加一个不相干新的类去做这件事，这叫委托模式了。</p>\n<h2 id=\"静态代理总结\"><a href=\"#静态代理总结\" class=\"headerlink\" title=\"静态代理总结:\"></a>静态代理总结:</h2><p>优点：可以做到在不修改目标对象的功能前提下,对目标功能扩展.<br>缺点:因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护。此时动态代理闪亮登场！</p>\n<h1 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h1><p>在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建。<br>比如这次不是我结婚了，而是我的宠物猫jack和rose要举行婚礼</p>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>待完善</p>\n"},{"title":"单例模式","date":"2019-01-21T14:13:50.000Z","description":"关于单例模式，有些场景需要类只有一个实例。比如王者荣耀里的大龙只有一个，所以该类，只能被实例化一次。再比如java中的日历Calendar类就是一个单例模式。","_content":"\n# 单例模式的三要素\n1. 构造方法私有化\n2. 静态属性修饰的实例\n3. public static的 getInstance方法，返回第二步实例引用\n\n\n\n\n# 单例模式的四种写法\n\n## 饿汉单例模式\n先创建一个实例等着调用\n```public class GiantDragon {\n   \n       //私有化构造方法使得该类无法在外部通过new 进行实例化\n       private GiantDragon(){  }\n    \n       //准备一个类属性，指向一个实例化对象。 因为是类属性，只有一个并且不需要实例即可使用\n       private static GiantDragon instance = new GiantDragon();\n        \n       //public static 方法，提供给调用者获取12行定义的对象\n       public static GiantDragon getInstance(){\n           return instance;}\n          public static void main(String[] args) {\n               GiantDragon g1 = GiantDragon.getInstance();\n           } \n   }\n```\n优点：1.线程安全\n缺点1.可能造成浪费，无论是否会用到这个对象，都会加载。\n2.还有一个漏洞，别人可以通过反射的方式创建一个新对象。\n\n## 懒汉单例模式\n只有在调用getInstance的时候，才会创建实例。\n```\npublic class GiantDragon {\n    //私有化构造方法使得该类无法在外部通过new 进行实例化\n    private GiantDragon(){       \n    }\n      //准备一个类属性，用于指向一个实例化对象，但是暂时指向null\n    private static GiantDragon instance;\n     \n    //public static 方法，返回实例对象\n    public static GiantDragon getInstance(){\n        //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象\n        if(null==instance){\n            instance = new GiantDragon();\n        }\n        //返回 instance指向的对象\n        return instance;\n    }\n      \n}\n```\n**注意这样写是线程不安全的！**\n问题出在直接“if(null==instance){”判断实例为null，就创建对象。\n为什么说是线程不安全的呢。请模拟一下两个线程同时来创建对象结果会发生什么？\n如果两个对象同时判断为空，结果就会创造了两个实例，就不是单例模式啦。\n因此加入**synchronized声明**。\n但如果判断语句写在同步代码后面，导致同步块包括了判断语句，这并没有必要，最重要的是很影响速度。（代码如下）\n`  synchronized (Singleton.class) {          \n  if (instance == null) {`\n如果在同步代码写在判断语句前面，可能会出现两个线程同时判断都为空，才进入同步块，线程1创建完一个对象后，线程2还会创造一个对象，只是两个线程创建对象不是同时发生而已，并没有解决线程不安全问题（代码如下）\n`  if (instance == null) {          \n  synchronized (Singleton.class){`\n重点来了，可以用**双重检测机制**，即在synchronized声明前后都判断一次是否为空，保证线程安全。\n如果没有第一个判断：所有调用这个方法的线程都得先获取锁，不管此时实例是否为空，有没有必要。\n如果没有第二个判断：如果两个线程同时判断为空，一个先取锁，一个后取锁。还是会创建两个对象，只不过是一个先一个后。第二个判断避免了两个线程** 同时判断为空 **先后获取锁创建对象的情况.线程1创建完实例后，线程2再执行的时候要经过第二次判断，此时已经有实例了，线程2就不满足创建条件。\n双重检测机制不会影响效率。因为在第一次判断语句不是在同步块内，并没有影响多少效率。\n第二次判断虽然在同步块内，但只有当实例为空的时候需要获取锁。\n\n另外，实例创建非原子性的，有可能出现**指令重排问题**，因此实例用**volatile**修饰。\ninstance = new Singleton();在 JVM 中会指令至少3条指令：\n第一步，是给 singleton 分配内存空间；\n第二步，开始调用 Singleton 的构造函数等，来初始化 singleton；\n第三步，将 singleton 对象指向分配的内存空间（执行完这步 singleton 就不是 null 了）。\n这里需要留意一下 1-2-3 的顺序，因为存在指令重排序的优化，也就是说第 2 步和第 3 步的顺序是不能保证的，最终的执行顺序，可能是 1-2-3，也有可能是 1-3-2。\n如果是 1-3-2，那么在第 3 步执行完以后，singleton 就不是 null 了，可是这时第 2 步并没有执行，singleton 对象未完成初始化，它的属性的值可能不是我们所预期的值。假设此时线程 2 进入 getInstance 方法，由于 singleton 已经不是 null 了，所以会通过第一重检查并直接返回，但其实这时的 singleton 并没有完成初始化，所以使用这个实例的时候会报错，\n```public class Singleton {\n    private static volatile Singleton instance = null;\n    private Singleton(){};\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class){\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance; }}\n```\n\n懒汉式优点：相对于饿汉模式；来说在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。\n懒汉式缺点：1.麻烦，需要我们来自己加锁，保证线程安全的问题。\n2.还是可以通过反射的方式来破坏单例模式。\n\n\n## 静态内部类\n\n```\npublic class Singleton3 {\n    //静态内部类\n    private static class LazyHolder{\n        private static Singleton3 instance = new Singleton3();\n    }\n    //私有构造器\n    private Singleton3(){};\n    public static Singleton3 getInstance() {\n        return LazyHolder.instance;\n    }\n}\n```\n由于**外部类无法访问静态内部类**，因此只有当外部类调用Singleton.getInstance()方法的时候，才能得到instance实例。并且，instance实例对象初始化的时机并不是在Singleton被加载的时候，而是当getInstance()方法被调用的时候，静态内部类才会被加载，这时instance对象才会被初始化。并且也是线程安全的。所以，与饿汉式相比，通过静态内部类的方式，可以保证instance实例对象不会被白白浪费。但是，它仍然存在反射问题。\n优点：1.线程安全\n2.不会浪费\n缺点：还是反射问题\n\n\n## 枚举\n\n```\npublic class SingletonTest {\n\n    private SingletonTest(){\n    }\n    /**\n     * 枚举类型是线程安全的，并且只会装载一次\n     */\n    private enum Singleton{\n        INSTANCE;\n\n        private final SingletonTest instance;\n\n        Singleton(){\n            instance = new SingletonTest();\n        }\n\n        private SingletonTest getInstance(){\n            return instance;\n        }\n    }\n\n    public static SingletonTest getInstance(){\n        return SingletonTest.Singleton.INSTANCE.getInstance();\n    }\n}\n```\n枚举方式优点：1.线程安全\n2.代码简单\n3.反射也不能获得多个对象，因为JVM能阻止反射获取枚举类的私有构造器\n枚举方式缺点：和饿汉式一样，由于一开始instance实例就被创建了，所以有可能出现白白浪费的情况。","source":"_posts/单例模式.md","raw":"---\ntitle: 单例模式\ndate: 2019-01-21 22:13:50\ncategories: 设计模式\ndescription: 关于单例模式，有些场景需要类只有一个实例。比如王者荣耀里的大龙只有一个，所以该类，只能被实例化一次。再比如java中的日历Calendar类就是一个单例模式。\n\n---\n\n# 单例模式的三要素\n1. 构造方法私有化\n2. 静态属性修饰的实例\n3. public static的 getInstance方法，返回第二步实例引用\n\n\n\n\n# 单例模式的四种写法\n\n## 饿汉单例模式\n先创建一个实例等着调用\n```public class GiantDragon {\n   \n       //私有化构造方法使得该类无法在外部通过new 进行实例化\n       private GiantDragon(){  }\n    \n       //准备一个类属性，指向一个实例化对象。 因为是类属性，只有一个并且不需要实例即可使用\n       private static GiantDragon instance = new GiantDragon();\n        \n       //public static 方法，提供给调用者获取12行定义的对象\n       public static GiantDragon getInstance(){\n           return instance;}\n          public static void main(String[] args) {\n               GiantDragon g1 = GiantDragon.getInstance();\n           } \n   }\n```\n优点：1.线程安全\n缺点1.可能造成浪费，无论是否会用到这个对象，都会加载。\n2.还有一个漏洞，别人可以通过反射的方式创建一个新对象。\n\n## 懒汉单例模式\n只有在调用getInstance的时候，才会创建实例。\n```\npublic class GiantDragon {\n    //私有化构造方法使得该类无法在外部通过new 进行实例化\n    private GiantDragon(){       \n    }\n      //准备一个类属性，用于指向一个实例化对象，但是暂时指向null\n    private static GiantDragon instance;\n     \n    //public static 方法，返回实例对象\n    public static GiantDragon getInstance(){\n        //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象\n        if(null==instance){\n            instance = new GiantDragon();\n        }\n        //返回 instance指向的对象\n        return instance;\n    }\n      \n}\n```\n**注意这样写是线程不安全的！**\n问题出在直接“if(null==instance){”判断实例为null，就创建对象。\n为什么说是线程不安全的呢。请模拟一下两个线程同时来创建对象结果会发生什么？\n如果两个对象同时判断为空，结果就会创造了两个实例，就不是单例模式啦。\n因此加入**synchronized声明**。\n但如果判断语句写在同步代码后面，导致同步块包括了判断语句，这并没有必要，最重要的是很影响速度。（代码如下）\n`  synchronized (Singleton.class) {          \n  if (instance == null) {`\n如果在同步代码写在判断语句前面，可能会出现两个线程同时判断都为空，才进入同步块，线程1创建完一个对象后，线程2还会创造一个对象，只是两个线程创建对象不是同时发生而已，并没有解决线程不安全问题（代码如下）\n`  if (instance == null) {          \n  synchronized (Singleton.class){`\n重点来了，可以用**双重检测机制**，即在synchronized声明前后都判断一次是否为空，保证线程安全。\n如果没有第一个判断：所有调用这个方法的线程都得先获取锁，不管此时实例是否为空，有没有必要。\n如果没有第二个判断：如果两个线程同时判断为空，一个先取锁，一个后取锁。还是会创建两个对象，只不过是一个先一个后。第二个判断避免了两个线程** 同时判断为空 **先后获取锁创建对象的情况.线程1创建完实例后，线程2再执行的时候要经过第二次判断，此时已经有实例了，线程2就不满足创建条件。\n双重检测机制不会影响效率。因为在第一次判断语句不是在同步块内，并没有影响多少效率。\n第二次判断虽然在同步块内，但只有当实例为空的时候需要获取锁。\n\n另外，实例创建非原子性的，有可能出现**指令重排问题**，因此实例用**volatile**修饰。\ninstance = new Singleton();在 JVM 中会指令至少3条指令：\n第一步，是给 singleton 分配内存空间；\n第二步，开始调用 Singleton 的构造函数等，来初始化 singleton；\n第三步，将 singleton 对象指向分配的内存空间（执行完这步 singleton 就不是 null 了）。\n这里需要留意一下 1-2-3 的顺序，因为存在指令重排序的优化，也就是说第 2 步和第 3 步的顺序是不能保证的，最终的执行顺序，可能是 1-2-3，也有可能是 1-3-2。\n如果是 1-3-2，那么在第 3 步执行完以后，singleton 就不是 null 了，可是这时第 2 步并没有执行，singleton 对象未完成初始化，它的属性的值可能不是我们所预期的值。假设此时线程 2 进入 getInstance 方法，由于 singleton 已经不是 null 了，所以会通过第一重检查并直接返回，但其实这时的 singleton 并没有完成初始化，所以使用这个实例的时候会报错，\n```public class Singleton {\n    private static volatile Singleton instance = null;\n    private Singleton(){};\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class){\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance; }}\n```\n\n懒汉式优点：相对于饿汉模式；来说在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。\n懒汉式缺点：1.麻烦，需要我们来自己加锁，保证线程安全的问题。\n2.还是可以通过反射的方式来破坏单例模式。\n\n\n## 静态内部类\n\n```\npublic class Singleton3 {\n    //静态内部类\n    private static class LazyHolder{\n        private static Singleton3 instance = new Singleton3();\n    }\n    //私有构造器\n    private Singleton3(){};\n    public static Singleton3 getInstance() {\n        return LazyHolder.instance;\n    }\n}\n```\n由于**外部类无法访问静态内部类**，因此只有当外部类调用Singleton.getInstance()方法的时候，才能得到instance实例。并且，instance实例对象初始化的时机并不是在Singleton被加载的时候，而是当getInstance()方法被调用的时候，静态内部类才会被加载，这时instance对象才会被初始化。并且也是线程安全的。所以，与饿汉式相比，通过静态内部类的方式，可以保证instance实例对象不会被白白浪费。但是，它仍然存在反射问题。\n优点：1.线程安全\n2.不会浪费\n缺点：还是反射问题\n\n\n## 枚举\n\n```\npublic class SingletonTest {\n\n    private SingletonTest(){\n    }\n    /**\n     * 枚举类型是线程安全的，并且只会装载一次\n     */\n    private enum Singleton{\n        INSTANCE;\n\n        private final SingletonTest instance;\n\n        Singleton(){\n            instance = new SingletonTest();\n        }\n\n        private SingletonTest getInstance(){\n            return instance;\n        }\n    }\n\n    public static SingletonTest getInstance(){\n        return SingletonTest.Singleton.INSTANCE.getInstance();\n    }\n}\n```\n枚举方式优点：1.线程安全\n2.代码简单\n3.反射也不能获得多个对象，因为JVM能阻止反射获取枚举类的私有构造器\n枚举方式缺点：和饿汉式一样，由于一开始instance实例就被创建了，所以有可能出现白白浪费的情况。","slug":"单例模式","published":1,"updated":"2022-02-28T08:02:02.477Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qkk0017w9rpwhdwxa0k","content":"<h1 id=\"单例模式的三要素\"><a href=\"#单例模式的三要素\" class=\"headerlink\" title=\"单例模式的三要素\"></a>单例模式的三要素</h1><ol>\n<li>构造方法私有化</li>\n<li>静态属性修饰的实例</li>\n<li>public static的 getInstance方法，返回第二步实例引用</li>\n</ol>\n<h1 id=\"单例模式的四种写法\"><a href=\"#单例模式的四种写法\" class=\"headerlink\" title=\"单例模式的四种写法\"></a>单例模式的四种写法</h1><h2 id=\"饿汉单例模式\"><a href=\"#饿汉单例模式\" class=\"headerlink\" title=\"饿汉单例模式\"></a>饿汉单例模式</h2><p>先创建一个实例等着调用<br><figure class=\"highlight plain\"><figcaption><span>class GiantDragon &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    //私有化构造方法使得该类无法在外部通过new 进行实例化</span><br><span class=\"line\">    private GiantDragon()&#123;  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    //准备一个类属性，指向一个实例化对象。 因为是类属性，只有一个并且不需要实例即可使用</span><br><span class=\"line\">    private static GiantDragon instance = new GiantDragon();</span><br><span class=\"line\">     </span><br><span class=\"line\">    //public static 方法，提供给调用者获取12行定义的对象</span><br><span class=\"line\">    public static GiantDragon getInstance()&#123;</span><br><span class=\"line\">        return instance;&#125;</span><br><span class=\"line\">       public static void main(String[] args) &#123;</span><br><span class=\"line\">            GiantDragon g1 = GiantDragon.getInstance();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>优点：1.线程安全<br>缺点1.可能造成浪费，无论是否会用到这个对象，都会加载。<br>2.还有一个漏洞，别人可以通过反射的方式创建一个新对象。</p>\n<h2 id=\"懒汉单例模式\"><a href=\"#懒汉单例模式\" class=\"headerlink\" title=\"懒汉单例模式\"></a>懒汉单例模式</h2><p>只有在调用getInstance的时候，才会创建实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class GiantDragon &#123;</span><br><span class=\"line\">    //私有化构造方法使得该类无法在外部通过new 进行实例化</span><br><span class=\"line\">    private GiantDragon()&#123;       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      //准备一个类属性，用于指向一个实例化对象，但是暂时指向null</span><br><span class=\"line\">    private static GiantDragon instance;</span><br><span class=\"line\">     </span><br><span class=\"line\">    //public static 方法，返回实例对象</span><br><span class=\"line\">    public static GiantDragon getInstance()&#123;</span><br><span class=\"line\">        //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象</span><br><span class=\"line\">        if(null==instance)&#123;</span><br><span class=\"line\">            instance = new GiantDragon();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //返回 instance指向的对象</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意这样写是线程不安全的！</strong><br>问题出在直接“if(null==instance){”判断实例为null，就创建对象。<br>为什么说是线程不安全的呢。请模拟一下两个线程同时来创建对象结果会发生什么？<br>如果两个对象同时判断为空，结果就会创造了两个实例，就不是单例模式啦。<br>因此加入<strong>synchronized声明</strong>。<br>但如果判断语句写在同步代码后面，导致同步块包括了判断语句，这并没有必要，最重要的是很影响速度。（代码如下）<br><code>synchronized (Singleton.class) {          \n  if (instance == null) {</code><br>如果在同步代码写在判断语句前面，可能会出现两个线程同时判断都为空，才进入同步块，线程1创建完一个对象后，线程2还会创造一个对象，只是两个线程创建对象不是同时发生而已，并没有解决线程不安全问题（代码如下）<br><code>if (instance == null) {          \n  synchronized (Singleton.class){</code><br>重点来了，可以用<strong>双重检测机制</strong>，即在synchronized声明前后都判断一次是否为空，保证线程安全。<br>如果没有第一个判断：所有调用这个方法的线程都得先获取锁，不管此时实例是否为空，有没有必要。<br>如果没有第二个判断：如果两个线程同时判断为空，一个先取锁，一个后取锁。还是会创建两个对象，只不过是一个先一个后。第二个判断避免了两个线程<strong> 同时判断为空 </strong>先后获取锁创建对象的情况.线程1创建完实例后，线程2再执行的时候要经过第二次判断，此时已经有实例了，线程2就不满足创建条件。<br>双重检测机制不会影响效率。因为在第一次判断语句不是在同步块内，并没有影响多少效率。<br>第二次判断虽然在同步块内，但只有当实例为空的时候需要获取锁。</p>\n<p>另外，实例创建非原子性的，有可能出现<strong>指令重排问题</strong>，因此实例用<strong>volatile</strong>修饰。<br>instance = new Singleton();在 JVM 中会指令至少3条指令：<br>第一步，是给 singleton 分配内存空间；<br>第二步，开始调用 Singleton 的构造函数等，来初始化 singleton；<br>第三步，将 singleton 对象指向分配的内存空间（执行完这步 singleton 就不是 null 了）。<br>这里需要留意一下 1-2-3 的顺序，因为存在指令重排序的优化，也就是说第 2 步和第 3 步的顺序是不能保证的，最终的执行顺序，可能是 1-2-3，也有可能是 1-3-2。<br>如果是 1-3-2，那么在第 3 步执行完以后，singleton 就不是 null 了，可是这时第 2 步并没有执行，singleton 对象未完成初始化，它的属性的值可能不是我们所预期的值。假设此时线程 2 进入 getInstance 方法，由于 singleton 已经不是 null 了，所以会通过第一重检查并直接返回，但其实这时的 singleton 并没有完成初始化，所以使用这个实例的时候会报错，<br><figure class=\"highlight plain\"><figcaption><span>class Singleton &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static volatile Singleton instance = null;</span><br><span class=\"line\">private Singleton()&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">public static Singleton getInstance() &#123;</span><br><span class=\"line\">    if (instance == null) &#123;</span><br><span class=\"line\">        synchronized (Singleton.class)&#123;</span><br><span class=\"line\">            if (instance == null) &#123;</span><br><span class=\"line\">                instance = new Singleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return instance; &#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>懒汉式优点：相对于饿汉模式；来说在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。<br>懒汉式缺点：1.麻烦，需要我们来自己加锁，保证线程安全的问题。<br>2.还是可以通过反射的方式来破坏单例模式。</p>\n<h2 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton3 &#123;</span><br><span class=\"line\">    //静态内部类</span><br><span class=\"line\">    private static class LazyHolder&#123;</span><br><span class=\"line\">        private static Singleton3 instance = new Singleton3();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //私有构造器</span><br><span class=\"line\">    private Singleton3()&#123;&#125;;</span><br><span class=\"line\">    public static Singleton3 getInstance() &#123;</span><br><span class=\"line\">        return LazyHolder.instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于<strong>外部类无法访问静态内部类</strong>，因此只有当外部类调用Singleton.getInstance()方法的时候，才能得到instance实例。并且，instance实例对象初始化的时机并不是在Singleton被加载的时候，而是当getInstance()方法被调用的时候，静态内部类才会被加载，这时instance对象才会被初始化。并且也是线程安全的。所以，与饿汉式相比，通过静态内部类的方式，可以保证instance实例对象不会被白白浪费。但是，它仍然存在反射问题。<br>优点：1.线程安全<br>2.不会浪费<br>缺点：还是反射问题</p>\n<h2 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingletonTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private SingletonTest()&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 枚举类型是线程安全的，并且只会装载一次</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private enum Singleton&#123;</span><br><span class=\"line\">        INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">        private final SingletonTest instance;</span><br><span class=\"line\"></span><br><span class=\"line\">        Singleton()&#123;</span><br><span class=\"line\">            instance = new SingletonTest();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        private SingletonTest getInstance()&#123;</span><br><span class=\"line\">            return instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static SingletonTest getInstance()&#123;</span><br><span class=\"line\">        return SingletonTest.Singleton.INSTANCE.getInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>枚举方式优点：1.线程安全<br>2.代码简单<br>3.反射也不能获得多个对象，因为JVM能阻止反射获取枚举类的私有构造器<br>枚举方式缺点：和饿汉式一样，由于一开始instance实例就被创建了，所以有可能出现白白浪费的情况。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"单例模式的三要素\"><a href=\"#单例模式的三要素\" class=\"headerlink\" title=\"单例模式的三要素\"></a>单例模式的三要素</h1><ol>\n<li>构造方法私有化</li>\n<li>静态属性修饰的实例</li>\n<li>public static的 getInstance方法，返回第二步实例引用</li>\n</ol>\n<h1 id=\"单例模式的四种写法\"><a href=\"#单例模式的四种写法\" class=\"headerlink\" title=\"单例模式的四种写法\"></a>单例模式的四种写法</h1><h2 id=\"饿汉单例模式\"><a href=\"#饿汉单例模式\" class=\"headerlink\" title=\"饿汉单例模式\"></a>饿汉单例模式</h2><p>先创建一个实例等着调用<br><figure class=\"highlight plain\"><figcaption><span>class GiantDragon &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    //私有化构造方法使得该类无法在外部通过new 进行实例化</span><br><span class=\"line\">    private GiantDragon()&#123;  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    //准备一个类属性，指向一个实例化对象。 因为是类属性，只有一个并且不需要实例即可使用</span><br><span class=\"line\">    private static GiantDragon instance = new GiantDragon();</span><br><span class=\"line\">     </span><br><span class=\"line\">    //public static 方法，提供给调用者获取12行定义的对象</span><br><span class=\"line\">    public static GiantDragon getInstance()&#123;</span><br><span class=\"line\">        return instance;&#125;</span><br><span class=\"line\">       public static void main(String[] args) &#123;</span><br><span class=\"line\">            GiantDragon g1 = GiantDragon.getInstance();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>优点：1.线程安全<br>缺点1.可能造成浪费，无论是否会用到这个对象，都会加载。<br>2.还有一个漏洞，别人可以通过反射的方式创建一个新对象。</p>\n<h2 id=\"懒汉单例模式\"><a href=\"#懒汉单例模式\" class=\"headerlink\" title=\"懒汉单例模式\"></a>懒汉单例模式</h2><p>只有在调用getInstance的时候，才会创建实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class GiantDragon &#123;</span><br><span class=\"line\">    //私有化构造方法使得该类无法在外部通过new 进行实例化</span><br><span class=\"line\">    private GiantDragon()&#123;       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      //准备一个类属性，用于指向一个实例化对象，但是暂时指向null</span><br><span class=\"line\">    private static GiantDragon instance;</span><br><span class=\"line\">     </span><br><span class=\"line\">    //public static 方法，返回实例对象</span><br><span class=\"line\">    public static GiantDragon getInstance()&#123;</span><br><span class=\"line\">        //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象</span><br><span class=\"line\">        if(null==instance)&#123;</span><br><span class=\"line\">            instance = new GiantDragon();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //返回 instance指向的对象</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意这样写是线程不安全的！</strong><br>问题出在直接“if(null==instance){”判断实例为null，就创建对象。<br>为什么说是线程不安全的呢。请模拟一下两个线程同时来创建对象结果会发生什么？<br>如果两个对象同时判断为空，结果就会创造了两个实例，就不是单例模式啦。<br>因此加入<strong>synchronized声明</strong>。<br>但如果判断语句写在同步代码后面，导致同步块包括了判断语句，这并没有必要，最重要的是很影响速度。（代码如下）<br><code>synchronized (Singleton.class) {          \n  if (instance == null) {</code><br>如果在同步代码写在判断语句前面，可能会出现两个线程同时判断都为空，才进入同步块，线程1创建完一个对象后，线程2还会创造一个对象，只是两个线程创建对象不是同时发生而已，并没有解决线程不安全问题（代码如下）<br><code>if (instance == null) {          \n  synchronized (Singleton.class){</code><br>重点来了，可以用<strong>双重检测机制</strong>，即在synchronized声明前后都判断一次是否为空，保证线程安全。<br>如果没有第一个判断：所有调用这个方法的线程都得先获取锁，不管此时实例是否为空，有没有必要。<br>如果没有第二个判断：如果两个线程同时判断为空，一个先取锁，一个后取锁。还是会创建两个对象，只不过是一个先一个后。第二个判断避免了两个线程<strong> 同时判断为空 </strong>先后获取锁创建对象的情况.线程1创建完实例后，线程2再执行的时候要经过第二次判断，此时已经有实例了，线程2就不满足创建条件。<br>双重检测机制不会影响效率。因为在第一次判断语句不是在同步块内，并没有影响多少效率。<br>第二次判断虽然在同步块内，但只有当实例为空的时候需要获取锁。</p>\n<p>另外，实例创建非原子性的，有可能出现<strong>指令重排问题</strong>，因此实例用<strong>volatile</strong>修饰。<br>instance = new Singleton();在 JVM 中会指令至少3条指令：<br>第一步，是给 singleton 分配内存空间；<br>第二步，开始调用 Singleton 的构造函数等，来初始化 singleton；<br>第三步，将 singleton 对象指向分配的内存空间（执行完这步 singleton 就不是 null 了）。<br>这里需要留意一下 1-2-3 的顺序，因为存在指令重排序的优化，也就是说第 2 步和第 3 步的顺序是不能保证的，最终的执行顺序，可能是 1-2-3，也有可能是 1-3-2。<br>如果是 1-3-2，那么在第 3 步执行完以后，singleton 就不是 null 了，可是这时第 2 步并没有执行，singleton 对象未完成初始化，它的属性的值可能不是我们所预期的值。假设此时线程 2 进入 getInstance 方法，由于 singleton 已经不是 null 了，所以会通过第一重检查并直接返回，但其实这时的 singleton 并没有完成初始化，所以使用这个实例的时候会报错，<br><figure class=\"highlight plain\"><figcaption><span>class Singleton &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static volatile Singleton instance = null;</span><br><span class=\"line\">private Singleton()&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">public static Singleton getInstance() &#123;</span><br><span class=\"line\">    if (instance == null) &#123;</span><br><span class=\"line\">        synchronized (Singleton.class)&#123;</span><br><span class=\"line\">            if (instance == null) &#123;</span><br><span class=\"line\">                instance = new Singleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return instance; &#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>懒汉式优点：相对于饿汉模式；来说在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。<br>懒汉式缺点：1.麻烦，需要我们来自己加锁，保证线程安全的问题。<br>2.还是可以通过反射的方式来破坏单例模式。</p>\n<h2 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton3 &#123;</span><br><span class=\"line\">    //静态内部类</span><br><span class=\"line\">    private static class LazyHolder&#123;</span><br><span class=\"line\">        private static Singleton3 instance = new Singleton3();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //私有构造器</span><br><span class=\"line\">    private Singleton3()&#123;&#125;;</span><br><span class=\"line\">    public static Singleton3 getInstance() &#123;</span><br><span class=\"line\">        return LazyHolder.instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于<strong>外部类无法访问静态内部类</strong>，因此只有当外部类调用Singleton.getInstance()方法的时候，才能得到instance实例。并且，instance实例对象初始化的时机并不是在Singleton被加载的时候，而是当getInstance()方法被调用的时候，静态内部类才会被加载，这时instance对象才会被初始化。并且也是线程安全的。所以，与饿汉式相比，通过静态内部类的方式，可以保证instance实例对象不会被白白浪费。但是，它仍然存在反射问题。<br>优点：1.线程安全<br>2.不会浪费<br>缺点：还是反射问题</p>\n<h2 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingletonTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private SingletonTest()&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 枚举类型是线程安全的，并且只会装载一次</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private enum Singleton&#123;</span><br><span class=\"line\">        INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">        private final SingletonTest instance;</span><br><span class=\"line\"></span><br><span class=\"line\">        Singleton()&#123;</span><br><span class=\"line\">            instance = new SingletonTest();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        private SingletonTest getInstance()&#123;</span><br><span class=\"line\">            return instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static SingletonTest getInstance()&#123;</span><br><span class=\"line\">        return SingletonTest.Singleton.INSTANCE.getInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>枚举方式优点：1.线程安全<br>2.代码简单<br>3.反射也不能获得多个对象，因为JVM能阻止反射获取枚举类的私有构造器<br>枚举方式缺点：和饿汉式一样，由于一开始instance实例就被创建了，所以有可能出现白白浪费的情况。</p>\n"},{"title":"一文掌握redis","date":"2019-11-01T08:36:50.000Z","description":"写得比较完善的一篇笔记，应该有把握住一些重点。","_content":"\n\n\n[TOC]\n\n\n## 数据类型\n\nredis 主要有以下几种数据类型：\n\n|          | String字符串   | Hash                         | list                     | set                  | sort set |\n| -------- | -------------- | ---------------------------- | ------------------------ | -------------------- | -------- |\n| 存储方式 | K,V            | 结构存储                     | 有序                     | 无序和去重】、       | 排序列表 |\n| 应用     | 万物皆可字符串 | 存对象（但不可有对象的引用） | 粉丝、关注、评论         | 点赞人，全局过滤去重 | 排行榜   |\n| 技巧     |                | 可对象的操作字段             | lrange分页，bpop阻塞队列 | 交集并集差集、       |          |\n\n\n\n## 为啥 redis 效率这么高？\n\n- 纯内存操作。\n- 核心是基于非阻塞的 IO 多路复用机制。\n- C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。\n- 单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。\n\n## 过期策略\n\n- 往 redis 写入的数据怎么没了？\n\n内存是有限的，比如 redis 就只能用 10G，你要是往里面写了 20G 的数据，会干掉 10G 的数据，然后就保留 10G 的数据了。\n\n- 数据明明过期了，怎么还占用着内存？\n\n这是由 redis 的过期策略来决定。\n\n\n\n### redis 过期策略\n\nredis 过期策略是：**定期删除+惰性删除**。\n\n所谓**定期删除**，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。\n\n**惰性删除**:获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。\n\n如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？答案是：**走内存淘汰机制**。\n\n### 内存淘汰机制\n\nredis 内存淘汰机制有以下几个：\n\n- noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。\n- **allkeys-lru**：当内存不足以容纳新写入数据时，在**键空间**中，移除最近最少使用的 key（这个是**最常用**的）。\n- allkeys-random：当内存不足以容纳新写入数据时，在**键空间**中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。\n- volatile-lru：当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，移除最近最少使用的 key（这个一般不太合适）。\n- volatile-random：当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，**随机移除**某个 key。\n- volatile-ttl：当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，有**更早过期时间**的 key 优先移除。\n\n\n\n## 持久化\n\n- RDB：RDB 持久化机制，是对 redis 中的数据执行**周期性**的持久化。\n- AOF：AOF 机制对每条写入命令作为日志，以 `append-only` 的模式写入一个日志文件中，在 redis 重启的时候，可以通过**回放** AOF 日志中的写入指令来重新构建整个数据集。\n\n|      | 如何持久化   | 丢失数据                 | 写入性能               | 文件大小           | 恢复速度 | 场景           |\n| ---- | ------------ | ------------------------ | ---------------------- | ------------------ | -------- | -------------- |\n| RDB  | 数据周期存储 | 容易丢失                 | 低                     | 小                 | 快       | 冷备           |\n| AOF  | 指令重新构建 | 不容易（只丢失最近一秒） | 高，没有磁盘寻址的开销 | 大，文件是逐渐大的 | 慢       | 误删的紧急恢复 |\n\n\n\n### RDB 快照（保存值）\n\n触发机制\n\n1.全量复制：主从复制的时候，主会自动生成RDB文件\n2.debug reload：不需要将内存清空的重启也会触发RDB的生成\n3.shutdown，关闭的时候会自动生成shutdown save\n\n三种命令\n\nsave（同步）数据进行完整的拷贝的话可能会阻塞注命令\nbgsave(异步)生成子进程去完成RDB的生成\n自动：满足900秒有1个改变、300秒有10个，60秒有1000个改变一条件就进行save\n\n场景：冷备\n\n\n\n### AOF 日志（保存命令）\n\n这个文件是逐渐增大的。\n\n三种策略：always everysec no（os决定）\n\n AOF重写：把一些过期的命令进行优化。\n\n场景：误删的紧急处理。比如某人不小心用 `flushall` 命令清空了所有数据，只要这个时候后台 `rewrite` 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 `flushall` 命令给删了，然后再将该 `AOF` 文件放回去，就可以通过恢复机制，自动恢复所有数据。\n\n### RDB 和 AOF 到底该如何选择\n\n- 仅仅使用 RDB，因为那样会导致你丢失很多数据；\n\n- 仅仅使用 AOF有两个问题：第一， AOF 没有 RDB 做冷备来的**恢复速度**更快；第二，RDB 每次简单粗暴生成数据快照，**更加健壮**，可以避免 AOF 这种复杂的备份和恢复机制的 bug；\n\n- redis 支持同时开启开启两种持久化方式，我用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。另外，如果同时使用 RDB 和 AOF 两种持久化机制，**redis** 重启的时候，会使用 **AOF** 来重新构建数据，因为 AOF 中的**数据更加完整**。\n\n  \n\n## 主从复制\n\n数据流是单项的，从master到slave\n\n### 开启 master 的持久化\n\n如果用 slave node 作为 master node 的数据热备可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。\n\n另外，master 的各种备份方案，也需要做。**万一本地的所有文件丢失了**，从备份中挑选一份 rdb 去恢复 master，这样才能**确保启动的时候，是有数据的**\n\n### 心跳检测\n\n主从节点互相都会发送 heartbeat 信息。\n\nmaster 默认每隔 10秒 发送一次 heartbeat\n\n而slave 呢：\n\n- slave node 每隔 1秒 发送一个 heartbeat。并检查是否有新的 master node 要连接和复制。\n- 如果有， slave node 发送 `ping` 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。\n- master node **第一次执行全量复制**，将所有数据发给 slave node。\n- 而在后续，master node 持续将写命令，**异步复制**给 slave node。\n\n### 每次写请求异步复制\n\nmaster 每次接收到写命令之后，先在内部写入数据，然后**异步**发送给 slave node。\n\n\n\n### 全量复制\n\n- 从服务器向主服务器发送PSYNC命令，；第一次的话，slave不知道master 的 runid，所以是？,偏移量是-1\n\n2. 主服务器验证runid和自身runid是否一致，如不一致，则进行全量复制；\n3. Master把自己的runid和offset（偏移量）发给slave，slave保存起来\n4. 使用bgsave生成RDB文件。\n\n- 由于bgsave是异步的过程，master还可以继续写数据，这一段时间的操作放入缓冲区。\n- 通过网络磁盘传去，再把缓冲区数据传去。\n- Salve会先清除原来的数据，加载RDB和缓冲区数据，写入本地磁盘，然后再从本地磁盘加载到内存\n\n过程如下图：\n![这里写图片描述](http://javaduqing.oss-cn-hangzhou.aliyuncs.com/QiuniuTransfer/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-5.png)\n\n\n\n#### **开销**\n\n包括以下几个方面：\n\n1. bgsave时间\n2. RDB文件网络传输时间\n3. 从节点清空数据时间\n4. 从节点加载RDB数据时间\n\n\n\n\n\n### 部分复制（增量复制）\n\n部分复制过程如下图：\n![这里写图片描述](http://javaduqing.oss-cn-hangzhou.aliyuncs.com/QiuniuTransfer/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-6.png)\n\n**部分复制的过程：**\n\n1. 当网络发生抖动，slave向master发送连接\n\n2. 要求同步master数据，同时自己的传递偏移量和master runid\n\n3. 如果runid一致，则查看slave的偏移量和master的偏移量是否一直。如果不一致，则观察偏移量是否超过repl_back_buffer中能存储的数据。\n\n4. 如果超过则可能进行全量复制\n\n5. 如果未超过则，将repl_back_buffer中存储的数据发送给slave，slave完成数据的同步\n\n   \n\n## 哨兵保证高可用\n\n哨兵使用是raft协议在宕机时的选举保障集群高可用，raft是一个强一致性算法。\n\n用**流言协议**（gossip protocols)来接收关于主服务器是否下线的信息。\n\n### 三个定时任务\n\n（1）**每隔10s确认主从关系。**每个sentinel会对master节点和slave节点执行info命令，作用就是发现slave节点。当一个主服务器被 Sentinel 标记为客观下线时， Sentinel 向下线主服务器的所有从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。\n\n（2）**每隔两秒，sentinel都会通过master节点内部的channel来交换信息（基于发布订阅）**。 信息包括Sentinel 的 IP 地址、端口号和运行 ID （runid），互相感知到其他的哨兵的存在。\n\n（3） **每隔一秒每个sentinel对其他的redis节点（master，slave，sentinel）执行ping操作**，对于master来说，若超过30s内没有回复，就对该master进行主观下线并询问其他的Sentinel节点是否可以客观下线。\n\n### 主观下线和 客观下线\n\n- sdown 是主观宕机，就一个哨兵如果自己觉得一个 master 宕机了，那么就是主观宕机\n- odown 是客观宕机，如果 quorum 数量的哨兵都觉得一个 master 宕机了，那么就是客观宕机\n\nsdown 达成的条件很简单，如果一个哨兵 ping 一个 master，超过了 `is-master-down-after-milliseconds` 指定的毫秒数之后，就主观认为 master 宕机了；如果一个哨兵在指定时间内，收到了 quorum 数量的其它哨兵也认为那个 master 是 sdown 的，那么就认为是 odown 了。\n\n\n\n### sentinel领导选举与法定人数\n\n。原因:只有一个sentinel节点完成故障转移\n。选举:通过sentinel is-master-down-by-addr命令申请成为领导者\n\n1.    每个做主观下线的Sentinel节点向其他Sentinel节点发送命令,要求将它设置为领导者。\n2.    收到命令的Sentinel节点如果没有同意通过其他Sentinel节点发送命令,那么将同意该请求，否则拒绝。\n3.    如果该Sentinel节点发现自己的票数已经超过Sentinel集合半数且超过quorum,那么它将成为领导者。\n4.    如果此过程有多个Sentinel节点成为了领导者,那么将等待一段时间重新进行选举。\n\n备注：quorum可以在sentinel的conf里配置,后面的2就是法定人数\n\n```\nsentinel monitor mymaster 127.0.0.1 6379 2\n```\n\n法定人数需要比一般的哨兵数还大，如果小于，法定人数为一半以上的哨兵数。\n\n如果 quorum < majority，比如 5 个哨兵，majority 就是 3，quorum 设置为 2，那么就 3 个哨兵授权就可以执行切换。\n\n但是如果 quorum >= majority，那么必须 quorum 数量的哨兵都授权，比如 5 个哨兵，quorum 是 5，那么必须 5 个哨兵都同意授权，才能执行切换。\n\n### master选举算法\n\n如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换\n\n首先如果一个 slave 跟 master 断开连接的时间已经超过了 `down-after-milliseconds` 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。\n\n```\n(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state\n```\n\n接下来会对 slave 进行排序：\n\n- 按照 slave 优先级进行排序，slave priority 越低，**优先级**就越高。\n- 如果 slave priority 相同，那么看 replica **offset**，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。\n- 如果上面两个条件都相同，那么选择一个 **run id** 比较小的那个 slave。\n\n### slave 配置的自动纠正\n\n哨兵会负责自动纠正 slave 的一些配置，比如 slave 如果要成为潜在的 master 候选人，哨兵会确保 slave 复制现有 master 的数据；如果 slave 连接到了一个错误的 master 上，比如故障转移之后，那么哨兵会确保它们连接到正确的 master 上。\n\nslave上升为master日志中可以发现，这一条配置重写的日志\n\n```\n989:M 21 Aug 19:20:42.729 # CONFIG REWRITE executed with success.\n```\n\n## 数据丢失\n\n### 脑裂\n\n脑裂，某个 master 掉线了一会，但是实际上还运行着。此时哨兵可能就会认为 master 宕机了，然后开启选举，集群里就会有两个 master ，也就是所谓的脑裂。 client 还没来得及切换到新的 master，还继续向旧 master 写数据。因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master 并没有后来 client 写入的数据，因此，这部分数据也就丢失了。\n\n解决方案\n\n进行如下配置：\n\n```bash\nmin-slaves-to-write 1\nmin-slaves-max-lag 10\n```\n\n表示，要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒。\n\n如果说一旦所有的 slave，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，master 就不会再接收任何请求了。在脑裂场景下，最多就丢失 10 秒的数据。\n\n### 异步复制\n\n因为 master->slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了。\n\n## Redis 集群\n\n数据分片：按某种规则对海量数据划分，分散存储多个结点上。\n\n常见的数据分布方式有两种\n\n1. 哈希分布：分散高，与业务无关，无法顺序访问\n2. 顺序分布：分散低易倾斜，与业务有关，可顺序访问\n\nredis哈希分布，但不是简单的取模，因为这样动态的添加/删除结点会大费周章\n\n### 一致性哈希分区\n\n一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。\n\n来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环**顺时针“行走”**，遇到的第一个 master 节点就是 key 所在位置。\n\n在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。\n\n**一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。**\n\n燃鹅，一致性哈希算法在**节点太少**时，容易因为节点分布不均匀而造成**缓存热点/数据倾斜**的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个**虚拟节点**。这样就实现了数据的均匀分布，负载均衡。\n\n[![consistent-hashing-algorithm](https://github.com/doocs/advanced-java/raw/master/images/consistent-hashing-algorithm.png)](https://github.com/doocs/advanced-java/blob/master/images/consistent-hashing-algorithm.png)\n\n### hash slot 算法\n\nredis cluster 有固定的 `16384` 个 hash slot，对每个 `key` 计算 `CRC16` 值，然后对 `16384` 取模，可以获取 key 对应的 hash slot。\n\nredis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加/减少一个 master，就将它的 hash slot 移动。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 `hash tag` 来实现。\n\n与取模分片的区别在于，hashsolt把%的数据量变大了，任何一台机器宕机，另外两个节点，不影响的。因为 key 找的是 hash slot，不是机器。\n\n[![hash-slot](https://github.com/doocs/advanced-java/raw/master/images/hash-slot.png)](https://github.com/doocs/advanced-java/blob/master/images/hash-slot.png)\n\n1. 虚拟槽分区\n\n### 高可用\n\nredis cluster 的高可用的原理，几乎跟哨兵是类似的。\n\n#### 判断节点宕机，主观+客观下线\n\ncluster-node-timeout` 内，某个节点一直没有返回 `pong`，那么就被认为 `pfail`。\n\n`pfail`，**主观宕机**。类似odown。\n\nfail，**客观宕机**。类似sdown。超过半数的节点都认为 `pfail` 了，那么就会变成 `fail`。\n\n#### 新master 选举\n\n对宕机的 master node，从其所有的 slave node 中，选择一个切换成 master node。\n\n- 断开连接的时间超过了 `cluster-node-timeout * cluster-slave-validity-factor`，**没有资格**切换成 `master`。\n- offset越大，优先进行选举。\n- 选举投票，拥有N/2 + 1票的结点选举通过成为master。\n- 从节点执行主备切换，从节点切换为主节点。\n\n与主从复制和哨兵\n\n**二者都可以做到高并发高性，用哪个主要看数据量**\n\n如果你的数据量很少就几个 G，单机就足够了，可以自己搭建一个 sentinel 集群去保证 redis 主从架构的高可用性。\n\nredis cluster，主要是针对**海量数据+高并发+高可用**的场景。redis cluster 还可以支持横向扩容更多的 master 节点。\n\n### 节点间的内部通信机制\n\n#### 基本通信原理\n\n集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。\n\n- 集中式是将集群元数据（节点信息、故障等等）集中存储在某个节点上。\n- gossip` 协议，所有节点都持有一份元数据，元数据的变更会发送给其它的节点通知变更。\n\n集中式的好处在于，元数据时效常好。不好在于，集中存储元数据有更新访问压力。\n\ngossip 正好相反。好处在于，元数据分散，降低了压力；不好在于，元数据更新滞后。\n\n#### gossip 协议\n\n- 10000 端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 `ping` 消息，同时其它几个节点接收到 `ping` 之后返回 `pong`。\n- 交换的信息：信息包括故障信息，节点的增加和删除，hash slot 信息等等。\n\nGossip协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的Gossip消息，常用的Gossip消息可分为：ping消息、pong消息、meet消息、fail消息\n\n- meet消息：**用于通知新节点加入**。消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换\n- ping消息：**集群内交换最频繁的消息，**集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。ping消息发送封装了自身节点和部分其他节点的状态数据\n- pong消息：当接收到ping、meet消息时，**作为响应消息回复**给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新\n- fail消息：**用于主观下线到客观下线**。判断为主观节点后就发送 fail 给其它节点 。\n\n\n\n## 雪崩、穿透和击穿\n\n雪崩：缓存管理，请求全打在数据库上，把数据库也打挂了。\n\n- 事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。\n- 事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。\n- 事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。\n\n用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 redis。如果 ehcache 和 redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 redis 中。\n\n限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？**走降级**！可以返回一些默认的值，或者友情提示，或者空白的值。\n\n好处：\n\n- 数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。\n- 只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。\n- 只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。\n\n### 缓存穿透\n\n缓存穿透，即黑客发几千个不存在的恶意攻击请求。缓存中查不到，会直接去数据库里查（当然也查不到）。但**这种恶意攻击场景的缓存穿透就会直接把数据库给打死。**\n\n解决：每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 `set -999 UNKNOWN`。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。\n\n但是如果**key是随机生成**的，这样的做法就用处不大了。可以**布隆过滤器**解决，请求过来，先调用布隆过滤器判断数据是否存在。如果不存在的数据，就不要把请求引向数据库。直接过滤掉了大量不存在的数据攻击。redis就带有bitmap哦，我猜就是做这个功能的。\n\n### 缓存击穿\n\n缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，**当这个 key 在失效的瞬间**，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。\n\n解决方式也很简单，可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。\n\n## 缓存与数据库的双写一致性\n\n问题1：先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。\n\n解决思路：**先删除缓存，再更新数据库。**如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。（每天上亿的读请求，每秒并发读几万）\n\n问题2：数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中。随后数据变更的程序完成了数据库的修改。造成不一致\n解决思路(1)：写请求先删除缓存，再去更新数据库，（异步等待段时间)再删除缓存（成功表示有脏数据出现）。这种方案读取快速，但会出现短时间的脏数据。\n\n解决思路(2)：**写请求先修改缓存为指定值，再去更新数据库**，再更新缓存。读请求过来后，先读缓存，判断是指定值后进入循环状态，等待写请求更新缓存。如果循环超时就去数据库读取数据，更新缓存。这种方案保证了读写的一致性，但是读请求会等待写操作的完成，降低了吞吐量\n\n## 分布式锁\n\n\n\n 3 个考量点：\n\n- 互斥（只能有一个客户端获取锁）\n- 不能死锁\n- 容错（只要大部分 redis 节点创建了这把锁就可以）\n\n### `setnx` \n\n```\nSET resource_name my_random_value NX PX 30000\n```\n\n- `NX`：表示只有 `key` 不存在的时候才会设置成功。（如果此时 redis 中存在这个 key，那么设置失败，返回 `nil`）\n- `PX 30000`：意思是 30s 后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了。\n\n\n\n但这种简单的实现方式，如果单实例，就单点故障。如果是普通主从，如果主节点挂了（key 就没有了），key 还没同步到从节点，此时从节点切换为主节点，别人就可以 set key，从而拿到锁。\n\n#### RedLock 算法\n\n这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：\n\n1. 获取当前时间戳，单位是毫秒；\n2. 跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；\n3. 尝试在**大多数节点**上建立一个锁，比如 5 个节点就要求是 3 个节点 `n / 2 + 1`；\n4. 客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；\n5. 要是锁建立失败了，那么就依次之前建立过的锁删除；\n6. 只要别人建立了一把分布式锁，你就得**不断轮询去尝试获取锁**。\n\n\n\n## 其他\n\n此处笔记比较潦草简单，可略过不看。\n\n### 用redis实现一个异步队列\n\n有三种方式\n\n1.prush+lpop 非阻塞，应用层加入sleep机制\n2.prush+bpop阻塞 只能供一个消费者消费\n2.pub+sub主题订阅 无状态不保证消息一定到达 想要进阶只能用kafka消息队列\n\n\n\n### 慢查询\n\n慢查询队列：\n\n1. FIFO\n2. 固定长度，超过会丢弃\n3. 保存在内存里\n\n注意：查询的生命周期，慢查询不是发生在网络请求和排队上\n\n两个配置 \n\n- showlog-log-slower-than最慢超过多少就会记录\n- showlog-max-len队列最大长度\n\n三个命令 \n\n- 获取慢查询队列\n- 获取慢查询队列长度\n- 清空慢查询\n\n运维经验：慢查询定期持久化\n\n### pipeline\n\n流水线：redis命令是超快，但网络请求时间慢，于是有了流水线——多个命令一起请求。这样，把n次命令+n次网络请求的时间就缩减为n次命令+1次网络的时间\n\n使用建议\n1.注意每次pipeline携带数据量\n2.pipeline每次只能作用在一个Redis节点上\n3.M操作和pipeline的区别\n\n### 发布订阅\n\n三个角色：发布者(publisher)、订阅者(subscriber)、频道(channel) \n\n发布者发布消息到频道上，订阅者订阅频道就会收到消息\n\n#### API\n\npublish\nunsubscribe\nsubscribe\n\n与消息队列的区别：不是专业的，不能保证消息的可靠。新上线的订阅者不会收到以前的消息。\n\n与生产消费模式的区别：生产消费模式中，发布者发布一条，只有一个订阅者能够收到。而redis相当于一个广播，每一个订阅者都能收到。","source":"_posts/redis.md","raw":"---\ntitle: 一文掌握redis\ndate: 2019-11-01 16:36:50\ncategories: 秋招\ndescription: 写得比较完善的一篇笔记，应该有把握住一些重点。\n\n---\n\n\n\n[TOC]\n\n\n## 数据类型\n\nredis 主要有以下几种数据类型：\n\n|          | String字符串   | Hash                         | list                     | set                  | sort set |\n| -------- | -------------- | ---------------------------- | ------------------------ | -------------------- | -------- |\n| 存储方式 | K,V            | 结构存储                     | 有序                     | 无序和去重】、       | 排序列表 |\n| 应用     | 万物皆可字符串 | 存对象（但不可有对象的引用） | 粉丝、关注、评论         | 点赞人，全局过滤去重 | 排行榜   |\n| 技巧     |                | 可对象的操作字段             | lrange分页，bpop阻塞队列 | 交集并集差集、       |          |\n\n\n\n## 为啥 redis 效率这么高？\n\n- 纯内存操作。\n- 核心是基于非阻塞的 IO 多路复用机制。\n- C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。\n- 单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。\n\n## 过期策略\n\n- 往 redis 写入的数据怎么没了？\n\n内存是有限的，比如 redis 就只能用 10G，你要是往里面写了 20G 的数据，会干掉 10G 的数据，然后就保留 10G 的数据了。\n\n- 数据明明过期了，怎么还占用着内存？\n\n这是由 redis 的过期策略来决定。\n\n\n\n### redis 过期策略\n\nredis 过期策略是：**定期删除+惰性删除**。\n\n所谓**定期删除**，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。\n\n**惰性删除**:获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。\n\n如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？答案是：**走内存淘汰机制**。\n\n### 内存淘汰机制\n\nredis 内存淘汰机制有以下几个：\n\n- noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。\n- **allkeys-lru**：当内存不足以容纳新写入数据时，在**键空间**中，移除最近最少使用的 key（这个是**最常用**的）。\n- allkeys-random：当内存不足以容纳新写入数据时，在**键空间**中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。\n- volatile-lru：当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，移除最近最少使用的 key（这个一般不太合适）。\n- volatile-random：当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，**随机移除**某个 key。\n- volatile-ttl：当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，有**更早过期时间**的 key 优先移除。\n\n\n\n## 持久化\n\n- RDB：RDB 持久化机制，是对 redis 中的数据执行**周期性**的持久化。\n- AOF：AOF 机制对每条写入命令作为日志，以 `append-only` 的模式写入一个日志文件中，在 redis 重启的时候，可以通过**回放** AOF 日志中的写入指令来重新构建整个数据集。\n\n|      | 如何持久化   | 丢失数据                 | 写入性能               | 文件大小           | 恢复速度 | 场景           |\n| ---- | ------------ | ------------------------ | ---------------------- | ------------------ | -------- | -------------- |\n| RDB  | 数据周期存储 | 容易丢失                 | 低                     | 小                 | 快       | 冷备           |\n| AOF  | 指令重新构建 | 不容易（只丢失最近一秒） | 高，没有磁盘寻址的开销 | 大，文件是逐渐大的 | 慢       | 误删的紧急恢复 |\n\n\n\n### RDB 快照（保存值）\n\n触发机制\n\n1.全量复制：主从复制的时候，主会自动生成RDB文件\n2.debug reload：不需要将内存清空的重启也会触发RDB的生成\n3.shutdown，关闭的时候会自动生成shutdown save\n\n三种命令\n\nsave（同步）数据进行完整的拷贝的话可能会阻塞注命令\nbgsave(异步)生成子进程去完成RDB的生成\n自动：满足900秒有1个改变、300秒有10个，60秒有1000个改变一条件就进行save\n\n场景：冷备\n\n\n\n### AOF 日志（保存命令）\n\n这个文件是逐渐增大的。\n\n三种策略：always everysec no（os决定）\n\n AOF重写：把一些过期的命令进行优化。\n\n场景：误删的紧急处理。比如某人不小心用 `flushall` 命令清空了所有数据，只要这个时候后台 `rewrite` 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 `flushall` 命令给删了，然后再将该 `AOF` 文件放回去，就可以通过恢复机制，自动恢复所有数据。\n\n### RDB 和 AOF 到底该如何选择\n\n- 仅仅使用 RDB，因为那样会导致你丢失很多数据；\n\n- 仅仅使用 AOF有两个问题：第一， AOF 没有 RDB 做冷备来的**恢复速度**更快；第二，RDB 每次简单粗暴生成数据快照，**更加健壮**，可以避免 AOF 这种复杂的备份和恢复机制的 bug；\n\n- redis 支持同时开启开启两种持久化方式，我用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。另外，如果同时使用 RDB 和 AOF 两种持久化机制，**redis** 重启的时候，会使用 **AOF** 来重新构建数据，因为 AOF 中的**数据更加完整**。\n\n  \n\n## 主从复制\n\n数据流是单项的，从master到slave\n\n### 开启 master 的持久化\n\n如果用 slave node 作为 master node 的数据热备可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。\n\n另外，master 的各种备份方案，也需要做。**万一本地的所有文件丢失了**，从备份中挑选一份 rdb 去恢复 master，这样才能**确保启动的时候，是有数据的**\n\n### 心跳检测\n\n主从节点互相都会发送 heartbeat 信息。\n\nmaster 默认每隔 10秒 发送一次 heartbeat\n\n而slave 呢：\n\n- slave node 每隔 1秒 发送一个 heartbeat。并检查是否有新的 master node 要连接和复制。\n- 如果有， slave node 发送 `ping` 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。\n- master node **第一次执行全量复制**，将所有数据发给 slave node。\n- 而在后续，master node 持续将写命令，**异步复制**给 slave node。\n\n### 每次写请求异步复制\n\nmaster 每次接收到写命令之后，先在内部写入数据，然后**异步**发送给 slave node。\n\n\n\n### 全量复制\n\n- 从服务器向主服务器发送PSYNC命令，；第一次的话，slave不知道master 的 runid，所以是？,偏移量是-1\n\n2. 主服务器验证runid和自身runid是否一致，如不一致，则进行全量复制；\n3. Master把自己的runid和offset（偏移量）发给slave，slave保存起来\n4. 使用bgsave生成RDB文件。\n\n- 由于bgsave是异步的过程，master还可以继续写数据，这一段时间的操作放入缓冲区。\n- 通过网络磁盘传去，再把缓冲区数据传去。\n- Salve会先清除原来的数据，加载RDB和缓冲区数据，写入本地磁盘，然后再从本地磁盘加载到内存\n\n过程如下图：\n![这里写图片描述](http://javaduqing.oss-cn-hangzhou.aliyuncs.com/QiuniuTransfer/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-5.png)\n\n\n\n#### **开销**\n\n包括以下几个方面：\n\n1. bgsave时间\n2. RDB文件网络传输时间\n3. 从节点清空数据时间\n4. 从节点加载RDB数据时间\n\n\n\n\n\n### 部分复制（增量复制）\n\n部分复制过程如下图：\n![这里写图片描述](http://javaduqing.oss-cn-hangzhou.aliyuncs.com/QiuniuTransfer/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-6.png)\n\n**部分复制的过程：**\n\n1. 当网络发生抖动，slave向master发送连接\n\n2. 要求同步master数据，同时自己的传递偏移量和master runid\n\n3. 如果runid一致，则查看slave的偏移量和master的偏移量是否一直。如果不一致，则观察偏移量是否超过repl_back_buffer中能存储的数据。\n\n4. 如果超过则可能进行全量复制\n\n5. 如果未超过则，将repl_back_buffer中存储的数据发送给slave，slave完成数据的同步\n\n   \n\n## 哨兵保证高可用\n\n哨兵使用是raft协议在宕机时的选举保障集群高可用，raft是一个强一致性算法。\n\n用**流言协议**（gossip protocols)来接收关于主服务器是否下线的信息。\n\n### 三个定时任务\n\n（1）**每隔10s确认主从关系。**每个sentinel会对master节点和slave节点执行info命令，作用就是发现slave节点。当一个主服务器被 Sentinel 标记为客观下线时， Sentinel 向下线主服务器的所有从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。\n\n（2）**每隔两秒，sentinel都会通过master节点内部的channel来交换信息（基于发布订阅）**。 信息包括Sentinel 的 IP 地址、端口号和运行 ID （runid），互相感知到其他的哨兵的存在。\n\n（3） **每隔一秒每个sentinel对其他的redis节点（master，slave，sentinel）执行ping操作**，对于master来说，若超过30s内没有回复，就对该master进行主观下线并询问其他的Sentinel节点是否可以客观下线。\n\n### 主观下线和 客观下线\n\n- sdown 是主观宕机，就一个哨兵如果自己觉得一个 master 宕机了，那么就是主观宕机\n- odown 是客观宕机，如果 quorum 数量的哨兵都觉得一个 master 宕机了，那么就是客观宕机\n\nsdown 达成的条件很简单，如果一个哨兵 ping 一个 master，超过了 `is-master-down-after-milliseconds` 指定的毫秒数之后，就主观认为 master 宕机了；如果一个哨兵在指定时间内，收到了 quorum 数量的其它哨兵也认为那个 master 是 sdown 的，那么就认为是 odown 了。\n\n\n\n### sentinel领导选举与法定人数\n\n。原因:只有一个sentinel节点完成故障转移\n。选举:通过sentinel is-master-down-by-addr命令申请成为领导者\n\n1.    每个做主观下线的Sentinel节点向其他Sentinel节点发送命令,要求将它设置为领导者。\n2.    收到命令的Sentinel节点如果没有同意通过其他Sentinel节点发送命令,那么将同意该请求，否则拒绝。\n3.    如果该Sentinel节点发现自己的票数已经超过Sentinel集合半数且超过quorum,那么它将成为领导者。\n4.    如果此过程有多个Sentinel节点成为了领导者,那么将等待一段时间重新进行选举。\n\n备注：quorum可以在sentinel的conf里配置,后面的2就是法定人数\n\n```\nsentinel monitor mymaster 127.0.0.1 6379 2\n```\n\n法定人数需要比一般的哨兵数还大，如果小于，法定人数为一半以上的哨兵数。\n\n如果 quorum < majority，比如 5 个哨兵，majority 就是 3，quorum 设置为 2，那么就 3 个哨兵授权就可以执行切换。\n\n但是如果 quorum >= majority，那么必须 quorum 数量的哨兵都授权，比如 5 个哨兵，quorum 是 5，那么必须 5 个哨兵都同意授权，才能执行切换。\n\n### master选举算法\n\n如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换\n\n首先如果一个 slave 跟 master 断开连接的时间已经超过了 `down-after-milliseconds` 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。\n\n```\n(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state\n```\n\n接下来会对 slave 进行排序：\n\n- 按照 slave 优先级进行排序，slave priority 越低，**优先级**就越高。\n- 如果 slave priority 相同，那么看 replica **offset**，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。\n- 如果上面两个条件都相同，那么选择一个 **run id** 比较小的那个 slave。\n\n### slave 配置的自动纠正\n\n哨兵会负责自动纠正 slave 的一些配置，比如 slave 如果要成为潜在的 master 候选人，哨兵会确保 slave 复制现有 master 的数据；如果 slave 连接到了一个错误的 master 上，比如故障转移之后，那么哨兵会确保它们连接到正确的 master 上。\n\nslave上升为master日志中可以发现，这一条配置重写的日志\n\n```\n989:M 21 Aug 19:20:42.729 # CONFIG REWRITE executed with success.\n```\n\n## 数据丢失\n\n### 脑裂\n\n脑裂，某个 master 掉线了一会，但是实际上还运行着。此时哨兵可能就会认为 master 宕机了，然后开启选举，集群里就会有两个 master ，也就是所谓的脑裂。 client 还没来得及切换到新的 master，还继续向旧 master 写数据。因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master 并没有后来 client 写入的数据，因此，这部分数据也就丢失了。\n\n解决方案\n\n进行如下配置：\n\n```bash\nmin-slaves-to-write 1\nmin-slaves-max-lag 10\n```\n\n表示，要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒。\n\n如果说一旦所有的 slave，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，master 就不会再接收任何请求了。在脑裂场景下，最多就丢失 10 秒的数据。\n\n### 异步复制\n\n因为 master->slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了。\n\n## Redis 集群\n\n数据分片：按某种规则对海量数据划分，分散存储多个结点上。\n\n常见的数据分布方式有两种\n\n1. 哈希分布：分散高，与业务无关，无法顺序访问\n2. 顺序分布：分散低易倾斜，与业务有关，可顺序访问\n\nredis哈希分布，但不是简单的取模，因为这样动态的添加/删除结点会大费周章\n\n### 一致性哈希分区\n\n一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。\n\n来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环**顺时针“行走”**，遇到的第一个 master 节点就是 key 所在位置。\n\n在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。\n\n**一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。**\n\n燃鹅，一致性哈希算法在**节点太少**时，容易因为节点分布不均匀而造成**缓存热点/数据倾斜**的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个**虚拟节点**。这样就实现了数据的均匀分布，负载均衡。\n\n[![consistent-hashing-algorithm](https://github.com/doocs/advanced-java/raw/master/images/consistent-hashing-algorithm.png)](https://github.com/doocs/advanced-java/blob/master/images/consistent-hashing-algorithm.png)\n\n### hash slot 算法\n\nredis cluster 有固定的 `16384` 个 hash slot，对每个 `key` 计算 `CRC16` 值，然后对 `16384` 取模，可以获取 key 对应的 hash slot。\n\nredis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加/减少一个 master，就将它的 hash slot 移动。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 `hash tag` 来实现。\n\n与取模分片的区别在于，hashsolt把%的数据量变大了，任何一台机器宕机，另外两个节点，不影响的。因为 key 找的是 hash slot，不是机器。\n\n[![hash-slot](https://github.com/doocs/advanced-java/raw/master/images/hash-slot.png)](https://github.com/doocs/advanced-java/blob/master/images/hash-slot.png)\n\n1. 虚拟槽分区\n\n### 高可用\n\nredis cluster 的高可用的原理，几乎跟哨兵是类似的。\n\n#### 判断节点宕机，主观+客观下线\n\ncluster-node-timeout` 内，某个节点一直没有返回 `pong`，那么就被认为 `pfail`。\n\n`pfail`，**主观宕机**。类似odown。\n\nfail，**客观宕机**。类似sdown。超过半数的节点都认为 `pfail` 了，那么就会变成 `fail`。\n\n#### 新master 选举\n\n对宕机的 master node，从其所有的 slave node 中，选择一个切换成 master node。\n\n- 断开连接的时间超过了 `cluster-node-timeout * cluster-slave-validity-factor`，**没有资格**切换成 `master`。\n- offset越大，优先进行选举。\n- 选举投票，拥有N/2 + 1票的结点选举通过成为master。\n- 从节点执行主备切换，从节点切换为主节点。\n\n与主从复制和哨兵\n\n**二者都可以做到高并发高性，用哪个主要看数据量**\n\n如果你的数据量很少就几个 G，单机就足够了，可以自己搭建一个 sentinel 集群去保证 redis 主从架构的高可用性。\n\nredis cluster，主要是针对**海量数据+高并发+高可用**的场景。redis cluster 还可以支持横向扩容更多的 master 节点。\n\n### 节点间的内部通信机制\n\n#### 基本通信原理\n\n集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。\n\n- 集中式是将集群元数据（节点信息、故障等等）集中存储在某个节点上。\n- gossip` 协议，所有节点都持有一份元数据，元数据的变更会发送给其它的节点通知变更。\n\n集中式的好处在于，元数据时效常好。不好在于，集中存储元数据有更新访问压力。\n\ngossip 正好相反。好处在于，元数据分散，降低了压力；不好在于，元数据更新滞后。\n\n#### gossip 协议\n\n- 10000 端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 `ping` 消息，同时其它几个节点接收到 `ping` 之后返回 `pong`。\n- 交换的信息：信息包括故障信息，节点的增加和删除，hash slot 信息等等。\n\nGossip协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的Gossip消息，常用的Gossip消息可分为：ping消息、pong消息、meet消息、fail消息\n\n- meet消息：**用于通知新节点加入**。消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换\n- ping消息：**集群内交换最频繁的消息，**集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。ping消息发送封装了自身节点和部分其他节点的状态数据\n- pong消息：当接收到ping、meet消息时，**作为响应消息回复**给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新\n- fail消息：**用于主观下线到客观下线**。判断为主观节点后就发送 fail 给其它节点 。\n\n\n\n## 雪崩、穿透和击穿\n\n雪崩：缓存管理，请求全打在数据库上，把数据库也打挂了。\n\n- 事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。\n- 事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。\n- 事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。\n\n用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 redis。如果 ehcache 和 redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 redis 中。\n\n限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？**走降级**！可以返回一些默认的值，或者友情提示，或者空白的值。\n\n好处：\n\n- 数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。\n- 只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。\n- 只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。\n\n### 缓存穿透\n\n缓存穿透，即黑客发几千个不存在的恶意攻击请求。缓存中查不到，会直接去数据库里查（当然也查不到）。但**这种恶意攻击场景的缓存穿透就会直接把数据库给打死。**\n\n解决：每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 `set -999 UNKNOWN`。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。\n\n但是如果**key是随机生成**的，这样的做法就用处不大了。可以**布隆过滤器**解决，请求过来，先调用布隆过滤器判断数据是否存在。如果不存在的数据，就不要把请求引向数据库。直接过滤掉了大量不存在的数据攻击。redis就带有bitmap哦，我猜就是做这个功能的。\n\n### 缓存击穿\n\n缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，**当这个 key 在失效的瞬间**，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。\n\n解决方式也很简单，可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。\n\n## 缓存与数据库的双写一致性\n\n问题1：先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。\n\n解决思路：**先删除缓存，再更新数据库。**如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。（每天上亿的读请求，每秒并发读几万）\n\n问题2：数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中。随后数据变更的程序完成了数据库的修改。造成不一致\n解决思路(1)：写请求先删除缓存，再去更新数据库，（异步等待段时间)再删除缓存（成功表示有脏数据出现）。这种方案读取快速，但会出现短时间的脏数据。\n\n解决思路(2)：**写请求先修改缓存为指定值，再去更新数据库**，再更新缓存。读请求过来后，先读缓存，判断是指定值后进入循环状态，等待写请求更新缓存。如果循环超时就去数据库读取数据，更新缓存。这种方案保证了读写的一致性，但是读请求会等待写操作的完成，降低了吞吐量\n\n## 分布式锁\n\n\n\n 3 个考量点：\n\n- 互斥（只能有一个客户端获取锁）\n- 不能死锁\n- 容错（只要大部分 redis 节点创建了这把锁就可以）\n\n### `setnx` \n\n```\nSET resource_name my_random_value NX PX 30000\n```\n\n- `NX`：表示只有 `key` 不存在的时候才会设置成功。（如果此时 redis 中存在这个 key，那么设置失败，返回 `nil`）\n- `PX 30000`：意思是 30s 后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了。\n\n\n\n但这种简单的实现方式，如果单实例，就单点故障。如果是普通主从，如果主节点挂了（key 就没有了），key 还没同步到从节点，此时从节点切换为主节点，别人就可以 set key，从而拿到锁。\n\n#### RedLock 算法\n\n这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：\n\n1. 获取当前时间戳，单位是毫秒；\n2. 跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；\n3. 尝试在**大多数节点**上建立一个锁，比如 5 个节点就要求是 3 个节点 `n / 2 + 1`；\n4. 客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；\n5. 要是锁建立失败了，那么就依次之前建立过的锁删除；\n6. 只要别人建立了一把分布式锁，你就得**不断轮询去尝试获取锁**。\n\n\n\n## 其他\n\n此处笔记比较潦草简单，可略过不看。\n\n### 用redis实现一个异步队列\n\n有三种方式\n\n1.prush+lpop 非阻塞，应用层加入sleep机制\n2.prush+bpop阻塞 只能供一个消费者消费\n2.pub+sub主题订阅 无状态不保证消息一定到达 想要进阶只能用kafka消息队列\n\n\n\n### 慢查询\n\n慢查询队列：\n\n1. FIFO\n2. 固定长度，超过会丢弃\n3. 保存在内存里\n\n注意：查询的生命周期，慢查询不是发生在网络请求和排队上\n\n两个配置 \n\n- showlog-log-slower-than最慢超过多少就会记录\n- showlog-max-len队列最大长度\n\n三个命令 \n\n- 获取慢查询队列\n- 获取慢查询队列长度\n- 清空慢查询\n\n运维经验：慢查询定期持久化\n\n### pipeline\n\n流水线：redis命令是超快，但网络请求时间慢，于是有了流水线——多个命令一起请求。这样，把n次命令+n次网络请求的时间就缩减为n次命令+1次网络的时间\n\n使用建议\n1.注意每次pipeline携带数据量\n2.pipeline每次只能作用在一个Redis节点上\n3.M操作和pipeline的区别\n\n### 发布订阅\n\n三个角色：发布者(publisher)、订阅者(subscriber)、频道(channel) \n\n发布者发布消息到频道上，订阅者订阅频道就会收到消息\n\n#### API\n\npublish\nunsubscribe\nsubscribe\n\n与消息队列的区别：不是专业的，不能保证消息的可靠。新上线的订阅者不会收到以前的消息。\n\n与生产消费模式的区别：生产消费模式中，发布者发布一条，只有一个订阅者能够收到。而redis相当于一个广播，每一个订阅者都能收到。","slug":"redis","published":1,"updated":"2022-07-08T14:11:19.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qkk001aw9rpos5j07h3","content":"<p>[TOC]</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>redis 主要有以下几种数据类型：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>String字符串</th>\n<th>Hash</th>\n<th>list</th>\n<th>set</th>\n<th>sort set</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>存储方式</td>\n<td>K,V</td>\n<td>结构存储</td>\n<td>有序</td>\n<td>无序和去重】、</td>\n<td>排序列表</td>\n</tr>\n<tr>\n<td>应用</td>\n<td>万物皆可字符串</td>\n<td>存对象（但不可有对象的引用）</td>\n<td>粉丝、关注、评论</td>\n<td>点赞人，全局过滤去重</td>\n<td>排行榜</td>\n</tr>\n<tr>\n<td>技巧</td>\n<td></td>\n<td>可对象的操作字段</td>\n<td>lrange分页，bpop阻塞队列</td>\n<td>交集并集差集、</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"为啥-redis-效率这么高？\"><a href=\"#为啥-redis-效率这么高？\" class=\"headerlink\" title=\"为啥 redis 效率这么高？\"></a>为啥 redis 效率这么高？</h2><ul>\n<li>纯内存操作。</li>\n<li>核心是基于非阻塞的 IO 多路复用机制。</li>\n<li>C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。</li>\n<li>单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。</li>\n</ul>\n<h2 id=\"过期策略\"><a href=\"#过期策略\" class=\"headerlink\" title=\"过期策略\"></a>过期策略</h2><ul>\n<li>往 redis 写入的数据怎么没了？</li>\n</ul>\n<p>内存是有限的，比如 redis 就只能用 10G，你要是往里面写了 20G 的数据，会干掉 10G 的数据，然后就保留 10G 的数据了。</p>\n<ul>\n<li>数据明明过期了，怎么还占用着内存？</li>\n</ul>\n<p>这是由 redis 的过期策略来决定。</p>\n<h3 id=\"redis-过期策略\"><a href=\"#redis-过期策略\" class=\"headerlink\" title=\"redis 过期策略\"></a>redis 过期策略</h3><p>redis 过期策略是：<strong>定期删除+惰性删除</strong>。</p>\n<p>所谓<strong>定期删除</strong>，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。</p>\n<p><strong>惰性删除</strong>:获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。</p>\n<p>如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？答案是：<strong>走内存淘汰机制</strong>。</p>\n<h3 id=\"内存淘汰机制\"><a href=\"#内存淘汰机制\" class=\"headerlink\" title=\"内存淘汰机制\"></a>内存淘汰机制</h3><p>redis 内存淘汰机制有以下几个：</p>\n<ul>\n<li>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。</li>\n<li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，移除最近最少使用的 key（这个是<strong>最常用</strong>的）。</li>\n<li>allkeys-random：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。</li>\n<li>volatile-lru：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，移除最近最少使用的 key（这个一般不太合适）。</li>\n<li>volatile-random：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，<strong>随机移除</strong>某个 key。</li>\n<li>volatile-ttl：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，有<strong>更早过期时间</strong>的 key 优先移除。</li>\n</ul>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><ul>\n<li>RDB：RDB 持久化机制，是对 redis 中的数据执行<strong>周期性</strong>的持久化。</li>\n<li>AOF：AOF 机制对每条写入命令作为日志，以 <code>append-only</code> 的模式写入一个日志文件中，在 redis 重启的时候，可以通过<strong>回放</strong> AOF 日志中的写入指令来重新构建整个数据集。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>如何持久化</th>\n<th>丢失数据</th>\n<th>写入性能</th>\n<th>文件大小</th>\n<th>恢复速度</th>\n<th>场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RDB</td>\n<td>数据周期存储</td>\n<td>容易丢失</td>\n<td>低</td>\n<td>小</td>\n<td>快</td>\n<td>冷备</td>\n</tr>\n<tr>\n<td>AOF</td>\n<td>指令重新构建</td>\n<td>不容易（只丢失最近一秒）</td>\n<td>高，没有磁盘寻址的开销</td>\n<td>大，文件是逐渐大的</td>\n<td>慢</td>\n<td>误删的紧急恢复</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"RDB-快照（保存值）\"><a href=\"#RDB-快照（保存值）\" class=\"headerlink\" title=\"RDB 快照（保存值）\"></a>RDB 快照（保存值）</h3><p>触发机制</p>\n<p>1.全量复制：主从复制的时候，主会自动生成RDB文件<br>2.debug reload：不需要将内存清空的重启也会触发RDB的生成<br>3.shutdown，关闭的时候会自动生成shutdown save</p>\n<p>三种命令</p>\n<p>save（同步）数据进行完整的拷贝的话可能会阻塞注命令<br>bgsave(异步)生成子进程去完成RDB的生成<br>自动：满足900秒有1个改变、300秒有10个，60秒有1000个改变一条件就进行save</p>\n<p>场景：冷备</p>\n<h3 id=\"AOF-日志（保存命令）\"><a href=\"#AOF-日志（保存命令）\" class=\"headerlink\" title=\"AOF 日志（保存命令）\"></a>AOF 日志（保存命令）</h3><p>这个文件是逐渐增大的。</p>\n<p>三种策略：always everysec no（os决定）</p>\n<p> AOF重写：把一些过期的命令进行优化。</p>\n<p>场景：误删的紧急处理。比如某人不小心用 <code>flushall</code> 命令清空了所有数据，只要这个时候后台 <code>rewrite</code> 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 <code>flushall</code> 命令给删了，然后再将该 <code>AOF</code> 文件放回去，就可以通过恢复机制，自动恢复所有数据。</p>\n<h3 id=\"RDB-和-AOF-到底该如何选择\"><a href=\"#RDB-和-AOF-到底该如何选择\" class=\"headerlink\" title=\"RDB 和 AOF 到底该如何选择\"></a>RDB 和 AOF 到底该如何选择</h3><ul>\n<li><p>仅仅使用 RDB，因为那样会导致你丢失很多数据；</p>\n</li>\n<li><p>仅仅使用 AOF有两个问题：第一， AOF 没有 RDB 做冷备来的<strong>恢复速度</strong>更快；第二，RDB 每次简单粗暴生成数据快照，<strong>更加健壮</strong>，可以避免 AOF 这种复杂的备份和恢复机制的 bug；</p>\n</li>\n<li><p>redis 支持同时开启开启两种持久化方式，我用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。另外，如果同时使用 RDB 和 AOF 两种持久化机制，<strong>redis</strong> 重启的时候，会使用 <strong>AOF</strong> 来重新构建数据，因为 AOF 中的<strong>数据更加完整</strong>。</p>\n</li>\n</ul>\n<h2 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h2><p>数据流是单项的，从master到slave</p>\n<h3 id=\"开启-master-的持久化\"><a href=\"#开启-master-的持久化\" class=\"headerlink\" title=\"开启 master 的持久化\"></a>开启 master 的持久化</h3><p>如果用 slave node 作为 master node 的数据热备可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p>\n<p>另外，master 的各种备份方案，也需要做。<strong>万一本地的所有文件丢失了</strong>，从备份中挑选一份 rdb 去恢复 master，这样才能<strong>确保启动的时候，是有数据的</strong></p>\n<h3 id=\"心跳检测\"><a href=\"#心跳检测\" class=\"headerlink\" title=\"心跳检测\"></a>心跳检测</h3><p>主从节点互相都会发送 heartbeat 信息。</p>\n<p>master 默认每隔 10秒 发送一次 heartbeat</p>\n<p>而slave 呢：</p>\n<ul>\n<li>slave node 每隔 1秒 发送一个 heartbeat。并检查是否有新的 master node 要连接和复制。</li>\n<li>如果有， slave node 发送 <code>ping</code> 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。</li>\n<li>master node <strong>第一次执行全量复制</strong>，将所有数据发给 slave node。</li>\n<li>而在后续，master node 持续将写命令，<strong>异步复制</strong>给 slave node。</li>\n</ul>\n<h3 id=\"每次写请求异步复制\"><a href=\"#每次写请求异步复制\" class=\"headerlink\" title=\"每次写请求异步复制\"></a>每次写请求异步复制</h3><p>master 每次接收到写命令之后，先在内部写入数据，然后<strong>异步</strong>发送给 slave node。</p>\n<h3 id=\"全量复制\"><a href=\"#全量复制\" class=\"headerlink\" title=\"全量复制\"></a>全量复制</h3><ul>\n<li>从服务器向主服务器发送PSYNC命令，；第一次的话，slave不知道master 的 runid，所以是？,偏移量是-1</li>\n</ul>\n<ol start=\"2\">\n<li>主服务器验证runid和自身runid是否一致，如不一致，则进行全量复制；</li>\n<li>Master把自己的runid和offset（偏移量）发给slave，slave保存起来</li>\n<li>使用bgsave生成RDB文件。</li>\n</ol>\n<ul>\n<li>由于bgsave是异步的过程，master还可以继续写数据，这一段时间的操作放入缓冲区。</li>\n<li>通过网络磁盘传去，再把缓冲区数据传去。</li>\n<li>Salve会先清除原来的数据，加载RDB和缓冲区数据，写入本地磁盘，然后再从本地磁盘加载到内存</li>\n</ul>\n<p>过程如下图：<br><img src=\"http://javaduqing.oss-cn-hangzhou.aliyuncs.com/QiuniuTransfer/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-5.png\" alt=\"这里写图片描述\"></p>\n<h4 id=\"开销\"><a href=\"#开销\" class=\"headerlink\" title=\"开销\"></a><strong>开销</strong></h4><p>包括以下几个方面：</p>\n<ol>\n<li>bgsave时间</li>\n<li>RDB文件网络传输时间</li>\n<li>从节点清空数据时间</li>\n<li>从节点加载RDB数据时间</li>\n</ol>\n<h3 id=\"部分复制（增量复制）\"><a href=\"#部分复制（增量复制）\" class=\"headerlink\" title=\"部分复制（增量复制）\"></a>部分复制（增量复制）</h3><p>部分复制过程如下图：<br><img src=\"http://javaduqing.oss-cn-hangzhou.aliyuncs.com/QiuniuTransfer/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-6.png\" alt=\"这里写图片描述\"></p>\n<p><strong>部分复制的过程：</strong></p>\n<ol>\n<li><p>当网络发生抖动，slave向master发送连接</p>\n</li>\n<li><p>要求同步master数据，同时自己的传递偏移量和master runid</p>\n</li>\n<li><p>如果runid一致，则查看slave的偏移量和master的偏移量是否一直。如果不一致，则观察偏移量是否超过repl_back_buffer中能存储的数据。</p>\n</li>\n<li><p>如果超过则可能进行全量复制</p>\n</li>\n<li><p>如果未超过则，将repl_back_buffer中存储的数据发送给slave，slave完成数据的同步</p>\n</li>\n</ol>\n<h2 id=\"哨兵保证高可用\"><a href=\"#哨兵保证高可用\" class=\"headerlink\" title=\"哨兵保证高可用\"></a>哨兵保证高可用</h2><p>哨兵使用是raft协议在宕机时的选举保障集群高可用，raft是一个强一致性算法。</p>\n<p>用<strong>流言协议</strong>（gossip protocols)来接收关于主服务器是否下线的信息。</p>\n<h3 id=\"三个定时任务\"><a href=\"#三个定时任务\" class=\"headerlink\" title=\"三个定时任务\"></a>三个定时任务</h3><p>（1）<strong>每隔10s确认主从关系。</strong>每个sentinel会对master节点和slave节点执行info命令，作用就是发现slave节点。当一个主服务器被 Sentinel 标记为客观下线时， Sentinel 向下线主服务器的所有从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</p>\n<p>（2）<strong>每隔两秒，sentinel都会通过master节点内部的channel来交换信息（基于发布订阅）</strong>。 信息包括Sentinel 的 IP 地址、端口号和运行 ID （runid），互相感知到其他的哨兵的存在。</p>\n<p>（3） <strong>每隔一秒每个sentinel对其他的redis节点（master，slave，sentinel）执行ping操作</strong>，对于master来说，若超过30s内没有回复，就对该master进行主观下线并询问其他的Sentinel节点是否可以客观下线。</p>\n<h3 id=\"主观下线和-客观下线\"><a href=\"#主观下线和-客观下线\" class=\"headerlink\" title=\"主观下线和 客观下线\"></a>主观下线和 客观下线</h3><ul>\n<li>sdown 是主观宕机，就一个哨兵如果自己觉得一个 master 宕机了，那么就是主观宕机</li>\n<li>odown 是客观宕机，如果 quorum 数量的哨兵都觉得一个 master 宕机了，那么就是客观宕机</li>\n</ul>\n<p>sdown 达成的条件很简单，如果一个哨兵 ping 一个 master，超过了 <code>is-master-down-after-milliseconds</code> 指定的毫秒数之后，就主观认为 master 宕机了；如果一个哨兵在指定时间内，收到了 quorum 数量的其它哨兵也认为那个 master 是 sdown 的，那么就认为是 odown 了。</p>\n<h3 id=\"sentinel领导选举与法定人数\"><a href=\"#sentinel领导选举与法定人数\" class=\"headerlink\" title=\"sentinel领导选举与法定人数\"></a>sentinel领导选举与法定人数</h3><p>。原因:只有一个sentinel节点完成故障转移<br>。选举:通过sentinel is-master-down-by-addr命令申请成为领导者</p>\n<ol>\n<li>每个做主观下线的Sentinel节点向其他Sentinel节点发送命令,要求将它设置为领导者。</li>\n<li>收到命令的Sentinel节点如果没有同意通过其他Sentinel节点发送命令,那么将同意该请求，否则拒绝。</li>\n<li>如果该Sentinel节点发现自己的票数已经超过Sentinel集合半数且超过quorum,那么它将成为领导者。</li>\n<li>如果此过程有多个Sentinel节点成为了领导者,那么将等待一段时间重新进行选举。</li>\n</ol>\n<p>备注：quorum可以在sentinel的conf里配置,后面的2就是法定人数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sentinel monitor mymaster 127.0.0.1 6379 2</span><br></pre></td></tr></table></figure>\n<p>法定人数需要比一般的哨兵数还大，如果小于，法定人数为一半以上的哨兵数。</p>\n<p>如果 quorum &lt; majority，比如 5 个哨兵，majority 就是 3，quorum 设置为 2，那么就 3 个哨兵授权就可以执行切换。</p>\n<p>但是如果 quorum &gt;= majority，那么必须 quorum 数量的哨兵都授权，比如 5 个哨兵，quorum 是 5，那么必须 5 个哨兵都同意授权，才能执行切换。</p>\n<h3 id=\"master选举算法\"><a href=\"#master选举算法\" class=\"headerlink\" title=\"master选举算法\"></a>master选举算法</h3><p>如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换</p>\n<p>首先如果一个 slave 跟 master 断开连接的时间已经超过了 <code>down-after-milliseconds</code> 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state</span><br></pre></td></tr></table></figure>\n<p>接下来会对 slave 进行排序：</p>\n<ul>\n<li>按照 slave 优先级进行排序，slave priority 越低，<strong>优先级</strong>就越高。</li>\n<li>如果 slave priority 相同，那么看 replica <strong>offset</strong>，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。</li>\n<li>如果上面两个条件都相同，那么选择一个 <strong>run id</strong> 比较小的那个 slave。</li>\n</ul>\n<h3 id=\"slave-配置的自动纠正\"><a href=\"#slave-配置的自动纠正\" class=\"headerlink\" title=\"slave 配置的自动纠正\"></a>slave 配置的自动纠正</h3><p>哨兵会负责自动纠正 slave 的一些配置，比如 slave 如果要成为潜在的 master 候选人，哨兵会确保 slave 复制现有 master 的数据；如果 slave 连接到了一个错误的 master 上，比如故障转移之后，那么哨兵会确保它们连接到正确的 master 上。</p>\n<p>slave上升为master日志中可以发现，这一条配置重写的日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">989:M 21 Aug 19:20:42.729 # CONFIG REWRITE executed with success.</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据丢失\"><a href=\"#数据丢失\" class=\"headerlink\" title=\"数据丢失\"></a>数据丢失</h2><h3 id=\"脑裂\"><a href=\"#脑裂\" class=\"headerlink\" title=\"脑裂\"></a>脑裂</h3><p>脑裂，某个 master 掉线了一会，但是实际上还运行着。此时哨兵可能就会认为 master 宕机了，然后开启选举，集群里就会有两个 master ，也就是所谓的脑裂。 client 还没来得及切换到新的 master，还继续向旧 master 写数据。因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master 并没有后来 client 写入的数据，因此，这部分数据也就丢失了。</p>\n<p>解决方案</p>\n<p>进行如下配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min-slaves-to-write 1</span><br><span class=\"line\">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>\n<p>表示，要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒。</p>\n<p>如果说一旦所有的 slave，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，master 就不会再接收任何请求了。在脑裂场景下，最多就丢失 10 秒的数据。</p>\n<h3 id=\"异步复制\"><a href=\"#异步复制\" class=\"headerlink\" title=\"异步复制\"></a>异步复制</h3><p>因为 master-&gt;slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了。</p>\n<h2 id=\"Redis-集群\"><a href=\"#Redis-集群\" class=\"headerlink\" title=\"Redis 集群\"></a>Redis 集群</h2><p>数据分片：按某种规则对海量数据划分，分散存储多个结点上。</p>\n<p>常见的数据分布方式有两种</p>\n<ol>\n<li>哈希分布：分散高，与业务无关，无法顺序访问</li>\n<li>顺序分布：分散低易倾斜，与业务有关，可顺序访问</li>\n</ol>\n<p>redis哈希分布，但不是简单的取模，因为这样动态的添加/删除结点会大费周章</p>\n<h3 id=\"一致性哈希分区\"><a href=\"#一致性哈希分区\" class=\"headerlink\" title=\"一致性哈希分区\"></a>一致性哈希分区</h3><p>一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。</p>\n<p>来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环<strong>顺时针“行走”</strong>，遇到的第一个 master 节点就是 key 所在位置。</p>\n<p>在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。</p>\n<p><strong>一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</strong></p>\n<p>燃鹅，一致性哈希算法在<strong>节点太少</strong>时，容易因为节点分布不均匀而造成<strong>缓存热点/数据倾斜</strong>的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个<strong>虚拟节点</strong>。这样就实现了数据的均匀分布，负载均衡。</p>\n<p><a href=\"https://github.com/doocs/advanced-java/blob/master/images/consistent-hashing-algorithm.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://github.com/doocs/advanced-java/raw/master/images/consistent-hashing-algorithm.png\" alt=\"consistent-hashing-algorithm\"></a></p>\n<h3 id=\"hash-slot-算法\"><a href=\"#hash-slot-算法\" class=\"headerlink\" title=\"hash slot 算法\"></a>hash slot 算法</h3><p>redis cluster 有固定的 <code>16384</code> 个 hash slot，对每个 <code>key</code> 计算 <code>CRC16</code> 值，然后对 <code>16384</code> 取模，可以获取 key 对应的 hash slot。</p>\n<p>redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加/减少一个 master，就将它的 hash slot 移动。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 <code>hash tag</code> 来实现。</p>\n<p>与取模分片的区别在于，hashsolt把%的数据量变大了，任何一台机器宕机，另外两个节点，不影响的。因为 key 找的是 hash slot，不是机器。</p>\n<p><a href=\"https://github.com/doocs/advanced-java/blob/master/images/hash-slot.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://github.com/doocs/advanced-java/raw/master/images/hash-slot.png\" alt=\"hash-slot\"></a></p>\n<ol>\n<li>虚拟槽分区</li>\n</ol>\n<h3 id=\"高可用\"><a href=\"#高可用\" class=\"headerlink\" title=\"高可用\"></a>高可用</h3><p>redis cluster 的高可用的原理，几乎跟哨兵是类似的。</p>\n<h4 id=\"判断节点宕机，主观-客观下线\"><a href=\"#判断节点宕机，主观-客观下线\" class=\"headerlink\" title=\"判断节点宕机，主观+客观下线\"></a>判断节点宕机，主观+客观下线</h4><p>cluster-node-timeout<code>内，某个节点一直没有返回</code>pong<code>，那么就被认为</code>pfail`。</p>\n<p><code>pfail</code>，<strong>主观宕机</strong>。类似odown。</p>\n<p>fail，<strong>客观宕机</strong>。类似sdown。超过半数的节点都认为 <code>pfail</code> 了，那么就会变成 <code>fail</code>。</p>\n<h4 id=\"新master-选举\"><a href=\"#新master-选举\" class=\"headerlink\" title=\"新master 选举\"></a>新master 选举</h4><p>对宕机的 master node，从其所有的 slave node 中，选择一个切换成 master node。</p>\n<ul>\n<li>断开连接的时间超过了 <code>cluster-node-timeout * cluster-slave-validity-factor</code>，<strong>没有资格</strong>切换成 <code>master</code>。</li>\n<li>offset越大，优先进行选举。</li>\n<li>选举投票，拥有N/2 + 1票的结点选举通过成为master。</li>\n<li>从节点执行主备切换，从节点切换为主节点。</li>\n</ul>\n<p>与主从复制和哨兵</p>\n<p><strong>二者都可以做到高并发高性，用哪个主要看数据量</strong></p>\n<p>如果你的数据量很少就几个 G，单机就足够了，可以自己搭建一个 sentinel 集群去保证 redis 主从架构的高可用性。</p>\n<p>redis cluster，主要是针对<strong>海量数据+高并发+高可用</strong>的场景。redis cluster 还可以支持横向扩容更多的 master 节点。</p>\n<h3 id=\"节点间的内部通信机制\"><a href=\"#节点间的内部通信机制\" class=\"headerlink\" title=\"节点间的内部通信机制\"></a>节点间的内部通信机制</h3><h4 id=\"基本通信原理\"><a href=\"#基本通信原理\" class=\"headerlink\" title=\"基本通信原理\"></a>基本通信原理</h4><p>集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。</p>\n<ul>\n<li>集中式是将集群元数据（节点信息、故障等等）集中存储在某个节点上。</li>\n<li>gossip` 协议，所有节点都持有一份元数据，元数据的变更会发送给其它的节点通知变更。</li>\n</ul>\n<p>集中式的好处在于，元数据时效常好。不好在于，集中存储元数据有更新访问压力。</p>\n<p>gossip 正好相反。好处在于，元数据分散，降低了压力；不好在于，元数据更新滞后。</p>\n<h4 id=\"gossip-协议\"><a href=\"#gossip-协议\" class=\"headerlink\" title=\"gossip 协议\"></a>gossip 协议</h4><ul>\n<li>10000 端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 <code>ping</code> 消息，同时其它几个节点接收到 <code>ping</code> 之后返回 <code>pong</code>。</li>\n<li>交换的信息：信息包括故障信息，节点的增加和删除，hash slot 信息等等。</li>\n</ul>\n<p>Gossip协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的Gossip消息，常用的Gossip消息可分为：ping消息、pong消息、meet消息、fail消息</p>\n<ul>\n<li>meet消息：<strong>用于通知新节点加入</strong>。消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换</li>\n<li>ping消息：<strong>集群内交换最频繁的消息，</strong>集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。ping消息发送封装了自身节点和部分其他节点的状态数据</li>\n<li>pong消息：当接收到ping、meet消息时，<strong>作为响应消息回复</strong>给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新</li>\n<li>fail消息：<strong>用于主观下线到客观下线</strong>。判断为主观节点后就发送 fail 给其它节点 。</li>\n</ul>\n<h2 id=\"雪崩、穿透和击穿\"><a href=\"#雪崩、穿透和击穿\" class=\"headerlink\" title=\"雪崩、穿透和击穿\"></a>雪崩、穿透和击穿</h2><p>雪崩：缓存管理，请求全打在数据库上，把数据库也打挂了。</p>\n<ul>\n<li>事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。</li>\n<li>事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</li>\n<li>事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li>\n</ul>\n<p>用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 redis。如果 ehcache 和 redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 redis 中。</p>\n<p>限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？<strong>走降级</strong>！可以返回一些默认的值，或者友情提示，或者空白的值。</p>\n<p>好处：</p>\n<ul>\n<li>数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。</li>\n<li>只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。</li>\n<li>只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。</li>\n</ul>\n<h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><p>缓存穿透，即黑客发几千个不存在的恶意攻击请求。缓存中查不到，会直接去数据库里查（当然也查不到）。但<strong>这种恶意攻击场景的缓存穿透就会直接把数据库给打死。</strong></p>\n<p>解决：每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 <code>set -999 UNKNOWN</code>。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。</p>\n<p>但是如果<strong>key是随机生成</strong>的，这样的做法就用处不大了。可以<strong>布隆过滤器</strong>解决，请求过来，先调用布隆过滤器判断数据是否存在。如果不存在的数据，就不要把请求引向数据库。直接过滤掉了大量不存在的数据攻击。redis就带有bitmap哦，我猜就是做这个功能的。</p>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><p>缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，<strong>当这个 key 在失效的瞬间</strong>，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</p>\n<p>解决方式也很简单，可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。</p>\n<h2 id=\"缓存与数据库的双写一致性\"><a href=\"#缓存与数据库的双写一致性\" class=\"headerlink\" title=\"缓存与数据库的双写一致性\"></a>缓存与数据库的双写一致性</h2><p>问题1：先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p>\n<p>解决思路：<strong>先删除缓存，再更新数据库。</strong>如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。（每天上亿的读请求，每秒并发读几万）</p>\n<p>问题2：数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中。随后数据变更的程序完成了数据库的修改。造成不一致<br>解决思路(1)：写请求先删除缓存，再去更新数据库，（异步等待段时间)再删除缓存（成功表示有脏数据出现）。这种方案读取快速，但会出现短时间的脏数据。</p>\n<p>解决思路(2)：<strong>写请求先修改缓存为指定值，再去更新数据库</strong>，再更新缓存。读请求过来后，先读缓存，判断是指定值后进入循环状态，等待写请求更新缓存。如果循环超时就去数据库读取数据，更新缓存。这种方案保证了读写的一致性，但是读请求会等待写操作的完成，降低了吞吐量</p>\n<h2 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h2><p> 3 个考量点：</p>\n<ul>\n<li>互斥（只能有一个客户端获取锁）</li>\n<li>不能死锁</li>\n<li>容错（只要大部分 redis 节点创建了这把锁就可以）</li>\n</ul>\n<h3 id=\"setnx\"><a href=\"#setnx\" class=\"headerlink\" title=\"setnx\"></a><code>setnx</code></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET resource_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>NX</code>：表示只有 <code>key</code> 不存在的时候才会设置成功。（如果此时 redis 中存在这个 key，那么设置失败，返回 <code>nil</code>）</li>\n<li><code>PX 30000</code>：意思是 30s 后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了。</li>\n</ul>\n<p>但这种简单的实现方式，如果单实例，就单点故障。如果是普通主从，如果主节点挂了（key 就没有了），key 还没同步到从节点，此时从节点切换为主节点，别人就可以 set key，从而拿到锁。</p>\n<h4 id=\"RedLock-算法\"><a href=\"#RedLock-算法\" class=\"headerlink\" title=\"RedLock 算法\"></a>RedLock 算法</h4><p>这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：</p>\n<ol>\n<li>获取当前时间戳，单位是毫秒；</li>\n<li>跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；</li>\n<li>尝试在<strong>大多数节点</strong>上建立一个锁，比如 5 个节点就要求是 3 个节点 <code>n / 2 + 1</code>；</li>\n<li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；</li>\n<li>要是锁建立失败了，那么就依次之前建立过的锁删除；</li>\n<li>只要别人建立了一把分布式锁，你就得<strong>不断轮询去尝试获取锁</strong>。</li>\n</ol>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>此处笔记比较潦草简单，可略过不看。</p>\n<h3 id=\"用redis实现一个异步队列\"><a href=\"#用redis实现一个异步队列\" class=\"headerlink\" title=\"用redis实现一个异步队列\"></a>用redis实现一个异步队列</h3><p>有三种方式</p>\n<p>1.prush+lpop 非阻塞，应用层加入sleep机制<br>2.prush+bpop阻塞 只能供一个消费者消费<br>2.pub+sub主题订阅 无状态不保证消息一定到达 想要进阶只能用kafka消息队列</p>\n<h3 id=\"慢查询\"><a href=\"#慢查询\" class=\"headerlink\" title=\"慢查询\"></a>慢查询</h3><p>慢查询队列：</p>\n<ol>\n<li>FIFO</li>\n<li>固定长度，超过会丢弃</li>\n<li>保存在内存里</li>\n</ol>\n<p>注意：查询的生命周期，慢查询不是发生在网络请求和排队上</p>\n<p>两个配置 </p>\n<ul>\n<li>showlog-log-slower-than最慢超过多少就会记录</li>\n<li>showlog-max-len队列最大长度</li>\n</ul>\n<p>三个命令 </p>\n<ul>\n<li>获取慢查询队列</li>\n<li>获取慢查询队列长度</li>\n<li>清空慢查询</li>\n</ul>\n<p>运维经验：慢查询定期持久化</p>\n<h3 id=\"pipeline\"><a href=\"#pipeline\" class=\"headerlink\" title=\"pipeline\"></a>pipeline</h3><p>流水线：redis命令是超快，但网络请求时间慢，于是有了流水线——多个命令一起请求。这样，把n次命令+n次网络请求的时间就缩减为n次命令+1次网络的时间</p>\n<p>使用建议<br>1.注意每次pipeline携带数据量<br>2.pipeline每次只能作用在一个Redis节点上<br>3.M操作和pipeline的区别</p>\n<h3 id=\"发布订阅\"><a href=\"#发布订阅\" class=\"headerlink\" title=\"发布订阅\"></a>发布订阅</h3><p>三个角色：发布者(publisher)、订阅者(subscriber)、频道(channel) </p>\n<p>发布者发布消息到频道上，订阅者订阅频道就会收到消息</p>\n<h4 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h4><p>publish<br>unsubscribe<br>subscribe</p>\n<p>与消息队列的区别：不是专业的，不能保证消息的可靠。新上线的订阅者不会收到以前的消息。</p>\n<p>与生产消费模式的区别：生产消费模式中，发布者发布一条，只有一个订阅者能够收到。而redis相当于一个广播，每一个订阅者都能收到。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>redis 主要有以下几种数据类型：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>String字符串</th>\n<th>Hash</th>\n<th>list</th>\n<th>set</th>\n<th>sort set</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>存储方式</td>\n<td>K,V</td>\n<td>结构存储</td>\n<td>有序</td>\n<td>无序和去重】、</td>\n<td>排序列表</td>\n</tr>\n<tr>\n<td>应用</td>\n<td>万物皆可字符串</td>\n<td>存对象（但不可有对象的引用）</td>\n<td>粉丝、关注、评论</td>\n<td>点赞人，全局过滤去重</td>\n<td>排行榜</td>\n</tr>\n<tr>\n<td>技巧</td>\n<td></td>\n<td>可对象的操作字段</td>\n<td>lrange分页，bpop阻塞队列</td>\n<td>交集并集差集、</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"为啥-redis-效率这么高？\"><a href=\"#为啥-redis-效率这么高？\" class=\"headerlink\" title=\"为啥 redis 效率这么高？\"></a>为啥 redis 效率这么高？</h2><ul>\n<li>纯内存操作。</li>\n<li>核心是基于非阻塞的 IO 多路复用机制。</li>\n<li>C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。</li>\n<li>单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。</li>\n</ul>\n<h2 id=\"过期策略\"><a href=\"#过期策略\" class=\"headerlink\" title=\"过期策略\"></a>过期策略</h2><ul>\n<li>往 redis 写入的数据怎么没了？</li>\n</ul>\n<p>内存是有限的，比如 redis 就只能用 10G，你要是往里面写了 20G 的数据，会干掉 10G 的数据，然后就保留 10G 的数据了。</p>\n<ul>\n<li>数据明明过期了，怎么还占用着内存？</li>\n</ul>\n<p>这是由 redis 的过期策略来决定。</p>\n<h3 id=\"redis-过期策略\"><a href=\"#redis-过期策略\" class=\"headerlink\" title=\"redis 过期策略\"></a>redis 过期策略</h3><p>redis 过期策略是：<strong>定期删除+惰性删除</strong>。</p>\n<p>所谓<strong>定期删除</strong>，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。</p>\n<p><strong>惰性删除</strong>:获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。</p>\n<p>如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？答案是：<strong>走内存淘汰机制</strong>。</p>\n<h3 id=\"内存淘汰机制\"><a href=\"#内存淘汰机制\" class=\"headerlink\" title=\"内存淘汰机制\"></a>内存淘汰机制</h3><p>redis 内存淘汰机制有以下几个：</p>\n<ul>\n<li>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。</li>\n<li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，移除最近最少使用的 key（这个是<strong>最常用</strong>的）。</li>\n<li>allkeys-random：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。</li>\n<li>volatile-lru：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，移除最近最少使用的 key（这个一般不太合适）。</li>\n<li>volatile-random：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，<strong>随机移除</strong>某个 key。</li>\n<li>volatile-ttl：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，有<strong>更早过期时间</strong>的 key 优先移除。</li>\n</ul>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><ul>\n<li>RDB：RDB 持久化机制，是对 redis 中的数据执行<strong>周期性</strong>的持久化。</li>\n<li>AOF：AOF 机制对每条写入命令作为日志，以 <code>append-only</code> 的模式写入一个日志文件中，在 redis 重启的时候，可以通过<strong>回放</strong> AOF 日志中的写入指令来重新构建整个数据集。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>如何持久化</th>\n<th>丢失数据</th>\n<th>写入性能</th>\n<th>文件大小</th>\n<th>恢复速度</th>\n<th>场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RDB</td>\n<td>数据周期存储</td>\n<td>容易丢失</td>\n<td>低</td>\n<td>小</td>\n<td>快</td>\n<td>冷备</td>\n</tr>\n<tr>\n<td>AOF</td>\n<td>指令重新构建</td>\n<td>不容易（只丢失最近一秒）</td>\n<td>高，没有磁盘寻址的开销</td>\n<td>大，文件是逐渐大的</td>\n<td>慢</td>\n<td>误删的紧急恢复</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"RDB-快照（保存值）\"><a href=\"#RDB-快照（保存值）\" class=\"headerlink\" title=\"RDB 快照（保存值）\"></a>RDB 快照（保存值）</h3><p>触发机制</p>\n<p>1.全量复制：主从复制的时候，主会自动生成RDB文件<br>2.debug reload：不需要将内存清空的重启也会触发RDB的生成<br>3.shutdown，关闭的时候会自动生成shutdown save</p>\n<p>三种命令</p>\n<p>save（同步）数据进行完整的拷贝的话可能会阻塞注命令<br>bgsave(异步)生成子进程去完成RDB的生成<br>自动：满足900秒有1个改变、300秒有10个，60秒有1000个改变一条件就进行save</p>\n<p>场景：冷备</p>\n<h3 id=\"AOF-日志（保存命令）\"><a href=\"#AOF-日志（保存命令）\" class=\"headerlink\" title=\"AOF 日志（保存命令）\"></a>AOF 日志（保存命令）</h3><p>这个文件是逐渐增大的。</p>\n<p>三种策略：always everysec no（os决定）</p>\n<p> AOF重写：把一些过期的命令进行优化。</p>\n<p>场景：误删的紧急处理。比如某人不小心用 <code>flushall</code> 命令清空了所有数据，只要这个时候后台 <code>rewrite</code> 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 <code>flushall</code> 命令给删了，然后再将该 <code>AOF</code> 文件放回去，就可以通过恢复机制，自动恢复所有数据。</p>\n<h3 id=\"RDB-和-AOF-到底该如何选择\"><a href=\"#RDB-和-AOF-到底该如何选择\" class=\"headerlink\" title=\"RDB 和 AOF 到底该如何选择\"></a>RDB 和 AOF 到底该如何选择</h3><ul>\n<li><p>仅仅使用 RDB，因为那样会导致你丢失很多数据；</p>\n</li>\n<li><p>仅仅使用 AOF有两个问题：第一， AOF 没有 RDB 做冷备来的<strong>恢复速度</strong>更快；第二，RDB 每次简单粗暴生成数据快照，<strong>更加健壮</strong>，可以避免 AOF 这种复杂的备份和恢复机制的 bug；</p>\n</li>\n<li><p>redis 支持同时开启开启两种持久化方式，我用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。另外，如果同时使用 RDB 和 AOF 两种持久化机制，<strong>redis</strong> 重启的时候，会使用 <strong>AOF</strong> 来重新构建数据，因为 AOF 中的<strong>数据更加完整</strong>。</p>\n</li>\n</ul>\n<h2 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h2><p>数据流是单项的，从master到slave</p>\n<h3 id=\"开启-master-的持久化\"><a href=\"#开启-master-的持久化\" class=\"headerlink\" title=\"开启 master 的持久化\"></a>开启 master 的持久化</h3><p>如果用 slave node 作为 master node 的数据热备可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p>\n<p>另外，master 的各种备份方案，也需要做。<strong>万一本地的所有文件丢失了</strong>，从备份中挑选一份 rdb 去恢复 master，这样才能<strong>确保启动的时候，是有数据的</strong></p>\n<h3 id=\"心跳检测\"><a href=\"#心跳检测\" class=\"headerlink\" title=\"心跳检测\"></a>心跳检测</h3><p>主从节点互相都会发送 heartbeat 信息。</p>\n<p>master 默认每隔 10秒 发送一次 heartbeat</p>\n<p>而slave 呢：</p>\n<ul>\n<li>slave node 每隔 1秒 发送一个 heartbeat。并检查是否有新的 master node 要连接和复制。</li>\n<li>如果有， slave node 发送 <code>ping</code> 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。</li>\n<li>master node <strong>第一次执行全量复制</strong>，将所有数据发给 slave node。</li>\n<li>而在后续，master node 持续将写命令，<strong>异步复制</strong>给 slave node。</li>\n</ul>\n<h3 id=\"每次写请求异步复制\"><a href=\"#每次写请求异步复制\" class=\"headerlink\" title=\"每次写请求异步复制\"></a>每次写请求异步复制</h3><p>master 每次接收到写命令之后，先在内部写入数据，然后<strong>异步</strong>发送给 slave node。</p>\n<h3 id=\"全量复制\"><a href=\"#全量复制\" class=\"headerlink\" title=\"全量复制\"></a>全量复制</h3><ul>\n<li>从服务器向主服务器发送PSYNC命令，；第一次的话，slave不知道master 的 runid，所以是？,偏移量是-1</li>\n</ul>\n<ol start=\"2\">\n<li>主服务器验证runid和自身runid是否一致，如不一致，则进行全量复制；</li>\n<li>Master把自己的runid和offset（偏移量）发给slave，slave保存起来</li>\n<li>使用bgsave生成RDB文件。</li>\n</ol>\n<ul>\n<li>由于bgsave是异步的过程，master还可以继续写数据，这一段时间的操作放入缓冲区。</li>\n<li>通过网络磁盘传去，再把缓冲区数据传去。</li>\n<li>Salve会先清除原来的数据，加载RDB和缓冲区数据，写入本地磁盘，然后再从本地磁盘加载到内存</li>\n</ul>\n<p>过程如下图：<br><img src=\"http://javaduqing.oss-cn-hangzhou.aliyuncs.com/QiuniuTransfer/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-5.png\" alt=\"这里写图片描述\"></p>\n<h4 id=\"开销\"><a href=\"#开销\" class=\"headerlink\" title=\"开销\"></a><strong>开销</strong></h4><p>包括以下几个方面：</p>\n<ol>\n<li>bgsave时间</li>\n<li>RDB文件网络传输时间</li>\n<li>从节点清空数据时间</li>\n<li>从节点加载RDB数据时间</li>\n</ol>\n<h3 id=\"部分复制（增量复制）\"><a href=\"#部分复制（增量复制）\" class=\"headerlink\" title=\"部分复制（增量复制）\"></a>部分复制（增量复制）</h3><p>部分复制过程如下图：<br><img src=\"http://javaduqing.oss-cn-hangzhou.aliyuncs.com/QiuniuTransfer/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-6.png\" alt=\"这里写图片描述\"></p>\n<p><strong>部分复制的过程：</strong></p>\n<ol>\n<li><p>当网络发生抖动，slave向master发送连接</p>\n</li>\n<li><p>要求同步master数据，同时自己的传递偏移量和master runid</p>\n</li>\n<li><p>如果runid一致，则查看slave的偏移量和master的偏移量是否一直。如果不一致，则观察偏移量是否超过repl_back_buffer中能存储的数据。</p>\n</li>\n<li><p>如果超过则可能进行全量复制</p>\n</li>\n<li><p>如果未超过则，将repl_back_buffer中存储的数据发送给slave，slave完成数据的同步</p>\n</li>\n</ol>\n<h2 id=\"哨兵保证高可用\"><a href=\"#哨兵保证高可用\" class=\"headerlink\" title=\"哨兵保证高可用\"></a>哨兵保证高可用</h2><p>哨兵使用是raft协议在宕机时的选举保障集群高可用，raft是一个强一致性算法。</p>\n<p>用<strong>流言协议</strong>（gossip protocols)来接收关于主服务器是否下线的信息。</p>\n<h3 id=\"三个定时任务\"><a href=\"#三个定时任务\" class=\"headerlink\" title=\"三个定时任务\"></a>三个定时任务</h3><p>（1）<strong>每隔10s确认主从关系。</strong>每个sentinel会对master节点和slave节点执行info命令，作用就是发现slave节点。当一个主服务器被 Sentinel 标记为客观下线时， Sentinel 向下线主服务器的所有从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</p>\n<p>（2）<strong>每隔两秒，sentinel都会通过master节点内部的channel来交换信息（基于发布订阅）</strong>。 信息包括Sentinel 的 IP 地址、端口号和运行 ID （runid），互相感知到其他的哨兵的存在。</p>\n<p>（3） <strong>每隔一秒每个sentinel对其他的redis节点（master，slave，sentinel）执行ping操作</strong>，对于master来说，若超过30s内没有回复，就对该master进行主观下线并询问其他的Sentinel节点是否可以客观下线。</p>\n<h3 id=\"主观下线和-客观下线\"><a href=\"#主观下线和-客观下线\" class=\"headerlink\" title=\"主观下线和 客观下线\"></a>主观下线和 客观下线</h3><ul>\n<li>sdown 是主观宕机，就一个哨兵如果自己觉得一个 master 宕机了，那么就是主观宕机</li>\n<li>odown 是客观宕机，如果 quorum 数量的哨兵都觉得一个 master 宕机了，那么就是客观宕机</li>\n</ul>\n<p>sdown 达成的条件很简单，如果一个哨兵 ping 一个 master，超过了 <code>is-master-down-after-milliseconds</code> 指定的毫秒数之后，就主观认为 master 宕机了；如果一个哨兵在指定时间内，收到了 quorum 数量的其它哨兵也认为那个 master 是 sdown 的，那么就认为是 odown 了。</p>\n<h3 id=\"sentinel领导选举与法定人数\"><a href=\"#sentinel领导选举与法定人数\" class=\"headerlink\" title=\"sentinel领导选举与法定人数\"></a>sentinel领导选举与法定人数</h3><p>。原因:只有一个sentinel节点完成故障转移<br>。选举:通过sentinel is-master-down-by-addr命令申请成为领导者</p>\n<ol>\n<li>每个做主观下线的Sentinel节点向其他Sentinel节点发送命令,要求将它设置为领导者。</li>\n<li>收到命令的Sentinel节点如果没有同意通过其他Sentinel节点发送命令,那么将同意该请求，否则拒绝。</li>\n<li>如果该Sentinel节点发现自己的票数已经超过Sentinel集合半数且超过quorum,那么它将成为领导者。</li>\n<li>如果此过程有多个Sentinel节点成为了领导者,那么将等待一段时间重新进行选举。</li>\n</ol>\n<p>备注：quorum可以在sentinel的conf里配置,后面的2就是法定人数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sentinel monitor mymaster 127.0.0.1 6379 2</span><br></pre></td></tr></table></figure>\n<p>法定人数需要比一般的哨兵数还大，如果小于，法定人数为一半以上的哨兵数。</p>\n<p>如果 quorum &lt; majority，比如 5 个哨兵，majority 就是 3，quorum 设置为 2，那么就 3 个哨兵授权就可以执行切换。</p>\n<p>但是如果 quorum &gt;= majority，那么必须 quorum 数量的哨兵都授权，比如 5 个哨兵，quorum 是 5，那么必须 5 个哨兵都同意授权，才能执行切换。</p>\n<h3 id=\"master选举算法\"><a href=\"#master选举算法\" class=\"headerlink\" title=\"master选举算法\"></a>master选举算法</h3><p>如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换</p>\n<p>首先如果一个 slave 跟 master 断开连接的时间已经超过了 <code>down-after-milliseconds</code> 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state</span><br></pre></td></tr></table></figure>\n<p>接下来会对 slave 进行排序：</p>\n<ul>\n<li>按照 slave 优先级进行排序，slave priority 越低，<strong>优先级</strong>就越高。</li>\n<li>如果 slave priority 相同，那么看 replica <strong>offset</strong>，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。</li>\n<li>如果上面两个条件都相同，那么选择一个 <strong>run id</strong> 比较小的那个 slave。</li>\n</ul>\n<h3 id=\"slave-配置的自动纠正\"><a href=\"#slave-配置的自动纠正\" class=\"headerlink\" title=\"slave 配置的自动纠正\"></a>slave 配置的自动纠正</h3><p>哨兵会负责自动纠正 slave 的一些配置，比如 slave 如果要成为潜在的 master 候选人，哨兵会确保 slave 复制现有 master 的数据；如果 slave 连接到了一个错误的 master 上，比如故障转移之后，那么哨兵会确保它们连接到正确的 master 上。</p>\n<p>slave上升为master日志中可以发现，这一条配置重写的日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">989:M 21 Aug 19:20:42.729 # CONFIG REWRITE executed with success.</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据丢失\"><a href=\"#数据丢失\" class=\"headerlink\" title=\"数据丢失\"></a>数据丢失</h2><h3 id=\"脑裂\"><a href=\"#脑裂\" class=\"headerlink\" title=\"脑裂\"></a>脑裂</h3><p>脑裂，某个 master 掉线了一会，但是实际上还运行着。此时哨兵可能就会认为 master 宕机了，然后开启选举，集群里就会有两个 master ，也就是所谓的脑裂。 client 还没来得及切换到新的 master，还继续向旧 master 写数据。因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master 并没有后来 client 写入的数据，因此，这部分数据也就丢失了。</p>\n<p>解决方案</p>\n<p>进行如下配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min-slaves-to-write 1</span><br><span class=\"line\">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>\n<p>表示，要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒。</p>\n<p>如果说一旦所有的 slave，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，master 就不会再接收任何请求了。在脑裂场景下，最多就丢失 10 秒的数据。</p>\n<h3 id=\"异步复制\"><a href=\"#异步复制\" class=\"headerlink\" title=\"异步复制\"></a>异步复制</h3><p>因为 master-&gt;slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了。</p>\n<h2 id=\"Redis-集群\"><a href=\"#Redis-集群\" class=\"headerlink\" title=\"Redis 集群\"></a>Redis 集群</h2><p>数据分片：按某种规则对海量数据划分，分散存储多个结点上。</p>\n<p>常见的数据分布方式有两种</p>\n<ol>\n<li>哈希分布：分散高，与业务无关，无法顺序访问</li>\n<li>顺序分布：分散低易倾斜，与业务有关，可顺序访问</li>\n</ol>\n<p>redis哈希分布，但不是简单的取模，因为这样动态的添加/删除结点会大费周章</p>\n<h3 id=\"一致性哈希分区\"><a href=\"#一致性哈希分区\" class=\"headerlink\" title=\"一致性哈希分区\"></a>一致性哈希分区</h3><p>一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。</p>\n<p>来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环<strong>顺时针“行走”</strong>，遇到的第一个 master 节点就是 key 所在位置。</p>\n<p>在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。</p>\n<p><strong>一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</strong></p>\n<p>燃鹅，一致性哈希算法在<strong>节点太少</strong>时，容易因为节点分布不均匀而造成<strong>缓存热点/数据倾斜</strong>的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个<strong>虚拟节点</strong>。这样就实现了数据的均匀分布，负载均衡。</p>\n<p><a href=\"https://github.com/doocs/advanced-java/blob/master/images/consistent-hashing-algorithm.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://github.com/doocs/advanced-java/raw/master/images/consistent-hashing-algorithm.png\" alt=\"consistent-hashing-algorithm\"></a></p>\n<h3 id=\"hash-slot-算法\"><a href=\"#hash-slot-算法\" class=\"headerlink\" title=\"hash slot 算法\"></a>hash slot 算法</h3><p>redis cluster 有固定的 <code>16384</code> 个 hash slot，对每个 <code>key</code> 计算 <code>CRC16</code> 值，然后对 <code>16384</code> 取模，可以获取 key 对应的 hash slot。</p>\n<p>redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加/减少一个 master，就将它的 hash slot 移动。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 <code>hash tag</code> 来实现。</p>\n<p>与取模分片的区别在于，hashsolt把%的数据量变大了，任何一台机器宕机，另外两个节点，不影响的。因为 key 找的是 hash slot，不是机器。</p>\n<p><a href=\"https://github.com/doocs/advanced-java/blob/master/images/hash-slot.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://github.com/doocs/advanced-java/raw/master/images/hash-slot.png\" alt=\"hash-slot\"></a></p>\n<ol>\n<li>虚拟槽分区</li>\n</ol>\n<h3 id=\"高可用\"><a href=\"#高可用\" class=\"headerlink\" title=\"高可用\"></a>高可用</h3><p>redis cluster 的高可用的原理，几乎跟哨兵是类似的。</p>\n<h4 id=\"判断节点宕机，主观-客观下线\"><a href=\"#判断节点宕机，主观-客观下线\" class=\"headerlink\" title=\"判断节点宕机，主观+客观下线\"></a>判断节点宕机，主观+客观下线</h4><p>cluster-node-timeout<code>内，某个节点一直没有返回</code>pong<code>，那么就被认为</code>pfail`。</p>\n<p><code>pfail</code>，<strong>主观宕机</strong>。类似odown。</p>\n<p>fail，<strong>客观宕机</strong>。类似sdown。超过半数的节点都认为 <code>pfail</code> 了，那么就会变成 <code>fail</code>。</p>\n<h4 id=\"新master-选举\"><a href=\"#新master-选举\" class=\"headerlink\" title=\"新master 选举\"></a>新master 选举</h4><p>对宕机的 master node，从其所有的 slave node 中，选择一个切换成 master node。</p>\n<ul>\n<li>断开连接的时间超过了 <code>cluster-node-timeout * cluster-slave-validity-factor</code>，<strong>没有资格</strong>切换成 <code>master</code>。</li>\n<li>offset越大，优先进行选举。</li>\n<li>选举投票，拥有N/2 + 1票的结点选举通过成为master。</li>\n<li>从节点执行主备切换，从节点切换为主节点。</li>\n</ul>\n<p>与主从复制和哨兵</p>\n<p><strong>二者都可以做到高并发高性，用哪个主要看数据量</strong></p>\n<p>如果你的数据量很少就几个 G，单机就足够了，可以自己搭建一个 sentinel 集群去保证 redis 主从架构的高可用性。</p>\n<p>redis cluster，主要是针对<strong>海量数据+高并发+高可用</strong>的场景。redis cluster 还可以支持横向扩容更多的 master 节点。</p>\n<h3 id=\"节点间的内部通信机制\"><a href=\"#节点间的内部通信机制\" class=\"headerlink\" title=\"节点间的内部通信机制\"></a>节点间的内部通信机制</h3><h4 id=\"基本通信原理\"><a href=\"#基本通信原理\" class=\"headerlink\" title=\"基本通信原理\"></a>基本通信原理</h4><p>集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。</p>\n<ul>\n<li>集中式是将集群元数据（节点信息、故障等等）集中存储在某个节点上。</li>\n<li>gossip` 协议，所有节点都持有一份元数据，元数据的变更会发送给其它的节点通知变更。</li>\n</ul>\n<p>集中式的好处在于，元数据时效常好。不好在于，集中存储元数据有更新访问压力。</p>\n<p>gossip 正好相反。好处在于，元数据分散，降低了压力；不好在于，元数据更新滞后。</p>\n<h4 id=\"gossip-协议\"><a href=\"#gossip-协议\" class=\"headerlink\" title=\"gossip 协议\"></a>gossip 协议</h4><ul>\n<li>10000 端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 <code>ping</code> 消息，同时其它几个节点接收到 <code>ping</code> 之后返回 <code>pong</code>。</li>\n<li>交换的信息：信息包括故障信息，节点的增加和删除，hash slot 信息等等。</li>\n</ul>\n<p>Gossip协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的Gossip消息，常用的Gossip消息可分为：ping消息、pong消息、meet消息、fail消息</p>\n<ul>\n<li>meet消息：<strong>用于通知新节点加入</strong>。消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换</li>\n<li>ping消息：<strong>集群内交换最频繁的消息，</strong>集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。ping消息发送封装了自身节点和部分其他节点的状态数据</li>\n<li>pong消息：当接收到ping、meet消息时，<strong>作为响应消息回复</strong>给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新</li>\n<li>fail消息：<strong>用于主观下线到客观下线</strong>。判断为主观节点后就发送 fail 给其它节点 。</li>\n</ul>\n<h2 id=\"雪崩、穿透和击穿\"><a href=\"#雪崩、穿透和击穿\" class=\"headerlink\" title=\"雪崩、穿透和击穿\"></a>雪崩、穿透和击穿</h2><p>雪崩：缓存管理，请求全打在数据库上，把数据库也打挂了。</p>\n<ul>\n<li>事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。</li>\n<li>事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</li>\n<li>事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li>\n</ul>\n<p>用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 redis。如果 ehcache 和 redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 redis 中。</p>\n<p>限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？<strong>走降级</strong>！可以返回一些默认的值，或者友情提示，或者空白的值。</p>\n<p>好处：</p>\n<ul>\n<li>数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。</li>\n<li>只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。</li>\n<li>只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。</li>\n</ul>\n<h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><p>缓存穿透，即黑客发几千个不存在的恶意攻击请求。缓存中查不到，会直接去数据库里查（当然也查不到）。但<strong>这种恶意攻击场景的缓存穿透就会直接把数据库给打死。</strong></p>\n<p>解决：每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 <code>set -999 UNKNOWN</code>。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。</p>\n<p>但是如果<strong>key是随机生成</strong>的，这样的做法就用处不大了。可以<strong>布隆过滤器</strong>解决，请求过来，先调用布隆过滤器判断数据是否存在。如果不存在的数据，就不要把请求引向数据库。直接过滤掉了大量不存在的数据攻击。redis就带有bitmap哦，我猜就是做这个功能的。</p>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><p>缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，<strong>当这个 key 在失效的瞬间</strong>，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</p>\n<p>解决方式也很简单，可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。</p>\n<h2 id=\"缓存与数据库的双写一致性\"><a href=\"#缓存与数据库的双写一致性\" class=\"headerlink\" title=\"缓存与数据库的双写一致性\"></a>缓存与数据库的双写一致性</h2><p>问题1：先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p>\n<p>解决思路：<strong>先删除缓存，再更新数据库。</strong>如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。（每天上亿的读请求，每秒并发读几万）</p>\n<p>问题2：数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中。随后数据变更的程序完成了数据库的修改。造成不一致<br>解决思路(1)：写请求先删除缓存，再去更新数据库，（异步等待段时间)再删除缓存（成功表示有脏数据出现）。这种方案读取快速，但会出现短时间的脏数据。</p>\n<p>解决思路(2)：<strong>写请求先修改缓存为指定值，再去更新数据库</strong>，再更新缓存。读请求过来后，先读缓存，判断是指定值后进入循环状态，等待写请求更新缓存。如果循环超时就去数据库读取数据，更新缓存。这种方案保证了读写的一致性，但是读请求会等待写操作的完成，降低了吞吐量</p>\n<h2 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h2><p> 3 个考量点：</p>\n<ul>\n<li>互斥（只能有一个客户端获取锁）</li>\n<li>不能死锁</li>\n<li>容错（只要大部分 redis 节点创建了这把锁就可以）</li>\n</ul>\n<h3 id=\"setnx\"><a href=\"#setnx\" class=\"headerlink\" title=\"setnx\"></a><code>setnx</code></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET resource_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>NX</code>：表示只有 <code>key</code> 不存在的时候才会设置成功。（如果此时 redis 中存在这个 key，那么设置失败，返回 <code>nil</code>）</li>\n<li><code>PX 30000</code>：意思是 30s 后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了。</li>\n</ul>\n<p>但这种简单的实现方式，如果单实例，就单点故障。如果是普通主从，如果主节点挂了（key 就没有了），key 还没同步到从节点，此时从节点切换为主节点，别人就可以 set key，从而拿到锁。</p>\n<h4 id=\"RedLock-算法\"><a href=\"#RedLock-算法\" class=\"headerlink\" title=\"RedLock 算法\"></a>RedLock 算法</h4><p>这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：</p>\n<ol>\n<li>获取当前时间戳，单位是毫秒；</li>\n<li>跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；</li>\n<li>尝试在<strong>大多数节点</strong>上建立一个锁，比如 5 个节点就要求是 3 个节点 <code>n / 2 + 1</code>；</li>\n<li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；</li>\n<li>要是锁建立失败了，那么就依次之前建立过的锁删除；</li>\n<li>只要别人建立了一把分布式锁，你就得<strong>不断轮询去尝试获取锁</strong>。</li>\n</ol>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>此处笔记比较潦草简单，可略过不看。</p>\n<h3 id=\"用redis实现一个异步队列\"><a href=\"#用redis实现一个异步队列\" class=\"headerlink\" title=\"用redis实现一个异步队列\"></a>用redis实现一个异步队列</h3><p>有三种方式</p>\n<p>1.prush+lpop 非阻塞，应用层加入sleep机制<br>2.prush+bpop阻塞 只能供一个消费者消费<br>2.pub+sub主题订阅 无状态不保证消息一定到达 想要进阶只能用kafka消息队列</p>\n<h3 id=\"慢查询\"><a href=\"#慢查询\" class=\"headerlink\" title=\"慢查询\"></a>慢查询</h3><p>慢查询队列：</p>\n<ol>\n<li>FIFO</li>\n<li>固定长度，超过会丢弃</li>\n<li>保存在内存里</li>\n</ol>\n<p>注意：查询的生命周期，慢查询不是发生在网络请求和排队上</p>\n<p>两个配置 </p>\n<ul>\n<li>showlog-log-slower-than最慢超过多少就会记录</li>\n<li>showlog-max-len队列最大长度</li>\n</ul>\n<p>三个命令 </p>\n<ul>\n<li>获取慢查询队列</li>\n<li>获取慢查询队列长度</li>\n<li>清空慢查询</li>\n</ul>\n<p>运维经验：慢查询定期持久化</p>\n<h3 id=\"pipeline\"><a href=\"#pipeline\" class=\"headerlink\" title=\"pipeline\"></a>pipeline</h3><p>流水线：redis命令是超快，但网络请求时间慢，于是有了流水线——多个命令一起请求。这样，把n次命令+n次网络请求的时间就缩减为n次命令+1次网络的时间</p>\n<p>使用建议<br>1.注意每次pipeline携带数据量<br>2.pipeline每次只能作用在一个Redis节点上<br>3.M操作和pipeline的区别</p>\n<h3 id=\"发布订阅\"><a href=\"#发布订阅\" class=\"headerlink\" title=\"发布订阅\"></a>发布订阅</h3><p>三个角色：发布者(publisher)、订阅者(subscriber)、频道(channel) </p>\n<p>发布者发布消息到频道上，订阅者订阅频道就会收到消息</p>\n<h4 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h4><p>publish<br>unsubscribe<br>subscribe</p>\n<p>与消息队列的区别：不是专业的，不能保证消息的可靠。新上线的订阅者不会收到以前的消息。</p>\n<p>与生产消费模式的区别：生产消费模式中，发布者发布一条，只有一个订阅者能够收到。而redis相当于一个广播，每一个订阅者都能收到。</p>\n"},{"title":"布隆过滤器","date":"2019-04-16T10:00:50.000Z","top":10,"_content":"\n布隆过滤器应用于最近比较火的海量处理问题。可以快速判断一个元素在不在海量数据的集合当中。缺点是有一定的失误率，优势是占用内存较少。\n<!-- more -->\n这篇文章我也同时发布在荣哥的公众号，搬砖攻城狮。[公众号推文](https://mp.weixin.qq.com/s?__biz=MzUzNjk5NDk1OQ==&mid=2247483707&idx=1&sn=fd9d8f04edc085a9d60511fd5513fd0d&chksm=faecf4dbcd9b7dcd3dde98e71e2f447cdeb98f8b5c6a776eb7344c267bab6351c5cde169e527&mpshare=1&scene=1&srcid=0429kbCkM8nl32g91u4cjwOE&pass_ticket=o7Y28LwCkECdew2CB9ZmY%2BKd3rs%2BvSQamorjwZdBJfHahNMblqC42vSiDnvNcg%2F2#rd)\n\n## 0一道大数据黑名单题\n不安全网页的黑名单里有100亿个URL，每一个网页的URL最多占用64B。要求实现一种过滤系统，可以根据网页的URL判断是否在这个黑名单中。要求的额外的空间不能超过30GB。\n\n\n## 1布隆过滤器是什么？\n布隆过滤器本质上是一个bit数组，可以用极少的空间解决“判断在不在”这种问题。\n以这道题为例，一般的思路是将所有的URL整个都存储起来，**但是这个题目其实只需要我们判断在不在，我们根本无需存整个URL，甚至无需在意一个URL是多少字节，只需要存这个URL是“在”还是“不在”这两种状态就好了。**\n讲到这里不知读者有没联想我们计算机世界的0和1。我们完全可以用一个容器存放这两种状态，在黑名单URL用1来表示，不在黑名单用0来表示。\n接下来我们就使用布隆过滤器着手解决这道题。首先创建一个bit数组，数组里所有位置初始化都为0。然后100亿个URL每一个都做hash运算，每一次得出的结果在bit数组对应的下标位置把0变成1。有URL对应的数组位置会被我们“标记”。当100亿个URL改变了bit数组里对应位置的值后，就得到我们所需要的布隆过滤器。\n![布隆过滤器](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap1)\n\n重头戏来了，当我们需要判断一个URL在不在黑名单里，只需要判断URL在经过hash函数后对应的bit数组下标的位置是“0”还是“1”。\n如果对应位置是0，意味这个位置仍是初始化状态，没有被标记过，所以这个URL不在黑名单里。如果对应位置是1，意味这个位置已经被标记过，所以这个URL在黑名单里。\n讲到这里，读者可能已经有一个“布隆过滤器器就是一个bit数组的”模糊全局概念。因为以上描述只是为了让读者知道布隆过滤器是个啥。接下来，请看几个布隆过滤的重要知识点。\n\n## 2hash函数\n上面所提到的“100亿个URL每一个都做hash运算”，这里的hash运算在实际中不只是一个hash函数，而是**一组hash函数**。顺便说一句hash函数不需要自己实现，经典的哈希函数已经有很多了，比如MD5、SHAI。\n但为什么URL经过hash函数的出来的值一定会是bit数组下标？打个比方，一个最简单的hash运算：%3。集合里的数经过%3的hash运算后，是只可能得出0或1或2，这三种情况。也就是说hash运算得出的输出域是固定的。这是hash函数的一个重要性质：**哈希函数有无限的输入域，但只有固定有限输出域。**\n\n\n## 3布隆过滤器误判类型\n布隆过滤器是有一定失误率。它的误判类型是——**宁可错杀一百，也不能放过一个**。也就是说如果URL在黑名单，判断结果一定会表示在。可能失误的情况是：某个URL不在黑名单里，也被判断在。\n为什么布隆过滤器会失误？并且只会“冤枉”，不会“漏判”？这是因为hash函数的另一个性质：**不同的输入值hash运算后得到的散列输出值可能不同**，也可能相同。但是不同的散列输出值对应的输入值一定不同。\n假如要判断的两个URLhash运算得到了相同的结果，但一个在黑名单里，一个不在黑名单里，对应的数组下标位置已经被描黑，那么两个URL都会被判为在黑名单里。\n\n## 4计算误判率\n误判率与数组长度、哈希函数的个数成负相关，与样本量成正相关。\n举一个极端的例子，如果样本量很大而bit数组太小，经过100亿和URL的标记后，数组里的所有元素都被“描黑”。此时任意一个URL都会被判断在黑名单里。\n想要减少失误率就需根据三个公式设计一个长度合适的bit数组。\n还是上面那道题为例，n是样本量，即100亿；p预期失误率，即0.0001，m是数组元素个数。01\n公式一：计算布隆过滤器的大小把p和n代入公式match，lnp等于-9.21，（ln2）的平方是0.7，n是100亿计算出来m等于19.19n，转为GB,等于bit数组大小要开25G02\n![公式一](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap2.jpg)\n\n公式二：我们还得确定hash函数的个数，哈希函数的个数k公式:算出k为14，需要14个hash函数03\n![公式二](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap3.jpg)\n\n公式三：计算失误率，p公式：算出失误率是0.006%。还是以上面那道题目为例，如果布隆过滤器的大小开25g，那么有0.006%的失误率，内存和失误率都满足要求。”\n![公式三](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap4.jpg)\n\n附注：这里本来有三张公式图的，但在markdown放图片太麻烦了，如果想看可以去[公众号推文上看。](https://mp.weixin.qq.com/s?__biz=MzUzNjk5NDk1OQ==&mid=2247483707&idx=1&sn=fd9d8f04edc085a9d60511fd5513fd0d&chksm=faecf4dbcd9b7dcd3dde98e71e2f447cdeb98f8b5c6a776eb7344c267bab6351c5cde169e527&mpshare=1&scene=1&srcid=0429kbCkM8nl32g91u4cjwOE&pass_ticket=o7Y28LwCkECdew2CB9ZmY%2BKd3rs%2BvSQamorjwZdBJfHahNMblqC42vSiDnvNcg%2F2#rd)\n\n## 5扩展\n布隆过滤器可以解决许多问题，比如：**网页URL的去重，缓存穿透，垃圾邮件的判别**等问题。\n这里重点介绍一下布隆过滤器如何解决缓存穿透的问题。**缓存穿透**，简单来说就是因为有海量的不存在的key请求，导致缓存起不了作用，大量请求引向数据库，导致数据库宕机。\n当有人恶意攻击，把发起海量的不存在的key请求，由于都是不存在的请求，缓存自然查不到，这些海量的请求就会都会落到数据库中。导致数据库崩溃。\n一般解决方案是：缓存空数据，如果某key数据库查询结果为空，则把这个不存在值的key也缓存起来，设置较短过期时间，当后续又出现该key时，就可以在缓存里查询到了，不再请求数据库。\n但是如果有人恶意攻击，key是随机生存的，请求的key是大量而不重复，这样的做法就用处不大了。\n用布隆过滤器解决：是请求过来，先调用布隆过滤器判断数据是否存在。如果不存在的数据，就不要把请求引向数据库。直接过滤掉了大量不存在的数据攻击。\n**总的来说，当数据量比较大并且重复率不高的时候，布隆过滤器的成本比一般解决方案成本更低。**\n\n## 6练练手\n看了这篇文章，不如乘热打铁，做道题目看看感觉如何\n<u>*题目：32位无符号整数的范围是0 - 4294967295，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然有没出现过的数。可以使用最多1GB的内存，怎么找到所有出现过两次的数？在看答案前，请自己试着做一做吧*</u>！\n\n\n","source":"_posts/布隆过滤器.md","raw":"---\ntitle: 布隆过滤器\ndate: 2019-04-16 18:00:50\ncategories: 算法\ntop: 10\n---\n\n布隆过滤器应用于最近比较火的海量处理问题。可以快速判断一个元素在不在海量数据的集合当中。缺点是有一定的失误率，优势是占用内存较少。\n<!-- more -->\n这篇文章我也同时发布在荣哥的公众号，搬砖攻城狮。[公众号推文](https://mp.weixin.qq.com/s?__biz=MzUzNjk5NDk1OQ==&mid=2247483707&idx=1&sn=fd9d8f04edc085a9d60511fd5513fd0d&chksm=faecf4dbcd9b7dcd3dde98e71e2f447cdeb98f8b5c6a776eb7344c267bab6351c5cde169e527&mpshare=1&scene=1&srcid=0429kbCkM8nl32g91u4cjwOE&pass_ticket=o7Y28LwCkECdew2CB9ZmY%2BKd3rs%2BvSQamorjwZdBJfHahNMblqC42vSiDnvNcg%2F2#rd)\n\n## 0一道大数据黑名单题\n不安全网页的黑名单里有100亿个URL，每一个网页的URL最多占用64B。要求实现一种过滤系统，可以根据网页的URL判断是否在这个黑名单中。要求的额外的空间不能超过30GB。\n\n\n## 1布隆过滤器是什么？\n布隆过滤器本质上是一个bit数组，可以用极少的空间解决“判断在不在”这种问题。\n以这道题为例，一般的思路是将所有的URL整个都存储起来，**但是这个题目其实只需要我们判断在不在，我们根本无需存整个URL，甚至无需在意一个URL是多少字节，只需要存这个URL是“在”还是“不在”这两种状态就好了。**\n讲到这里不知读者有没联想我们计算机世界的0和1。我们完全可以用一个容器存放这两种状态，在黑名单URL用1来表示，不在黑名单用0来表示。\n接下来我们就使用布隆过滤器着手解决这道题。首先创建一个bit数组，数组里所有位置初始化都为0。然后100亿个URL每一个都做hash运算，每一次得出的结果在bit数组对应的下标位置把0变成1。有URL对应的数组位置会被我们“标记”。当100亿个URL改变了bit数组里对应位置的值后，就得到我们所需要的布隆过滤器。\n![布隆过滤器](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap1)\n\n重头戏来了，当我们需要判断一个URL在不在黑名单里，只需要判断URL在经过hash函数后对应的bit数组下标的位置是“0”还是“1”。\n如果对应位置是0，意味这个位置仍是初始化状态，没有被标记过，所以这个URL不在黑名单里。如果对应位置是1，意味这个位置已经被标记过，所以这个URL在黑名单里。\n讲到这里，读者可能已经有一个“布隆过滤器器就是一个bit数组的”模糊全局概念。因为以上描述只是为了让读者知道布隆过滤器是个啥。接下来，请看几个布隆过滤的重要知识点。\n\n## 2hash函数\n上面所提到的“100亿个URL每一个都做hash运算”，这里的hash运算在实际中不只是一个hash函数，而是**一组hash函数**。顺便说一句hash函数不需要自己实现，经典的哈希函数已经有很多了，比如MD5、SHAI。\n但为什么URL经过hash函数的出来的值一定会是bit数组下标？打个比方，一个最简单的hash运算：%3。集合里的数经过%3的hash运算后，是只可能得出0或1或2，这三种情况。也就是说hash运算得出的输出域是固定的。这是hash函数的一个重要性质：**哈希函数有无限的输入域，但只有固定有限输出域。**\n\n\n## 3布隆过滤器误判类型\n布隆过滤器是有一定失误率。它的误判类型是——**宁可错杀一百，也不能放过一个**。也就是说如果URL在黑名单，判断结果一定会表示在。可能失误的情况是：某个URL不在黑名单里，也被判断在。\n为什么布隆过滤器会失误？并且只会“冤枉”，不会“漏判”？这是因为hash函数的另一个性质：**不同的输入值hash运算后得到的散列输出值可能不同**，也可能相同。但是不同的散列输出值对应的输入值一定不同。\n假如要判断的两个URLhash运算得到了相同的结果，但一个在黑名单里，一个不在黑名单里，对应的数组下标位置已经被描黑，那么两个URL都会被判为在黑名单里。\n\n## 4计算误判率\n误判率与数组长度、哈希函数的个数成负相关，与样本量成正相关。\n举一个极端的例子，如果样本量很大而bit数组太小，经过100亿和URL的标记后，数组里的所有元素都被“描黑”。此时任意一个URL都会被判断在黑名单里。\n想要减少失误率就需根据三个公式设计一个长度合适的bit数组。\n还是上面那道题为例，n是样本量，即100亿；p预期失误率，即0.0001，m是数组元素个数。01\n公式一：计算布隆过滤器的大小把p和n代入公式match，lnp等于-9.21，（ln2）的平方是0.7，n是100亿计算出来m等于19.19n，转为GB,等于bit数组大小要开25G02\n![公式一](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap2.jpg)\n\n公式二：我们还得确定hash函数的个数，哈希函数的个数k公式:算出k为14，需要14个hash函数03\n![公式二](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap3.jpg)\n\n公式三：计算失误率，p公式：算出失误率是0.006%。还是以上面那道题目为例，如果布隆过滤器的大小开25g，那么有0.006%的失误率，内存和失误率都满足要求。”\n![公式三](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap4.jpg)\n\n附注：这里本来有三张公式图的，但在markdown放图片太麻烦了，如果想看可以去[公众号推文上看。](https://mp.weixin.qq.com/s?__biz=MzUzNjk5NDk1OQ==&mid=2247483707&idx=1&sn=fd9d8f04edc085a9d60511fd5513fd0d&chksm=faecf4dbcd9b7dcd3dde98e71e2f447cdeb98f8b5c6a776eb7344c267bab6351c5cde169e527&mpshare=1&scene=1&srcid=0429kbCkM8nl32g91u4cjwOE&pass_ticket=o7Y28LwCkECdew2CB9ZmY%2BKd3rs%2BvSQamorjwZdBJfHahNMblqC42vSiDnvNcg%2F2#rd)\n\n## 5扩展\n布隆过滤器可以解决许多问题，比如：**网页URL的去重，缓存穿透，垃圾邮件的判别**等问题。\n这里重点介绍一下布隆过滤器如何解决缓存穿透的问题。**缓存穿透**，简单来说就是因为有海量的不存在的key请求，导致缓存起不了作用，大量请求引向数据库，导致数据库宕机。\n当有人恶意攻击，把发起海量的不存在的key请求，由于都是不存在的请求，缓存自然查不到，这些海量的请求就会都会落到数据库中。导致数据库崩溃。\n一般解决方案是：缓存空数据，如果某key数据库查询结果为空，则把这个不存在值的key也缓存起来，设置较短过期时间，当后续又出现该key时，就可以在缓存里查询到了，不再请求数据库。\n但是如果有人恶意攻击，key是随机生存的，请求的key是大量而不重复，这样的做法就用处不大了。\n用布隆过滤器解决：是请求过来，先调用布隆过滤器判断数据是否存在。如果不存在的数据，就不要把请求引向数据库。直接过滤掉了大量不存在的数据攻击。\n**总的来说，当数据量比较大并且重复率不高的时候，布隆过滤器的成本比一般解决方案成本更低。**\n\n## 6练练手\n看了这篇文章，不如乘热打铁，做道题目看看感觉如何\n<u>*题目：32位无符号整数的范围是0 - 4294967295，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然有没出现过的数。可以使用最多1GB的内存，怎么找到所有出现过两次的数？在看答案前，请自己试着做一做吧*</u>！\n\n\n","slug":"布隆过滤器","published":1,"updated":"2022-02-08T07:09:41.228Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qkl001cw9rpec87kaq1","content":"<p>布隆过滤器应用于最近比较火的海量处理问题。可以快速判断一个元素在不在海量数据的集合当中。缺点是有一定的失误率，优势是占用内存较少。<br><a id=\"more\"></a><br>这篇文章我也同时发布在荣哥的公众号，搬砖攻城狮。<a href=\"https://mp.weixin.qq.com/s?__biz=MzUzNjk5NDk1OQ==&amp;mid=2247483707&amp;idx=1&amp;sn=fd9d8f04edc085a9d60511fd5513fd0d&amp;chksm=faecf4dbcd9b7dcd3dde98e71e2f447cdeb98f8b5c6a776eb7344c267bab6351c5cde169e527&amp;mpshare=1&amp;scene=1&amp;srcid=0429kbCkM8nl32g91u4cjwOE&amp;pass_ticket=o7Y28LwCkECdew2CB9ZmY%2BKd3rs%2BvSQamorjwZdBJfHahNMblqC42vSiDnvNcg%2F2#rd\" target=\"_blank\" rel=\"noopener\">公众号推文</a></p>\n<h2 id=\"0一道大数据黑名单题\"><a href=\"#0一道大数据黑名单题\" class=\"headerlink\" title=\"0一道大数据黑名单题\"></a>0一道大数据黑名单题</h2><p>不安全网页的黑名单里有100亿个URL，每一个网页的URL最多占用64B。要求实现一种过滤系统，可以根据网页的URL判断是否在这个黑名单中。要求的额外的空间不能超过30GB。</p>\n<h2 id=\"1布隆过滤器是什么？\"><a href=\"#1布隆过滤器是什么？\" class=\"headerlink\" title=\"1布隆过滤器是什么？\"></a>1布隆过滤器是什么？</h2><p>布隆过滤器本质上是一个bit数组，可以用极少的空间解决“判断在不在”这种问题。<br>以这道题为例，一般的思路是将所有的URL整个都存储起来，<strong>但是这个题目其实只需要我们判断在不在，我们根本无需存整个URL，甚至无需在意一个URL是多少字节，只需要存这个URL是“在”还是“不在”这两种状态就好了。</strong><br>讲到这里不知读者有没联想我们计算机世界的0和1。我们完全可以用一个容器存放这两种状态，在黑名单URL用1来表示，不在黑名单用0来表示。<br>接下来我们就使用布隆过滤器着手解决这道题。首先创建一个bit数组，数组里所有位置初始化都为0。然后100亿个URL每一个都做hash运算，每一次得出的结果在bit数组对应的下标位置把0变成1。有URL对应的数组位置会被我们“标记”。当100亿个URL改变了bit数组里对应位置的值后，就得到我们所需要的布隆过滤器。<br><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap1\" alt=\"布隆过滤器\"></p>\n<p>重头戏来了，当我们需要判断一个URL在不在黑名单里，只需要判断URL在经过hash函数后对应的bit数组下标的位置是“0”还是“1”。<br>如果对应位置是0，意味这个位置仍是初始化状态，没有被标记过，所以这个URL不在黑名单里。如果对应位置是1，意味这个位置已经被标记过，所以这个URL在黑名单里。<br>讲到这里，读者可能已经有一个“布隆过滤器器就是一个bit数组的”模糊全局概念。因为以上描述只是为了让读者知道布隆过滤器是个啥。接下来，请看几个布隆过滤的重要知识点。</p>\n<h2 id=\"2hash函数\"><a href=\"#2hash函数\" class=\"headerlink\" title=\"2hash函数\"></a>2hash函数</h2><p>上面所提到的“100亿个URL每一个都做hash运算”，这里的hash运算在实际中不只是一个hash函数，而是<strong>一组hash函数</strong>。顺便说一句hash函数不需要自己实现，经典的哈希函数已经有很多了，比如MD5、SHAI。<br>但为什么URL经过hash函数的出来的值一定会是bit数组下标？打个比方，一个最简单的hash运算：%3。集合里的数经过%3的hash运算后，是只可能得出0或1或2，这三种情况。也就是说hash运算得出的输出域是固定的。这是hash函数的一个重要性质：<strong>哈希函数有无限的输入域，但只有固定有限输出域。</strong></p>\n<h2 id=\"3布隆过滤器误判类型\"><a href=\"#3布隆过滤器误判类型\" class=\"headerlink\" title=\"3布隆过滤器误判类型\"></a>3布隆过滤器误判类型</h2><p>布隆过滤器是有一定失误率。它的误判类型是——<strong>宁可错杀一百，也不能放过一个</strong>。也就是说如果URL在黑名单，判断结果一定会表示在。可能失误的情况是：某个URL不在黑名单里，也被判断在。<br>为什么布隆过滤器会失误？并且只会“冤枉”，不会“漏判”？这是因为hash函数的另一个性质：<strong>不同的输入值hash运算后得到的散列输出值可能不同</strong>，也可能相同。但是不同的散列输出值对应的输入值一定不同。<br>假如要判断的两个URLhash运算得到了相同的结果，但一个在黑名单里，一个不在黑名单里，对应的数组下标位置已经被描黑，那么两个URL都会被判为在黑名单里。</p>\n<h2 id=\"4计算误判率\"><a href=\"#4计算误判率\" class=\"headerlink\" title=\"4计算误判率\"></a>4计算误判率</h2><p>误判率与数组长度、哈希函数的个数成负相关，与样本量成正相关。<br>举一个极端的例子，如果样本量很大而bit数组太小，经过100亿和URL的标记后，数组里的所有元素都被“描黑”。此时任意一个URL都会被判断在黑名单里。<br>想要减少失误率就需根据三个公式设计一个长度合适的bit数组。<br>还是上面那道题为例，n是样本量，即100亿；p预期失误率，即0.0001，m是数组元素个数。01<br>公式一：计算布隆过滤器的大小把p和n代入公式match，lnp等于-9.21，（ln2）的平方是0.7，n是100亿计算出来m等于19.19n，转为GB,等于bit数组大小要开25G02<br><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap2.jpg\" alt=\"公式一\"></p>\n<p>公式二：我们还得确定hash函数的个数，哈希函数的个数k公式:算出k为14，需要14个hash函数03<br><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap3.jpg\" alt=\"公式二\"></p>\n<p>公式三：计算失误率，p公式：算出失误率是0.006%。还是以上面那道题目为例，如果布隆过滤器的大小开25g，那么有0.006%的失误率，内存和失误率都满足要求。”<br><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap4.jpg\" alt=\"公式三\"></p>\n<p>附注：这里本来有三张公式图的，但在markdown放图片太麻烦了，如果想看可以去<a href=\"https://mp.weixin.qq.com/s?__biz=MzUzNjk5NDk1OQ==&amp;mid=2247483707&amp;idx=1&amp;sn=fd9d8f04edc085a9d60511fd5513fd0d&amp;chksm=faecf4dbcd9b7dcd3dde98e71e2f447cdeb98f8b5c6a776eb7344c267bab6351c5cde169e527&amp;mpshare=1&amp;scene=1&amp;srcid=0429kbCkM8nl32g91u4cjwOE&amp;pass_ticket=o7Y28LwCkECdew2CB9ZmY%2BKd3rs%2BvSQamorjwZdBJfHahNMblqC42vSiDnvNcg%2F2#rd\" target=\"_blank\" rel=\"noopener\">公众号推文上看。</a></p>\n<h2 id=\"5扩展\"><a href=\"#5扩展\" class=\"headerlink\" title=\"5扩展\"></a>5扩展</h2><p>布隆过滤器可以解决许多问题，比如：<strong>网页URL的去重，缓存穿透，垃圾邮件的判别</strong>等问题。<br>这里重点介绍一下布隆过滤器如何解决缓存穿透的问题。<strong>缓存穿透</strong>，简单来说就是因为有海量的不存在的key请求，导致缓存起不了作用，大量请求引向数据库，导致数据库宕机。<br>当有人恶意攻击，把发起海量的不存在的key请求，由于都是不存在的请求，缓存自然查不到，这些海量的请求就会都会落到数据库中。导致数据库崩溃。<br>一般解决方案是：缓存空数据，如果某key数据库查询结果为空，则把这个不存在值的key也缓存起来，设置较短过期时间，当后续又出现该key时，就可以在缓存里查询到了，不再请求数据库。<br>但是如果有人恶意攻击，key是随机生存的，请求的key是大量而不重复，这样的做法就用处不大了。<br>用布隆过滤器解决：是请求过来，先调用布隆过滤器判断数据是否存在。如果不存在的数据，就不要把请求引向数据库。直接过滤掉了大量不存在的数据攻击。<br><strong>总的来说，当数据量比较大并且重复率不高的时候，布隆过滤器的成本比一般解决方案成本更低。</strong></p>\n<h2 id=\"6练练手\"><a href=\"#6练练手\" class=\"headerlink\" title=\"6练练手\"></a>6练练手</h2><p>看了这篇文章，不如乘热打铁，做道题目看看感觉如何<br><u><em>题目：32位无符号整数的范围是0 - 4294967295，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然有没出现过的数。可以使用最多1GB的内存，怎么找到所有出现过两次的数？在看答案前，请自己试着做一做吧</em></u>！</p>\n","site":{"data":{}},"excerpt":"<p>布隆过滤器应用于最近比较火的海量处理问题。可以快速判断一个元素在不在海量数据的集合当中。缺点是有一定的失误率，优势是占用内存较少。<br>","more":"<br>这篇文章我也同时发布在荣哥的公众号，搬砖攻城狮。<a href=\"https://mp.weixin.qq.com/s?__biz=MzUzNjk5NDk1OQ==&amp;mid=2247483707&amp;idx=1&amp;sn=fd9d8f04edc085a9d60511fd5513fd0d&amp;chksm=faecf4dbcd9b7dcd3dde98e71e2f447cdeb98f8b5c6a776eb7344c267bab6351c5cde169e527&amp;mpshare=1&amp;scene=1&amp;srcid=0429kbCkM8nl32g91u4cjwOE&amp;pass_ticket=o7Y28LwCkECdew2CB9ZmY%2BKd3rs%2BvSQamorjwZdBJfHahNMblqC42vSiDnvNcg%2F2#rd\" target=\"_blank\" rel=\"noopener\">公众号推文</a></p>\n<h2 id=\"0一道大数据黑名单题\"><a href=\"#0一道大数据黑名单题\" class=\"headerlink\" title=\"0一道大数据黑名单题\"></a>0一道大数据黑名单题</h2><p>不安全网页的黑名单里有100亿个URL，每一个网页的URL最多占用64B。要求实现一种过滤系统，可以根据网页的URL判断是否在这个黑名单中。要求的额外的空间不能超过30GB。</p>\n<h2 id=\"1布隆过滤器是什么？\"><a href=\"#1布隆过滤器是什么？\" class=\"headerlink\" title=\"1布隆过滤器是什么？\"></a>1布隆过滤器是什么？</h2><p>布隆过滤器本质上是一个bit数组，可以用极少的空间解决“判断在不在”这种问题。<br>以这道题为例，一般的思路是将所有的URL整个都存储起来，<strong>但是这个题目其实只需要我们判断在不在，我们根本无需存整个URL，甚至无需在意一个URL是多少字节，只需要存这个URL是“在”还是“不在”这两种状态就好了。</strong><br>讲到这里不知读者有没联想我们计算机世界的0和1。我们完全可以用一个容器存放这两种状态，在黑名单URL用1来表示，不在黑名单用0来表示。<br>接下来我们就使用布隆过滤器着手解决这道题。首先创建一个bit数组，数组里所有位置初始化都为0。然后100亿个URL每一个都做hash运算，每一次得出的结果在bit数组对应的下标位置把0变成1。有URL对应的数组位置会被我们“标记”。当100亿个URL改变了bit数组里对应位置的值后，就得到我们所需要的布隆过滤器。<br><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap1\" alt=\"布隆过滤器\"></p>\n<p>重头戏来了，当我们需要判断一个URL在不在黑名单里，只需要判断URL在经过hash函数后对应的bit数组下标的位置是“0”还是“1”。<br>如果对应位置是0，意味这个位置仍是初始化状态，没有被标记过，所以这个URL不在黑名单里。如果对应位置是1，意味这个位置已经被标记过，所以这个URL在黑名单里。<br>讲到这里，读者可能已经有一个“布隆过滤器器就是一个bit数组的”模糊全局概念。因为以上描述只是为了让读者知道布隆过滤器是个啥。接下来，请看几个布隆过滤的重要知识点。</p>\n<h2 id=\"2hash函数\"><a href=\"#2hash函数\" class=\"headerlink\" title=\"2hash函数\"></a>2hash函数</h2><p>上面所提到的“100亿个URL每一个都做hash运算”，这里的hash运算在实际中不只是一个hash函数，而是<strong>一组hash函数</strong>。顺便说一句hash函数不需要自己实现，经典的哈希函数已经有很多了，比如MD5、SHAI。<br>但为什么URL经过hash函数的出来的值一定会是bit数组下标？打个比方，一个最简单的hash运算：%3。集合里的数经过%3的hash运算后，是只可能得出0或1或2，这三种情况。也就是说hash运算得出的输出域是固定的。这是hash函数的一个重要性质：<strong>哈希函数有无限的输入域，但只有固定有限输出域。</strong></p>\n<h2 id=\"3布隆过滤器误判类型\"><a href=\"#3布隆过滤器误判类型\" class=\"headerlink\" title=\"3布隆过滤器误判类型\"></a>3布隆过滤器误判类型</h2><p>布隆过滤器是有一定失误率。它的误判类型是——<strong>宁可错杀一百，也不能放过一个</strong>。也就是说如果URL在黑名单，判断结果一定会表示在。可能失误的情况是：某个URL不在黑名单里，也被判断在。<br>为什么布隆过滤器会失误？并且只会“冤枉”，不会“漏判”？这是因为hash函数的另一个性质：<strong>不同的输入值hash运算后得到的散列输出值可能不同</strong>，也可能相同。但是不同的散列输出值对应的输入值一定不同。<br>假如要判断的两个URLhash运算得到了相同的结果，但一个在黑名单里，一个不在黑名单里，对应的数组下标位置已经被描黑，那么两个URL都会被判为在黑名单里。</p>\n<h2 id=\"4计算误判率\"><a href=\"#4计算误判率\" class=\"headerlink\" title=\"4计算误判率\"></a>4计算误判率</h2><p>误判率与数组长度、哈希函数的个数成负相关，与样本量成正相关。<br>举一个极端的例子，如果样本量很大而bit数组太小，经过100亿和URL的标记后，数组里的所有元素都被“描黑”。此时任意一个URL都会被判断在黑名单里。<br>想要减少失误率就需根据三个公式设计一个长度合适的bit数组。<br>还是上面那道题为例，n是样本量，即100亿；p预期失误率，即0.0001，m是数组元素个数。01<br>公式一：计算布隆过滤器的大小把p和n代入公式match，lnp等于-9.21，（ln2）的平方是0.7，n是100亿计算出来m等于19.19n，转为GB,等于bit数组大小要开25G02<br><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap2.jpg\" alt=\"公式一\"></p>\n<p>公式二：我们还得确定hash函数的个数，哈希函数的个数k公式:算出k为14，需要14个hash函数03<br><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap3.jpg\" alt=\"公式二\"></p>\n<p>公式三：计算失误率，p公式：算出失误率是0.006%。还是以上面那道题目为例，如果布隆过滤器的大小开25g，那么有0.006%的失误率，内存和失误率都满足要求。”<br><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bitmap4.jpg\" alt=\"公式三\"></p>\n<p>附注：这里本来有三张公式图的，但在markdown放图片太麻烦了，如果想看可以去<a href=\"https://mp.weixin.qq.com/s?__biz=MzUzNjk5NDk1OQ==&amp;mid=2247483707&amp;idx=1&amp;sn=fd9d8f04edc085a9d60511fd5513fd0d&amp;chksm=faecf4dbcd9b7dcd3dde98e71e2f447cdeb98f8b5c6a776eb7344c267bab6351c5cde169e527&amp;mpshare=1&amp;scene=1&amp;srcid=0429kbCkM8nl32g91u4cjwOE&amp;pass_ticket=o7Y28LwCkECdew2CB9ZmY%2BKd3rs%2BvSQamorjwZdBJfHahNMblqC42vSiDnvNcg%2F2#rd\" target=\"_blank\" rel=\"noopener\">公众号推文上看。</a></p>\n<h2 id=\"5扩展\"><a href=\"#5扩展\" class=\"headerlink\" title=\"5扩展\"></a>5扩展</h2><p>布隆过滤器可以解决许多问题，比如：<strong>网页URL的去重，缓存穿透，垃圾邮件的判别</strong>等问题。<br>这里重点介绍一下布隆过滤器如何解决缓存穿透的问题。<strong>缓存穿透</strong>，简单来说就是因为有海量的不存在的key请求，导致缓存起不了作用，大量请求引向数据库，导致数据库宕机。<br>当有人恶意攻击，把发起海量的不存在的key请求，由于都是不存在的请求，缓存自然查不到，这些海量的请求就会都会落到数据库中。导致数据库崩溃。<br>一般解决方案是：缓存空数据，如果某key数据库查询结果为空，则把这个不存在值的key也缓存起来，设置较短过期时间，当后续又出现该key时，就可以在缓存里查询到了，不再请求数据库。<br>但是如果有人恶意攻击，key是随机生存的，请求的key是大量而不重复，这样的做法就用处不大了。<br>用布隆过滤器解决：是请求过来，先调用布隆过滤器判断数据是否存在。如果不存在的数据，就不要把请求引向数据库。直接过滤掉了大量不存在的数据攻击。<br><strong>总的来说，当数据量比较大并且重复率不高的时候，布隆过滤器的成本比一般解决方案成本更低。</strong></p>\n<h2 id=\"6练练手\"><a href=\"#6练练手\" class=\"headerlink\" title=\"6练练手\"></a>6练练手</h2><p>看了这篇文章，不如乘热打铁，做道题目看看感觉如何<br><u><em>题目：32位无符号整数的范围是0 - 4294967295，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然有没出现过的数。可以使用最多1GB的内存，怎么找到所有出现过两次的数？在看答案前，请自己试着做一做吧</em></u>！</p>"},{"title":"Spring怎么解决循环依赖？","date":"2019-10-09T00:52:50.000Z","description":"答：三层缓存","_content":"\n## Spring怎么解决循环依赖？\n\n\n\n### 循环依赖\n\n循环依赖是个啥？在创建TestA类时，构需要TestB类，那将去创建TestB，在创建TestB类时又需要TestA，从而形成一个环，没办法创建。\n\nspring解决这个问题与三特别有缘分，对于三种不同程度的循环依赖，spring能解决的程度不同；而解决的办法正是用到了三级缓存。\n\n下面就分别来讨论三种不同程度的循环依赖。\n\n### 第一种：构造器的循环依赖，无法解决，会报错\n\n#### 情况\n\nA的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象\n\n#### 无法解决原因\n\n一、Spring容器会将每一个正在创建的Bean 标识符放在一个“当前创建Bean池”中，Bean标识符在创建过程中将一直保持在这个池中，因此如果在创建Bean过程中发现自己已经在“当前创建Bean池”里时将抛出BeanCurrentlyInCreationException异常表示循环依赖；而对于创建完毕的Bean将从“当前创建Bean池”中清除掉。\n\nSpring容器先创建单例StudentA，StudentA依赖StudentB，然后将A放在“当前创建Bean池”中，此时创建StudentB,StudentB依赖StudentA， 但是，此时StudentA已经在池中，所以会报错，因为在池中的Bean都是未初始化完的，所以会依赖错误 ，（初始化完的Bean会从池中移除）\n\n二、循环依赖发生的时候还没有执行完构造器，也就无法使用三级缓存解决问题。spring解决循环依赖的手段是三级缓存，而三级缓存的的前提是执行了构造器，才会调用addSingletonFactory加入三级缓存，所以构造器的循环依赖没法解决。这在下面一种情况中会有解释，就先不展开了。\n\n### 第二种：field属性的单例循环依赖，可解决。\n\n#### 情况\n\nA的构造方法中依赖了B的实例对象，同时B的某个field或者setter需要A的实例对象\n\n#### 解决前提\n\n- 前提一：比第一种情况，此时循环依赖发生在字段属性中，而不是构造器中。\n- 前提二：比第三种情况，因为是单例的，所以才会用到三级缓存。\n\n前提一：**是先实例化在设置对象属性的，否则解决field属性的setter方式单例循环依赖将无从谈起。**先来看看spring bean生命周期的一张图。\n\n![1564554784479](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)\n\n大体的流程就是：实例化>填充属性>initializeBean(调用spring xml中的init 方法)\n\n循环依赖主要发生在实例化>填充属性这两步。\n\n前提二：**对于单例来说**，在Spring容器会把对象放在缓存中，而为了解决单例的循环依赖问题，使用了**Spring三级缓存**。\n\n#### 解决手段\n\n三级缓存,这三级缓存分别指： \n\n1. singletonObjects：单例对象的cache，一级缓存。\n2. earlySingletonObjects ：提前暴光的单例对象的Cache ，二级缓存。\n3. singletonFactories ： 单例对象工厂的cache ，三级缓存。\n\n由上往下，缓存中的bean是逐渐完善的，三级缓存中的bean 是最初始的状态。\n\n#### 解决过程\n\n“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。\n\nA首先完成了初始化的第一步，并且将自己提前曝光到**singletonFactories**三级缓存中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程。\n\nB在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A提前曝光了，所以B能够通过三级缓存singletonFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)。\n\nB拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中。\n\n而且由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。\n\n\n\n#### 源码\n\n##### getSingleton（）\n\n获取单例的方法，逐层从缓存中取\n\n```java\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n //首先从一级缓存singletonObjects中获取\n    Object singletonObject = this.singletonObjects.get(beanName);\n //如果获取不到，并且对象正在创建中\n    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n        synchronized (this.singletonObjects) {\n  //再从二级缓存earlySingletonObjects中获取\n            singletonObject = this.earlySingletonObjects.get(beanName);\n            if (singletonObject == null && allowEarlyReference) {\n                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);\n                if (singletonFactory != null) {\n    //从三级缓存singletonFactory获取\n                    singletonObject = singletonFactory.getObject();\n      //放入二级缓存\n                    this.earlySingletonObjects.put(beanName, singletonObject);\n     //从三级缓存中删除，也就是把bean自动三级移到了二级缓存中\n                    this.singletonFactories.remove(beanName);\n                }\n            }\n        }\n    }\n    return (singletonObject != NULL_OBJECT ? singletonObject : null);\n}\n\n```\n\n\n\n##### addSingletonFactory（）\n\n这段代码发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来(调用了构造器)。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。\n\n注意：这里有一个细节就是ObjectFactory，**三级缓存的类型是ObjectFactory并非一个bean（还没实例化好呢）。**\n\n```java\nprotected void addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory) {\n    Assert.notNull(singletonFactory, \"Singleton factory must not be null\");\n    synchronized (this.singletonObjects) {\n        if (!this.singletonObjects.containsKey(beanName)) {\n     //三级缓存的类型是ObjectFactory\n            this.singletonFactories.put(beanName, singletonFactory);\n            this.earlySingletonObjects.remove(beanName);\n            this.registeredSingletons.add(beanName);\n        }\n    }\n}\n```\n\n知道了这个原理时候，肯定就知道为啥Spring不能解决第一种情况“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”。因为加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决。\n\n### 第三种：field属性的prototype循环依赖，无法解决解决，报错\n\n#### 情况\n\nA的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象。\n\n#### 不能解决的前提\n\n**因为没有缓存。**\n\nscope=\"prototype\" 意思是 每次请求都会创建一个实例对象。两者的区别是：有状态的bean都使用Prototype作用域，无状态的一般都使用singleton单例作用域。\n\n**对于“prototype”作用域Bean，Spring容器无法完成依赖注入，因为“prototype”作用域的Bean，Spring容器不进行缓存，因此无法提前暴露一个创建中的Bean。**\n\n\n\n> [Spring循环依赖的三种方式](https://blog.csdn.net/u010644448/article/details/59108799)\n>\n> [Spring源码初探-IOC(4)-Bean的初始化-循环依赖的解决](https://www.jianshu.com/p/6c359768b1dc)\n>\n> [Spring-bean的循环依赖以及解决方式](https://blog.csdn.net/u010853261/article/details/77940767)\n\n","source":"_posts/循环依赖.md","raw":"---\ntitle: Spring怎么解决循环依赖？\ndate: 2019-10-09 08:52:50\ncategories: spring\ndescription: 答：三层缓存\n\n\n---\n\n## Spring怎么解决循环依赖？\n\n\n\n### 循环依赖\n\n循环依赖是个啥？在创建TestA类时，构需要TestB类，那将去创建TestB，在创建TestB类时又需要TestA，从而形成一个环，没办法创建。\n\nspring解决这个问题与三特别有缘分，对于三种不同程度的循环依赖，spring能解决的程度不同；而解决的办法正是用到了三级缓存。\n\n下面就分别来讨论三种不同程度的循环依赖。\n\n### 第一种：构造器的循环依赖，无法解决，会报错\n\n#### 情况\n\nA的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象\n\n#### 无法解决原因\n\n一、Spring容器会将每一个正在创建的Bean 标识符放在一个“当前创建Bean池”中，Bean标识符在创建过程中将一直保持在这个池中，因此如果在创建Bean过程中发现自己已经在“当前创建Bean池”里时将抛出BeanCurrentlyInCreationException异常表示循环依赖；而对于创建完毕的Bean将从“当前创建Bean池”中清除掉。\n\nSpring容器先创建单例StudentA，StudentA依赖StudentB，然后将A放在“当前创建Bean池”中，此时创建StudentB,StudentB依赖StudentA， 但是，此时StudentA已经在池中，所以会报错，因为在池中的Bean都是未初始化完的，所以会依赖错误 ，（初始化完的Bean会从池中移除）\n\n二、循环依赖发生的时候还没有执行完构造器，也就无法使用三级缓存解决问题。spring解决循环依赖的手段是三级缓存，而三级缓存的的前提是执行了构造器，才会调用addSingletonFactory加入三级缓存，所以构造器的循环依赖没法解决。这在下面一种情况中会有解释，就先不展开了。\n\n### 第二种：field属性的单例循环依赖，可解决。\n\n#### 情况\n\nA的构造方法中依赖了B的实例对象，同时B的某个field或者setter需要A的实例对象\n\n#### 解决前提\n\n- 前提一：比第一种情况，此时循环依赖发生在字段属性中，而不是构造器中。\n- 前提二：比第三种情况，因为是单例的，所以才会用到三级缓存。\n\n前提一：**是先实例化在设置对象属性的，否则解决field属性的setter方式单例循环依赖将无从谈起。**先来看看spring bean生命周期的一张图。\n\n![1564554784479](https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)\n\n大体的流程就是：实例化>填充属性>initializeBean(调用spring xml中的init 方法)\n\n循环依赖主要发生在实例化>填充属性这两步。\n\n前提二：**对于单例来说**，在Spring容器会把对象放在缓存中，而为了解决单例的循环依赖问题，使用了**Spring三级缓存**。\n\n#### 解决手段\n\n三级缓存,这三级缓存分别指： \n\n1. singletonObjects：单例对象的cache，一级缓存。\n2. earlySingletonObjects ：提前暴光的单例对象的Cache ，二级缓存。\n3. singletonFactories ： 单例对象工厂的cache ，三级缓存。\n\n由上往下，缓存中的bean是逐渐完善的，三级缓存中的bean 是最初始的状态。\n\n#### 解决过程\n\n“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。\n\nA首先完成了初始化的第一步，并且将自己提前曝光到**singletonFactories**三级缓存中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程。\n\nB在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A提前曝光了，所以B能够通过三级缓存singletonFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)。\n\nB拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中。\n\n而且由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。\n\n\n\n#### 源码\n\n##### getSingleton（）\n\n获取单例的方法，逐层从缓存中取\n\n```java\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n //首先从一级缓存singletonObjects中获取\n    Object singletonObject = this.singletonObjects.get(beanName);\n //如果获取不到，并且对象正在创建中\n    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n        synchronized (this.singletonObjects) {\n  //再从二级缓存earlySingletonObjects中获取\n            singletonObject = this.earlySingletonObjects.get(beanName);\n            if (singletonObject == null && allowEarlyReference) {\n                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);\n                if (singletonFactory != null) {\n    //从三级缓存singletonFactory获取\n                    singletonObject = singletonFactory.getObject();\n      //放入二级缓存\n                    this.earlySingletonObjects.put(beanName, singletonObject);\n     //从三级缓存中删除，也就是把bean自动三级移到了二级缓存中\n                    this.singletonFactories.remove(beanName);\n                }\n            }\n        }\n    }\n    return (singletonObject != NULL_OBJECT ? singletonObject : null);\n}\n\n```\n\n\n\n##### addSingletonFactory（）\n\n这段代码发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来(调用了构造器)。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。\n\n注意：这里有一个细节就是ObjectFactory，**三级缓存的类型是ObjectFactory并非一个bean（还没实例化好呢）。**\n\n```java\nprotected void addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory) {\n    Assert.notNull(singletonFactory, \"Singleton factory must not be null\");\n    synchronized (this.singletonObjects) {\n        if (!this.singletonObjects.containsKey(beanName)) {\n     //三级缓存的类型是ObjectFactory\n            this.singletonFactories.put(beanName, singletonFactory);\n            this.earlySingletonObjects.remove(beanName);\n            this.registeredSingletons.add(beanName);\n        }\n    }\n}\n```\n\n知道了这个原理时候，肯定就知道为啥Spring不能解决第一种情况“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”。因为加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决。\n\n### 第三种：field属性的prototype循环依赖，无法解决解决，报错\n\n#### 情况\n\nA的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象。\n\n#### 不能解决的前提\n\n**因为没有缓存。**\n\nscope=\"prototype\" 意思是 每次请求都会创建一个实例对象。两者的区别是：有状态的bean都使用Prototype作用域，无状态的一般都使用singleton单例作用域。\n\n**对于“prototype”作用域Bean，Spring容器无法完成依赖注入，因为“prototype”作用域的Bean，Spring容器不进行缓存，因此无法提前暴露一个创建中的Bean。**\n\n\n\n> [Spring循环依赖的三种方式](https://blog.csdn.net/u010644448/article/details/59108799)\n>\n> [Spring源码初探-IOC(4)-Bean的初始化-循环依赖的解决](https://www.jianshu.com/p/6c359768b1dc)\n>\n> [Spring-bean的循环依赖以及解决方式](https://blog.csdn.net/u010853261/article/details/77940767)\n\n","slug":"循环依赖","published":1,"updated":"2022-02-08T07:09:41.228Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qkl001fw9rpt44lzmh2","content":"<h2 id=\"Spring怎么解决循环依赖？\"><a href=\"#Spring怎么解决循环依赖？\" class=\"headerlink\" title=\"Spring怎么解决循环依赖？\"></a>Spring怎么解决循环依赖？</h2><h3 id=\"循环依赖\"><a href=\"#循环依赖\" class=\"headerlink\" title=\"循环依赖\"></a>循环依赖</h3><p>循环依赖是个啥？在创建TestA类时，构需要TestB类，那将去创建TestB，在创建TestB类时又需要TestA，从而形成一个环，没办法创建。</p>\n<p>spring解决这个问题与三特别有缘分，对于三种不同程度的循环依赖，spring能解决的程度不同；而解决的办法正是用到了三级缓存。</p>\n<p>下面就分别来讨论三种不同程度的循环依赖。</p>\n<h3 id=\"第一种：构造器的循环依赖，无法解决，会报错\"><a href=\"#第一种：构造器的循环依赖，无法解决，会报错\" class=\"headerlink\" title=\"第一种：构造器的循环依赖，无法解决，会报错\"></a>第一种：构造器的循环依赖，无法解决，会报错</h3><h4 id=\"情况\"><a href=\"#情况\" class=\"headerlink\" title=\"情况\"></a>情况</h4><p>A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象</p>\n<h4 id=\"无法解决原因\"><a href=\"#无法解决原因\" class=\"headerlink\" title=\"无法解决原因\"></a>无法解决原因</h4><p>一、Spring容器会将每一个正在创建的Bean 标识符放在一个“当前创建Bean池”中，Bean标识符在创建过程中将一直保持在这个池中，因此如果在创建Bean过程中发现自己已经在“当前创建Bean池”里时将抛出BeanCurrentlyInCreationException异常表示循环依赖；而对于创建完毕的Bean将从“当前创建Bean池”中清除掉。</p>\n<p>Spring容器先创建单例StudentA，StudentA依赖StudentB，然后将A放在“当前创建Bean池”中，此时创建StudentB,StudentB依赖StudentA， 但是，此时StudentA已经在池中，所以会报错，因为在池中的Bean都是未初始化完的，所以会依赖错误 ，（初始化完的Bean会从池中移除）</p>\n<p>二、循环依赖发生的时候还没有执行完构造器，也就无法使用三级缓存解决问题。spring解决循环依赖的手段是三级缓存，而三级缓存的的前提是执行了构造器，才会调用addSingletonFactory加入三级缓存，所以构造器的循环依赖没法解决。这在下面一种情况中会有解释，就先不展开了。</p>\n<h3 id=\"第二种：field属性的单例循环依赖，可解决。\"><a href=\"#第二种：field属性的单例循环依赖，可解决。\" class=\"headerlink\" title=\"第二种：field属性的单例循环依赖，可解决。\"></a>第二种：field属性的单例循环依赖，可解决。</h3><h4 id=\"情况-1\"><a href=\"#情况-1\" class=\"headerlink\" title=\"情况\"></a>情况</h4><p>A的构造方法中依赖了B的实例对象，同时B的某个field或者setter需要A的实例对象</p>\n<h4 id=\"解决前提\"><a href=\"#解决前提\" class=\"headerlink\" title=\"解决前提\"></a>解决前提</h4><ul>\n<li>前提一：比第一种情况，此时循环依赖发生在字段属性中，而不是构造器中。</li>\n<li>前提二：比第三种情况，因为是单例的，所以才会用到三级缓存。</li>\n</ul>\n<p>前提一：<strong>是先实例化在设置对象属性的，否则解决field属性的setter方式单例循环依赖将无从谈起。</strong>先来看看spring bean生命周期的一张图。</p>\n<p><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png\" alt=\"1564554784479\"></p>\n<p>大体的流程就是：实例化&gt;填充属性&gt;initializeBean(调用spring xml中的init 方法)</p>\n<p>循环依赖主要发生在实例化&gt;填充属性这两步。</p>\n<p>前提二：<strong>对于单例来说</strong>，在Spring容器会把对象放在缓存中，而为了解决单例的循环依赖问题，使用了<strong>Spring三级缓存</strong>。</p>\n<h4 id=\"解决手段\"><a href=\"#解决手段\" class=\"headerlink\" title=\"解决手段\"></a>解决手段</h4><p>三级缓存,这三级缓存分别指： </p>\n<ol>\n<li>singletonObjects：单例对象的cache，一级缓存。</li>\n<li>earlySingletonObjects ：提前暴光的单例对象的Cache ，二级缓存。</li>\n<li>singletonFactories ： 单例对象工厂的cache ，三级缓存。</li>\n</ol>\n<p>由上往下，缓存中的bean是逐渐完善的，三级缓存中的bean 是最初始的状态。</p>\n<h4 id=\"解决过程\"><a href=\"#解决过程\" class=\"headerlink\" title=\"解决过程\"></a>解决过程</h4><p>“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。</p>\n<p>A首先完成了初始化的第一步，并且将自己提前曝光到<strong>singletonFactories</strong>三级缓存中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程。</p>\n<p>B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A提前曝光了，所以B能够通过三级缓存singletonFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)。</p>\n<p>B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中。</p>\n<p>而且由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。</p>\n<h4 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h4><h5 id=\"getSingleton（）\"><a href=\"#getSingleton（）\" class=\"headerlink\" title=\"getSingleton（）\"></a>getSingleton（）</h5><p>获取单例的方法，逐层从缓存中取</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">getSingleton</span><span class=\"params\">(String beanName, <span class=\"keyword\">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">//首先从一级缓存singletonObjects中获取</span></span><br><span class=\"line\">    Object singletonObject = <span class=\"keyword\">this</span>.singletonObjects.get(beanName);</span><br><span class=\"line\"> <span class=\"comment\">//如果获取不到，并且对象正在创建中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singletonObject == <span class=\"keyword\">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.singletonObjects) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//再从二级缓存earlySingletonObjects中获取</span></span><br><span class=\"line\">            singletonObject = <span class=\"keyword\">this</span>.earlySingletonObjects.get(beanName);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (singletonObject == <span class=\"keyword\">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class=\"line\">                ObjectFactory&lt;?&gt; singletonFactory = <span class=\"keyword\">this</span>.singletonFactories.get(beanName);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singletonFactory != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//从三级缓存singletonFactory获取</span></span><br><span class=\"line\">                    singletonObject = singletonFactory.getObject();</span><br><span class=\"line\">      <span class=\"comment\">//放入二级缓存</span></span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class=\"line\">     <span class=\"comment\">//从三级缓存中删除，也就是把bean自动三级移到了二级缓存中</span></span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.singletonFactories.remove(beanName);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"addSingletonFactory（）\"><a href=\"#addSingletonFactory（）\" class=\"headerlink\" title=\"addSingletonFactory（）\"></a>addSingletonFactory（）</h5><p>这段代码发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来(调用了构造器)。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。</p>\n<p>注意：这里有一个细节就是ObjectFactory，<strong>三级缓存的类型是ObjectFactory并非一个bean（还没实例化好呢）。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addSingletonFactory</span><span class=\"params\">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class=\"line\">    Assert.notNull(singletonFactory, <span class=\"string\">\"Singleton factory must not be null\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.singletonObjects) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class=\"line\">     <span class=\"comment\">//三级缓存的类型是ObjectFactory</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.registeredSingletons.add(beanName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>知道了这个原理时候，肯定就知道为啥Spring不能解决第一种情况“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”。因为加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决。</p>\n<h3 id=\"第三种：field属性的prototype循环依赖，无法解决解决，报错\"><a href=\"#第三种：field属性的prototype循环依赖，无法解决解决，报错\" class=\"headerlink\" title=\"第三种：field属性的prototype循环依赖，无法解决解决，报错\"></a>第三种：field属性的prototype循环依赖，无法解决解决，报错</h3><h4 id=\"情况-2\"><a href=\"#情况-2\" class=\"headerlink\" title=\"情况\"></a>情况</h4><p>A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象。</p>\n<h4 id=\"不能解决的前提\"><a href=\"#不能解决的前提\" class=\"headerlink\" title=\"不能解决的前提\"></a>不能解决的前提</h4><p><strong>因为没有缓存。</strong></p>\n<p>scope=”prototype” 意思是 每次请求都会创建一个实例对象。两者的区别是：有状态的bean都使用Prototype作用域，无状态的一般都使用singleton单例作用域。</p>\n<p><strong>对于“prototype”作用域Bean，Spring容器无法完成依赖注入，因为“prototype”作用域的Bean，Spring容器不进行缓存，因此无法提前暴露一个创建中的Bean。</strong></p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/u010644448/article/details/59108799\" target=\"_blank\" rel=\"noopener\">Spring循环依赖的三种方式</a></p>\n<p><a href=\"https://www.jianshu.com/p/6c359768b1dc\" target=\"_blank\" rel=\"noopener\">Spring源码初探-IOC(4)-Bean的初始化-循环依赖的解决</a></p>\n<p><a href=\"https://blog.csdn.net/u010853261/article/details/77940767\" target=\"_blank\" rel=\"noopener\">Spring-bean的循环依赖以及解决方式</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Spring怎么解决循环依赖？\"><a href=\"#Spring怎么解决循环依赖？\" class=\"headerlink\" title=\"Spring怎么解决循环依赖？\"></a>Spring怎么解决循环依赖？</h2><h3 id=\"循环依赖\"><a href=\"#循环依赖\" class=\"headerlink\" title=\"循环依赖\"></a>循环依赖</h3><p>循环依赖是个啥？在创建TestA类时，构需要TestB类，那将去创建TestB，在创建TestB类时又需要TestA，从而形成一个环，没办法创建。</p>\n<p>spring解决这个问题与三特别有缘分，对于三种不同程度的循环依赖，spring能解决的程度不同；而解决的办法正是用到了三级缓存。</p>\n<p>下面就分别来讨论三种不同程度的循环依赖。</p>\n<h3 id=\"第一种：构造器的循环依赖，无法解决，会报错\"><a href=\"#第一种：构造器的循环依赖，无法解决，会报错\" class=\"headerlink\" title=\"第一种：构造器的循环依赖，无法解决，会报错\"></a>第一种：构造器的循环依赖，无法解决，会报错</h3><h4 id=\"情况\"><a href=\"#情况\" class=\"headerlink\" title=\"情况\"></a>情况</h4><p>A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象</p>\n<h4 id=\"无法解决原因\"><a href=\"#无法解决原因\" class=\"headerlink\" title=\"无法解决原因\"></a>无法解决原因</h4><p>一、Spring容器会将每一个正在创建的Bean 标识符放在一个“当前创建Bean池”中，Bean标识符在创建过程中将一直保持在这个池中，因此如果在创建Bean过程中发现自己已经在“当前创建Bean池”里时将抛出BeanCurrentlyInCreationException异常表示循环依赖；而对于创建完毕的Bean将从“当前创建Bean池”中清除掉。</p>\n<p>Spring容器先创建单例StudentA，StudentA依赖StudentB，然后将A放在“当前创建Bean池”中，此时创建StudentB,StudentB依赖StudentA， 但是，此时StudentA已经在池中，所以会报错，因为在池中的Bean都是未初始化完的，所以会依赖错误 ，（初始化完的Bean会从池中移除）</p>\n<p>二、循环依赖发生的时候还没有执行完构造器，也就无法使用三级缓存解决问题。spring解决循环依赖的手段是三级缓存，而三级缓存的的前提是执行了构造器，才会调用addSingletonFactory加入三级缓存，所以构造器的循环依赖没法解决。这在下面一种情况中会有解释，就先不展开了。</p>\n<h3 id=\"第二种：field属性的单例循环依赖，可解决。\"><a href=\"#第二种：field属性的单例循环依赖，可解决。\" class=\"headerlink\" title=\"第二种：field属性的单例循环依赖，可解决。\"></a>第二种：field属性的单例循环依赖，可解决。</h3><h4 id=\"情况-1\"><a href=\"#情况-1\" class=\"headerlink\" title=\"情况\"></a>情况</h4><p>A的构造方法中依赖了B的实例对象，同时B的某个field或者setter需要A的实例对象</p>\n<h4 id=\"解决前提\"><a href=\"#解决前提\" class=\"headerlink\" title=\"解决前提\"></a>解决前提</h4><ul>\n<li>前提一：比第一种情况，此时循环依赖发生在字段属性中，而不是构造器中。</li>\n<li>前提二：比第三种情况，因为是单例的，所以才会用到三级缓存。</li>\n</ul>\n<p>前提一：<strong>是先实例化在设置对象属性的，否则解决field属性的setter方式单例循环依赖将无从谈起。</strong>先来看看spring bean生命周期的一张图。</p>\n<p><img src=\"https://wangxuanni.oss-cn-hongkong.aliyuncs.com/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png\" alt=\"1564554784479\"></p>\n<p>大体的流程就是：实例化&gt;填充属性&gt;initializeBean(调用spring xml中的init 方法)</p>\n<p>循环依赖主要发生在实例化&gt;填充属性这两步。</p>\n<p>前提二：<strong>对于单例来说</strong>，在Spring容器会把对象放在缓存中，而为了解决单例的循环依赖问题，使用了<strong>Spring三级缓存</strong>。</p>\n<h4 id=\"解决手段\"><a href=\"#解决手段\" class=\"headerlink\" title=\"解决手段\"></a>解决手段</h4><p>三级缓存,这三级缓存分别指： </p>\n<ol>\n<li>singletonObjects：单例对象的cache，一级缓存。</li>\n<li>earlySingletonObjects ：提前暴光的单例对象的Cache ，二级缓存。</li>\n<li>singletonFactories ： 单例对象工厂的cache ，三级缓存。</li>\n</ol>\n<p>由上往下，缓存中的bean是逐渐完善的，三级缓存中的bean 是最初始的状态。</p>\n<h4 id=\"解决过程\"><a href=\"#解决过程\" class=\"headerlink\" title=\"解决过程\"></a>解决过程</h4><p>“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。</p>\n<p>A首先完成了初始化的第一步，并且将自己提前曝光到<strong>singletonFactories</strong>三级缓存中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程。</p>\n<p>B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A提前曝光了，所以B能够通过三级缓存singletonFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)。</p>\n<p>B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中。</p>\n<p>而且由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。</p>\n<h4 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h4><h5 id=\"getSingleton（）\"><a href=\"#getSingleton（）\" class=\"headerlink\" title=\"getSingleton（）\"></a>getSingleton（）</h5><p>获取单例的方法，逐层从缓存中取</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">getSingleton</span><span class=\"params\">(String beanName, <span class=\"keyword\">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">//首先从一级缓存singletonObjects中获取</span></span><br><span class=\"line\">    Object singletonObject = <span class=\"keyword\">this</span>.singletonObjects.get(beanName);</span><br><span class=\"line\"> <span class=\"comment\">//如果获取不到，并且对象正在创建中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singletonObject == <span class=\"keyword\">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.singletonObjects) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//再从二级缓存earlySingletonObjects中获取</span></span><br><span class=\"line\">            singletonObject = <span class=\"keyword\">this</span>.earlySingletonObjects.get(beanName);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (singletonObject == <span class=\"keyword\">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class=\"line\">                ObjectFactory&lt;?&gt; singletonFactory = <span class=\"keyword\">this</span>.singletonFactories.get(beanName);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singletonFactory != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//从三级缓存singletonFactory获取</span></span><br><span class=\"line\">                    singletonObject = singletonFactory.getObject();</span><br><span class=\"line\">      <span class=\"comment\">//放入二级缓存</span></span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class=\"line\">     <span class=\"comment\">//从三级缓存中删除，也就是把bean自动三级移到了二级缓存中</span></span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.singletonFactories.remove(beanName);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"addSingletonFactory（）\"><a href=\"#addSingletonFactory（）\" class=\"headerlink\" title=\"addSingletonFactory（）\"></a>addSingletonFactory（）</h5><p>这段代码发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来(调用了构造器)。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。</p>\n<p>注意：这里有一个细节就是ObjectFactory，<strong>三级缓存的类型是ObjectFactory并非一个bean（还没实例化好呢）。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addSingletonFactory</span><span class=\"params\">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class=\"line\">    Assert.notNull(singletonFactory, <span class=\"string\">\"Singleton factory must not be null\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.singletonObjects) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class=\"line\">     <span class=\"comment\">//三级缓存的类型是ObjectFactory</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.registeredSingletons.add(beanName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>知道了这个原理时候，肯定就知道为啥Spring不能解决第一种情况“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”。因为加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决。</p>\n<h3 id=\"第三种：field属性的prototype循环依赖，无法解决解决，报错\"><a href=\"#第三种：field属性的prototype循环依赖，无法解决解决，报错\" class=\"headerlink\" title=\"第三种：field属性的prototype循环依赖，无法解决解决，报错\"></a>第三种：field属性的prototype循环依赖，无法解决解决，报错</h3><h4 id=\"情况-2\"><a href=\"#情况-2\" class=\"headerlink\" title=\"情况\"></a>情况</h4><p>A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象。</p>\n<h4 id=\"不能解决的前提\"><a href=\"#不能解决的前提\" class=\"headerlink\" title=\"不能解决的前提\"></a>不能解决的前提</h4><p><strong>因为没有缓存。</strong></p>\n<p>scope=”prototype” 意思是 每次请求都会创建一个实例对象。两者的区别是：有状态的bean都使用Prototype作用域，无状态的一般都使用singleton单例作用域。</p>\n<p><strong>对于“prototype”作用域Bean，Spring容器无法完成依赖注入，因为“prototype”作用域的Bean，Spring容器不进行缓存，因此无法提前暴露一个创建中的Bean。</strong></p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/u010644448/article/details/59108799\" target=\"_blank\" rel=\"noopener\">Spring循环依赖的三种方式</a></p>\n<p><a href=\"https://www.jianshu.com/p/6c359768b1dc\" target=\"_blank\" rel=\"noopener\">Spring源码初探-IOC(4)-Bean的初始化-循环依赖的解决</a></p>\n<p><a href=\"https://blog.csdn.net/u010853261/article/details/77940767\" target=\"_blank\" rel=\"noopener\">Spring-bean的循环依赖以及解决方式</a></p>\n</blockquote>\n"},{"title":"我的第一篇博文","date":"2018-09-06T02:44:16.000Z","_content":"**<center>我的征途，是星辰大海</center>**\n\n<!-- more -->\n\n\n","source":"_posts/我的第一个博文.md","raw":"---\ntitle: 我的第一篇博文\ndate: 2018-09-06 10:44:16\ntags:\n---\n**<center>我的征途，是星辰大海</center>**\n\n<!-- more -->\n\n\n","slug":"我的第一个博文","published":1,"updated":"2022-02-08T07:09:41.228Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qkm001hw9rpmbnrh766","content":"<p><strong><center>我的征途，是星辰大海</center></strong></p>\n<a id=\"more\"></a>\n","site":{"data":{}},"excerpt":"<p><strong><center>我的征途，是星辰大海</center></strong></p>","more":""},{"title":"数据库系统工程师（软考中级）","date":"2018-09-08T06:00:50.000Z","_content":"\n大二下学期考过了软考中级证书。趁自己还记得，写点东西记录一下。\n<!-- more -->\n# 写在前面的几句废话\n\n这个是软考中级证书的一门，含金量还行吧，现在还没在什么招聘要求上看到它。听师兄说国企会在工资考评上算上它，有它能加几百块钱，不知道是不是真的。考它的主要原因是大二上学了数据库原理。大二下学期又比较闲，想以考带学，查漏补缺。\n简单介绍一下吧。数据库系统工程师资格（水平）考试，一年一次，大概在3 4月份网上报名，5月份考试。考试上午一场，下午一场。两场满分75,45分通过。上午题全是选择题，内容是理论知识，下午5道大题填空或者回答。\n没考试之前，我对于数据库的学习主要是大二一学期都按习题敲代码。对于增删查改，条件查询，视图、储存过程、触发器的代码比较熟悉。期末考虽然也有理论，但就是死记硬背，没有深入学透。\n考取这门证书，让我收获许多理论知识。诸如范式、关系代数。还有可怕的计算机专业知识的考查(ಥ_ಥ)比如校验码，补码，磁盘容量计算，流水线，计算机网络。。。\n敲代码以后可以搬砖。而学习这些理论知识比如范式、关系代数有什么用，我之前也有一些困惑。在知乎上有相似的问题，下面有一些不错的回答。https://www.zhihu.com/question/273489729\n总之，经过这次考证最初加强数据库理论知识的目的达到了。不过，越学越觉得自己知识漏洞越多。。。\n\n# 首先\n\n这门考试仅仅需要准备两本书，这两本都是考试官方指定用书。\n《数据库系统工程师2012至2017年试题分析与解答》这本是历年真题有超详细的解析，需认真刷完。\n《数据库系统工程师考试全程指导》第二本大砖头用于对理论查漏补缺，不买也行，我就没买。by图书馆有的借。\n\n# 当时对我有帮助的博文。\n\n对于三级模式（ 外模式，内模式，模式）刘慰老师的回答让我有种恍然大悟的感觉，推荐阅读！。\nhttps://www.zhihu.com/question/38737183/answer/93294527\n\n列了一些常见的概念 https://blog.csdn.net/BI_25_RED/article/details/52564110\n\n我的软考之路 https://www.cnblogs.com/clnchanpin/p/7358003.html\n\n# 我个人做的一小部分笔记\n\n\n### 上午题常见的概念\n- s读锁（共享） 任何人只能读 \nx写锁（排他） 只有那个人可以读或写\n\n- 并发，就像一个人（cpu）喂2个孩子（程序），轮换着每人喂一口，表面上两个孩子都在吃饭。并行，就是2个人喂2个孩子，两个孩子也同时在吃饭。\n串行：喂完一个再喂第二个。\n\n- 脏读 修改之后 被别人读到 但这个修改又被撤回作废 别人读到就是脏数据。简单来说就是读到的数据是人家不要的。\n幻读 一个事务两次查询，第二次比第一次多了或者少了几行几列数据\n不可重复读 和幻读差不多 不过幻读重点在insert\n更新丢失 回滚多了\n\n- undo 撤销 完成之后\nrollback 未全部完成\nredo日志 数据修改后的\nundo日志 数据修改前的\n\n- 集成测试［在概要设计阶段］：接口，通信 黑\n确认测试［需求设计阶段］：最终用户\n系统测试\n恢复测试即容错测试\n\n- 瀑布模型（理想）一个个阶段过，不回头\n原型（动态定义需求）\n螺旋模型 结合瀑布和演化并加入风险 小系统一圈一圈走阶段\n喷泉模型 （迭代）各阶段交叉‼️对风险进行识别和分析\n\n- 标记耦合和控制耦合的区别：标记耦合传递不是简单的变量而是数据结构\n\n- 人耳可听到的范围是20hz-20khz\n日常说话300-3400hz\n乐器20hz-20khz\n\n- 共享性是指各结点数据共享。\n自制性是指每个节点对本地数据都能独立管理。\n可用性是指当某一场地故障时，系统可以使用其他场地上的副本，而不至于使整个系统瘫痪。\n分布性是指数据在不同场地上的储存。\n\n- 笛卡尔积 的个数 等于两个个数相乘\nπ投影 垂直 就一个表中只需要姓名和成绩，其他过滤\n∂选择 水平\n\n- 中继器（转发器） 物理层\n网桥 数据链路层\n路由器 网络层\n网关（协议转换，交换机） 高层\n集线器 物理层\n\n- 超健：唯一标识（知道学号姓名就可以知道她的年龄班级）\n候选健：超健基础上，不含多余属性（学号姓名知道一个就行了，但加一个课程名才知成绩）\n主键：候选健中随意挑一个\n候选健都是主属性\n\n- 需求分析：数据流图和数据字典。\n逻辑设计：设计关系模式及相关视图。\n物理设计：设计数据的物理组织如索引。\n\n- 将所有对象进行分类，然后确定各类的实体，找出属性，这一过程称为聚集。\n从实体中抽象出子类和父类这一过程称作概括。\n\n- 事物的永久性是指事物一旦提交，其对数据库的影响是永久的，即使系统发生故障也不受影响，提交可以看作是系统对用户的承诺。\n\n### 说说下午题中一些油腻腻的套路。\n\n- 第一大题（数据流图）\n加工的输入数据流和输出数据流要平衡，保证加工的输出数据流都有对应的输入和输出数据流。\n绘制过程中可能出现的错误：\n数据黑洞：只进不出\n数据奇迹：只出不进\n数据灰洞：加工不出输出流\n\n- 第二大题（sql代码）\n一个信息点一个信息的标记出来，别漏了。\n尤其喜欢让你补写GROUP BY。查询了多少个表，group by后面就要跟多少个表。当然函数比如avg（工资）不用。\n补写where。查询多少个表，where是表数减一条。\n\n- 第三大题（设计实体）\n实体的关系不止于两个实体。喜欢考三个实体的关系。\n\n- 第四大题（范式）\n第二范式：消除了非主属性对主属性的部分依赖。缺点是数据冗余，修改、删除、插入异常\n第三范式：消除了非主属性对主属性的传递依赖。缺点是删除、插入异常。\nBNF：消除了主属性对码的部分传递函数依赖。\n\n- 第五大题，略。\n\n\n<div class=\"aplayer\" data-id=\"30953120\" data-server=\"netease\" data-type=\"song\" data-autoplay=\"true\"></div>\n","source":"_posts/数据库系统工程师（软考）.md","raw":"---\ntitle: 数据库系统工程师（软考中级）\ndate: 2018-09-08 14:00:50\ncategories: 数据库\n---\n\n大二下学期考过了软考中级证书。趁自己还记得，写点东西记录一下。\n<!-- more -->\n# 写在前面的几句废话\n\n这个是软考中级证书的一门，含金量还行吧，现在还没在什么招聘要求上看到它。听师兄说国企会在工资考评上算上它，有它能加几百块钱，不知道是不是真的。考它的主要原因是大二上学了数据库原理。大二下学期又比较闲，想以考带学，查漏补缺。\n简单介绍一下吧。数据库系统工程师资格（水平）考试，一年一次，大概在3 4月份网上报名，5月份考试。考试上午一场，下午一场。两场满分75,45分通过。上午题全是选择题，内容是理论知识，下午5道大题填空或者回答。\n没考试之前，我对于数据库的学习主要是大二一学期都按习题敲代码。对于增删查改，条件查询，视图、储存过程、触发器的代码比较熟悉。期末考虽然也有理论，但就是死记硬背，没有深入学透。\n考取这门证书，让我收获许多理论知识。诸如范式、关系代数。还有可怕的计算机专业知识的考查(ಥ_ಥ)比如校验码，补码，磁盘容量计算，流水线，计算机网络。。。\n敲代码以后可以搬砖。而学习这些理论知识比如范式、关系代数有什么用，我之前也有一些困惑。在知乎上有相似的问题，下面有一些不错的回答。https://www.zhihu.com/question/273489729\n总之，经过这次考证最初加强数据库理论知识的目的达到了。不过，越学越觉得自己知识漏洞越多。。。\n\n# 首先\n\n这门考试仅仅需要准备两本书，这两本都是考试官方指定用书。\n《数据库系统工程师2012至2017年试题分析与解答》这本是历年真题有超详细的解析，需认真刷完。\n《数据库系统工程师考试全程指导》第二本大砖头用于对理论查漏补缺，不买也行，我就没买。by图书馆有的借。\n\n# 当时对我有帮助的博文。\n\n对于三级模式（ 外模式，内模式，模式）刘慰老师的回答让我有种恍然大悟的感觉，推荐阅读！。\nhttps://www.zhihu.com/question/38737183/answer/93294527\n\n列了一些常见的概念 https://blog.csdn.net/BI_25_RED/article/details/52564110\n\n我的软考之路 https://www.cnblogs.com/clnchanpin/p/7358003.html\n\n# 我个人做的一小部分笔记\n\n\n### 上午题常见的概念\n- s读锁（共享） 任何人只能读 \nx写锁（排他） 只有那个人可以读或写\n\n- 并发，就像一个人（cpu）喂2个孩子（程序），轮换着每人喂一口，表面上两个孩子都在吃饭。并行，就是2个人喂2个孩子，两个孩子也同时在吃饭。\n串行：喂完一个再喂第二个。\n\n- 脏读 修改之后 被别人读到 但这个修改又被撤回作废 别人读到就是脏数据。简单来说就是读到的数据是人家不要的。\n幻读 一个事务两次查询，第二次比第一次多了或者少了几行几列数据\n不可重复读 和幻读差不多 不过幻读重点在insert\n更新丢失 回滚多了\n\n- undo 撤销 完成之后\nrollback 未全部完成\nredo日志 数据修改后的\nundo日志 数据修改前的\n\n- 集成测试［在概要设计阶段］：接口，通信 黑\n确认测试［需求设计阶段］：最终用户\n系统测试\n恢复测试即容错测试\n\n- 瀑布模型（理想）一个个阶段过，不回头\n原型（动态定义需求）\n螺旋模型 结合瀑布和演化并加入风险 小系统一圈一圈走阶段\n喷泉模型 （迭代）各阶段交叉‼️对风险进行识别和分析\n\n- 标记耦合和控制耦合的区别：标记耦合传递不是简单的变量而是数据结构\n\n- 人耳可听到的范围是20hz-20khz\n日常说话300-3400hz\n乐器20hz-20khz\n\n- 共享性是指各结点数据共享。\n自制性是指每个节点对本地数据都能独立管理。\n可用性是指当某一场地故障时，系统可以使用其他场地上的副本，而不至于使整个系统瘫痪。\n分布性是指数据在不同场地上的储存。\n\n- 笛卡尔积 的个数 等于两个个数相乘\nπ投影 垂直 就一个表中只需要姓名和成绩，其他过滤\n∂选择 水平\n\n- 中继器（转发器） 物理层\n网桥 数据链路层\n路由器 网络层\n网关（协议转换，交换机） 高层\n集线器 物理层\n\n- 超健：唯一标识（知道学号姓名就可以知道她的年龄班级）\n候选健：超健基础上，不含多余属性（学号姓名知道一个就行了，但加一个课程名才知成绩）\n主键：候选健中随意挑一个\n候选健都是主属性\n\n- 需求分析：数据流图和数据字典。\n逻辑设计：设计关系模式及相关视图。\n物理设计：设计数据的物理组织如索引。\n\n- 将所有对象进行分类，然后确定各类的实体，找出属性，这一过程称为聚集。\n从实体中抽象出子类和父类这一过程称作概括。\n\n- 事物的永久性是指事物一旦提交，其对数据库的影响是永久的，即使系统发生故障也不受影响，提交可以看作是系统对用户的承诺。\n\n### 说说下午题中一些油腻腻的套路。\n\n- 第一大题（数据流图）\n加工的输入数据流和输出数据流要平衡，保证加工的输出数据流都有对应的输入和输出数据流。\n绘制过程中可能出现的错误：\n数据黑洞：只进不出\n数据奇迹：只出不进\n数据灰洞：加工不出输出流\n\n- 第二大题（sql代码）\n一个信息点一个信息的标记出来，别漏了。\n尤其喜欢让你补写GROUP BY。查询了多少个表，group by后面就要跟多少个表。当然函数比如avg（工资）不用。\n补写where。查询多少个表，where是表数减一条。\n\n- 第三大题（设计实体）\n实体的关系不止于两个实体。喜欢考三个实体的关系。\n\n- 第四大题（范式）\n第二范式：消除了非主属性对主属性的部分依赖。缺点是数据冗余，修改、删除、插入异常\n第三范式：消除了非主属性对主属性的传递依赖。缺点是删除、插入异常。\nBNF：消除了主属性对码的部分传递函数依赖。\n\n- 第五大题，略。\n\n\n<div class=\"aplayer\" data-id=\"30953120\" data-server=\"netease\" data-type=\"song\" data-autoplay=\"true\"></div>\n","slug":"数据库系统工程师（软考）","published":1,"updated":"2022-02-08T07:09:41.229Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qkn001kw9rppmxdfoxp","content":"<p>大二下学期考过了软考中级证书。趁自己还记得，写点东西记录一下。<br><a id=\"more\"></a></p>\n<h1 id=\"写在前面的几句废话\"><a href=\"#写在前面的几句废话\" class=\"headerlink\" title=\"写在前面的几句废话\"></a>写在前面的几句废话</h1><p>这个是软考中级证书的一门，含金量还行吧，现在还没在什么招聘要求上看到它。听师兄说国企会在工资考评上算上它，有它能加几百块钱，不知道是不是真的。考它的主要原因是大二上学了数据库原理。大二下学期又比较闲，想以考带学，查漏补缺。<br>简单介绍一下吧。数据库系统工程师资格（水平）考试，一年一次，大概在3 4月份网上报名，5月份考试。考试上午一场，下午一场。两场满分75,45分通过。上午题全是选择题，内容是理论知识，下午5道大题填空或者回答。<br>没考试之前，我对于数据库的学习主要是大二一学期都按习题敲代码。对于增删查改，条件查询，视图、储存过程、触发器的代码比较熟悉。期末考虽然也有理论，但就是死记硬背，没有深入学透。<br>考取这门证书，让我收获许多理论知识。诸如范式、关系代数。还有可怕的计算机专业知识的考查(ಥ_ಥ)比如校验码，补码，磁盘容量计算，流水线，计算机网络。。。<br>敲代码以后可以搬砖。而学习这些理论知识比如范式、关系代数有什么用，我之前也有一些困惑。在知乎上有相似的问题，下面有一些不错的回答。<a href=\"https://www.zhihu.com/question/273489729\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/273489729</a><br>总之，经过这次考证最初加强数据库理论知识的目的达到了。不过，越学越觉得自己知识漏洞越多。。。</p>\n<h1 id=\"首先\"><a href=\"#首先\" class=\"headerlink\" title=\"首先\"></a>首先</h1><p>这门考试仅仅需要准备两本书，这两本都是考试官方指定用书。<br>《数据库系统工程师2012至2017年试题分析与解答》这本是历年真题有超详细的解析，需认真刷完。<br>《数据库系统工程师考试全程指导》第二本大砖头用于对理论查漏补缺，不买也行，我就没买。by图书馆有的借。</p>\n<h1 id=\"当时对我有帮助的博文。\"><a href=\"#当时对我有帮助的博文。\" class=\"headerlink\" title=\"当时对我有帮助的博文。\"></a>当时对我有帮助的博文。</h1><p>对于三级模式（ 外模式，内模式，模式）刘慰老师的回答让我有种恍然大悟的感觉，推荐阅读！。<br><a href=\"https://www.zhihu.com/question/38737183/answer/93294527\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/38737183/answer/93294527</a></p>\n<p>列了一些常见的概念 <a href=\"https://blog.csdn.net/BI_25_RED/article/details/52564110\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/BI_25_RED/article/details/52564110</a></p>\n<p>我的软考之路 <a href=\"https://www.cnblogs.com/clnchanpin/p/7358003.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/clnchanpin/p/7358003.html</a></p>\n<h1 id=\"我个人做的一小部分笔记\"><a href=\"#我个人做的一小部分笔记\" class=\"headerlink\" title=\"我个人做的一小部分笔记\"></a>我个人做的一小部分笔记</h1><h3 id=\"上午题常见的概念\"><a href=\"#上午题常见的概念\" class=\"headerlink\" title=\"上午题常见的概念\"></a>上午题常见的概念</h3><ul>\n<li><p>s读锁（共享） 任何人只能读<br>x写锁（排他） 只有那个人可以读或写</p>\n</li>\n<li><p>并发，就像一个人（cpu）喂2个孩子（程序），轮换着每人喂一口，表面上两个孩子都在吃饭。并行，就是2个人喂2个孩子，两个孩子也同时在吃饭。<br>串行：喂完一个再喂第二个。</p>\n</li>\n<li><p>脏读 修改之后 被别人读到 但这个修改又被撤回作废 别人读到就是脏数据。简单来说就是读到的数据是人家不要的。<br>幻读 一个事务两次查询，第二次比第一次多了或者少了几行几列数据<br>不可重复读 和幻读差不多 不过幻读重点在insert<br>更新丢失 回滚多了</p>\n</li>\n<li><p>undo 撤销 完成之后<br>rollback 未全部完成<br>redo日志 数据修改后的<br>undo日志 数据修改前的</p>\n</li>\n<li><p>集成测试［在概要设计阶段］：接口，通信 黑<br>确认测试［需求设计阶段］：最终用户<br>系统测试<br>恢复测试即容错测试</p>\n</li>\n<li><p>瀑布模型（理想）一个个阶段过，不回头<br>原型（动态定义需求）<br>螺旋模型 结合瀑布和演化并加入风险 小系统一圈一圈走阶段<br>喷泉模型 （迭代）各阶段交叉‼️对风险进行识别和分析</p>\n</li>\n<li><p>标记耦合和控制耦合的区别：标记耦合传递不是简单的变量而是数据结构</p>\n</li>\n<li><p>人耳可听到的范围是20hz-20khz<br>日常说话300-3400hz<br>乐器20hz-20khz</p>\n</li>\n<li><p>共享性是指各结点数据共享。<br>自制性是指每个节点对本地数据都能独立管理。<br>可用性是指当某一场地故障时，系统可以使用其他场地上的副本，而不至于使整个系统瘫痪。<br>分布性是指数据在不同场地上的储存。</p>\n</li>\n<li><p>笛卡尔积 的个数 等于两个个数相乘<br>π投影 垂直 就一个表中只需要姓名和成绩，其他过滤<br>∂选择 水平</p>\n</li>\n<li><p>中继器（转发器） 物理层<br>网桥 数据链路层<br>路由器 网络层<br>网关（协议转换，交换机） 高层<br>集线器 物理层</p>\n</li>\n<li><p>超健：唯一标识（知道学号姓名就可以知道她的年龄班级）<br>候选健：超健基础上，不含多余属性（学号姓名知道一个就行了，但加一个课程名才知成绩）<br>主键：候选健中随意挑一个<br>候选健都是主属性</p>\n</li>\n<li><p>需求分析：数据流图和数据字典。<br>逻辑设计：设计关系模式及相关视图。<br>物理设计：设计数据的物理组织如索引。</p>\n</li>\n<li><p>将所有对象进行分类，然后确定各类的实体，找出属性，这一过程称为聚集。<br>从实体中抽象出子类和父类这一过程称作概括。</p>\n</li>\n<li><p>事物的永久性是指事物一旦提交，其对数据库的影响是永久的，即使系统发生故障也不受影响，提交可以看作是系统对用户的承诺。</p>\n</li>\n</ul>\n<h3 id=\"说说下午题中一些油腻腻的套路。\"><a href=\"#说说下午题中一些油腻腻的套路。\" class=\"headerlink\" title=\"说说下午题中一些油腻腻的套路。\"></a>说说下午题中一些油腻腻的套路。</h3><ul>\n<li><p>第一大题（数据流图）<br>加工的输入数据流和输出数据流要平衡，保证加工的输出数据流都有对应的输入和输出数据流。<br>绘制过程中可能出现的错误：<br>数据黑洞：只进不出<br>数据奇迹：只出不进<br>数据灰洞：加工不出输出流</p>\n</li>\n<li><p>第二大题（sql代码）<br>一个信息点一个信息的标记出来，别漏了。<br>尤其喜欢让你补写GROUP BY。查询了多少个表，group by后面就要跟多少个表。当然函数比如avg（工资）不用。<br>补写where。查询多少个表，where是表数减一条。</p>\n</li>\n<li><p>第三大题（设计实体）<br>实体的关系不止于两个实体。喜欢考三个实体的关系。</p>\n</li>\n<li><p>第四大题（范式）<br>第二范式：消除了非主属性对主属性的部分依赖。缺点是数据冗余，修改、删除、插入异常<br>第三范式：消除了非主属性对主属性的传递依赖。缺点是删除、插入异常。<br>BNF：消除了主属性对码的部分传递函数依赖。</p>\n</li>\n<li><p>第五大题，略。</p>\n</li>\n</ul>\n<div class=\"aplayer\" data-id=\"30953120\" data-server=\"netease\" data-type=\"song\" data-autoplay=\"true\"></div>\n","site":{"data":{}},"excerpt":"<p>大二下学期考过了软考中级证书。趁自己还记得，写点东西记录一下。<br>","more":"</p>\n<h1 id=\"写在前面的几句废话\"><a href=\"#写在前面的几句废话\" class=\"headerlink\" title=\"写在前面的几句废话\"></a>写在前面的几句废话</h1><p>这个是软考中级证书的一门，含金量还行吧，现在还没在什么招聘要求上看到它。听师兄说国企会在工资考评上算上它，有它能加几百块钱，不知道是不是真的。考它的主要原因是大二上学了数据库原理。大二下学期又比较闲，想以考带学，查漏补缺。<br>简单介绍一下吧。数据库系统工程师资格（水平）考试，一年一次，大概在3 4月份网上报名，5月份考试。考试上午一场，下午一场。两场满分75,45分通过。上午题全是选择题，内容是理论知识，下午5道大题填空或者回答。<br>没考试之前，我对于数据库的学习主要是大二一学期都按习题敲代码。对于增删查改，条件查询，视图、储存过程、触发器的代码比较熟悉。期末考虽然也有理论，但就是死记硬背，没有深入学透。<br>考取这门证书，让我收获许多理论知识。诸如范式、关系代数。还有可怕的计算机专业知识的考查(ಥ_ಥ)比如校验码，补码，磁盘容量计算，流水线，计算机网络。。。<br>敲代码以后可以搬砖。而学习这些理论知识比如范式、关系代数有什么用，我之前也有一些困惑。在知乎上有相似的问题，下面有一些不错的回答。<a href=\"https://www.zhihu.com/question/273489729\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/273489729</a><br>总之，经过这次考证最初加强数据库理论知识的目的达到了。不过，越学越觉得自己知识漏洞越多。。。</p>\n<h1 id=\"首先\"><a href=\"#首先\" class=\"headerlink\" title=\"首先\"></a>首先</h1><p>这门考试仅仅需要准备两本书，这两本都是考试官方指定用书。<br>《数据库系统工程师2012至2017年试题分析与解答》这本是历年真题有超详细的解析，需认真刷完。<br>《数据库系统工程师考试全程指导》第二本大砖头用于对理论查漏补缺，不买也行，我就没买。by图书馆有的借。</p>\n<h1 id=\"当时对我有帮助的博文。\"><a href=\"#当时对我有帮助的博文。\" class=\"headerlink\" title=\"当时对我有帮助的博文。\"></a>当时对我有帮助的博文。</h1><p>对于三级模式（ 外模式，内模式，模式）刘慰老师的回答让我有种恍然大悟的感觉，推荐阅读！。<br><a href=\"https://www.zhihu.com/question/38737183/answer/93294527\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/38737183/answer/93294527</a></p>\n<p>列了一些常见的概念 <a href=\"https://blog.csdn.net/BI_25_RED/article/details/52564110\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/BI_25_RED/article/details/52564110</a></p>\n<p>我的软考之路 <a href=\"https://www.cnblogs.com/clnchanpin/p/7358003.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/clnchanpin/p/7358003.html</a></p>\n<h1 id=\"我个人做的一小部分笔记\"><a href=\"#我个人做的一小部分笔记\" class=\"headerlink\" title=\"我个人做的一小部分笔记\"></a>我个人做的一小部分笔记</h1><h3 id=\"上午题常见的概念\"><a href=\"#上午题常见的概念\" class=\"headerlink\" title=\"上午题常见的概念\"></a>上午题常见的概念</h3><ul>\n<li><p>s读锁（共享） 任何人只能读<br>x写锁（排他） 只有那个人可以读或写</p>\n</li>\n<li><p>并发，就像一个人（cpu）喂2个孩子（程序），轮换着每人喂一口，表面上两个孩子都在吃饭。并行，就是2个人喂2个孩子，两个孩子也同时在吃饭。<br>串行：喂完一个再喂第二个。</p>\n</li>\n<li><p>脏读 修改之后 被别人读到 但这个修改又被撤回作废 别人读到就是脏数据。简单来说就是读到的数据是人家不要的。<br>幻读 一个事务两次查询，第二次比第一次多了或者少了几行几列数据<br>不可重复读 和幻读差不多 不过幻读重点在insert<br>更新丢失 回滚多了</p>\n</li>\n<li><p>undo 撤销 完成之后<br>rollback 未全部完成<br>redo日志 数据修改后的<br>undo日志 数据修改前的</p>\n</li>\n<li><p>集成测试［在概要设计阶段］：接口，通信 黑<br>确认测试［需求设计阶段］：最终用户<br>系统测试<br>恢复测试即容错测试</p>\n</li>\n<li><p>瀑布模型（理想）一个个阶段过，不回头<br>原型（动态定义需求）<br>螺旋模型 结合瀑布和演化并加入风险 小系统一圈一圈走阶段<br>喷泉模型 （迭代）各阶段交叉‼️对风险进行识别和分析</p>\n</li>\n<li><p>标记耦合和控制耦合的区别：标记耦合传递不是简单的变量而是数据结构</p>\n</li>\n<li><p>人耳可听到的范围是20hz-20khz<br>日常说话300-3400hz<br>乐器20hz-20khz</p>\n</li>\n<li><p>共享性是指各结点数据共享。<br>自制性是指每个节点对本地数据都能独立管理。<br>可用性是指当某一场地故障时，系统可以使用其他场地上的副本，而不至于使整个系统瘫痪。<br>分布性是指数据在不同场地上的储存。</p>\n</li>\n<li><p>笛卡尔积 的个数 等于两个个数相乘<br>π投影 垂直 就一个表中只需要姓名和成绩，其他过滤<br>∂选择 水平</p>\n</li>\n<li><p>中继器（转发器） 物理层<br>网桥 数据链路层<br>路由器 网络层<br>网关（协议转换，交换机） 高层<br>集线器 物理层</p>\n</li>\n<li><p>超健：唯一标识（知道学号姓名就可以知道她的年龄班级）<br>候选健：超健基础上，不含多余属性（学号姓名知道一个就行了，但加一个课程名才知成绩）<br>主键：候选健中随意挑一个<br>候选健都是主属性</p>\n</li>\n<li><p>需求分析：数据流图和数据字典。<br>逻辑设计：设计关系模式及相关视图。<br>物理设计：设计数据的物理组织如索引。</p>\n</li>\n<li><p>将所有对象进行分类，然后确定各类的实体，找出属性，这一过程称为聚集。<br>从实体中抽象出子类和父类这一过程称作概括。</p>\n</li>\n<li><p>事物的永久性是指事物一旦提交，其对数据库的影响是永久的，即使系统发生故障也不受影响，提交可以看作是系统对用户的承诺。</p>\n</li>\n</ul>\n<h3 id=\"说说下午题中一些油腻腻的套路。\"><a href=\"#说说下午题中一些油腻腻的套路。\" class=\"headerlink\" title=\"说说下午题中一些油腻腻的套路。\"></a>说说下午题中一些油腻腻的套路。</h3><ul>\n<li><p>第一大题（数据流图）<br>加工的输入数据流和输出数据流要平衡，保证加工的输出数据流都有对应的输入和输出数据流。<br>绘制过程中可能出现的错误：<br>数据黑洞：只进不出<br>数据奇迹：只出不进<br>数据灰洞：加工不出输出流</p>\n</li>\n<li><p>第二大题（sql代码）<br>一个信息点一个信息的标记出来，别漏了。<br>尤其喜欢让你补写GROUP BY。查询了多少个表，group by后面就要跟多少个表。当然函数比如avg（工资）不用。<br>补写where。查询多少个表，where是表数减一条。</p>\n</li>\n<li><p>第三大题（设计实体）<br>实体的关系不止于两个实体。喜欢考三个实体的关系。</p>\n</li>\n<li><p>第四大题（范式）<br>第二范式：消除了非主属性对主属性的部分依赖。缺点是数据冗余，修改、删除、插入异常<br>第三范式：消除了非主属性对主属性的传递依赖。缺点是删除、插入异常。<br>BNF：消除了主属性对码的部分传递函数依赖。</p>\n</li>\n<li><p>第五大题，略。</p>\n</li>\n</ul>\n<div class=\"aplayer\" data-id=\"30953120\" data-server=\"netease\" data-type=\"song\" data-autoplay=\"true\"></div>"},{"title":"手写http服务器（一）","date":"2019-05-29T02:44:16.000Z","description":"V1","_content":">这里默认读者是连http服务器是啥一点概念都没有（但是得有网络编程基础），会从最基本的概念讲起，一步步写一个服务器，大神就不要点进来看我献丑了hhh\n\n\n# 版本全览\n版本一：基于bio百行代码实现http服务器\n版本二：基于nio\n版本三：serlevt容器、cookie、封装、日志\n版本四：长连接、参考了tomcat设计\n# 起源\n*早在学jsp的时候，就很好奇tomcat是什么，为什么可以运行jsp、servlet？当时试图看业界盛誉的《how to tomcat work》，没看懂（但这确实是本神书）；问师兄，师兄也不太清楚。网上的博客就更不用说了。这个困惑就先被我放到一边去了。\n寒假的时候用socket、多线程写了一个聊天室。突然明白，其实tomcat就像一个聊天室的服务器啊，浏览器相当于客户端，HTTP请求响应相当于聊天消息，浏览器给服务器发消息，服务器做处理。http报文只是遵守一定格式的字符串。\n只不过聊天室的服务器是把收到的信息转发给其他客户端。而HTTP的服务的返回一个符合HTTP协议的消息。\n最初的版本v1，只能把收到的HTTP报文打印到控制台，返回浏览器响应显示一句话。\n后来发现github上比我大一两届的前辈也写过这个东西，但是他们有好多功能比如基于nio、servlet等等，像模像样。受到启发，这项目认真起来大有搞头。就有了把这个当成自己的一个项目去完善的心态。看了一些书、博客、视频。最近还发现群里的小伙伴也有在写这个的，此处点名糖糖。*\n写这个服务器的好处：\n* 写轮子所需几乎覆盖java所有知识点，因为即使是一个xml解析也要自己写，不像写后台一样有很多框架、工具可以用。\n* 成就感强。tomcat算比较适合自己造轮子的入门中间件。曾经也有写一个Spring的想法，但看了源码之后就放弃了。Spring源码优秀，适合参读，但不太适合自己撸一个。\n* 对后台开发的眼界会\n\n# V1\n## 关键字：bio、百行代码内\n\n***[代码链接](https://github.com/wangxuanni/MyTomcat/tree/master/src/v1/BioServer.java)***\n\n\n## 技术点\n* BIO\n* Socket\n* 缓存线程池\n* lambda表达式\n* HTTP请求响应报文\n\n## 5个步骤的关键代码\n\n一、开启服务器绑定端口\n`ServerSocket serverSocket = new ServerSocket(8080);`\n二、一直循环等待\n`while（true）{`\n三、收到请求的套接字\n`Socket socket = serverSocket.accept();`\n四、套接字可以获得一个字节输入流，把这个输入流转成字符串，打印在控制台。\n`InputStream inputStream = socket.getInputStream();`\n五、创建响应报文（其实就是按照HTTP报文的格式构建的一个字符串）并返回响应\n`BufferedWriter bw =new BufferedWriter(new \nOutputStreamWriter(socket.getOutputStream()));`\n\n\n## 注意一些小坑\n缓存字符流写入后记得要刷新！！！bw.flush();\n选择缓存线程池是因为它更适合短连接。\n构建响应报文用StringBuilder比String更好\n响应报文正文要构建好并且要记录长度，因为响应头有一个Content-length:正文长度属性要填\n记得在finally块把socket.close()关闭\n\n\n\n# V2\n\n\n## 关键字：NIO\n这个版本主要从bio升级为nio。\n***[代码链接](https://github.com/wangxuanni/MyTomcat/tree/master/src/v2)***\nv2\n最重要是弄懂nio是时候掏出我之前的bio、nio笔记了。\n### bio\n先讲一下bio抛砖引玉，主要是为了和nio做对比。\n#### 1.概念\n阻塞并同步。特点是IO两个阶段被阻塞。基于流模型。\n客户端一个请求服务端就启动一个线程，线序发生请求给内核，由内核去通信，在内核准备好数据之前，线程是被挂起的，知道数据从内核复制到用户空间。调用是可靠的线性顺序\n缺点：每次请求创建一个线程在销毁开销比较大，操作系统对线程的总数有限制，太多服务器可能瘫痪。可以用线程池改进。\n创建bio服务器只需要一步。\n#### 2.配置服务器\n```\n一、ServerSocket serverSocket = new ServerSocket(8080);\n```\n#### 3.处理请求返回响应\n```\n二、一直循环等待\n`while（true）{\n三、收到请求的套接字\n`Socket socket = serverSocket.accept();`\n四、用套接字得到输入输出流，处理请求响应\n}\n```\n### nio\n#### 1.概念\n非阻塞并同步。可构建多路复用、同步非阻塞的io操作。特点是程序去不断询问内核是否准备好，基于buffers。\n客户端请求会注册到多路复用上，单线程轮询到有io请求时，才启动一个线程进行处理，仅仅selector是阻塞的。\n核心：Channels（类似流，全双工，可以读写。socketChannel、serverSocketChannel）\nbuffers8种基本类型都有，数据从channel读到buffer中，也可以从buffer写到channel。本质是一块方便读写数据的内存\nselector多路复用器，以监听多个Channel通道感兴趣的事情。允许单线程处理多个channel。 \n* OP_ACCEPT: 接收就绪\n* OP_READ: 读取就绪\n* OP_WRITE: 写入就绪\n* OP_CONNECT: 连接就绪\n\n一个server socket channel准备好接收新进入的连接称为“接收就绪”。某个channel成功连接到另一个服务器称为“连接就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。\n所以只有OP_ACCEPT: 接收就绪是serviceSocketChannel使用的，其他三个都是socketChannel使用。\n\n#### 2.配置服务器\n```\n     /**\n         * 1. 创建Selector\n         */\n        Selector selector = Selector.open();\n        /**\n         * 2. 通过ServerSocketChannel创建channel通道\n         */\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        /**\n         * 3. 为channel通道绑定监听端口\n         */\n        serverSocketChannel.bind(new InetSocketAddress(8000));\n\n        /**\n         * 4. **设置channel为非阻塞模式**\n         */\n        serverSocketChannel.configureBlocking(false);\n        /**\n         * 5. 将channel注册到selector上，监听连接事件\n         */\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        System.out.println(\"服务器启动成功！\");\n       \n\n```\n总结一下上面代码，创建多路复用器，创建ServerSocketChannel，简称ssc，ssc绑定端口并设置为非阻塞，将ssc注册到多路复用器上，监听连接事件。到这里服务器已经配置好了。\n\n#### 3.处理请求返回响应\n\n```\n /**\n    while (true) {\n            int readyChannels = selector.select();\n            if (readyChannels == 0) {\n                continue;\n            }\n            Set<SelectionKey> selectionKeys = selector.selectedKeys();\n            Iterator iterator = selectionKeys.iterator();\n\n            while (iterator.hasNext()) {\n\n                SelectionKey selectionKey = (SelectionKey) iterator.next();\n\n                if (selectionKey.isAcceptable()) {\n                    SocketChannel socketChannel = serverSocketChannel.accept();\n                    socketChannel.configureBlocking(false);\n                    socketChannel.register(selector, SelectionKey.OP_READ);\n\n                    Response response = new Response(socketChannel);\n\n                    response.print(\"<html>\");\n                    response.print(\"<head>\");\n                    response.print(\"<title>\");\n                    response.print(\"服务器响应成功\");\n                    response.print(\"</title>\");\n                    response.print(\"</head>\");\n                    response.print(\"<body>\");\n                    response.print(\"来而不往非礼也\");\n                    response.print(\"</body>\");\n                    response.print(\"</html>\");\n\n                    response.pushToBrowser(200);\n\n                }\n\n                if (selectionKey.isReadable()) {\n                    Request request = new Request(selectionKey);\n                }\n                iterator.remove();\n            }\n\n        }\n\n\n```\n#### 4.总结\n\n循环询问多路复用器的selectedKeys是否有值，等待连接事件\n当有连接事件过来了，创建socketChannel\n将socketChannel设置为非阻塞工作模式\n将channel注册回selector上，监听**可读事件**\n创建Response并传入socketChannel，在Response里socketChannel.write();返回响应\n\n如果是可读事件，把selectionKey传入Request解析请求，Request类首先selectionKey里获取socketChannel（就之前接入事件创建的socketChannel），然后创建byteBuffer，用于读取客户端请求信息。\n\n#### 5.其他\nSelector、ServerSocketChannel本身为抽象类，不能直接创建,需要通过open()方法打开。\n注意这段代码\n```\n     if (readyChannels == 0) {\n                continue;}\n```\n\n最后献上教程，关于nio，[慕课有一个特别好的教程](http://www.imooc.com/learn/1118)，老师讲的很清楚。\n# V3\n进行封装 request接受请求并打印。\nresponse根据传入的状态码封装固定的头信息、推送响应信息。\nserver类只关心内容和状态码.\n","source":"_posts/手写http服务器.md","raw":"---\ntitle: 手写http服务器（一）\ndate: 2019-05-29 10:44:16\ncategories: mytomcat\ndescription: V1\n---\n>这里默认读者是连http服务器是啥一点概念都没有（但是得有网络编程基础），会从最基本的概念讲起，一步步写一个服务器，大神就不要点进来看我献丑了hhh\n\n\n# 版本全览\n版本一：基于bio百行代码实现http服务器\n版本二：基于nio\n版本三：serlevt容器、cookie、封装、日志\n版本四：长连接、参考了tomcat设计\n# 起源\n*早在学jsp的时候，就很好奇tomcat是什么，为什么可以运行jsp、servlet？当时试图看业界盛誉的《how to tomcat work》，没看懂（但这确实是本神书）；问师兄，师兄也不太清楚。网上的博客就更不用说了。这个困惑就先被我放到一边去了。\n寒假的时候用socket、多线程写了一个聊天室。突然明白，其实tomcat就像一个聊天室的服务器啊，浏览器相当于客户端，HTTP请求响应相当于聊天消息，浏览器给服务器发消息，服务器做处理。http报文只是遵守一定格式的字符串。\n只不过聊天室的服务器是把收到的信息转发给其他客户端。而HTTP的服务的返回一个符合HTTP协议的消息。\n最初的版本v1，只能把收到的HTTP报文打印到控制台，返回浏览器响应显示一句话。\n后来发现github上比我大一两届的前辈也写过这个东西，但是他们有好多功能比如基于nio、servlet等等，像模像样。受到启发，这项目认真起来大有搞头。就有了把这个当成自己的一个项目去完善的心态。看了一些书、博客、视频。最近还发现群里的小伙伴也有在写这个的，此处点名糖糖。*\n写这个服务器的好处：\n* 写轮子所需几乎覆盖java所有知识点，因为即使是一个xml解析也要自己写，不像写后台一样有很多框架、工具可以用。\n* 成就感强。tomcat算比较适合自己造轮子的入门中间件。曾经也有写一个Spring的想法，但看了源码之后就放弃了。Spring源码优秀，适合参读，但不太适合自己撸一个。\n* 对后台开发的眼界会\n\n# V1\n## 关键字：bio、百行代码内\n\n***[代码链接](https://github.com/wangxuanni/MyTomcat/tree/master/src/v1/BioServer.java)***\n\n\n## 技术点\n* BIO\n* Socket\n* 缓存线程池\n* lambda表达式\n* HTTP请求响应报文\n\n## 5个步骤的关键代码\n\n一、开启服务器绑定端口\n`ServerSocket serverSocket = new ServerSocket(8080);`\n二、一直循环等待\n`while（true）{`\n三、收到请求的套接字\n`Socket socket = serverSocket.accept();`\n四、套接字可以获得一个字节输入流，把这个输入流转成字符串，打印在控制台。\n`InputStream inputStream = socket.getInputStream();`\n五、创建响应报文（其实就是按照HTTP报文的格式构建的一个字符串）并返回响应\n`BufferedWriter bw =new BufferedWriter(new \nOutputStreamWriter(socket.getOutputStream()));`\n\n\n## 注意一些小坑\n缓存字符流写入后记得要刷新！！！bw.flush();\n选择缓存线程池是因为它更适合短连接。\n构建响应报文用StringBuilder比String更好\n响应报文正文要构建好并且要记录长度，因为响应头有一个Content-length:正文长度属性要填\n记得在finally块把socket.close()关闭\n\n\n\n# V2\n\n\n## 关键字：NIO\n这个版本主要从bio升级为nio。\n***[代码链接](https://github.com/wangxuanni/MyTomcat/tree/master/src/v2)***\nv2\n最重要是弄懂nio是时候掏出我之前的bio、nio笔记了。\n### bio\n先讲一下bio抛砖引玉，主要是为了和nio做对比。\n#### 1.概念\n阻塞并同步。特点是IO两个阶段被阻塞。基于流模型。\n客户端一个请求服务端就启动一个线程，线序发生请求给内核，由内核去通信，在内核准备好数据之前，线程是被挂起的，知道数据从内核复制到用户空间。调用是可靠的线性顺序\n缺点：每次请求创建一个线程在销毁开销比较大，操作系统对线程的总数有限制，太多服务器可能瘫痪。可以用线程池改进。\n创建bio服务器只需要一步。\n#### 2.配置服务器\n```\n一、ServerSocket serverSocket = new ServerSocket(8080);\n```\n#### 3.处理请求返回响应\n```\n二、一直循环等待\n`while（true）{\n三、收到请求的套接字\n`Socket socket = serverSocket.accept();`\n四、用套接字得到输入输出流，处理请求响应\n}\n```\n### nio\n#### 1.概念\n非阻塞并同步。可构建多路复用、同步非阻塞的io操作。特点是程序去不断询问内核是否准备好，基于buffers。\n客户端请求会注册到多路复用上，单线程轮询到有io请求时，才启动一个线程进行处理，仅仅selector是阻塞的。\n核心：Channels（类似流，全双工，可以读写。socketChannel、serverSocketChannel）\nbuffers8种基本类型都有，数据从channel读到buffer中，也可以从buffer写到channel。本质是一块方便读写数据的内存\nselector多路复用器，以监听多个Channel通道感兴趣的事情。允许单线程处理多个channel。 \n* OP_ACCEPT: 接收就绪\n* OP_READ: 读取就绪\n* OP_WRITE: 写入就绪\n* OP_CONNECT: 连接就绪\n\n一个server socket channel准备好接收新进入的连接称为“接收就绪”。某个channel成功连接到另一个服务器称为“连接就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。\n所以只有OP_ACCEPT: 接收就绪是serviceSocketChannel使用的，其他三个都是socketChannel使用。\n\n#### 2.配置服务器\n```\n     /**\n         * 1. 创建Selector\n         */\n        Selector selector = Selector.open();\n        /**\n         * 2. 通过ServerSocketChannel创建channel通道\n         */\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        /**\n         * 3. 为channel通道绑定监听端口\n         */\n        serverSocketChannel.bind(new InetSocketAddress(8000));\n\n        /**\n         * 4. **设置channel为非阻塞模式**\n         */\n        serverSocketChannel.configureBlocking(false);\n        /**\n         * 5. 将channel注册到selector上，监听连接事件\n         */\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        System.out.println(\"服务器启动成功！\");\n       \n\n```\n总结一下上面代码，创建多路复用器，创建ServerSocketChannel，简称ssc，ssc绑定端口并设置为非阻塞，将ssc注册到多路复用器上，监听连接事件。到这里服务器已经配置好了。\n\n#### 3.处理请求返回响应\n\n```\n /**\n    while (true) {\n            int readyChannels = selector.select();\n            if (readyChannels == 0) {\n                continue;\n            }\n            Set<SelectionKey> selectionKeys = selector.selectedKeys();\n            Iterator iterator = selectionKeys.iterator();\n\n            while (iterator.hasNext()) {\n\n                SelectionKey selectionKey = (SelectionKey) iterator.next();\n\n                if (selectionKey.isAcceptable()) {\n                    SocketChannel socketChannel = serverSocketChannel.accept();\n                    socketChannel.configureBlocking(false);\n                    socketChannel.register(selector, SelectionKey.OP_READ);\n\n                    Response response = new Response(socketChannel);\n\n                    response.print(\"<html>\");\n                    response.print(\"<head>\");\n                    response.print(\"<title>\");\n                    response.print(\"服务器响应成功\");\n                    response.print(\"</title>\");\n                    response.print(\"</head>\");\n                    response.print(\"<body>\");\n                    response.print(\"来而不往非礼也\");\n                    response.print(\"</body>\");\n                    response.print(\"</html>\");\n\n                    response.pushToBrowser(200);\n\n                }\n\n                if (selectionKey.isReadable()) {\n                    Request request = new Request(selectionKey);\n                }\n                iterator.remove();\n            }\n\n        }\n\n\n```\n#### 4.总结\n\n循环询问多路复用器的selectedKeys是否有值，等待连接事件\n当有连接事件过来了，创建socketChannel\n将socketChannel设置为非阻塞工作模式\n将channel注册回selector上，监听**可读事件**\n创建Response并传入socketChannel，在Response里socketChannel.write();返回响应\n\n如果是可读事件，把selectionKey传入Request解析请求，Request类首先selectionKey里获取socketChannel（就之前接入事件创建的socketChannel），然后创建byteBuffer，用于读取客户端请求信息。\n\n#### 5.其他\nSelector、ServerSocketChannel本身为抽象类，不能直接创建,需要通过open()方法打开。\n注意这段代码\n```\n     if (readyChannels == 0) {\n                continue;}\n```\n\n最后献上教程，关于nio，[慕课有一个特别好的教程](http://www.imooc.com/learn/1118)，老师讲的很清楚。\n# V3\n进行封装 request接受请求并打印。\nresponse根据传入的状态码封装固定的头信息、推送响应信息。\nserver类只关心内容和状态码.\n","slug":"手写http服务器","published":1,"updated":"2022-02-08T07:09:41.228Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qkp001mw9rpmn46o4w7","content":"<blockquote>\n<p>这里默认读者是连http服务器是啥一点概念都没有（但是得有网络编程基础），会从最基本的概念讲起，一步步写一个服务器，大神就不要点进来看我献丑了hhh</p>\n</blockquote>\n<h1 id=\"版本全览\"><a href=\"#版本全览\" class=\"headerlink\" title=\"版本全览\"></a>版本全览</h1><p>版本一：基于bio百行代码实现http服务器<br>版本二：基于nio<br>版本三：serlevt容器、cookie、封装、日志<br>版本四：长连接、参考了tomcat设计</p>\n<h1 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h1><p><em>早在学jsp的时候，就很好奇tomcat是什么，为什么可以运行jsp、servlet？当时试图看业界盛誉的《how to tomcat work》，没看懂（但这确实是本神书）；问师兄，师兄也不太清楚。网上的博客就更不用说了。这个困惑就先被我放到一边去了。<br>寒假的时候用socket、多线程写了一个聊天室。突然明白，其实tomcat就像一个聊天室的服务器啊，浏览器相当于客户端，HTTP请求响应相当于聊天消息，浏览器给服务器发消息，服务器做处理。http报文只是遵守一定格式的字符串。<br>只不过聊天室的服务器是把收到的信息转发给其他客户端。而HTTP的服务的返回一个符合HTTP协议的消息。<br>最初的版本v1，只能把收到的HTTP报文打印到控制台，返回浏览器响应显示一句话。<br>后来发现github上比我大一两届的前辈也写过这个东西，但是他们有好多功能比如基于nio、servlet等等，像模像样。受到启发，这项目认真起来大有搞头。就有了把这个当成自己的一个项目去完善的心态。看了一些书、博客、视频。最近还发现群里的小伙伴也有在写这个的，此处点名糖糖。</em><br>写这个服务器的好处：</p>\n<ul>\n<li>写轮子所需几乎覆盖java所有知识点，因为即使是一个xml解析也要自己写，不像写后台一样有很多框架、工具可以用。</li>\n<li>成就感强。tomcat算比较适合自己造轮子的入门中间件。曾经也有写一个Spring的想法，但看了源码之后就放弃了。Spring源码优秀，适合参读，但不太适合自己撸一个。</li>\n<li>对后台开发的眼界会</li>\n</ul>\n<h1 id=\"V1\"><a href=\"#V1\" class=\"headerlink\" title=\"V1\"></a>V1</h1><h2 id=\"关键字：bio、百行代码内\"><a href=\"#关键字：bio、百行代码内\" class=\"headerlink\" title=\"关键字：bio、百行代码内\"></a>关键字：bio、百行代码内</h2><p><strong><em><a href=\"https://github.com/wangxuanni/MyTomcat/tree/master/src/v1/BioServer.java\" target=\"_blank\" rel=\"noopener\">代码链接</a></em></strong></p>\n<h2 id=\"技术点\"><a href=\"#技术点\" class=\"headerlink\" title=\"技术点\"></a>技术点</h2><ul>\n<li>BIO</li>\n<li>Socket</li>\n<li>缓存线程池</li>\n<li>lambda表达式</li>\n<li>HTTP请求响应报文</li>\n</ul>\n<h2 id=\"5个步骤的关键代码\"><a href=\"#5个步骤的关键代码\" class=\"headerlink\" title=\"5个步骤的关键代码\"></a>5个步骤的关键代码</h2><p>一、开启服务器绑定端口<br><code>ServerSocket serverSocket = new ServerSocket(8080);</code><br>二、一直循环等待<br><code>while（true）{</code><br>三、收到请求的套接字<br><code>Socket socket = serverSocket.accept();</code><br>四、套接字可以获得一个字节输入流，把这个输入流转成字符串，打印在控制台。<br><code>InputStream inputStream = socket.getInputStream();</code><br>五、创建响应报文（其实就是按照HTTP报文的格式构建的一个字符串）并返回响应<br><code>BufferedWriter bw =new BufferedWriter(new \nOutputStreamWriter(socket.getOutputStream()));</code></p>\n<h2 id=\"注意一些小坑\"><a href=\"#注意一些小坑\" class=\"headerlink\" title=\"注意一些小坑\"></a>注意一些小坑</h2><p>缓存字符流写入后记得要刷新！！！bw.flush();<br>选择缓存线程池是因为它更适合短连接。<br>构建响应报文用StringBuilder比String更好<br>响应报文正文要构建好并且要记录长度，因为响应头有一个Content-length:正文长度属性要填<br>记得在finally块把socket.close()关闭</p>\n<h1 id=\"V2\"><a href=\"#V2\" class=\"headerlink\" title=\"V2\"></a>V2</h1><h2 id=\"关键字：NIO\"><a href=\"#关键字：NIO\" class=\"headerlink\" title=\"关键字：NIO\"></a>关键字：NIO</h2><p>这个版本主要从bio升级为nio。<br><strong><em><a href=\"https://github.com/wangxuanni/MyTomcat/tree/master/src/v2\" target=\"_blank\" rel=\"noopener\">代码链接</a></em></strong><br>v2<br>最重要是弄懂nio是时候掏出我之前的bio、nio笔记了。</p>\n<h3 id=\"bio\"><a href=\"#bio\" class=\"headerlink\" title=\"bio\"></a>bio</h3><p>先讲一下bio抛砖引玉，主要是为了和nio做对比。</p>\n<h4 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1.概念\"></a>1.概念</h4><p>阻塞并同步。特点是IO两个阶段被阻塞。基于流模型。<br>客户端一个请求服务端就启动一个线程，线序发生请求给内核，由内核去通信，在内核准备好数据之前，线程是被挂起的，知道数据从内核复制到用户空间。调用是可靠的线性顺序<br>缺点：每次请求创建一个线程在销毁开销比较大，操作系统对线程的总数有限制，太多服务器可能瘫痪。可以用线程池改进。<br>创建bio服务器只需要一步。</p>\n<h4 id=\"2-配置服务器\"><a href=\"#2-配置服务器\" class=\"headerlink\" title=\"2.配置服务器\"></a>2.配置服务器</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一、ServerSocket serverSocket = new ServerSocket(8080);</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-处理请求返回响应\"><a href=\"#3-处理请求返回响应\" class=\"headerlink\" title=\"3.处理请求返回响应\"></a>3.处理请求返回响应</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">二、一直循环等待</span><br><span class=\"line\">`while（true）&#123;</span><br><span class=\"line\">三、收到请求的套接字</span><br><span class=\"line\">`Socket socket = serverSocket.accept();`</span><br><span class=\"line\">四、用套接字得到输入输出流，处理请求响应</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"nio\"><a href=\"#nio\" class=\"headerlink\" title=\"nio\"></a>nio</h3><h4 id=\"1-概念-1\"><a href=\"#1-概念-1\" class=\"headerlink\" title=\"1.概念\"></a>1.概念</h4><p>非阻塞并同步。可构建多路复用、同步非阻塞的io操作。特点是程序去不断询问内核是否准备好，基于buffers。<br>客户端请求会注册到多路复用上，单线程轮询到有io请求时，才启动一个线程进行处理，仅仅selector是阻塞的。<br>核心：Channels（类似流，全双工，可以读写。socketChannel、serverSocketChannel）<br>buffers8种基本类型都有，数据从channel读到buffer中，也可以从buffer写到channel。本质是一块方便读写数据的内存<br>selector多路复用器，以监听多个Channel通道感兴趣的事情。允许单线程处理多个channel。 </p>\n<ul>\n<li>OP_ACCEPT: 接收就绪</li>\n<li>OP_READ: 读取就绪</li>\n<li>OP_WRITE: 写入就绪</li>\n<li>OP_CONNECT: 连接就绪</li>\n</ul>\n<p>一个server socket channel准备好接收新进入的连接称为“接收就绪”。某个channel成功连接到另一个服务器称为“连接就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。<br>所以只有OP_ACCEPT: 接收就绪是serviceSocketChannel使用的，其他三个都是socketChannel使用。</p>\n<h4 id=\"2-配置服务器-1\"><a href=\"#2-配置服务器-1\" class=\"headerlink\" title=\"2.配置服务器\"></a>2.配置服务器</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     /**</span><br><span class=\"line\">         * 1. 创建Selector</span><br><span class=\"line\">         */</span><br><span class=\"line\">        Selector selector = Selector.open();</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 2. 通过ServerSocketChannel创建channel通道</span><br><span class=\"line\">         */</span><br><span class=\"line\">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 3. 为channel通道绑定监听端口</span><br><span class=\"line\">         */</span><br><span class=\"line\">        serverSocketChannel.bind(new InetSocketAddress(8000));</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 4. **设置channel为非阻塞模式**</span><br><span class=\"line\">         */</span><br><span class=\"line\">        serverSocketChannel.configureBlocking(false);</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 5. 将channel注册到selector上，监听连接事件</span><br><span class=\"line\">         */</span><br><span class=\"line\">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\">        System.out.println(&quot;服务器启动成功！&quot;);</span><br></pre></td></tr></table></figure>\n<p>总结一下上面代码，创建多路复用器，创建ServerSocketChannel，简称ssc，ssc绑定端口并设置为非阻塞，将ssc注册到多路复用器上，监听连接事件。到这里服务器已经配置好了。</p>\n<h4 id=\"3-处理请求返回响应-1\"><a href=\"#3-处理请求返回响应-1\" class=\"headerlink\" title=\"3.处理请求返回响应\"></a>3.处理请求返回响应</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> /**</span><br><span class=\"line\">    while (true) &#123;</span><br><span class=\"line\">    int readyChannels = selector.select();</span><br><span class=\"line\">    if (readyChannels == 0) &#123;</span><br><span class=\"line\">        continue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class=\"line\">    Iterator iterator = selectionKeys.iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">    while (iterator.hasNext()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        SelectionKey selectionKey = (SelectionKey) iterator.next();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (selectionKey.isAcceptable()) &#123;</span><br><span class=\"line\">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class=\"line\">            socketChannel.configureBlocking(false);</span><br><span class=\"line\">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\"></span><br><span class=\"line\">            Response response = new Response(socketChannel);</span><br><span class=\"line\"></span><br><span class=\"line\">            response.print(&quot;&lt;html&gt;&quot;);</span><br><span class=\"line\">            response.print(&quot;&lt;head&gt;&quot;);</span><br><span class=\"line\">            response.print(&quot;&lt;title&gt;&quot;);</span><br><span class=\"line\">            response.print(&quot;服务器响应成功&quot;);</span><br><span class=\"line\">            response.print(&quot;&lt;/title&gt;&quot;);</span><br><span class=\"line\">            response.print(&quot;&lt;/head&gt;&quot;);</span><br><span class=\"line\">            response.print(&quot;&lt;body&gt;&quot;);</span><br><span class=\"line\">            response.print(&quot;来而不往非礼也&quot;);</span><br><span class=\"line\">            response.print(&quot;&lt;/body&gt;&quot;);</span><br><span class=\"line\">            response.print(&quot;&lt;/html&gt;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">            response.pushToBrowser(200);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (selectionKey.isReadable()) &#123;</span><br><span class=\"line\">            Request request = new Request(selectionKey);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        iterator.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h4><p>循环询问多路复用器的selectedKeys是否有值，等待连接事件<br>当有连接事件过来了，创建socketChannel<br>将socketChannel设置为非阻塞工作模式<br>将channel注册回selector上，监听<strong>可读事件</strong><br>创建Response并传入socketChannel，在Response里socketChannel.write();返回响应</p>\n<p>如果是可读事件，把selectionKey传入Request解析请求，Request类首先selectionKey里获取socketChannel（就之前接入事件创建的socketChannel），然后创建byteBuffer，用于读取客户端请求信息。</p>\n<h4 id=\"5-其他\"><a href=\"#5-其他\" class=\"headerlink\" title=\"5.其他\"></a>5.其他</h4><p>Selector、ServerSocketChannel本身为抽象类，不能直接创建,需要通过open()方法打开。<br>注意这段代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (readyChannels == 0) &#123;</span><br><span class=\"line\">           continue;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后献上教程，关于nio，<a href=\"http://www.imooc.com/learn/1118\" target=\"_blank\" rel=\"noopener\">慕课有一个特别好的教程</a>，老师讲的很清楚。</p>\n<h1 id=\"V3\"><a href=\"#V3\" class=\"headerlink\" title=\"V3\"></a>V3</h1><p>进行封装 request接受请求并打印。<br>response根据传入的状态码封装固定的头信息、推送响应信息。<br>server类只关心内容和状态码.</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>这里默认读者是连http服务器是啥一点概念都没有（但是得有网络编程基础），会从最基本的概念讲起，一步步写一个服务器，大神就不要点进来看我献丑了hhh</p>\n</blockquote>\n<h1 id=\"版本全览\"><a href=\"#版本全览\" class=\"headerlink\" title=\"版本全览\"></a>版本全览</h1><p>版本一：基于bio百行代码实现http服务器<br>版本二：基于nio<br>版本三：serlevt容器、cookie、封装、日志<br>版本四：长连接、参考了tomcat设计</p>\n<h1 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h1><p><em>早在学jsp的时候，就很好奇tomcat是什么，为什么可以运行jsp、servlet？当时试图看业界盛誉的《how to tomcat work》，没看懂（但这确实是本神书）；问师兄，师兄也不太清楚。网上的博客就更不用说了。这个困惑就先被我放到一边去了。<br>寒假的时候用socket、多线程写了一个聊天室。突然明白，其实tomcat就像一个聊天室的服务器啊，浏览器相当于客户端，HTTP请求响应相当于聊天消息，浏览器给服务器发消息，服务器做处理。http报文只是遵守一定格式的字符串。<br>只不过聊天室的服务器是把收到的信息转发给其他客户端。而HTTP的服务的返回一个符合HTTP协议的消息。<br>最初的版本v1，只能把收到的HTTP报文打印到控制台，返回浏览器响应显示一句话。<br>后来发现github上比我大一两届的前辈也写过这个东西，但是他们有好多功能比如基于nio、servlet等等，像模像样。受到启发，这项目认真起来大有搞头。就有了把这个当成自己的一个项目去完善的心态。看了一些书、博客、视频。最近还发现群里的小伙伴也有在写这个的，此处点名糖糖。</em><br>写这个服务器的好处：</p>\n<ul>\n<li>写轮子所需几乎覆盖java所有知识点，因为即使是一个xml解析也要自己写，不像写后台一样有很多框架、工具可以用。</li>\n<li>成就感强。tomcat算比较适合自己造轮子的入门中间件。曾经也有写一个Spring的想法，但看了源码之后就放弃了。Spring源码优秀，适合参读，但不太适合自己撸一个。</li>\n<li>对后台开发的眼界会</li>\n</ul>\n<h1 id=\"V1\"><a href=\"#V1\" class=\"headerlink\" title=\"V1\"></a>V1</h1><h2 id=\"关键字：bio、百行代码内\"><a href=\"#关键字：bio、百行代码内\" class=\"headerlink\" title=\"关键字：bio、百行代码内\"></a>关键字：bio、百行代码内</h2><p><strong><em><a href=\"https://github.com/wangxuanni/MyTomcat/tree/master/src/v1/BioServer.java\" target=\"_blank\" rel=\"noopener\">代码链接</a></em></strong></p>\n<h2 id=\"技术点\"><a href=\"#技术点\" class=\"headerlink\" title=\"技术点\"></a>技术点</h2><ul>\n<li>BIO</li>\n<li>Socket</li>\n<li>缓存线程池</li>\n<li>lambda表达式</li>\n<li>HTTP请求响应报文</li>\n</ul>\n<h2 id=\"5个步骤的关键代码\"><a href=\"#5个步骤的关键代码\" class=\"headerlink\" title=\"5个步骤的关键代码\"></a>5个步骤的关键代码</h2><p>一、开启服务器绑定端口<br><code>ServerSocket serverSocket = new ServerSocket(8080);</code><br>二、一直循环等待<br><code>while（true）{</code><br>三、收到请求的套接字<br><code>Socket socket = serverSocket.accept();</code><br>四、套接字可以获得一个字节输入流，把这个输入流转成字符串，打印在控制台。<br><code>InputStream inputStream = socket.getInputStream();</code><br>五、创建响应报文（其实就是按照HTTP报文的格式构建的一个字符串）并返回响应<br><code>BufferedWriter bw =new BufferedWriter(new \nOutputStreamWriter(socket.getOutputStream()));</code></p>\n<h2 id=\"注意一些小坑\"><a href=\"#注意一些小坑\" class=\"headerlink\" title=\"注意一些小坑\"></a>注意一些小坑</h2><p>缓存字符流写入后记得要刷新！！！bw.flush();<br>选择缓存线程池是因为它更适合短连接。<br>构建响应报文用StringBuilder比String更好<br>响应报文正文要构建好并且要记录长度，因为响应头有一个Content-length:正文长度属性要填<br>记得在finally块把socket.close()关闭</p>\n<h1 id=\"V2\"><a href=\"#V2\" class=\"headerlink\" title=\"V2\"></a>V2</h1><h2 id=\"关键字：NIO\"><a href=\"#关键字：NIO\" class=\"headerlink\" title=\"关键字：NIO\"></a>关键字：NIO</h2><p>这个版本主要从bio升级为nio。<br><strong><em><a href=\"https://github.com/wangxuanni/MyTomcat/tree/master/src/v2\" target=\"_blank\" rel=\"noopener\">代码链接</a></em></strong><br>v2<br>最重要是弄懂nio是时候掏出我之前的bio、nio笔记了。</p>\n<h3 id=\"bio\"><a href=\"#bio\" class=\"headerlink\" title=\"bio\"></a>bio</h3><p>先讲一下bio抛砖引玉，主要是为了和nio做对比。</p>\n<h4 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1.概念\"></a>1.概念</h4><p>阻塞并同步。特点是IO两个阶段被阻塞。基于流模型。<br>客户端一个请求服务端就启动一个线程，线序发生请求给内核，由内核去通信，在内核准备好数据之前，线程是被挂起的，知道数据从内核复制到用户空间。调用是可靠的线性顺序<br>缺点：每次请求创建一个线程在销毁开销比较大，操作系统对线程的总数有限制，太多服务器可能瘫痪。可以用线程池改进。<br>创建bio服务器只需要一步。</p>\n<h4 id=\"2-配置服务器\"><a href=\"#2-配置服务器\" class=\"headerlink\" title=\"2.配置服务器\"></a>2.配置服务器</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一、ServerSocket serverSocket = new ServerSocket(8080);</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-处理请求返回响应\"><a href=\"#3-处理请求返回响应\" class=\"headerlink\" title=\"3.处理请求返回响应\"></a>3.处理请求返回响应</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">二、一直循环等待</span><br><span class=\"line\">`while（true）&#123;</span><br><span class=\"line\">三、收到请求的套接字</span><br><span class=\"line\">`Socket socket = serverSocket.accept();`</span><br><span class=\"line\">四、用套接字得到输入输出流，处理请求响应</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"nio\"><a href=\"#nio\" class=\"headerlink\" title=\"nio\"></a>nio</h3><h4 id=\"1-概念-1\"><a href=\"#1-概念-1\" class=\"headerlink\" title=\"1.概念\"></a>1.概念</h4><p>非阻塞并同步。可构建多路复用、同步非阻塞的io操作。特点是程序去不断询问内核是否准备好，基于buffers。<br>客户端请求会注册到多路复用上，单线程轮询到有io请求时，才启动一个线程进行处理，仅仅selector是阻塞的。<br>核心：Channels（类似流，全双工，可以读写。socketChannel、serverSocketChannel）<br>buffers8种基本类型都有，数据从channel读到buffer中，也可以从buffer写到channel。本质是一块方便读写数据的内存<br>selector多路复用器，以监听多个Channel通道感兴趣的事情。允许单线程处理多个channel。 </p>\n<ul>\n<li>OP_ACCEPT: 接收就绪</li>\n<li>OP_READ: 读取就绪</li>\n<li>OP_WRITE: 写入就绪</li>\n<li>OP_CONNECT: 连接就绪</li>\n</ul>\n<p>一个server socket channel准备好接收新进入的连接称为“接收就绪”。某个channel成功连接到另一个服务器称为“连接就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。<br>所以只有OP_ACCEPT: 接收就绪是serviceSocketChannel使用的，其他三个都是socketChannel使用。</p>\n<h4 id=\"2-配置服务器-1\"><a href=\"#2-配置服务器-1\" class=\"headerlink\" title=\"2.配置服务器\"></a>2.配置服务器</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     /**</span><br><span class=\"line\">         * 1. 创建Selector</span><br><span class=\"line\">         */</span><br><span class=\"line\">        Selector selector = Selector.open();</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 2. 通过ServerSocketChannel创建channel通道</span><br><span class=\"line\">         */</span><br><span class=\"line\">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 3. 为channel通道绑定监听端口</span><br><span class=\"line\">         */</span><br><span class=\"line\">        serverSocketChannel.bind(new InetSocketAddress(8000));</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 4. **设置channel为非阻塞模式**</span><br><span class=\"line\">         */</span><br><span class=\"line\">        serverSocketChannel.configureBlocking(false);</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 5. 将channel注册到selector上，监听连接事件</span><br><span class=\"line\">         */</span><br><span class=\"line\">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\">        System.out.println(&quot;服务器启动成功！&quot;);</span><br></pre></td></tr></table></figure>\n<p>总结一下上面代码，创建多路复用器，创建ServerSocketChannel，简称ssc，ssc绑定端口并设置为非阻塞，将ssc注册到多路复用器上，监听连接事件。到这里服务器已经配置好了。</p>\n<h4 id=\"3-处理请求返回响应-1\"><a href=\"#3-处理请求返回响应-1\" class=\"headerlink\" title=\"3.处理请求返回响应\"></a>3.处理请求返回响应</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> /**</span><br><span class=\"line\">    while (true) &#123;</span><br><span class=\"line\">    int readyChannels = selector.select();</span><br><span class=\"line\">    if (readyChannels == 0) &#123;</span><br><span class=\"line\">        continue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class=\"line\">    Iterator iterator = selectionKeys.iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">    while (iterator.hasNext()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        SelectionKey selectionKey = (SelectionKey) iterator.next();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (selectionKey.isAcceptable()) &#123;</span><br><span class=\"line\">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class=\"line\">            socketChannel.configureBlocking(false);</span><br><span class=\"line\">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\"></span><br><span class=\"line\">            Response response = new Response(socketChannel);</span><br><span class=\"line\"></span><br><span class=\"line\">            response.print(&quot;&lt;html&gt;&quot;);</span><br><span class=\"line\">            response.print(&quot;&lt;head&gt;&quot;);</span><br><span class=\"line\">            response.print(&quot;&lt;title&gt;&quot;);</span><br><span class=\"line\">            response.print(&quot;服务器响应成功&quot;);</span><br><span class=\"line\">            response.print(&quot;&lt;/title&gt;&quot;);</span><br><span class=\"line\">            response.print(&quot;&lt;/head&gt;&quot;);</span><br><span class=\"line\">            response.print(&quot;&lt;body&gt;&quot;);</span><br><span class=\"line\">            response.print(&quot;来而不往非礼也&quot;);</span><br><span class=\"line\">            response.print(&quot;&lt;/body&gt;&quot;);</span><br><span class=\"line\">            response.print(&quot;&lt;/html&gt;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">            response.pushToBrowser(200);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (selectionKey.isReadable()) &#123;</span><br><span class=\"line\">            Request request = new Request(selectionKey);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        iterator.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h4><p>循环询问多路复用器的selectedKeys是否有值，等待连接事件<br>当有连接事件过来了，创建socketChannel<br>将socketChannel设置为非阻塞工作模式<br>将channel注册回selector上，监听<strong>可读事件</strong><br>创建Response并传入socketChannel，在Response里socketChannel.write();返回响应</p>\n<p>如果是可读事件，把selectionKey传入Request解析请求，Request类首先selectionKey里获取socketChannel（就之前接入事件创建的socketChannel），然后创建byteBuffer，用于读取客户端请求信息。</p>\n<h4 id=\"5-其他\"><a href=\"#5-其他\" class=\"headerlink\" title=\"5.其他\"></a>5.其他</h4><p>Selector、ServerSocketChannel本身为抽象类，不能直接创建,需要通过open()方法打开。<br>注意这段代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (readyChannels == 0) &#123;</span><br><span class=\"line\">           continue;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后献上教程，关于nio，<a href=\"http://www.imooc.com/learn/1118\" target=\"_blank\" rel=\"noopener\">慕课有一个特别好的教程</a>，老师讲的很清楚。</p>\n<h1 id=\"V3\"><a href=\"#V3\" class=\"headerlink\" title=\"V3\"></a>V3</h1><p>进行封装 request接受请求并打印。<br>response根据传入的状态码封装固定的头信息、推送响应信息。<br>server类只关心内容和状态码.</p>\n"},{"title":"实习笔记——开发技巧","date":"2019-11-25T12:09:50.000Z","description":"实习时候的笔记，分为四部分：linux常用命令、Git使用总结、框架常用注解、提升开发效率的技巧","_content":"\n\n\n[TOC]\n\n\n\n\n\n# Linux常用命令\n\n常用命令\n\n[菜鸟教程常用命令](https://www.runoob.com/w3cnote/linux-common-command-2.html)\n\n```\n切换目录\ncd /usr查看目录下的文件lsls -lh 遍历详细信息，如权限，所属用户，创建日期，大小等等信息\n查看当前所处目录pwd\n创建目录文件mkdir -p /test/abctouch test.java\n删除文件\nrm -f test.java\nvi abc.txt要进行编辑，要输入 a 或者 i ，才可以进行编辑哦\n要退出，首先要离开当前的编辑模式，点击左上角的ESC键，退出编辑模式然后输入冒号 (shift+分号) 打开控制命令接着输入wq，然后敲回车，即保存退出wq 是quit+write的缩写\n```\n\n\n\n### grep搜索文本，支持正则\n\n#### 参数\n\n```\ngrep [-acinv] [--color=auto] '搜寻字符串' filename\n-a：将binary文件以text文件的方式搜寻数据\n-c：计算找到'搜寻字符串'的次数\n-i：忽略大小写\n-n：顺便输出行号\n-v：反向选择，即输出没有'搜索字符串'的内容\n--color=auto：可以将找到的关键词部分加上颜色显示\n-A 5：可以显示前面5行加上查找行的信息\n-B 5：可以显示后面5行加上查找行的信息\n-C 5：可以显示前后5行加上查找行的信息\n```\n\n#### 例子\n\n `grep 2017010500345878 --color info.log`\n\n这行命令在info.log中搜索含有\"2017010500345878\"关键词的段落并且使用其他颜色标记关键词。\n复制代码\n\n`grep -v 'ERROR' error.log` 查找不含”ERROR”的行\n\n`grep -C 50 \"关键字\" info.log`\n\n\n\n\n\n### less分页查看，比more更强\n\n`ps -ef |less`\n\nps查看进程信息并通过less分页显示\n\n搭配grep使用\n\n`less -N tomcat_stdout.log|grep job`\n`less xxx.log | grep -i -n -C10 --color=auto xx`\n\n有用的命令\n\n- 按F,监控更新.如果要暂停监控，可以CTRL+C.\n- /字符串：搜索“字符串”的功能\n- G:调到文本末尾\n- 空格键 滚动一页\n- 回车键 滚动一行\n- Q: 退出\n- gg: 调到文本最前面\n- 按v进入编辑模式，可以类似于vim的方式来编辑保存文件了\n\n其他有用的命令\n\n1.全屏导航\n\n- ctrl + F - 向前移动一屏forward\n- ctrl + B - 向后移动一屏backward\n- ctrl + D - 向前移动半屏\n- ctrl + U - 向后移动半屏\n\n2.单行导航\n\n- j - 向前移动一行\n- k - 向后移动一行\n\n3.其它导航\n\n- G - 移动到最后一行\n- g - 移动到第一行\n- q / ZZ - 退出 less 命令\n\n4.标记导航\n\n当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置：\n\n- ma - 使用 a 标记文本的当前位置\n- 'a - 导航到标记 a 处\n\n### vi编辑文本\n\n> 使用找一个字符串，在vi命令模式下键入“/”，后面跟要查找的字符串，再按回车。vi将光标定位在该串下一次出现的地方上。键入n跳到该串的下一个出现处，键入N跳到该串的上一个出现处。\n\n\n\n### tail查看文件后面几行，默认尾10行，可实时更新\n\n**-f 关键字，tail 会自动实时更新文件内容。**\n\n`tail -f [logfile]`\n\n`tail -n +100 [logfile]` \n\n查询从日志文件的第100行开始\n\n`tail -n 100 [logfile] | grep '结果' --color`   \n\n–color是查询结果带颜色\n\n\n\n### head查看文件前面几行,默认前10行;\n\n\n\n `head -50 info.log` \n\n查看info.log文件的前50行。\n\n`head -n -100 [logfile]`\n\n查询日志文件除了最后10行的其他所有日志\n\n\n\n### cat查看文件\n\n常用有三大功能:\n\n- 1.一次显示整个文件;\n- 2.从键盘创建一个文件。\n- 3.将几个文件合并为一个文件。\n\n\n\n**-n 可以显示行号**\n\n```\ncat -n test.log |tail -n +63820|head -n 20\n```\n\ntail -n +63820表示查询63820行之后的日志\nhead -n 20 则表示在前面的查询结果里再查前20条记录\n\n```\ncat -n info.log |grep \"关键字\" |more\n```\n\n这样就分页打印了,通过点击空格键翻页\n\n\n\n\n\n### sed编辑文件\n\n- 常见使用方法之: sed -n '800,900' info.log\n\n```\n查看info.log文件800到900行之间的内容\n复制代码\n```\n\n\n\n### 常见组合使用\n\n> 使用[grep -n 异常 --color info.log ]查询到异常在文件中发生的行数,然后再看前后几十行日志的内容[sed -n '800,900' info.log].\n\n\n\n\n\n[开发中常用日志搜索技巧]: https://juejin.im/post/5a992bbf6fb9a028bf04c429\n\n\n\n\n\n# Git使用总结\n\n\n\n## add与commit\n\n首先，选择一个合适的地方，创建一个空目录\n\n通过`git init`命令把这个目录变成Git可以管理的仓库。可以发现当前目录下多了一个`.git`的目录，这个目录是Git来跟踪管理版本库的。\n\n第一步，用命令`git add`告诉Git，把文件添加到仓库：\n\n第二步，用命令`git commit`告诉Git，把文件提交到仓库：\n\n```\ngit add readme.txt\ngit commit -m \"wrote a readme file\"\n```\n\n为什么Git添加文件需要`add`，`commit`一共两步呢？因为`commit`可以一次提交很多文件，所以你可以多次`add`不同的文件,也可以对一个文件进行不同更改\n\n\n\n## 版本\n\n`git log`命令显示从最近到最远的提交日志，\n\n```\ngit log --pretty=oneline\n```\n\n在Git中，用`HEAD`表示当前版本，上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本写100个`^`比较容易数不过来，所以写成`HEAD~100`。\n\n如果回到了原来的版本，git log看不到之前最新的提交记录了，但是git reflog还可以。只有知道版本号，就可还原之前的任何一个版本。\n\n```\ngit reset --hard HEAD^\ngit reset --hard 1094a\n```\n\n\n\n`git add`命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行`git commit`就可以一次性把暂存区的所有修改提交到分支。一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。\n\n`git status`可以查看一下状态，如果工作区进行了修改有没有add就会显示Untracked files\n\n一个重要的概念是:Git跟踪并管理的是修改，而非文件。把文件git add readme.txt添加到了暂存区，暂存区也只是跟踪了这次修改，而不是跟踪了这个文件。换句话说：add不是一劳永逸之后对这个文件的更改都会被commit。如果再对readme.txt进行修改，就需要在进行一次git add，如果不再add，commit提交就不会提交这次修改。**简而言之：每次修改都要进行git add。**\n\n删除文件：\n\n```\n git rm test.txt\n git commit -m \"remove test.txt\"\n```\n\n如果是误删，版本库里还有，想恢复.`git checkout`其实是用版本库里的**最新**版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。\n\n```\ngit checkout -- test.txt\n```\n\n\n\n## 分支\n\n切换分支和撤销修改是同一个关键词checkout，确实有点令人迷惑，不过切换分支的checkout也可以用switch替换\n\n```\ngit checkout -b dev #创建并切换到dev分支\ngit checkout master #切换回master分支\ngit merge dev #在master分支上合并dev\ngit branch -d dev #删除dev分支\ngit branch #查看分支\n```\n\n\n\n## 分支合并\n\n在实习的时候我经常遇到这样尴尬的情况\n\n比如：commit提交到本地分支了，切换到远程分支全没有了。解决办法：把本地和远程的分支和一下。\n\n再比如：在我的分支上明明有的方法，与其他的预发分支合并也没问题。发上去应用构建居然报错找不方法？？？原来是别人发布了一次，此时主分支就和我不一样了。本地分支当然能看到该方法，切到构建分支发现并没有这个方法。解决办法：把我的分支和主分支合并一下\n\n再再比如：\n\nCommit之后切换分支了，就commit不了，显示没有变更。解决方法：嘿嘿还是分支合并就vans了，惊不惊喜意不意外？\n\n那么问题来了，怎么万无一失的合并分支，并手动解决冲突？\n\n1. git fetch\n\n2. git checkout 分支一\n\n3. git merge origin/分支二417c909ab76eb47c8fc033479904544054e8ea0e\n\n4. 解决冲突，有一些会自动合并，必须手动解决的会在控制台输入什么类。加上`<<<<<<<`，`=======`，`>>>>>>>`这种，跟着报错提示很容易找到地方。\n\n5. git add -u  记得重新add一下否则会提示冲突没有解决\n\n6. git commit -m 'XXXXX'\n\n7. git push\n\n  \n\n​    \n\n   git log --graph --pretty=oneline --abbrev-commit可以查看分支合并情况。\n\n   \n\n   顺便说一下pull和fetch的区别\n\n`*git fetch`是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。*\n\n*而`git pull` 则是将远程主机的最新内容拉下来后直接合并，即：`git pull = git fetch + git merge`，这样可能会产生冲突，需要手动解决。*\n\n\n\n快速和并是看不出来曾经做过合并，禁用`Fast forward`模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\n\n```\ngit merge --no-ff -m \"merge with no-ff\" dev\n```\n\n\n\n## stash\n\nbug分支，工作写到一半还不能提交，但是bug得马上先修的尴尬局面。\n\n1. git stash可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：\n2. `git checkout -b issue-101`在修复bug的分支上创建临时bug分支\n3. 修完后add+提交，切换会原来的分支，合并，最后删除`issue-101`分支。\n4. `git stash list`查看之前储藏起来的内容。用`git stash apply`或者`git stash pop`，恢复，后者会在恢复的同时删除stash。（list中的id号可以让你恢复指定的stash）\n5. 如果其他分支也有该bug，git cherry-pick 4c805e2，`cherry-pick`能复制一个特定的提交到当前分支：\n\n```\ngit stash\n```\n\n如果要丢弃一个没有被合并过的分支，可以通过`git branch -D <name>`强行删除。\n\n\n\n## 小技巧\n\ncode review已提交的代码，点击主分支右键compare with current。\n\n\n\n强烈推荐这个教程，深入浅出.\nhttps://backlog.com/git-tutorial/cn/stepup/stepup7_5.html\n\n\n\n\n\n# 框架常用注解\n\n## spring\n\n## \n\n### bean的注册\n\n两种办法.\n\n#### 一、@Component或其派生 @Controller, @Service, @Repository注解\n\n- 位置: 注解在类上\n\n- 参数: 默认的bean的ID为首字母变为小写的类名\n\n- 作用域: \n\n  - 通过上述四个注解标识的 Bean，其默认作用域是\"singleton\"。\n\n    如果不想是单例，使用@Scope 注解。只需提供作用域的名称就行了。\n\n    ```java\n    @Scope(\"prototype\") \n    @Repository \n    public class Demo { … }\n    ```\n\n    \n\n@ComponentScan\n\n- 作用: @ComponentScan对应XML配置形式中的<context: component-scan>元素, 用于配合一些元信息 Java Annotation,比如@Component和@Repository等, 将标注了这些元信息 Annotation 的 bean 定义类批量采集到 Spring 的IoC容器中, 我们可以通过 basePackages等属性来细粒度地定制 @ComponentScan自动扫描的范围, 如果不指定, 则默认 Spring框架实现会从声明 @ComponentScan所在类的 package 进行扫描。\n\n#### 二、使用@Configuration 搭配 @Bean注解。\n\n **常用在配置第三方提供的bean.**\n\n- - @Configuration\n    - 位置: 注解在类上\n    - 作用: 声明当前类是一个配置类，相当于一个Spring配置的xml文件, 任何POJO+@Configuration都是一个JavaConfig配置类。 @Configuration也是一个@Component\n  - @Bean\n    - 位置: 注解在方法上\n    - 作用: 声明当前方法的返回值为一个Bean。\n\n```java\n// 使用 @Configuration + @Bean 配置一个Tesla Service\n\n@Configuration\n\npublic class TeslaServiceConfiguration {\n\n@Bean(name = \"userService\")\n\npublic UserService userService() throws TeslaException {\n\nreturn TeslaServiceConsumerFactory.getTeslaServiceConsumer(UserService.class);\n\t}\n}\n```\n\n\n\n### bean的获取\n\n@**Autowired** 搭配 @Qualifier 或者 @**Resource**\n\n@Resource和@Autowired使用起来区别不大, @Autowired优先byType装配, @Resource优先byName装配, [更多参考这里](http://www.dengshenyu.com/spring/2016/10/09/spring-inject.html)\n\n\n\n#### @Autowired(required = false)找不到也没关系\n\n问：如果属性注入找不到我不想让Spring容器抛出异常，而就是显示null，可以吗？答：将@Autowired注解的required属性设置为false即可\n\n```java\n` @Autowired(required = false)\n    private Car car;`\n```\n\n\n\n#### @Qualifier(\"BMW\")接口有多个实现拿哪一个\n\n问：一个Car接口有两个个实现，类Benz和BMW，要怎么拿？\n\n```java\n@Autowired\n    @Qualifier(\"BMW\")\n    private Car car;\n```\n\n\n\n@Autowired + @Qualifier(\"foo\")  等同于 @Resource(name=\"foo\")\n\n\n\n## bean生命周期\n\n在某些情况下，可能需要我们手工做一些额外的初始化或者销毁操作，这通常是针对一些资源的获取和释放操作。\n\nBean的生命周期 @Scope @PostConstruct 和 @PreDestroy \n\n### @Scope指定bean的作用域.\n\n```\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) or @Scope(\"prototype\")\n```\n\n\n\n### 生命周期的钩子\n\n- initMethod & destroyMethod\n  - 位置: 与@Bean搭配使用\n  - 作用: 指定bean的生命周期回调方法, bean实例化后, bean销毁前\n  - 例子: @Bean(initMethod=\"init\",destroyMethod=\"destory\")\n- @PostConstruct & @PreDestroy\n  - 位置: 与@Component搭配使用, 注解在方法上\n  - 作用: 指定bean的生命周期回调方法, bean实例化后, bean销毁前\n  - 例子: @PostConstruct public void init() {}\n\n```java\n// @PostConstruct & @PreDestroy 示例\n\n@PostConstruct\npublic void init() {}\n\n@PreDestroy\npublic void stop() {}\n```\n\n\n\n## @Value去配置文件取值\n\n```java\n@Value(\"${env}\")  \nprivate String env;\n```\n\n除了spring的application.properties，还会发现应用里对每一个环境都有不同的配置文件，诸如dev_config.properties、online_config.properties。\n\n@Value取值先去application.properties，如果配置文件以@开头结尾，如env=@env@，则根据当前环境去对应的配置文件里取\n\n##  SpringBoot\n\n- @SpringBootApplication\n  - @Configuration\n    - 启动类标注了@Configuration之后,本身其实也是一个IoC容器的配置类\n  - @EnableAutoConfiguration\n    - 从classpath中搜索所有META-INF/spring.factories配置文件, 加载配置到spring容器\n    - 比如moguboot的spring.factories就配置了很多内部中间件\n  - @ComponentScan\n\n\n\n## SpringMVC\n\n\n\n- @RequestParam & @PathVariable 做参数绑定\n  - 默认绑定\n    - 请求参数名和方法参数名一致\n  - 使用RequestParam明确指定绑定关系\n    - @RequestParam(value=\"age\" required=false)  required默认是true\n  - @PathVariable\n    - @RequestMapping(value=\"users/{userId}, method=RequestMethod.GET)\n    - foo(@PathVariable(\"userId\") long userId)\n- @RequestBody\n  - 添加 @RequestBody 后 Spring 会根据请求中的 Content-Type 头信息来选择合适的转换器, 将请求数据转为 Java 对象\n  - 比如Content-Type是application/json, 那么就是 JSON -> Model\n- @ResponseBody\n  - 添加 @ResponseBody 后 Spring 会根据请求中的 Accept 头信息来选择合适的转换器, Java 对象转化为客户端可接受的表述形式\n  - 比如Accept头部信息包含“application/json”, 就是Model -> JSON\n- @RestController\n  - @RestController 等于 @Controller + 每个方法默认加@ResponseBody\n\n\n## Lombok\n\n- @Data,相当于**@Getter+ @Setter+ toString + EqualsAndHashCode + RequiredArgsConstructor.*\n\n- @ **builder** 一个静态内部类https://juejin.im/post/5cfdf467f265da1b5d579fdd\n\n- @EqualsAndHashCode(callSuper = true)\n\n  \n\n  \n\n## 测试\n\n- @Test\n  - @Test注解标注这个方法需要测试\n- @Before\n  - 所有的测试方法之前都先执行这个方法\n- @After\n  - 所有的测试方法之后都要执行这个方法\n- 还有@BeforeClass @AfterClass等注解\n\n```java\n@Test\npublic void testAdd(){}\n\n@Before\npublic void prepare(){}\n\n@After\npublic void destroy(){}\n```\n\n\n\n\n\n\n\n[spring注解](https://www.cnblogs.com/xrq730/p/5313412.html)\n\n# 提升开发效率的技巧\n\n## idea\n\n### 常用快捷键排行榜\n\n1. 复制一行Ctrl+D  （光标所在行）\n2. 删除一行Ctrl+X （光标所在行）\n3. 选中的代码块注释  Ctrl + Shift + / \n4. 代码重新排列格式 Ctrl + Alt + L\n5. 全局替换 Ctrl+Shift+R\n6. 定位到下一个或上一个错误 F2 / Shift + F2\n7. Ctrl+Shift+F12 专注代码窗口\n8. Ctrl+E可以找到Recent Files最近浏览过的文件\n9. Ctrl + Shift + Z取消撤销 \n10. Ctrl + Shift +回车：无论光标在哪，跳到下一行\n11. ctrl+alt+v：自动补全方法/new对象的返回值。\n\n### idea中git的使用\n\n把idea项目关联为git仓库：菜单->VCS->import into Version Control->Create Git Repository->e:\\project\\hiworld-OK\n\n### 如何热部署？\n\n [热部署](https://blog.csdn.net/weixin_42831477/article/details/82229436)\n\n#### idea如何导入setting？\n\nfile -> export setting\n\n将会导出一个 setting.jar 的文件\n\n在新安装 IDEA 的电脑上，在开始的界面选择导入 setting \n\n### 查看源码五件套\n\n1. 一次性折叠所有Java方法：ctrl +shift+ 减号\n\n2. ctrl+鼠标单击某类 可以跳进该类查看源码\n\n3. Ctrl+F12 显示这个类的方法的（弹出窗口）\n\n4. alt + 7  显示这个类的方法的（左侧项目文件显示）\n\n5. Ctrl+O，这个用于查看一个类的纲要，再按一次时，列出该类继承的方法及变量。\n\n选中当前类中右击鼠标，右键菜单中选择Diagrams>Show Diagrams，快捷键Ctrl+Alt+Shift+U(不同的系统和快捷键风格快捷键会有差异)。如果是spring的类会出现如图所示的弹框，第一项是类图结构，第二个是spring beans的依赖\n\n\n\n\n\n## LINUX\n\n常用命令\n\n[菜鸟教程常用命令](https://www.runoob.com/w3cnote/linux-common-command-2.html)\n\n```\n切换目录\ncd /usr查看目录下的文件lsls -lh 遍历详细信息，如权限，所属用户，创建日期，大小等等信息\n查看当前所处目录pwd\n创建目录文件mkdir -p /test/abctouch test.java\n删除文件\nrm -f test.java\nvi abc.txt要进行编辑，要输入 a 或者 i ，才可以进行编辑哦\n要退出，首先要离开当前的编辑模式，点击左上角的ESC键，退出编辑模式然后输入冒号 (shift+分号) 打开控制命令接着输入wq，然后敲回车，即保存退出wq 是quit+write的缩写\n```\n\n\n\n## 云服务器\n\n[云翼计划,9.9一个月，需要学生认证](https://promotion.aliyun.com/ntms/campus2017.html)\n\n[安装常用软件比如java、mysql的步骤](http://how2j.cn/k/deploy2linux/deploy2linux-breif/1591.html)\n\n[MobaXterm和Navicat，远程连接服务器和数据库，不用每次都登陆阿里云网站，很好用](https://blog.csdn.net/M_Kerry/article/details/81664548)\n\n## cmd\n\n在文件夹空白处按住Shift，然后右键弹出快捷菜单，可以看到“在此处打开命令行窗口”\n\n使用上下方向键，翻看使用过的命令\n\ncd   切换目录\n\n例：cd   // 显示当前目录\n\n例：cd ..   // 进入父目录\n\n例：cd /d d:   // 进入上次d盘所在的目录（或在直接输入：d:）\n\n例：cd /d d:\\   // 进入d盘根目录\n\n例：cd d: // 显示上次d盘所在的目录\n\n例：cd /d d:\\src // 进入d:\\src目录\n\n例：cd prj\\src\\view  // 进入当前目录下的prj\\src\\view文件夹\n\n\n\n## 工具\n\n\n\n### Markdown工具 \n\n印象笔记：印象笔记也可以写md，体验一般\n\ntypora ：md文件编辑器，用起来很舒服（本篇就是用它写的）\n\nWritage 可直接将md文件打开为word，安装轻便。\n\n### 资源搜索\n\n盘搜搜：可以直接搜索网盘分享链接\n\n闲鱼：盘搜搜搜不到的网盘链接，可以在里搜搜\n\n\n\n## 其他\n\n### 合并多个word/pdf/md文件为一个？\n\n打开命令行cmd，输入下面这行命令，即可把E:\\File目录下所有md文件合并成一个文件。\n\n输入和输出路径不需要一样。\n\n```\ntype E:\\File\\*.md >> E:\\File\\margeFile.md\n```\n\n\n\n### 端口被占用？\n\n下面三行代码解决问题\n\n打开cmd命令行窗口\n\n第一行代码：查看端口号包含\"80\"的占用情况\n\n第二行代码：根据上一步找到的80端口对应的pid是1828\n\n结束java.exe\n\n```\nnetstat -ano|findstr \"8000\"\n\ntasklist|findstr \"4760\"\n\ntaskkill /f /t /im java.exe\n```\n\n### md文件转pdf？\n\nVScode安装插件后可以转。\n\n\n\n# \n","source":"_posts/实习笔记——开发技巧.md","raw":"---\ntitle: 实习笔记——开发技巧\ndate: 2019-11-25 20:09:50\ncategories: 工程技巧\ndescription: 实习时候的笔记，分为四部分：linux常用命令、Git使用总结、框架常用注解、提升开发效率的技巧\n---\n\n\n\n[TOC]\n\n\n\n\n\n# Linux常用命令\n\n常用命令\n\n[菜鸟教程常用命令](https://www.runoob.com/w3cnote/linux-common-command-2.html)\n\n```\n切换目录\ncd /usr查看目录下的文件lsls -lh 遍历详细信息，如权限，所属用户，创建日期，大小等等信息\n查看当前所处目录pwd\n创建目录文件mkdir -p /test/abctouch test.java\n删除文件\nrm -f test.java\nvi abc.txt要进行编辑，要输入 a 或者 i ，才可以进行编辑哦\n要退出，首先要离开当前的编辑模式，点击左上角的ESC键，退出编辑模式然后输入冒号 (shift+分号) 打开控制命令接着输入wq，然后敲回车，即保存退出wq 是quit+write的缩写\n```\n\n\n\n### grep搜索文本，支持正则\n\n#### 参数\n\n```\ngrep [-acinv] [--color=auto] '搜寻字符串' filename\n-a：将binary文件以text文件的方式搜寻数据\n-c：计算找到'搜寻字符串'的次数\n-i：忽略大小写\n-n：顺便输出行号\n-v：反向选择，即输出没有'搜索字符串'的内容\n--color=auto：可以将找到的关键词部分加上颜色显示\n-A 5：可以显示前面5行加上查找行的信息\n-B 5：可以显示后面5行加上查找行的信息\n-C 5：可以显示前后5行加上查找行的信息\n```\n\n#### 例子\n\n `grep 2017010500345878 --color info.log`\n\n这行命令在info.log中搜索含有\"2017010500345878\"关键词的段落并且使用其他颜色标记关键词。\n复制代码\n\n`grep -v 'ERROR' error.log` 查找不含”ERROR”的行\n\n`grep -C 50 \"关键字\" info.log`\n\n\n\n\n\n### less分页查看，比more更强\n\n`ps -ef |less`\n\nps查看进程信息并通过less分页显示\n\n搭配grep使用\n\n`less -N tomcat_stdout.log|grep job`\n`less xxx.log | grep -i -n -C10 --color=auto xx`\n\n有用的命令\n\n- 按F,监控更新.如果要暂停监控，可以CTRL+C.\n- /字符串：搜索“字符串”的功能\n- G:调到文本末尾\n- 空格键 滚动一页\n- 回车键 滚动一行\n- Q: 退出\n- gg: 调到文本最前面\n- 按v进入编辑模式，可以类似于vim的方式来编辑保存文件了\n\n其他有用的命令\n\n1.全屏导航\n\n- ctrl + F - 向前移动一屏forward\n- ctrl + B - 向后移动一屏backward\n- ctrl + D - 向前移动半屏\n- ctrl + U - 向后移动半屏\n\n2.单行导航\n\n- j - 向前移动一行\n- k - 向后移动一行\n\n3.其它导航\n\n- G - 移动到最后一行\n- g - 移动到第一行\n- q / ZZ - 退出 less 命令\n\n4.标记导航\n\n当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置：\n\n- ma - 使用 a 标记文本的当前位置\n- 'a - 导航到标记 a 处\n\n### vi编辑文本\n\n> 使用找一个字符串，在vi命令模式下键入“/”，后面跟要查找的字符串，再按回车。vi将光标定位在该串下一次出现的地方上。键入n跳到该串的下一个出现处，键入N跳到该串的上一个出现处。\n\n\n\n### tail查看文件后面几行，默认尾10行，可实时更新\n\n**-f 关键字，tail 会自动实时更新文件内容。**\n\n`tail -f [logfile]`\n\n`tail -n +100 [logfile]` \n\n查询从日志文件的第100行开始\n\n`tail -n 100 [logfile] | grep '结果' --color`   \n\n–color是查询结果带颜色\n\n\n\n### head查看文件前面几行,默认前10行;\n\n\n\n `head -50 info.log` \n\n查看info.log文件的前50行。\n\n`head -n -100 [logfile]`\n\n查询日志文件除了最后10行的其他所有日志\n\n\n\n### cat查看文件\n\n常用有三大功能:\n\n- 1.一次显示整个文件;\n- 2.从键盘创建一个文件。\n- 3.将几个文件合并为一个文件。\n\n\n\n**-n 可以显示行号**\n\n```\ncat -n test.log |tail -n +63820|head -n 20\n```\n\ntail -n +63820表示查询63820行之后的日志\nhead -n 20 则表示在前面的查询结果里再查前20条记录\n\n```\ncat -n info.log |grep \"关键字\" |more\n```\n\n这样就分页打印了,通过点击空格键翻页\n\n\n\n\n\n### sed编辑文件\n\n- 常见使用方法之: sed -n '800,900' info.log\n\n```\n查看info.log文件800到900行之间的内容\n复制代码\n```\n\n\n\n### 常见组合使用\n\n> 使用[grep -n 异常 --color info.log ]查询到异常在文件中发生的行数,然后再看前后几十行日志的内容[sed -n '800,900' info.log].\n\n\n\n\n\n[开发中常用日志搜索技巧]: https://juejin.im/post/5a992bbf6fb9a028bf04c429\n\n\n\n\n\n# Git使用总结\n\n\n\n## add与commit\n\n首先，选择一个合适的地方，创建一个空目录\n\n通过`git init`命令把这个目录变成Git可以管理的仓库。可以发现当前目录下多了一个`.git`的目录，这个目录是Git来跟踪管理版本库的。\n\n第一步，用命令`git add`告诉Git，把文件添加到仓库：\n\n第二步，用命令`git commit`告诉Git，把文件提交到仓库：\n\n```\ngit add readme.txt\ngit commit -m \"wrote a readme file\"\n```\n\n为什么Git添加文件需要`add`，`commit`一共两步呢？因为`commit`可以一次提交很多文件，所以你可以多次`add`不同的文件,也可以对一个文件进行不同更改\n\n\n\n## 版本\n\n`git log`命令显示从最近到最远的提交日志，\n\n```\ngit log --pretty=oneline\n```\n\n在Git中，用`HEAD`表示当前版本，上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本写100个`^`比较容易数不过来，所以写成`HEAD~100`。\n\n如果回到了原来的版本，git log看不到之前最新的提交记录了，但是git reflog还可以。只有知道版本号，就可还原之前的任何一个版本。\n\n```\ngit reset --hard HEAD^\ngit reset --hard 1094a\n```\n\n\n\n`git add`命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行`git commit`就可以一次性把暂存区的所有修改提交到分支。一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。\n\n`git status`可以查看一下状态，如果工作区进行了修改有没有add就会显示Untracked files\n\n一个重要的概念是:Git跟踪并管理的是修改，而非文件。把文件git add readme.txt添加到了暂存区，暂存区也只是跟踪了这次修改，而不是跟踪了这个文件。换句话说：add不是一劳永逸之后对这个文件的更改都会被commit。如果再对readme.txt进行修改，就需要在进行一次git add，如果不再add，commit提交就不会提交这次修改。**简而言之：每次修改都要进行git add。**\n\n删除文件：\n\n```\n git rm test.txt\n git commit -m \"remove test.txt\"\n```\n\n如果是误删，版本库里还有，想恢复.`git checkout`其实是用版本库里的**最新**版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。\n\n```\ngit checkout -- test.txt\n```\n\n\n\n## 分支\n\n切换分支和撤销修改是同一个关键词checkout，确实有点令人迷惑，不过切换分支的checkout也可以用switch替换\n\n```\ngit checkout -b dev #创建并切换到dev分支\ngit checkout master #切换回master分支\ngit merge dev #在master分支上合并dev\ngit branch -d dev #删除dev分支\ngit branch #查看分支\n```\n\n\n\n## 分支合并\n\n在实习的时候我经常遇到这样尴尬的情况\n\n比如：commit提交到本地分支了，切换到远程分支全没有了。解决办法：把本地和远程的分支和一下。\n\n再比如：在我的分支上明明有的方法，与其他的预发分支合并也没问题。发上去应用构建居然报错找不方法？？？原来是别人发布了一次，此时主分支就和我不一样了。本地分支当然能看到该方法，切到构建分支发现并没有这个方法。解决办法：把我的分支和主分支合并一下\n\n再再比如：\n\nCommit之后切换分支了，就commit不了，显示没有变更。解决方法：嘿嘿还是分支合并就vans了，惊不惊喜意不意外？\n\n那么问题来了，怎么万无一失的合并分支，并手动解决冲突？\n\n1. git fetch\n\n2. git checkout 分支一\n\n3. git merge origin/分支二417c909ab76eb47c8fc033479904544054e8ea0e\n\n4. 解决冲突，有一些会自动合并，必须手动解决的会在控制台输入什么类。加上`<<<<<<<`，`=======`，`>>>>>>>`这种，跟着报错提示很容易找到地方。\n\n5. git add -u  记得重新add一下否则会提示冲突没有解决\n\n6. git commit -m 'XXXXX'\n\n7. git push\n\n  \n\n​    \n\n   git log --graph --pretty=oneline --abbrev-commit可以查看分支合并情况。\n\n   \n\n   顺便说一下pull和fetch的区别\n\n`*git fetch`是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。*\n\n*而`git pull` 则是将远程主机的最新内容拉下来后直接合并，即：`git pull = git fetch + git merge`，这样可能会产生冲突，需要手动解决。*\n\n\n\n快速和并是看不出来曾经做过合并，禁用`Fast forward`模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\n\n```\ngit merge --no-ff -m \"merge with no-ff\" dev\n```\n\n\n\n## stash\n\nbug分支，工作写到一半还不能提交，但是bug得马上先修的尴尬局面。\n\n1. git stash可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：\n2. `git checkout -b issue-101`在修复bug的分支上创建临时bug分支\n3. 修完后add+提交，切换会原来的分支，合并，最后删除`issue-101`分支。\n4. `git stash list`查看之前储藏起来的内容。用`git stash apply`或者`git stash pop`，恢复，后者会在恢复的同时删除stash。（list中的id号可以让你恢复指定的stash）\n5. 如果其他分支也有该bug，git cherry-pick 4c805e2，`cherry-pick`能复制一个特定的提交到当前分支：\n\n```\ngit stash\n```\n\n如果要丢弃一个没有被合并过的分支，可以通过`git branch -D <name>`强行删除。\n\n\n\n## 小技巧\n\ncode review已提交的代码，点击主分支右键compare with current。\n\n\n\n强烈推荐这个教程，深入浅出.\nhttps://backlog.com/git-tutorial/cn/stepup/stepup7_5.html\n\n\n\n\n\n# 框架常用注解\n\n## spring\n\n## \n\n### bean的注册\n\n两种办法.\n\n#### 一、@Component或其派生 @Controller, @Service, @Repository注解\n\n- 位置: 注解在类上\n\n- 参数: 默认的bean的ID为首字母变为小写的类名\n\n- 作用域: \n\n  - 通过上述四个注解标识的 Bean，其默认作用域是\"singleton\"。\n\n    如果不想是单例，使用@Scope 注解。只需提供作用域的名称就行了。\n\n    ```java\n    @Scope(\"prototype\") \n    @Repository \n    public class Demo { … }\n    ```\n\n    \n\n@ComponentScan\n\n- 作用: @ComponentScan对应XML配置形式中的<context: component-scan>元素, 用于配合一些元信息 Java Annotation,比如@Component和@Repository等, 将标注了这些元信息 Annotation 的 bean 定义类批量采集到 Spring 的IoC容器中, 我们可以通过 basePackages等属性来细粒度地定制 @ComponentScan自动扫描的范围, 如果不指定, 则默认 Spring框架实现会从声明 @ComponentScan所在类的 package 进行扫描。\n\n#### 二、使用@Configuration 搭配 @Bean注解。\n\n **常用在配置第三方提供的bean.**\n\n- - @Configuration\n    - 位置: 注解在类上\n    - 作用: 声明当前类是一个配置类，相当于一个Spring配置的xml文件, 任何POJO+@Configuration都是一个JavaConfig配置类。 @Configuration也是一个@Component\n  - @Bean\n    - 位置: 注解在方法上\n    - 作用: 声明当前方法的返回值为一个Bean。\n\n```java\n// 使用 @Configuration + @Bean 配置一个Tesla Service\n\n@Configuration\n\npublic class TeslaServiceConfiguration {\n\n@Bean(name = \"userService\")\n\npublic UserService userService() throws TeslaException {\n\nreturn TeslaServiceConsumerFactory.getTeslaServiceConsumer(UserService.class);\n\t}\n}\n```\n\n\n\n### bean的获取\n\n@**Autowired** 搭配 @Qualifier 或者 @**Resource**\n\n@Resource和@Autowired使用起来区别不大, @Autowired优先byType装配, @Resource优先byName装配, [更多参考这里](http://www.dengshenyu.com/spring/2016/10/09/spring-inject.html)\n\n\n\n#### @Autowired(required = false)找不到也没关系\n\n问：如果属性注入找不到我不想让Spring容器抛出异常，而就是显示null，可以吗？答：将@Autowired注解的required属性设置为false即可\n\n```java\n` @Autowired(required = false)\n    private Car car;`\n```\n\n\n\n#### @Qualifier(\"BMW\")接口有多个实现拿哪一个\n\n问：一个Car接口有两个个实现，类Benz和BMW，要怎么拿？\n\n```java\n@Autowired\n    @Qualifier(\"BMW\")\n    private Car car;\n```\n\n\n\n@Autowired + @Qualifier(\"foo\")  等同于 @Resource(name=\"foo\")\n\n\n\n## bean生命周期\n\n在某些情况下，可能需要我们手工做一些额外的初始化或者销毁操作，这通常是针对一些资源的获取和释放操作。\n\nBean的生命周期 @Scope @PostConstruct 和 @PreDestroy \n\n### @Scope指定bean的作用域.\n\n```\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) or @Scope(\"prototype\")\n```\n\n\n\n### 生命周期的钩子\n\n- initMethod & destroyMethod\n  - 位置: 与@Bean搭配使用\n  - 作用: 指定bean的生命周期回调方法, bean实例化后, bean销毁前\n  - 例子: @Bean(initMethod=\"init\",destroyMethod=\"destory\")\n- @PostConstruct & @PreDestroy\n  - 位置: 与@Component搭配使用, 注解在方法上\n  - 作用: 指定bean的生命周期回调方法, bean实例化后, bean销毁前\n  - 例子: @PostConstruct public void init() {}\n\n```java\n// @PostConstruct & @PreDestroy 示例\n\n@PostConstruct\npublic void init() {}\n\n@PreDestroy\npublic void stop() {}\n```\n\n\n\n## @Value去配置文件取值\n\n```java\n@Value(\"${env}\")  \nprivate String env;\n```\n\n除了spring的application.properties，还会发现应用里对每一个环境都有不同的配置文件，诸如dev_config.properties、online_config.properties。\n\n@Value取值先去application.properties，如果配置文件以@开头结尾，如env=@env@，则根据当前环境去对应的配置文件里取\n\n##  SpringBoot\n\n- @SpringBootApplication\n  - @Configuration\n    - 启动类标注了@Configuration之后,本身其实也是一个IoC容器的配置类\n  - @EnableAutoConfiguration\n    - 从classpath中搜索所有META-INF/spring.factories配置文件, 加载配置到spring容器\n    - 比如moguboot的spring.factories就配置了很多内部中间件\n  - @ComponentScan\n\n\n\n## SpringMVC\n\n\n\n- @RequestParam & @PathVariable 做参数绑定\n  - 默认绑定\n    - 请求参数名和方法参数名一致\n  - 使用RequestParam明确指定绑定关系\n    - @RequestParam(value=\"age\" required=false)  required默认是true\n  - @PathVariable\n    - @RequestMapping(value=\"users/{userId}, method=RequestMethod.GET)\n    - foo(@PathVariable(\"userId\") long userId)\n- @RequestBody\n  - 添加 @RequestBody 后 Spring 会根据请求中的 Content-Type 头信息来选择合适的转换器, 将请求数据转为 Java 对象\n  - 比如Content-Type是application/json, 那么就是 JSON -> Model\n- @ResponseBody\n  - 添加 @ResponseBody 后 Spring 会根据请求中的 Accept 头信息来选择合适的转换器, Java 对象转化为客户端可接受的表述形式\n  - 比如Accept头部信息包含“application/json”, 就是Model -> JSON\n- @RestController\n  - @RestController 等于 @Controller + 每个方法默认加@ResponseBody\n\n\n## Lombok\n\n- @Data,相当于**@Getter+ @Setter+ toString + EqualsAndHashCode + RequiredArgsConstructor.*\n\n- @ **builder** 一个静态内部类https://juejin.im/post/5cfdf467f265da1b5d579fdd\n\n- @EqualsAndHashCode(callSuper = true)\n\n  \n\n  \n\n## 测试\n\n- @Test\n  - @Test注解标注这个方法需要测试\n- @Before\n  - 所有的测试方法之前都先执行这个方法\n- @After\n  - 所有的测试方法之后都要执行这个方法\n- 还有@BeforeClass @AfterClass等注解\n\n```java\n@Test\npublic void testAdd(){}\n\n@Before\npublic void prepare(){}\n\n@After\npublic void destroy(){}\n```\n\n\n\n\n\n\n\n[spring注解](https://www.cnblogs.com/xrq730/p/5313412.html)\n\n# 提升开发效率的技巧\n\n## idea\n\n### 常用快捷键排行榜\n\n1. 复制一行Ctrl+D  （光标所在行）\n2. 删除一行Ctrl+X （光标所在行）\n3. 选中的代码块注释  Ctrl + Shift + / \n4. 代码重新排列格式 Ctrl + Alt + L\n5. 全局替换 Ctrl+Shift+R\n6. 定位到下一个或上一个错误 F2 / Shift + F2\n7. Ctrl+Shift+F12 专注代码窗口\n8. Ctrl+E可以找到Recent Files最近浏览过的文件\n9. Ctrl + Shift + Z取消撤销 \n10. Ctrl + Shift +回车：无论光标在哪，跳到下一行\n11. ctrl+alt+v：自动补全方法/new对象的返回值。\n\n### idea中git的使用\n\n把idea项目关联为git仓库：菜单->VCS->import into Version Control->Create Git Repository->e:\\project\\hiworld-OK\n\n### 如何热部署？\n\n [热部署](https://blog.csdn.net/weixin_42831477/article/details/82229436)\n\n#### idea如何导入setting？\n\nfile -> export setting\n\n将会导出一个 setting.jar 的文件\n\n在新安装 IDEA 的电脑上，在开始的界面选择导入 setting \n\n### 查看源码五件套\n\n1. 一次性折叠所有Java方法：ctrl +shift+ 减号\n\n2. ctrl+鼠标单击某类 可以跳进该类查看源码\n\n3. Ctrl+F12 显示这个类的方法的（弹出窗口）\n\n4. alt + 7  显示这个类的方法的（左侧项目文件显示）\n\n5. Ctrl+O，这个用于查看一个类的纲要，再按一次时，列出该类继承的方法及变量。\n\n选中当前类中右击鼠标，右键菜单中选择Diagrams>Show Diagrams，快捷键Ctrl+Alt+Shift+U(不同的系统和快捷键风格快捷键会有差异)。如果是spring的类会出现如图所示的弹框，第一项是类图结构，第二个是spring beans的依赖\n\n\n\n\n\n## LINUX\n\n常用命令\n\n[菜鸟教程常用命令](https://www.runoob.com/w3cnote/linux-common-command-2.html)\n\n```\n切换目录\ncd /usr查看目录下的文件lsls -lh 遍历详细信息，如权限，所属用户，创建日期，大小等等信息\n查看当前所处目录pwd\n创建目录文件mkdir -p /test/abctouch test.java\n删除文件\nrm -f test.java\nvi abc.txt要进行编辑，要输入 a 或者 i ，才可以进行编辑哦\n要退出，首先要离开当前的编辑模式，点击左上角的ESC键，退出编辑模式然后输入冒号 (shift+分号) 打开控制命令接着输入wq，然后敲回车，即保存退出wq 是quit+write的缩写\n```\n\n\n\n## 云服务器\n\n[云翼计划,9.9一个月，需要学生认证](https://promotion.aliyun.com/ntms/campus2017.html)\n\n[安装常用软件比如java、mysql的步骤](http://how2j.cn/k/deploy2linux/deploy2linux-breif/1591.html)\n\n[MobaXterm和Navicat，远程连接服务器和数据库，不用每次都登陆阿里云网站，很好用](https://blog.csdn.net/M_Kerry/article/details/81664548)\n\n## cmd\n\n在文件夹空白处按住Shift，然后右键弹出快捷菜单，可以看到“在此处打开命令行窗口”\n\n使用上下方向键，翻看使用过的命令\n\ncd   切换目录\n\n例：cd   // 显示当前目录\n\n例：cd ..   // 进入父目录\n\n例：cd /d d:   // 进入上次d盘所在的目录（或在直接输入：d:）\n\n例：cd /d d:\\   // 进入d盘根目录\n\n例：cd d: // 显示上次d盘所在的目录\n\n例：cd /d d:\\src // 进入d:\\src目录\n\n例：cd prj\\src\\view  // 进入当前目录下的prj\\src\\view文件夹\n\n\n\n## 工具\n\n\n\n### Markdown工具 \n\n印象笔记：印象笔记也可以写md，体验一般\n\ntypora ：md文件编辑器，用起来很舒服（本篇就是用它写的）\n\nWritage 可直接将md文件打开为word，安装轻便。\n\n### 资源搜索\n\n盘搜搜：可以直接搜索网盘分享链接\n\n闲鱼：盘搜搜搜不到的网盘链接，可以在里搜搜\n\n\n\n## 其他\n\n### 合并多个word/pdf/md文件为一个？\n\n打开命令行cmd，输入下面这行命令，即可把E:\\File目录下所有md文件合并成一个文件。\n\n输入和输出路径不需要一样。\n\n```\ntype E:\\File\\*.md >> E:\\File\\margeFile.md\n```\n\n\n\n### 端口被占用？\n\n下面三行代码解决问题\n\n打开cmd命令行窗口\n\n第一行代码：查看端口号包含\"80\"的占用情况\n\n第二行代码：根据上一步找到的80端口对应的pid是1828\n\n结束java.exe\n\n```\nnetstat -ano|findstr \"8000\"\n\ntasklist|findstr \"4760\"\n\ntaskkill /f /t /im java.exe\n```\n\n### md文件转pdf？\n\nVScode安装插件后可以转。\n\n\n\n# \n","slug":"实习笔记——开发技巧","published":1,"updated":"2022-07-07T12:01:11.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qkq001ow9rp02ogomb5","content":"<p>[TOC]</p>\n<h1 id=\"Linux常用命令\"><a href=\"#Linux常用命令\" class=\"headerlink\" title=\"Linux常用命令\"></a>Linux常用命令</h1><p>常用命令</p>\n<p><a href=\"https://www.runoob.com/w3cnote/linux-common-command-2.html\" target=\"_blank\" rel=\"noopener\">菜鸟教程常用命令</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">切换目录</span><br><span class=\"line\">cd /usr查看目录下的文件lsls -lh 遍历详细信息，如权限，所属用户，创建日期，大小等等信息</span><br><span class=\"line\">查看当前所处目录pwd</span><br><span class=\"line\">创建目录文件mkdir -p /test/abctouch test.java</span><br><span class=\"line\">删除文件</span><br><span class=\"line\">rm -f test.java</span><br><span class=\"line\">vi abc.txt要进行编辑，要输入 a 或者 i ，才可以进行编辑哦</span><br><span class=\"line\">要退出，首先要离开当前的编辑模式，点击左上角的ESC键，退出编辑模式然后输入冒号 (shift+分号) 打开控制命令接着输入wq，然后敲回车，即保存退出wq 是quit+write的缩写</span><br></pre></td></tr></table></figure>\n<h3 id=\"grep搜索文本，支持正则\"><a href=\"#grep搜索文本，支持正则\" class=\"headerlink\" title=\"grep搜索文本，支持正则\"></a>grep搜索文本，支持正则</h3><h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep [-acinv] [--color=auto] &apos;搜寻字符串&apos; filename</span><br><span class=\"line\">-a：将binary文件以text文件的方式搜寻数据</span><br><span class=\"line\">-c：计算找到&apos;搜寻字符串&apos;的次数</span><br><span class=\"line\">-i：忽略大小写</span><br><span class=\"line\">-n：顺便输出行号</span><br><span class=\"line\">-v：反向选择，即输出没有&apos;搜索字符串&apos;的内容</span><br><span class=\"line\">--color=auto：可以将找到的关键词部分加上颜色显示</span><br><span class=\"line\">-A 5：可以显示前面5行加上查找行的信息</span><br><span class=\"line\">-B 5：可以显示后面5行加上查找行的信息</span><br><span class=\"line\">-C 5：可以显示前后5行加上查找行的信息</span><br></pre></td></tr></table></figure>\n<h4 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h4><p> <code>grep 2017010500345878 --color info.log</code></p>\n<p>这行命令在info.log中搜索含有”2017010500345878”关键词的段落并且使用其他颜色标记关键词。<br>复制代码</p>\n<p><code>grep -v &#39;ERROR&#39; error.log</code> 查找不含”ERROR”的行</p>\n<p><code>grep -C 50 &quot;关键字&quot; info.log</code></p>\n<h3 id=\"less分页查看，比more更强\"><a href=\"#less分页查看，比more更强\" class=\"headerlink\" title=\"less分页查看，比more更强\"></a>less分页查看，比more更强</h3><p><code>ps -ef |less</code></p>\n<p>ps查看进程信息并通过less分页显示</p>\n<p>搭配grep使用</p>\n<p><code>less -N tomcat_stdout.log|grep job</code><br><code>less xxx.log | grep -i -n -C10 --color=auto xx</code></p>\n<p>有用的命令</p>\n<ul>\n<li>按F,监控更新.如果要暂停监控，可以CTRL+C.</li>\n<li>/字符串：搜索“字符串”的功能</li>\n<li>G:调到文本末尾</li>\n<li>空格键 滚动一页</li>\n<li>回车键 滚动一行</li>\n<li>Q: 退出</li>\n<li>gg: 调到文本最前面</li>\n<li>按v进入编辑模式，可以类似于vim的方式来编辑保存文件了</li>\n</ul>\n<p>其他有用的命令</p>\n<p>1.全屏导航</p>\n<ul>\n<li>ctrl + F - 向前移动一屏forward</li>\n<li>ctrl + B - 向后移动一屏backward</li>\n<li>ctrl + D - 向前移动半屏</li>\n<li>ctrl + U - 向后移动半屏</li>\n</ul>\n<p>2.单行导航</p>\n<ul>\n<li>j - 向前移动一行</li>\n<li>k - 向后移动一行</li>\n</ul>\n<p>3.其它导航</p>\n<ul>\n<li>G - 移动到最后一行</li>\n<li>g - 移动到第一行</li>\n<li>q / ZZ - 退出 less 命令</li>\n</ul>\n<p>4.标记导航</p>\n<p>当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置：</p>\n<ul>\n<li>ma - 使用 a 标记文本的当前位置</li>\n<li>‘a - 导航到标记 a 处</li>\n</ul>\n<h3 id=\"vi编辑文本\"><a href=\"#vi编辑文本\" class=\"headerlink\" title=\"vi编辑文本\"></a>vi编辑文本</h3><blockquote>\n<p>使用找一个字符串，在vi命令模式下键入“/”，后面跟要查找的字符串，再按回车。vi将光标定位在该串下一次出现的地方上。键入n跳到该串的下一个出现处，键入N跳到该串的上一个出现处。</p>\n</blockquote>\n<h3 id=\"tail查看文件后面几行，默认尾10行，可实时更新\"><a href=\"#tail查看文件后面几行，默认尾10行，可实时更新\" class=\"headerlink\" title=\"tail查看文件后面几行，默认尾10行，可实时更新\"></a>tail查看文件后面几行，默认尾10行，可实时更新</h3><p><strong>-f 关键字，tail 会自动实时更新文件内容。</strong></p>\n<p><code>tail -f [logfile]</code></p>\n<p><code>tail -n +100 [logfile]</code> </p>\n<p>查询从日志文件的第100行开始</p>\n<p><code>tail -n 100 [logfile] | grep &#39;结果&#39; --color</code>   </p>\n<p>–color是查询结果带颜色</p>\n<h3 id=\"head查看文件前面几行-默认前10行\"><a href=\"#head查看文件前面几行-默认前10行\" class=\"headerlink\" title=\"head查看文件前面几行,默认前10行;\"></a>head查看文件前面几行,默认前10行;</h3><p> <code>head -50 info.log</code> </p>\n<p>查看info.log文件的前50行。</p>\n<p><code>head -n -100 [logfile]</code></p>\n<p>查询日志文件除了最后10行的其他所有日志</p>\n<h3 id=\"cat查看文件\"><a href=\"#cat查看文件\" class=\"headerlink\" title=\"cat查看文件\"></a>cat查看文件</h3><p>常用有三大功能:</p>\n<ul>\n<li>1.一次显示整个文件;</li>\n<li>2.从键盘创建一个文件。</li>\n<li>3.将几个文件合并为一个文件。</li>\n</ul>\n<p><strong>-n 可以显示行号</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat -n test.log |tail -n +63820|head -n 20</span><br></pre></td></tr></table></figure>\n<p>tail -n +63820表示查询63820行之后的日志<br>head -n 20 则表示在前面的查询结果里再查前20条记录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat -n info.log |grep &quot;关键字&quot; |more</span><br></pre></td></tr></table></figure>\n<p>这样就分页打印了,通过点击空格键翻页</p>\n<h3 id=\"sed编辑文件\"><a href=\"#sed编辑文件\" class=\"headerlink\" title=\"sed编辑文件\"></a>sed编辑文件</h3><ul>\n<li>常见使用方法之: sed -n ‘800,900’ info.log</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看info.log文件800到900行之间的内容</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<h3 id=\"常见组合使用\"><a href=\"#常见组合使用\" class=\"headerlink\" title=\"常见组合使用\"></a>常见组合使用</h3><blockquote>\n<p>使用[grep -n 异常 –color info.log ]查询到异常在文件中发生的行数,然后再看前后几十行日志的内容[sed -n ‘800,900’ info.log].</p>\n</blockquote>\n<h1 id=\"Git使用总结\"><a href=\"#Git使用总结\" class=\"headerlink\" title=\"Git使用总结\"></a>Git使用总结</h1><h2 id=\"add与commit\"><a href=\"#add与commit\" class=\"headerlink\" title=\"add与commit\"></a>add与commit</h2><p>首先，选择一个合适的地方，创建一个空目录</p>\n<p>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库。可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的。</p>\n<p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p>\n<p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add readme.txt</span><br><span class=\"line\">git commit -m &quot;wrote a readme file&quot;</span><br></pre></td></tr></table></figure>\n<p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件,也可以对一个文件进行不同更改</p>\n<h2 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h2><p><code>git log</code>命令显示从最近到最远的提交日志，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --pretty=oneline</span><br></pre></td></tr></table></figure>\n<p>在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p>\n<p>如果回到了原来的版本，git log看不到之前最新的提交记录了，但是git reflog还可以。只有知道版本号，就可还原之前的任何一个版本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD^</span><br><span class=\"line\">git reset --hard 1094a</span><br></pre></td></tr></table></figure>\n<p><code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。</p>\n<p><code>git status</code>可以查看一下状态，如果工作区进行了修改有没有add就会显示Untracked files</p>\n<p>一个重要的概念是:Git跟踪并管理的是修改，而非文件。把文件git add readme.txt添加到了暂存区，暂存区也只是跟踪了这次修改，而不是跟踪了这个文件。换句话说：add不是一劳永逸之后对这个文件的更改都会被commit。如果再对readme.txt进行修改，就需要在进行一次git add，如果不再add，commit提交就不会提交这次修改。<strong>简而言之：每次修改都要进行git add。</strong></p>\n<p>删除文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm test.txt</span><br><span class=\"line\">git commit -m &quot;remove test.txt&quot;</span><br></pre></td></tr></table></figure>\n<p>如果是误删，版本库里还有，想恢复.<code>git checkout</code>其实是用版本库里的<strong>最新</strong>版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -- test.txt</span><br></pre></td></tr></table></figure>\n<h2 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h2><p>切换分支和撤销修改是同一个关键词checkout，确实有点令人迷惑，不过切换分支的checkout也可以用switch替换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b dev #创建并切换到dev分支</span><br><span class=\"line\">git checkout master #切换回master分支</span><br><span class=\"line\">git merge dev #在master分支上合并dev</span><br><span class=\"line\">git branch -d dev #删除dev分支</span><br><span class=\"line\">git branch #查看分支</span><br></pre></td></tr></table></figure>\n<h2 id=\"分支合并\"><a href=\"#分支合并\" class=\"headerlink\" title=\"分支合并\"></a>分支合并</h2><p>在实习的时候我经常遇到这样尴尬的情况</p>\n<p>比如：commit提交到本地分支了，切换到远程分支全没有了。解决办法：把本地和远程的分支和一下。</p>\n<p>再比如：在我的分支上明明有的方法，与其他的预发分支合并也没问题。发上去应用构建居然报错找不方法？？？原来是别人发布了一次，此时主分支就和我不一样了。本地分支当然能看到该方法，切到构建分支发现并没有这个方法。解决办法：把我的分支和主分支合并一下</p>\n<p>再再比如：</p>\n<p>Commit之后切换分支了，就commit不了，显示没有变更。解决方法：嘿嘿还是分支合并就vans了，惊不惊喜意不意外？</p>\n<p>那么问题来了，怎么万无一失的合并分支，并手动解决冲突？</p>\n<ol>\n<li><p>git fetch</p>\n</li>\n<li><p>git checkout 分支一</p>\n</li>\n<li><p>git merge origin/分支二417c909ab76eb47c8fc033479904544054e8ea0e</p>\n</li>\n<li><p>解决冲突，有一些会自动合并，必须手动解决的会在控制台输入什么类。加上<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>这种，跟着报错提示很容易找到地方。</p>\n</li>\n<li><p>git add -u  记得重新add一下否则会提示冲突没有解决</p>\n</li>\n<li><p>git commit -m ‘XXXXX’</p>\n</li>\n<li><p>git push</p>\n</li>\n</ol>\n<p>​    </p>\n<p>   git log –graph –pretty=oneline –abbrev-commit可以查看分支合并情况。</p>\n<p>   顺便说一下pull和fetch的区别</p>\n<p><code>*git fetch</code>是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。*</p>\n<p><em>而<code>git pull</code> 则是将远程主机的最新内容拉下来后直接合并，即：<code>git pull = git fetch + git merge</code>，这样可能会产生冲突，需要手动解决。</em></p>\n<p>快速和并是看不出来曾经做过合并，禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure>\n<h2 id=\"stash\"><a href=\"#stash\" class=\"headerlink\" title=\"stash\"></a>stash</h2><p>bug分支，工作写到一半还不能提交，但是bug得马上先修的尴尬局面。</p>\n<ol>\n<li>git stash可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</li>\n<li><code>git checkout -b issue-101</code>在修复bug的分支上创建临时bug分支</li>\n<li>修完后add+提交，切换会原来的分支，合并，最后删除<code>issue-101</code>分支。</li>\n<li><code>git stash list</code>查看之前储藏起来的内容。用<code>git stash apply</code>或者<code>git stash pop</code>，恢复，后者会在恢复的同时删除stash。（list中的id号可以让你恢复指定的stash）</li>\n<li>如果其他分支也有该bug，git cherry-pick 4c805e2，<code>cherry-pick</code>能复制一个特定的提交到当前分支：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash</span><br></pre></td></tr></table></figure>\n<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>\n<h2 id=\"小技巧\"><a href=\"#小技巧\" class=\"headerlink\" title=\"小技巧\"></a>小技巧</h2><p>code review已提交的代码，点击主分支右键compare with current。</p>\n<p>强烈推荐这个教程，深入浅出.<br><a href=\"https://backlog.com/git-tutorial/cn/stepup/stepup7_5.html\" target=\"_blank\" rel=\"noopener\">https://backlog.com/git-tutorial/cn/stepup/stepup7_5.html</a></p>\n<h1 id=\"框架常用注解\"><a href=\"#框架常用注解\" class=\"headerlink\" title=\"框架常用注解\"></a>框架常用注解</h1><h2 id=\"spring\"><a href=\"#spring\" class=\"headerlink\" title=\"spring\"></a>spring</h2><p>## </p>\n<h3 id=\"bean的注册\"><a href=\"#bean的注册\" class=\"headerlink\" title=\"bean的注册\"></a>bean的注册</h3><p>两种办法.</p>\n<h4 id=\"一、-Component或其派生-Controller-Service-Repository注解\"><a href=\"#一、-Component或其派生-Controller-Service-Repository注解\" class=\"headerlink\" title=\"一、@Component或其派生 @Controller, @Service, @Repository注解\"></a>一、@Component或其派生 @Controller, @Service, @Repository注解</h4><ul>\n<li><p>位置: 注解在类上</p>\n</li>\n<li><p>参数: 默认的bean的ID为首字母变为小写的类名</p>\n</li>\n<li><p>作用域: </p>\n<ul>\n<li><p>通过上述四个注解标识的 Bean，其默认作用域是”singleton”。</p>\n<p>如果不想是单例，使用@Scope 注解。只需提供作用域的名称就行了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Scope</span>(<span class=\"string\">\"prototype\"</span>) </span><br><span class=\"line\"><span class=\"meta\">@Repository</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>@ComponentScan</p>\n<ul>\n<li>作用: @ComponentScan对应XML配置形式中的&lt;context: component-scan&gt;元素, 用于配合一些元信息 Java Annotation,比如@Component和@Repository等, 将标注了这些元信息 Annotation 的 bean 定义类批量采集到 Spring 的IoC容器中, 我们可以通过 basePackages等属性来细粒度地定制 @ComponentScan自动扫描的范围, 如果不指定, 则默认 Spring框架实现会从声明 @ComponentScan所在类的 package 进行扫描。</li>\n</ul>\n<h4 id=\"二、使用-Configuration-搭配-Bean注解。\"><a href=\"#二、使用-Configuration-搭配-Bean注解。\" class=\"headerlink\" title=\"二、使用@Configuration 搭配 @Bean注解。\"></a>二、使用@Configuration 搭配 @Bean注解。</h4><p> <strong>常用在配置第三方提供的bean.</strong></p>\n<ul>\n<li><ul>\n<li>@Configuration<ul>\n<li>位置: 注解在类上</li>\n<li>作用: 声明当前类是一个配置类，相当于一个Spring配置的xml文件, 任何POJO+@Configuration都是一个JavaConfig配置类。 @Configuration也是一个@Component</li>\n</ul>\n</li>\n<li>@Bean<ul>\n<li>位置: 注解在方法上</li>\n<li>作用: 声明当前方法的返回值为一个Bean。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 @Configuration + @Bean 配置一个Tesla Service</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TeslaServiceConfiguration</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span>(name = <span class=\"string\">\"userService\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> UserService <span class=\"title\">userService</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> TeslaException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> TeslaServiceConsumerFactory.getTeslaServiceConsumer(UserService.class);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"bean的获取\"><a href=\"#bean的获取\" class=\"headerlink\" title=\"bean的获取\"></a>bean的获取</h3><p>@<strong>Autowired</strong> 搭配 @Qualifier 或者 @<strong>Resource</strong></p>\n<p>@Resource和@Autowired使用起来区别不大, @Autowired优先byType装配, @Resource优先byName装配, <a href=\"http://www.dengshenyu.com/spring/2016/10/09/spring-inject.html\" target=\"_blank\" rel=\"noopener\">更多参考这里</a></p>\n<h4 id=\"Autowired-required-false-找不到也没关系\"><a href=\"#Autowired-required-false-找不到也没关系\" class=\"headerlink\" title=\"@Autowired(required = false)找不到也没关系\"></a>@Autowired(required = false)找不到也没关系</h4><p>问：如果属性注入找不到我不想让Spring容器抛出异常，而就是显示null，可以吗？答：将@Autowired注解的required属性设置为false即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">` <span class=\"meta\">@Autowired</span>(required = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Car car;`</span><br></pre></td></tr></table></figure>\n<h4 id=\"Qualifier-“BMW”-接口有多个实现拿哪一个\"><a href=\"#Qualifier-“BMW”-接口有多个实现拿哪一个\" class=\"headerlink\" title=\"@Qualifier(“BMW”)接口有多个实现拿哪一个\"></a>@Qualifier(“BMW”)接口有多个实现拿哪一个</h4><p>问：一个Car接口有两个个实现，类Benz和BMW，要怎么拿？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"BMW\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Car car;</span><br></pre></td></tr></table></figure>\n<p>@Autowired + @Qualifier(“foo”)  等同于 @Resource(name=”foo”)</p>\n<h2 id=\"bean生命周期\"><a href=\"#bean生命周期\" class=\"headerlink\" title=\"bean生命周期\"></a>bean生命周期</h2><p>在某些情况下，可能需要我们手工做一些额外的初始化或者销毁操作，这通常是针对一些资源的获取和释放操作。</p>\n<p>Bean的生命周期 @Scope @PostConstruct 和 @PreDestroy </p>\n<h3 id=\"Scope指定bean的作用域\"><a href=\"#Scope指定bean的作用域\" class=\"headerlink\" title=\"@Scope指定bean的作用域.\"></a>@Scope指定bean的作用域.</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) or @Scope(&quot;prototype&quot;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"生命周期的钩子\"><a href=\"#生命周期的钩子\" class=\"headerlink\" title=\"生命周期的钩子\"></a>生命周期的钩子</h3><ul>\n<li>initMethod &amp; destroyMethod<ul>\n<li>位置: 与@Bean搭配使用</li>\n<li>作用: 指定bean的生命周期回调方法, bean实例化后, bean销毁前</li>\n<li>例子: @Bean(initMethod=”init”,destroyMethod=”destory”)</li>\n</ul>\n</li>\n<li>@PostConstruct &amp; @PreDestroy<ul>\n<li>位置: 与@Component搭配使用, 注解在方法上</li>\n<li>作用: 指定bean的生命周期回调方法, bean实例化后, bean销毁前</li>\n<li>例子: @PostConstruct public void init() {}</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @PostConstruct &amp; @PreDestroy 示例</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Value去配置文件取值\"><a href=\"#Value去配置文件取值\" class=\"headerlink\" title=\"@Value去配置文件取值\"></a>@Value去配置文件取值</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;env&#125;\"</span>)  </span><br><span class=\"line\"><span class=\"keyword\">private</span> String env;</span><br></pre></td></tr></table></figure>\n<p>除了spring的application.properties，还会发现应用里对每一个环境都有不同的配置文件，诸如dev_config.properties、online_config.properties。</p>\n<p>@Value取值先去application.properties，如果配置文件以@开头结尾，如env=@env@，则根据当前环境去对应的配置文件里取</p>\n<h2 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h2><ul>\n<li>@SpringBootApplication<ul>\n<li>@Configuration<ul>\n<li>启动类标注了@Configuration之后,本身其实也是一个IoC容器的配置类</li>\n</ul>\n</li>\n<li>@EnableAutoConfiguration<ul>\n<li>从classpath中搜索所有META-INF/spring.factories配置文件, 加载配置到spring容器</li>\n<li>比如moguboot的spring.factories就配置了很多内部中间件</li>\n</ul>\n</li>\n<li>@ComponentScan</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"SpringMVC\"><a href=\"#SpringMVC\" class=\"headerlink\" title=\"SpringMVC\"></a>SpringMVC</h2><ul>\n<li>@RequestParam &amp; @PathVariable 做参数绑定<ul>\n<li>默认绑定<ul>\n<li>请求参数名和方法参数名一致</li>\n</ul>\n</li>\n<li>使用RequestParam明确指定绑定关系<ul>\n<li>@RequestParam(value=”age” required=false)  required默认是true</li>\n</ul>\n</li>\n<li>@PathVariable<ul>\n<li>@RequestMapping(value=”users/{userId}, method=RequestMethod.GET)</li>\n<li>foo(@PathVariable(“userId”) long userId)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>@RequestBody<ul>\n<li>添加 @RequestBody 后 Spring 会根据请求中的 Content-Type 头信息来选择合适的转换器, 将请求数据转为 Java 对象</li>\n<li>比如Content-Type是application/json, 那么就是 JSON -&gt; Model</li>\n</ul>\n</li>\n<li>@ResponseBody<ul>\n<li>添加 @ResponseBody 后 Spring 会根据请求中的 Accept 头信息来选择合适的转换器, Java 对象转化为客户端可接受的表述形式</li>\n<li>比如Accept头部信息包含“application/json”, 就是Model -&gt; JSON</li>\n</ul>\n</li>\n<li>@RestController<ul>\n<li>@RestController 等于 @Controller + 每个方法默认加@ResponseBody</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Lombok\"><a href=\"#Lombok\" class=\"headerlink\" title=\"Lombok\"></a>Lombok</h2><ul>\n<li><p>@Data,相当于*<em>@Getter+ @Setter+ toString + EqualsAndHashCode + RequiredArgsConstructor.</em></p>\n</li>\n<li><p>@ <strong>builder</strong> 一个静态内部类<a href=\"https://juejin.im/post/5cfdf467f265da1b5d579fdd\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5cfdf467f265da1b5d579fdd</a></p>\n</li>\n<li><p>@EqualsAndHashCode(callSuper = true)</p>\n</li>\n</ul>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><ul>\n<li>@Test<ul>\n<li>@Test注解标注这个方法需要测试</li>\n</ul>\n</li>\n<li>@Before<ul>\n<li>所有的测试方法之前都先执行这个方法</li>\n</ul>\n</li>\n<li>@After<ul>\n<li>所有的测试方法之后都要执行这个方法</li>\n</ul>\n</li>\n<li>还有@BeforeClass @AfterClass等注解</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testAdd</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Before</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@After</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://www.cnblogs.com/xrq730/p/5313412.html\" target=\"_blank\" rel=\"noopener\">spring注解</a></p>\n<h1 id=\"提升开发效率的技巧\"><a href=\"#提升开发效率的技巧\" class=\"headerlink\" title=\"提升开发效率的技巧\"></a>提升开发效率的技巧</h1><h2 id=\"idea\"><a href=\"#idea\" class=\"headerlink\" title=\"idea\"></a>idea</h2><h3 id=\"常用快捷键排行榜\"><a href=\"#常用快捷键排行榜\" class=\"headerlink\" title=\"常用快捷键排行榜\"></a>常用快捷键排行榜</h3><ol>\n<li>复制一行Ctrl+D  （光标所在行）</li>\n<li>删除一行Ctrl+X （光标所在行）</li>\n<li>选中的代码块注释  Ctrl + Shift + / </li>\n<li>代码重新排列格式 Ctrl + Alt + L</li>\n<li>全局替换 Ctrl+Shift+R</li>\n<li>定位到下一个或上一个错误 F2 / Shift + F2</li>\n<li>Ctrl+Shift+F12 专注代码窗口</li>\n<li>Ctrl+E可以找到Recent Files最近浏览过的文件</li>\n<li>Ctrl + Shift + Z取消撤销 </li>\n<li>Ctrl + Shift +回车：无论光标在哪，跳到下一行</li>\n<li>ctrl+alt+v：自动补全方法/new对象的返回值。</li>\n</ol>\n<h3 id=\"idea中git的使用\"><a href=\"#idea中git的使用\" class=\"headerlink\" title=\"idea中git的使用\"></a>idea中git的使用</h3><p>把idea项目关联为git仓库：菜单-&gt;VCS-&gt;import into Version Control-&gt;Create Git Repository-&gt;e:\\project\\hiworld-OK</p>\n<h3 id=\"如何热部署？\"><a href=\"#如何热部署？\" class=\"headerlink\" title=\"如何热部署？\"></a>如何热部署？</h3><p> <a href=\"https://blog.csdn.net/weixin_42831477/article/details/82229436\" target=\"_blank\" rel=\"noopener\">热部署</a></p>\n<h4 id=\"idea如何导入setting？\"><a href=\"#idea如何导入setting？\" class=\"headerlink\" title=\"idea如何导入setting？\"></a>idea如何导入setting？</h4><p>file -&gt; export setting</p>\n<p>将会导出一个 setting.jar 的文件</p>\n<p>在新安装 IDEA 的电脑上，在开始的界面选择导入 setting </p>\n<h3 id=\"查看源码五件套\"><a href=\"#查看源码五件套\" class=\"headerlink\" title=\"查看源码五件套\"></a>查看源码五件套</h3><ol>\n<li><p>一次性折叠所有Java方法：ctrl +shift+ 减号</p>\n</li>\n<li><p>ctrl+鼠标单击某类 可以跳进该类查看源码</p>\n</li>\n<li><p>Ctrl+F12 显示这个类的方法的（弹出窗口）</p>\n</li>\n<li><p>alt + 7  显示这个类的方法的（左侧项目文件显示）</p>\n</li>\n<li><p>Ctrl+O，这个用于查看一个类的纲要，再按一次时，列出该类继承的方法及变量。</p>\n</li>\n</ol>\n<p>选中当前类中右击鼠标，右键菜单中选择Diagrams&gt;Show Diagrams，快捷键Ctrl+Alt+Shift+U(不同的系统和快捷键风格快捷键会有差异)。如果是spring的类会出现如图所示的弹框，第一项是类图结构，第二个是spring beans的依赖</p>\n<h2 id=\"LINUX\"><a href=\"#LINUX\" class=\"headerlink\" title=\"LINUX\"></a>LINUX</h2><p>常用命令</p>\n<p><a href=\"https://www.runoob.com/w3cnote/linux-common-command-2.html\" target=\"_blank\" rel=\"noopener\">菜鸟教程常用命令</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">切换目录</span><br><span class=\"line\">cd /usr查看目录下的文件lsls -lh 遍历详细信息，如权限，所属用户，创建日期，大小等等信息</span><br><span class=\"line\">查看当前所处目录pwd</span><br><span class=\"line\">创建目录文件mkdir -p /test/abctouch test.java</span><br><span class=\"line\">删除文件</span><br><span class=\"line\">rm -f test.java</span><br><span class=\"line\">vi abc.txt要进行编辑，要输入 a 或者 i ，才可以进行编辑哦</span><br><span class=\"line\">要退出，首先要离开当前的编辑模式，点击左上角的ESC键，退出编辑模式然后输入冒号 (shift+分号) 打开控制命令接着输入wq，然后敲回车，即保存退出wq 是quit+write的缩写</span><br></pre></td></tr></table></figure>\n<h2 id=\"云服务器\"><a href=\"#云服务器\" class=\"headerlink\" title=\"云服务器\"></a>云服务器</h2><p><a href=\"https://promotion.aliyun.com/ntms/campus2017.html\" target=\"_blank\" rel=\"noopener\">云翼计划,9.9一个月，需要学生认证</a></p>\n<p><a href=\"http://how2j.cn/k/deploy2linux/deploy2linux-breif/1591.html\" target=\"_blank\" rel=\"noopener\">安装常用软件比如java、mysql的步骤</a></p>\n<p><a href=\"https://blog.csdn.net/M_Kerry/article/details/81664548\" target=\"_blank\" rel=\"noopener\">MobaXterm和Navicat，远程连接服务器和数据库，不用每次都登陆阿里云网站，很好用</a></p>\n<h2 id=\"cmd\"><a href=\"#cmd\" class=\"headerlink\" title=\"cmd\"></a>cmd</h2><p>在文件夹空白处按住Shift，然后右键弹出快捷菜单，可以看到“在此处打开命令行窗口”</p>\n<p>使用上下方向键，翻看使用过的命令</p>\n<p>cd   切换目录</p>\n<p>例：cd   // 显示当前目录</p>\n<p>例：cd ..   // 进入父目录</p>\n<p>例：cd /d d:   // 进入上次d盘所在的目录（或在直接输入：d:）</p>\n<p>例：cd /d d:\\   // 进入d盘根目录</p>\n<p>例：cd d: // 显示上次d盘所在的目录</p>\n<p>例：cd /d d:\\src // 进入d:\\src目录</p>\n<p>例：cd prj\\src\\view  // 进入当前目录下的prj\\src\\view文件夹</p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"Markdown工具\"><a href=\"#Markdown工具\" class=\"headerlink\" title=\"Markdown工具\"></a>Markdown工具</h3><p>印象笔记：印象笔记也可以写md，体验一般</p>\n<p>typora ：md文件编辑器，用起来很舒服（本篇就是用它写的）</p>\n<p>Writage 可直接将md文件打开为word，安装轻便。</p>\n<h3 id=\"资源搜索\"><a href=\"#资源搜索\" class=\"headerlink\" title=\"资源搜索\"></a>资源搜索</h3><p>盘搜搜：可以直接搜索网盘分享链接</p>\n<p>闲鱼：盘搜搜搜不到的网盘链接，可以在里搜搜</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"合并多个word-pdf-md文件为一个？\"><a href=\"#合并多个word-pdf-md文件为一个？\" class=\"headerlink\" title=\"合并多个word/pdf/md文件为一个？\"></a>合并多个word/pdf/md文件为一个？</h3><p>打开命令行cmd，输入下面这行命令，即可把E:\\File目录下所有md文件合并成一个文件。</p>\n<p>输入和输出路径不需要一样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type E:\\File\\*.md &gt;&gt; E:\\File\\margeFile.md</span><br></pre></td></tr></table></figure>\n<h3 id=\"端口被占用？\"><a href=\"#端口被占用？\" class=\"headerlink\" title=\"端口被占用？\"></a>端口被占用？</h3><p>下面三行代码解决问题</p>\n<p>打开cmd命令行窗口</p>\n<p>第一行代码：查看端口号包含”80”的占用情况</p>\n<p>第二行代码：根据上一步找到的80端口对应的pid是1828</p>\n<p>结束java.exe</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ano|findstr &quot;8000&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">tasklist|findstr &quot;4760&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">taskkill /f /t /im java.exe</span><br></pre></td></tr></table></figure>\n<h3 id=\"md文件转pdf？\"><a href=\"#md文件转pdf？\" class=\"headerlink\" title=\"md文件转pdf？\"></a>md文件转pdf？</h3><p>VScode安装插件后可以转。</p>\n<p># </p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"Linux常用命令\"><a href=\"#Linux常用命令\" class=\"headerlink\" title=\"Linux常用命令\"></a>Linux常用命令</h1><p>常用命令</p>\n<p><a href=\"https://www.runoob.com/w3cnote/linux-common-command-2.html\" target=\"_blank\" rel=\"noopener\">菜鸟教程常用命令</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">切换目录</span><br><span class=\"line\">cd /usr查看目录下的文件lsls -lh 遍历详细信息，如权限，所属用户，创建日期，大小等等信息</span><br><span class=\"line\">查看当前所处目录pwd</span><br><span class=\"line\">创建目录文件mkdir -p /test/abctouch test.java</span><br><span class=\"line\">删除文件</span><br><span class=\"line\">rm -f test.java</span><br><span class=\"line\">vi abc.txt要进行编辑，要输入 a 或者 i ，才可以进行编辑哦</span><br><span class=\"line\">要退出，首先要离开当前的编辑模式，点击左上角的ESC键，退出编辑模式然后输入冒号 (shift+分号) 打开控制命令接着输入wq，然后敲回车，即保存退出wq 是quit+write的缩写</span><br></pre></td></tr></table></figure>\n<h3 id=\"grep搜索文本，支持正则\"><a href=\"#grep搜索文本，支持正则\" class=\"headerlink\" title=\"grep搜索文本，支持正则\"></a>grep搜索文本，支持正则</h3><h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep [-acinv] [--color=auto] &apos;搜寻字符串&apos; filename</span><br><span class=\"line\">-a：将binary文件以text文件的方式搜寻数据</span><br><span class=\"line\">-c：计算找到&apos;搜寻字符串&apos;的次数</span><br><span class=\"line\">-i：忽略大小写</span><br><span class=\"line\">-n：顺便输出行号</span><br><span class=\"line\">-v：反向选择，即输出没有&apos;搜索字符串&apos;的内容</span><br><span class=\"line\">--color=auto：可以将找到的关键词部分加上颜色显示</span><br><span class=\"line\">-A 5：可以显示前面5行加上查找行的信息</span><br><span class=\"line\">-B 5：可以显示后面5行加上查找行的信息</span><br><span class=\"line\">-C 5：可以显示前后5行加上查找行的信息</span><br></pre></td></tr></table></figure>\n<h4 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h4><p> <code>grep 2017010500345878 --color info.log</code></p>\n<p>这行命令在info.log中搜索含有”2017010500345878”关键词的段落并且使用其他颜色标记关键词。<br>复制代码</p>\n<p><code>grep -v &#39;ERROR&#39; error.log</code> 查找不含”ERROR”的行</p>\n<p><code>grep -C 50 &quot;关键字&quot; info.log</code></p>\n<h3 id=\"less分页查看，比more更强\"><a href=\"#less分页查看，比more更强\" class=\"headerlink\" title=\"less分页查看，比more更强\"></a>less分页查看，比more更强</h3><p><code>ps -ef |less</code></p>\n<p>ps查看进程信息并通过less分页显示</p>\n<p>搭配grep使用</p>\n<p><code>less -N tomcat_stdout.log|grep job</code><br><code>less xxx.log | grep -i -n -C10 --color=auto xx</code></p>\n<p>有用的命令</p>\n<ul>\n<li>按F,监控更新.如果要暂停监控，可以CTRL+C.</li>\n<li>/字符串：搜索“字符串”的功能</li>\n<li>G:调到文本末尾</li>\n<li>空格键 滚动一页</li>\n<li>回车键 滚动一行</li>\n<li>Q: 退出</li>\n<li>gg: 调到文本最前面</li>\n<li>按v进入编辑模式，可以类似于vim的方式来编辑保存文件了</li>\n</ul>\n<p>其他有用的命令</p>\n<p>1.全屏导航</p>\n<ul>\n<li>ctrl + F - 向前移动一屏forward</li>\n<li>ctrl + B - 向后移动一屏backward</li>\n<li>ctrl + D - 向前移动半屏</li>\n<li>ctrl + U - 向后移动半屏</li>\n</ul>\n<p>2.单行导航</p>\n<ul>\n<li>j - 向前移动一行</li>\n<li>k - 向后移动一行</li>\n</ul>\n<p>3.其它导航</p>\n<ul>\n<li>G - 移动到最后一行</li>\n<li>g - 移动到第一行</li>\n<li>q / ZZ - 退出 less 命令</li>\n</ul>\n<p>4.标记导航</p>\n<p>当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置：</p>\n<ul>\n<li>ma - 使用 a 标记文本的当前位置</li>\n<li>‘a - 导航到标记 a 处</li>\n</ul>\n<h3 id=\"vi编辑文本\"><a href=\"#vi编辑文本\" class=\"headerlink\" title=\"vi编辑文本\"></a>vi编辑文本</h3><blockquote>\n<p>使用找一个字符串，在vi命令模式下键入“/”，后面跟要查找的字符串，再按回车。vi将光标定位在该串下一次出现的地方上。键入n跳到该串的下一个出现处，键入N跳到该串的上一个出现处。</p>\n</blockquote>\n<h3 id=\"tail查看文件后面几行，默认尾10行，可实时更新\"><a href=\"#tail查看文件后面几行，默认尾10行，可实时更新\" class=\"headerlink\" title=\"tail查看文件后面几行，默认尾10行，可实时更新\"></a>tail查看文件后面几行，默认尾10行，可实时更新</h3><p><strong>-f 关键字，tail 会自动实时更新文件内容。</strong></p>\n<p><code>tail -f [logfile]</code></p>\n<p><code>tail -n +100 [logfile]</code> </p>\n<p>查询从日志文件的第100行开始</p>\n<p><code>tail -n 100 [logfile] | grep &#39;结果&#39; --color</code>   </p>\n<p>–color是查询结果带颜色</p>\n<h3 id=\"head查看文件前面几行-默认前10行\"><a href=\"#head查看文件前面几行-默认前10行\" class=\"headerlink\" title=\"head查看文件前面几行,默认前10行;\"></a>head查看文件前面几行,默认前10行;</h3><p> <code>head -50 info.log</code> </p>\n<p>查看info.log文件的前50行。</p>\n<p><code>head -n -100 [logfile]</code></p>\n<p>查询日志文件除了最后10行的其他所有日志</p>\n<h3 id=\"cat查看文件\"><a href=\"#cat查看文件\" class=\"headerlink\" title=\"cat查看文件\"></a>cat查看文件</h3><p>常用有三大功能:</p>\n<ul>\n<li>1.一次显示整个文件;</li>\n<li>2.从键盘创建一个文件。</li>\n<li>3.将几个文件合并为一个文件。</li>\n</ul>\n<p><strong>-n 可以显示行号</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat -n test.log |tail -n +63820|head -n 20</span><br></pre></td></tr></table></figure>\n<p>tail -n +63820表示查询63820行之后的日志<br>head -n 20 则表示在前面的查询结果里再查前20条记录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat -n info.log |grep &quot;关键字&quot; |more</span><br></pre></td></tr></table></figure>\n<p>这样就分页打印了,通过点击空格键翻页</p>\n<h3 id=\"sed编辑文件\"><a href=\"#sed编辑文件\" class=\"headerlink\" title=\"sed编辑文件\"></a>sed编辑文件</h3><ul>\n<li>常见使用方法之: sed -n ‘800,900’ info.log</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看info.log文件800到900行之间的内容</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<h3 id=\"常见组合使用\"><a href=\"#常见组合使用\" class=\"headerlink\" title=\"常见组合使用\"></a>常见组合使用</h3><blockquote>\n<p>使用[grep -n 异常 –color info.log ]查询到异常在文件中发生的行数,然后再看前后几十行日志的内容[sed -n ‘800,900’ info.log].</p>\n</blockquote>\n<h1 id=\"Git使用总结\"><a href=\"#Git使用总结\" class=\"headerlink\" title=\"Git使用总结\"></a>Git使用总结</h1><h2 id=\"add与commit\"><a href=\"#add与commit\" class=\"headerlink\" title=\"add与commit\"></a>add与commit</h2><p>首先，选择一个合适的地方，创建一个空目录</p>\n<p>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库。可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的。</p>\n<p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p>\n<p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add readme.txt</span><br><span class=\"line\">git commit -m &quot;wrote a readme file&quot;</span><br></pre></td></tr></table></figure>\n<p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件,也可以对一个文件进行不同更改</p>\n<h2 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h2><p><code>git log</code>命令显示从最近到最远的提交日志，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --pretty=oneline</span><br></pre></td></tr></table></figure>\n<p>在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p>\n<p>如果回到了原来的版本，git log看不到之前最新的提交记录了，但是git reflog还可以。只有知道版本号，就可还原之前的任何一个版本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD^</span><br><span class=\"line\">git reset --hard 1094a</span><br></pre></td></tr></table></figure>\n<p><code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。</p>\n<p><code>git status</code>可以查看一下状态，如果工作区进行了修改有没有add就会显示Untracked files</p>\n<p>一个重要的概念是:Git跟踪并管理的是修改，而非文件。把文件git add readme.txt添加到了暂存区，暂存区也只是跟踪了这次修改，而不是跟踪了这个文件。换句话说：add不是一劳永逸之后对这个文件的更改都会被commit。如果再对readme.txt进行修改，就需要在进行一次git add，如果不再add，commit提交就不会提交这次修改。<strong>简而言之：每次修改都要进行git add。</strong></p>\n<p>删除文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm test.txt</span><br><span class=\"line\">git commit -m &quot;remove test.txt&quot;</span><br></pre></td></tr></table></figure>\n<p>如果是误删，版本库里还有，想恢复.<code>git checkout</code>其实是用版本库里的<strong>最新</strong>版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -- test.txt</span><br></pre></td></tr></table></figure>\n<h2 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h2><p>切换分支和撤销修改是同一个关键词checkout，确实有点令人迷惑，不过切换分支的checkout也可以用switch替换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b dev #创建并切换到dev分支</span><br><span class=\"line\">git checkout master #切换回master分支</span><br><span class=\"line\">git merge dev #在master分支上合并dev</span><br><span class=\"line\">git branch -d dev #删除dev分支</span><br><span class=\"line\">git branch #查看分支</span><br></pre></td></tr></table></figure>\n<h2 id=\"分支合并\"><a href=\"#分支合并\" class=\"headerlink\" title=\"分支合并\"></a>分支合并</h2><p>在实习的时候我经常遇到这样尴尬的情况</p>\n<p>比如：commit提交到本地分支了，切换到远程分支全没有了。解决办法：把本地和远程的分支和一下。</p>\n<p>再比如：在我的分支上明明有的方法，与其他的预发分支合并也没问题。发上去应用构建居然报错找不方法？？？原来是别人发布了一次，此时主分支就和我不一样了。本地分支当然能看到该方法，切到构建分支发现并没有这个方法。解决办法：把我的分支和主分支合并一下</p>\n<p>再再比如：</p>\n<p>Commit之后切换分支了，就commit不了，显示没有变更。解决方法：嘿嘿还是分支合并就vans了，惊不惊喜意不意外？</p>\n<p>那么问题来了，怎么万无一失的合并分支，并手动解决冲突？</p>\n<ol>\n<li><p>git fetch</p>\n</li>\n<li><p>git checkout 分支一</p>\n</li>\n<li><p>git merge origin/分支二417c909ab76eb47c8fc033479904544054e8ea0e</p>\n</li>\n<li><p>解决冲突，有一些会自动合并，必须手动解决的会在控制台输入什么类。加上<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>这种，跟着报错提示很容易找到地方。</p>\n</li>\n<li><p>git add -u  记得重新add一下否则会提示冲突没有解决</p>\n</li>\n<li><p>git commit -m ‘XXXXX’</p>\n</li>\n<li><p>git push</p>\n</li>\n</ol>\n<p>​    </p>\n<p>   git log –graph –pretty=oneline –abbrev-commit可以查看分支合并情况。</p>\n<p>   顺便说一下pull和fetch的区别</p>\n<p><code>*git fetch</code>是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。*</p>\n<p><em>而<code>git pull</code> 则是将远程主机的最新内容拉下来后直接合并，即：<code>git pull = git fetch + git merge</code>，这样可能会产生冲突，需要手动解决。</em></p>\n<p>快速和并是看不出来曾经做过合并，禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure>\n<h2 id=\"stash\"><a href=\"#stash\" class=\"headerlink\" title=\"stash\"></a>stash</h2><p>bug分支，工作写到一半还不能提交，但是bug得马上先修的尴尬局面。</p>\n<ol>\n<li>git stash可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</li>\n<li><code>git checkout -b issue-101</code>在修复bug的分支上创建临时bug分支</li>\n<li>修完后add+提交，切换会原来的分支，合并，最后删除<code>issue-101</code>分支。</li>\n<li><code>git stash list</code>查看之前储藏起来的内容。用<code>git stash apply</code>或者<code>git stash pop</code>，恢复，后者会在恢复的同时删除stash。（list中的id号可以让你恢复指定的stash）</li>\n<li>如果其他分支也有该bug，git cherry-pick 4c805e2，<code>cherry-pick</code>能复制一个特定的提交到当前分支：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash</span><br></pre></td></tr></table></figure>\n<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>\n<h2 id=\"小技巧\"><a href=\"#小技巧\" class=\"headerlink\" title=\"小技巧\"></a>小技巧</h2><p>code review已提交的代码，点击主分支右键compare with current。</p>\n<p>强烈推荐这个教程，深入浅出.<br><a href=\"https://backlog.com/git-tutorial/cn/stepup/stepup7_5.html\" target=\"_blank\" rel=\"noopener\">https://backlog.com/git-tutorial/cn/stepup/stepup7_5.html</a></p>\n<h1 id=\"框架常用注解\"><a href=\"#框架常用注解\" class=\"headerlink\" title=\"框架常用注解\"></a>框架常用注解</h1><h2 id=\"spring\"><a href=\"#spring\" class=\"headerlink\" title=\"spring\"></a>spring</h2><p>## </p>\n<h3 id=\"bean的注册\"><a href=\"#bean的注册\" class=\"headerlink\" title=\"bean的注册\"></a>bean的注册</h3><p>两种办法.</p>\n<h4 id=\"一、-Component或其派生-Controller-Service-Repository注解\"><a href=\"#一、-Component或其派生-Controller-Service-Repository注解\" class=\"headerlink\" title=\"一、@Component或其派生 @Controller, @Service, @Repository注解\"></a>一、@Component或其派生 @Controller, @Service, @Repository注解</h4><ul>\n<li><p>位置: 注解在类上</p>\n</li>\n<li><p>参数: 默认的bean的ID为首字母变为小写的类名</p>\n</li>\n<li><p>作用域: </p>\n<ul>\n<li><p>通过上述四个注解标识的 Bean，其默认作用域是”singleton”。</p>\n<p>如果不想是单例，使用@Scope 注解。只需提供作用域的名称就行了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Scope</span>(<span class=\"string\">\"prototype\"</span>) </span><br><span class=\"line\"><span class=\"meta\">@Repository</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>@ComponentScan</p>\n<ul>\n<li>作用: @ComponentScan对应XML配置形式中的&lt;context: component-scan&gt;元素, 用于配合一些元信息 Java Annotation,比如@Component和@Repository等, 将标注了这些元信息 Annotation 的 bean 定义类批量采集到 Spring 的IoC容器中, 我们可以通过 basePackages等属性来细粒度地定制 @ComponentScan自动扫描的范围, 如果不指定, 则默认 Spring框架实现会从声明 @ComponentScan所在类的 package 进行扫描。</li>\n</ul>\n<h4 id=\"二、使用-Configuration-搭配-Bean注解。\"><a href=\"#二、使用-Configuration-搭配-Bean注解。\" class=\"headerlink\" title=\"二、使用@Configuration 搭配 @Bean注解。\"></a>二、使用@Configuration 搭配 @Bean注解。</h4><p> <strong>常用在配置第三方提供的bean.</strong></p>\n<ul>\n<li><ul>\n<li>@Configuration<ul>\n<li>位置: 注解在类上</li>\n<li>作用: 声明当前类是一个配置类，相当于一个Spring配置的xml文件, 任何POJO+@Configuration都是一个JavaConfig配置类。 @Configuration也是一个@Component</li>\n</ul>\n</li>\n<li>@Bean<ul>\n<li>位置: 注解在方法上</li>\n<li>作用: 声明当前方法的返回值为一个Bean。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 @Configuration + @Bean 配置一个Tesla Service</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TeslaServiceConfiguration</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span>(name = <span class=\"string\">\"userService\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> UserService <span class=\"title\">userService</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> TeslaException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> TeslaServiceConsumerFactory.getTeslaServiceConsumer(UserService.class);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"bean的获取\"><a href=\"#bean的获取\" class=\"headerlink\" title=\"bean的获取\"></a>bean的获取</h3><p>@<strong>Autowired</strong> 搭配 @Qualifier 或者 @<strong>Resource</strong></p>\n<p>@Resource和@Autowired使用起来区别不大, @Autowired优先byType装配, @Resource优先byName装配, <a href=\"http://www.dengshenyu.com/spring/2016/10/09/spring-inject.html\" target=\"_blank\" rel=\"noopener\">更多参考这里</a></p>\n<h4 id=\"Autowired-required-false-找不到也没关系\"><a href=\"#Autowired-required-false-找不到也没关系\" class=\"headerlink\" title=\"@Autowired(required = false)找不到也没关系\"></a>@Autowired(required = false)找不到也没关系</h4><p>问：如果属性注入找不到我不想让Spring容器抛出异常，而就是显示null，可以吗？答：将@Autowired注解的required属性设置为false即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">` <span class=\"meta\">@Autowired</span>(required = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Car car;`</span><br></pre></td></tr></table></figure>\n<h4 id=\"Qualifier-“BMW”-接口有多个实现拿哪一个\"><a href=\"#Qualifier-“BMW”-接口有多个实现拿哪一个\" class=\"headerlink\" title=\"@Qualifier(“BMW”)接口有多个实现拿哪一个\"></a>@Qualifier(“BMW”)接口有多个实现拿哪一个</h4><p>问：一个Car接口有两个个实现，类Benz和BMW，要怎么拿？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"BMW\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Car car;</span><br></pre></td></tr></table></figure>\n<p>@Autowired + @Qualifier(“foo”)  等同于 @Resource(name=”foo”)</p>\n<h2 id=\"bean生命周期\"><a href=\"#bean生命周期\" class=\"headerlink\" title=\"bean生命周期\"></a>bean生命周期</h2><p>在某些情况下，可能需要我们手工做一些额外的初始化或者销毁操作，这通常是针对一些资源的获取和释放操作。</p>\n<p>Bean的生命周期 @Scope @PostConstruct 和 @PreDestroy </p>\n<h3 id=\"Scope指定bean的作用域\"><a href=\"#Scope指定bean的作用域\" class=\"headerlink\" title=\"@Scope指定bean的作用域.\"></a>@Scope指定bean的作用域.</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) or @Scope(&quot;prototype&quot;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"生命周期的钩子\"><a href=\"#生命周期的钩子\" class=\"headerlink\" title=\"生命周期的钩子\"></a>生命周期的钩子</h3><ul>\n<li>initMethod &amp; destroyMethod<ul>\n<li>位置: 与@Bean搭配使用</li>\n<li>作用: 指定bean的生命周期回调方法, bean实例化后, bean销毁前</li>\n<li>例子: @Bean(initMethod=”init”,destroyMethod=”destory”)</li>\n</ul>\n</li>\n<li>@PostConstruct &amp; @PreDestroy<ul>\n<li>位置: 与@Component搭配使用, 注解在方法上</li>\n<li>作用: 指定bean的生命周期回调方法, bean实例化后, bean销毁前</li>\n<li>例子: @PostConstruct public void init() {}</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @PostConstruct &amp; @PreDestroy 示例</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Value去配置文件取值\"><a href=\"#Value去配置文件取值\" class=\"headerlink\" title=\"@Value去配置文件取值\"></a>@Value去配置文件取值</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;env&#125;\"</span>)  </span><br><span class=\"line\"><span class=\"keyword\">private</span> String env;</span><br></pre></td></tr></table></figure>\n<p>除了spring的application.properties，还会发现应用里对每一个环境都有不同的配置文件，诸如dev_config.properties、online_config.properties。</p>\n<p>@Value取值先去application.properties，如果配置文件以@开头结尾，如env=@env@，则根据当前环境去对应的配置文件里取</p>\n<h2 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h2><ul>\n<li>@SpringBootApplication<ul>\n<li>@Configuration<ul>\n<li>启动类标注了@Configuration之后,本身其实也是一个IoC容器的配置类</li>\n</ul>\n</li>\n<li>@EnableAutoConfiguration<ul>\n<li>从classpath中搜索所有META-INF/spring.factories配置文件, 加载配置到spring容器</li>\n<li>比如moguboot的spring.factories就配置了很多内部中间件</li>\n</ul>\n</li>\n<li>@ComponentScan</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"SpringMVC\"><a href=\"#SpringMVC\" class=\"headerlink\" title=\"SpringMVC\"></a>SpringMVC</h2><ul>\n<li>@RequestParam &amp; @PathVariable 做参数绑定<ul>\n<li>默认绑定<ul>\n<li>请求参数名和方法参数名一致</li>\n</ul>\n</li>\n<li>使用RequestParam明确指定绑定关系<ul>\n<li>@RequestParam(value=”age” required=false)  required默认是true</li>\n</ul>\n</li>\n<li>@PathVariable<ul>\n<li>@RequestMapping(value=”users/{userId}, method=RequestMethod.GET)</li>\n<li>foo(@PathVariable(“userId”) long userId)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>@RequestBody<ul>\n<li>添加 @RequestBody 后 Spring 会根据请求中的 Content-Type 头信息来选择合适的转换器, 将请求数据转为 Java 对象</li>\n<li>比如Content-Type是application/json, 那么就是 JSON -&gt; Model</li>\n</ul>\n</li>\n<li>@ResponseBody<ul>\n<li>添加 @ResponseBody 后 Spring 会根据请求中的 Accept 头信息来选择合适的转换器, Java 对象转化为客户端可接受的表述形式</li>\n<li>比如Accept头部信息包含“application/json”, 就是Model -&gt; JSON</li>\n</ul>\n</li>\n<li>@RestController<ul>\n<li>@RestController 等于 @Controller + 每个方法默认加@ResponseBody</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Lombok\"><a href=\"#Lombok\" class=\"headerlink\" title=\"Lombok\"></a>Lombok</h2><ul>\n<li><p>@Data,相当于*<em>@Getter+ @Setter+ toString + EqualsAndHashCode + RequiredArgsConstructor.</em></p>\n</li>\n<li><p>@ <strong>builder</strong> 一个静态内部类<a href=\"https://juejin.im/post/5cfdf467f265da1b5d579fdd\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5cfdf467f265da1b5d579fdd</a></p>\n</li>\n<li><p>@EqualsAndHashCode(callSuper = true)</p>\n</li>\n</ul>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><ul>\n<li>@Test<ul>\n<li>@Test注解标注这个方法需要测试</li>\n</ul>\n</li>\n<li>@Before<ul>\n<li>所有的测试方法之前都先执行这个方法</li>\n</ul>\n</li>\n<li>@After<ul>\n<li>所有的测试方法之后都要执行这个方法</li>\n</ul>\n</li>\n<li>还有@BeforeClass @AfterClass等注解</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testAdd</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Before</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@After</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://www.cnblogs.com/xrq730/p/5313412.html\" target=\"_blank\" rel=\"noopener\">spring注解</a></p>\n<h1 id=\"提升开发效率的技巧\"><a href=\"#提升开发效率的技巧\" class=\"headerlink\" title=\"提升开发效率的技巧\"></a>提升开发效率的技巧</h1><h2 id=\"idea\"><a href=\"#idea\" class=\"headerlink\" title=\"idea\"></a>idea</h2><h3 id=\"常用快捷键排行榜\"><a href=\"#常用快捷键排行榜\" class=\"headerlink\" title=\"常用快捷键排行榜\"></a>常用快捷键排行榜</h3><ol>\n<li>复制一行Ctrl+D  （光标所在行）</li>\n<li>删除一行Ctrl+X （光标所在行）</li>\n<li>选中的代码块注释  Ctrl + Shift + / </li>\n<li>代码重新排列格式 Ctrl + Alt + L</li>\n<li>全局替换 Ctrl+Shift+R</li>\n<li>定位到下一个或上一个错误 F2 / Shift + F2</li>\n<li>Ctrl+Shift+F12 专注代码窗口</li>\n<li>Ctrl+E可以找到Recent Files最近浏览过的文件</li>\n<li>Ctrl + Shift + Z取消撤销 </li>\n<li>Ctrl + Shift +回车：无论光标在哪，跳到下一行</li>\n<li>ctrl+alt+v：自动补全方法/new对象的返回值。</li>\n</ol>\n<h3 id=\"idea中git的使用\"><a href=\"#idea中git的使用\" class=\"headerlink\" title=\"idea中git的使用\"></a>idea中git的使用</h3><p>把idea项目关联为git仓库：菜单-&gt;VCS-&gt;import into Version Control-&gt;Create Git Repository-&gt;e:\\project\\hiworld-OK</p>\n<h3 id=\"如何热部署？\"><a href=\"#如何热部署？\" class=\"headerlink\" title=\"如何热部署？\"></a>如何热部署？</h3><p> <a href=\"https://blog.csdn.net/weixin_42831477/article/details/82229436\" target=\"_blank\" rel=\"noopener\">热部署</a></p>\n<h4 id=\"idea如何导入setting？\"><a href=\"#idea如何导入setting？\" class=\"headerlink\" title=\"idea如何导入setting？\"></a>idea如何导入setting？</h4><p>file -&gt; export setting</p>\n<p>将会导出一个 setting.jar 的文件</p>\n<p>在新安装 IDEA 的电脑上，在开始的界面选择导入 setting </p>\n<h3 id=\"查看源码五件套\"><a href=\"#查看源码五件套\" class=\"headerlink\" title=\"查看源码五件套\"></a>查看源码五件套</h3><ol>\n<li><p>一次性折叠所有Java方法：ctrl +shift+ 减号</p>\n</li>\n<li><p>ctrl+鼠标单击某类 可以跳进该类查看源码</p>\n</li>\n<li><p>Ctrl+F12 显示这个类的方法的（弹出窗口）</p>\n</li>\n<li><p>alt + 7  显示这个类的方法的（左侧项目文件显示）</p>\n</li>\n<li><p>Ctrl+O，这个用于查看一个类的纲要，再按一次时，列出该类继承的方法及变量。</p>\n</li>\n</ol>\n<p>选中当前类中右击鼠标，右键菜单中选择Diagrams&gt;Show Diagrams，快捷键Ctrl+Alt+Shift+U(不同的系统和快捷键风格快捷键会有差异)。如果是spring的类会出现如图所示的弹框，第一项是类图结构，第二个是spring beans的依赖</p>\n<h2 id=\"LINUX\"><a href=\"#LINUX\" class=\"headerlink\" title=\"LINUX\"></a>LINUX</h2><p>常用命令</p>\n<p><a href=\"https://www.runoob.com/w3cnote/linux-common-command-2.html\" target=\"_blank\" rel=\"noopener\">菜鸟教程常用命令</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">切换目录</span><br><span class=\"line\">cd /usr查看目录下的文件lsls -lh 遍历详细信息，如权限，所属用户，创建日期，大小等等信息</span><br><span class=\"line\">查看当前所处目录pwd</span><br><span class=\"line\">创建目录文件mkdir -p /test/abctouch test.java</span><br><span class=\"line\">删除文件</span><br><span class=\"line\">rm -f test.java</span><br><span class=\"line\">vi abc.txt要进行编辑，要输入 a 或者 i ，才可以进行编辑哦</span><br><span class=\"line\">要退出，首先要离开当前的编辑模式，点击左上角的ESC键，退出编辑模式然后输入冒号 (shift+分号) 打开控制命令接着输入wq，然后敲回车，即保存退出wq 是quit+write的缩写</span><br></pre></td></tr></table></figure>\n<h2 id=\"云服务器\"><a href=\"#云服务器\" class=\"headerlink\" title=\"云服务器\"></a>云服务器</h2><p><a href=\"https://promotion.aliyun.com/ntms/campus2017.html\" target=\"_blank\" rel=\"noopener\">云翼计划,9.9一个月，需要学生认证</a></p>\n<p><a href=\"http://how2j.cn/k/deploy2linux/deploy2linux-breif/1591.html\" target=\"_blank\" rel=\"noopener\">安装常用软件比如java、mysql的步骤</a></p>\n<p><a href=\"https://blog.csdn.net/M_Kerry/article/details/81664548\" target=\"_blank\" rel=\"noopener\">MobaXterm和Navicat，远程连接服务器和数据库，不用每次都登陆阿里云网站，很好用</a></p>\n<h2 id=\"cmd\"><a href=\"#cmd\" class=\"headerlink\" title=\"cmd\"></a>cmd</h2><p>在文件夹空白处按住Shift，然后右键弹出快捷菜单，可以看到“在此处打开命令行窗口”</p>\n<p>使用上下方向键，翻看使用过的命令</p>\n<p>cd   切换目录</p>\n<p>例：cd   // 显示当前目录</p>\n<p>例：cd ..   // 进入父目录</p>\n<p>例：cd /d d:   // 进入上次d盘所在的目录（或在直接输入：d:）</p>\n<p>例：cd /d d:\\   // 进入d盘根目录</p>\n<p>例：cd d: // 显示上次d盘所在的目录</p>\n<p>例：cd /d d:\\src // 进入d:\\src目录</p>\n<p>例：cd prj\\src\\view  // 进入当前目录下的prj\\src\\view文件夹</p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"Markdown工具\"><a href=\"#Markdown工具\" class=\"headerlink\" title=\"Markdown工具\"></a>Markdown工具</h3><p>印象笔记：印象笔记也可以写md，体验一般</p>\n<p>typora ：md文件编辑器，用起来很舒服（本篇就是用它写的）</p>\n<p>Writage 可直接将md文件打开为word，安装轻便。</p>\n<h3 id=\"资源搜索\"><a href=\"#资源搜索\" class=\"headerlink\" title=\"资源搜索\"></a>资源搜索</h3><p>盘搜搜：可以直接搜索网盘分享链接</p>\n<p>闲鱼：盘搜搜搜不到的网盘链接，可以在里搜搜</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"合并多个word-pdf-md文件为一个？\"><a href=\"#合并多个word-pdf-md文件为一个？\" class=\"headerlink\" title=\"合并多个word/pdf/md文件为一个？\"></a>合并多个word/pdf/md文件为一个？</h3><p>打开命令行cmd，输入下面这行命令，即可把E:\\File目录下所有md文件合并成一个文件。</p>\n<p>输入和输出路径不需要一样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type E:\\File\\*.md &gt;&gt; E:\\File\\margeFile.md</span><br></pre></td></tr></table></figure>\n<h3 id=\"端口被占用？\"><a href=\"#端口被占用？\" class=\"headerlink\" title=\"端口被占用？\"></a>端口被占用？</h3><p>下面三行代码解决问题</p>\n<p>打开cmd命令行窗口</p>\n<p>第一行代码：查看端口号包含”80”的占用情况</p>\n<p>第二行代码：根据上一步找到的80端口对应的pid是1828</p>\n<p>结束java.exe</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ano|findstr &quot;8000&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">tasklist|findstr &quot;4760&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">taskkill /f /t /im java.exe</span><br></pre></td></tr></table></figure>\n<h3 id=\"md文件转pdf？\"><a href=\"#md文件转pdf？\" class=\"headerlink\" title=\"md文件转pdf？\"></a>md文件转pdf？</h3><p>VScode安装插件后可以转。</p>\n<p># </p>\n"},{"title":"java线程池详解","date":"2019-05-26T14:24:50.000Z","description":"java线程池详解","_content":"\n\n\n# 使用线程池的好处\n\n1. **降低资源销毁**。不用频繁的创建销毁线程，线程可以循环重复使用。\n2. **提高响应速度**。每当任务到达时，无需创建新线程。\n3. **提高线程的可管理性**。线程池可以统一分配、调优和监控。可以根据系统的承受能力，调整线程的数量，防止因为消耗过多内存导致服务器崩溃。\n\n\n# 创建线程\n\n创建线程池有两种方法。一、构造方法创建。二、通过Executor框架的工具类Executors实现。\n\n\n\n## 一、构造方法创建\n\n在ThreadPoolExecutor类中提供了四个构造方法。\n>\n>public ThreadPoolExecutor(**int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue**);\n>\n>    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,**ThreadFactory threadFactory**);\n>\n>    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,**RejectedExecutionHandler handler)**;\n>\n>    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,**ThreadFactory threadFactory,RejectedExecutionHandler handler**);\n>    \n### 参数介绍\n这里使用了上面构造方法的第一种进行创建一个线程池\n```\nThreadPoolExecutor threadPool= new ThreadPoolExecutor(\n        10, 15, 60, TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>(1024));\n```\n\n第一个参数corePoolSize=10 表示这个线程池初始化了10个线程在里面工作\n第二个参数maximumPoolSize=15 表示如果10个线程不够用了，就会自动增加到最多15个线程\n第三个参数keepAliveTime=60 结合第四个参数TimeUnit.SECONDS，表示经过60秒，多出来的线程还没有接到活儿，就会回收，最后保持池子里就10个\n第四个参数TimeUnit.SECONDS 第三参数的单位为秒，有7种静态属性。\n第五个参数 new LinkedBlockingQueue() 用来放任务的集合。有三个选择   \n\n* ArrayBlockingQueue;\n* LinkedBlockingQueue;\n* SynchronousQueue;\n\n\n### 拒绝策略\nhandler：表示当处理任务时的四种拒绝策略：\n\n* ThreadPoolExecutor.AbortPolicy:丢弃任务并**抛出RejectedExecutionException异常**。\n* ThreadPoolExecutor.DiscardPolicy：丢弃任务（**当前将要加入队列的任务**），但是不抛出异常。\n* ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列**最老的任务**，然后重新尝试执行任务，即重复此过程。\n* ThreadPoolExecutor.CallerRunsPolicy：**由调用线程处理该任务**\n\n## 二、通过Executor框架的工具类Executors实现\n\n* newCachedThreadPool创建一个**可缓存线程池**，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。适合处理短时间工作任务。\n* newFixedThreadPool 创建一个**定长线程池**，可控制线程最大并发数，超出的线程会在队列中等待。\n* newScheduledThreadPool 创建一个**定长线程池**，支持**定时或者周期性**任务执行。\n* newSingleThreadExecutor 创建一个**单线程化**的线程池，它只会用唯一的工作线程来执行任务，如何有异常结束，会有另一个线程去取代它。保证所有任务**按照指定顺序**(FIFO, LIFO, 优先级)执行。\n* newWorkStealingPool:1.8版本出现，利用working-stealing算法，**可窃取任务，并行处理**，需要穿一个并行级别的参数，如果不传，则被设定为默认的CPU数量。\n\n```\nExecutorService c= Executors.newCachedThreadPool();\nExecutorService f= Executors.newFixedThreadPool(3);\nScheduledExecutorService s= Executors.newScheduledThreadPool(5);\nExecutorService sin= Executors.newSingleThreadExecutor(); \n// 设置并行级别为2，即默认每时每刻只有2个线程同时执行\nExecutorService m = Executors.newWorkStealingPool(2);\n```\n\n## 三、不要使用Executors默认创建线程池的方式\n另外注意：不要使用Executors**默认**创建线程池的方式，这可能会导致OOM，因为LinkedBlockingQueue时未指定容量，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导致内存溢出问题。\n上面提到的问题主要体现在newFixedThreadPool和newSingleThreadExecutor两个工厂方法上，并不是说newCachedThreadPool和newScheduledThreadPool这两个方法就安全了，这两种方式默认创建的最大线程数可能是Integer.MAX_VALUE，而创建这么多线程，必然就有可能导致OOM。\n反例：\n\n```\n ExecutorService executor = Executors.newFixedThreadPool(15);//不要这样做\n```\n正例\n```\nExecutorService executor = new ThreadPoolExecutor(\n10, 10,60L, TimeUnit.SECONDS,new ArrayBlockingQueue(10));\n```\n\n\n\n# 线程池类的社会关系\n## 关系\n`ThreadPoolExecutor——>AbstractExecutorService——>ExecutorService——>Executor`\n线程池类ThreadPoolExecutor在包java.util.concurrent下， 继承了AbstractExecutorService 抽象类，该抽象类实现了ExecutorService接口，而该接口继承了Executor接口\n\n## 分析\nExecutor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；\nExecutorService接口声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；\n抽象类AbstractExecutorService基本实现了ExecutorService中声明的所有方法；\n在ThreadPoolExecutor类中有几个非常重要的方法：\n\n* execute()\n* submit()\n* shutdown()\n* shutdownNow()\n\nexecute()可以向线程池提交一个任务。\nsubmit()也是用来向线程池提交任务的，但是它和execute()方法不的是能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果。\nshutdown()和shutdownNow()是用来关闭线程池的。\n\n# 线程池的状态（5种）\n其中AtomicInteger变量ctl的功能非常强大：利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态：\n1、**RUNNING**：-1 << COUNT_BITS，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；\n2、**SHUTDOWN**： 0 << COUNT_BITS，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；\n3、**STOP** ： 1 << COUNT_BITS，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；\n4、**TIDYING** ： 2 << COUNT_BITS，即高3位为010，该状态表示线程池对线程进行整理优化；\n5、**TERMINATED**： 3 << COUNT_BITS，即高3位为011，该状态表示线程池停止工作；\n\n\n# 实现原理\n线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；\n如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果阻塞队列满了，那就创建新的线程执行当前任务；\n直到线程池中的线程数达到maxPoolSize,这时再有任务来，只能执行reject()处理该任务。\n\n\n# 如何合理配置线程池的大小？\n根据《Java并发编程实战》对于计算密集型的任务，在拥有N个处理器的系统上，当线程池的大小为N+1时，通常能实现最优的效率。(即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费。)\n\n如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 **NCPU+1**\n如果是IO密集型任务（比如数据库数据交互、文件上传下载、网络数据传输等等），参考值可以设置为**2*NCPU**\n*tips：这行代码可以查看Ncpu\n`System.out.println(Runtime.getRuntime().availableProcessors());//输出运行时可用处理器\n`*\n\n>参考博文\n>[这篇比较详细，还有源码解读](https://www.cnblogs.com/dolphin0520/p/3932921.html)\n>[关于ThreadFactory与BlockingQueue](https://www.cnblogs.com/leipDao/p/8436380.html)\n\n\n","source":"_posts/线程池详解.md","raw":"---\ntitle: java线程池详解\ndate: 2019-05-26 22:24:50\ncategories: 并发\ndescription: java线程池详解\n---\n\n\n\n# 使用线程池的好处\n\n1. **降低资源销毁**。不用频繁的创建销毁线程，线程可以循环重复使用。\n2. **提高响应速度**。每当任务到达时，无需创建新线程。\n3. **提高线程的可管理性**。线程池可以统一分配、调优和监控。可以根据系统的承受能力，调整线程的数量，防止因为消耗过多内存导致服务器崩溃。\n\n\n# 创建线程\n\n创建线程池有两种方法。一、构造方法创建。二、通过Executor框架的工具类Executors实现。\n\n\n\n## 一、构造方法创建\n\n在ThreadPoolExecutor类中提供了四个构造方法。\n>\n>public ThreadPoolExecutor(**int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue**);\n>\n>    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,**ThreadFactory threadFactory**);\n>\n>    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,**RejectedExecutionHandler handler)**;\n>\n>    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,**ThreadFactory threadFactory,RejectedExecutionHandler handler**);\n>    \n### 参数介绍\n这里使用了上面构造方法的第一种进行创建一个线程池\n```\nThreadPoolExecutor threadPool= new ThreadPoolExecutor(\n        10, 15, 60, TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>(1024));\n```\n\n第一个参数corePoolSize=10 表示这个线程池初始化了10个线程在里面工作\n第二个参数maximumPoolSize=15 表示如果10个线程不够用了，就会自动增加到最多15个线程\n第三个参数keepAliveTime=60 结合第四个参数TimeUnit.SECONDS，表示经过60秒，多出来的线程还没有接到活儿，就会回收，最后保持池子里就10个\n第四个参数TimeUnit.SECONDS 第三参数的单位为秒，有7种静态属性。\n第五个参数 new LinkedBlockingQueue() 用来放任务的集合。有三个选择   \n\n* ArrayBlockingQueue;\n* LinkedBlockingQueue;\n* SynchronousQueue;\n\n\n### 拒绝策略\nhandler：表示当处理任务时的四种拒绝策略：\n\n* ThreadPoolExecutor.AbortPolicy:丢弃任务并**抛出RejectedExecutionException异常**。\n* ThreadPoolExecutor.DiscardPolicy：丢弃任务（**当前将要加入队列的任务**），但是不抛出异常。\n* ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列**最老的任务**，然后重新尝试执行任务，即重复此过程。\n* ThreadPoolExecutor.CallerRunsPolicy：**由调用线程处理该任务**\n\n## 二、通过Executor框架的工具类Executors实现\n\n* newCachedThreadPool创建一个**可缓存线程池**，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。适合处理短时间工作任务。\n* newFixedThreadPool 创建一个**定长线程池**，可控制线程最大并发数，超出的线程会在队列中等待。\n* newScheduledThreadPool 创建一个**定长线程池**，支持**定时或者周期性**任务执行。\n* newSingleThreadExecutor 创建一个**单线程化**的线程池，它只会用唯一的工作线程来执行任务，如何有异常结束，会有另一个线程去取代它。保证所有任务**按照指定顺序**(FIFO, LIFO, 优先级)执行。\n* newWorkStealingPool:1.8版本出现，利用working-stealing算法，**可窃取任务，并行处理**，需要穿一个并行级别的参数，如果不传，则被设定为默认的CPU数量。\n\n```\nExecutorService c= Executors.newCachedThreadPool();\nExecutorService f= Executors.newFixedThreadPool(3);\nScheduledExecutorService s= Executors.newScheduledThreadPool(5);\nExecutorService sin= Executors.newSingleThreadExecutor(); \n// 设置并行级别为2，即默认每时每刻只有2个线程同时执行\nExecutorService m = Executors.newWorkStealingPool(2);\n```\n\n## 三、不要使用Executors默认创建线程池的方式\n另外注意：不要使用Executors**默认**创建线程池的方式，这可能会导致OOM，因为LinkedBlockingQueue时未指定容量，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导致内存溢出问题。\n上面提到的问题主要体现在newFixedThreadPool和newSingleThreadExecutor两个工厂方法上，并不是说newCachedThreadPool和newScheduledThreadPool这两个方法就安全了，这两种方式默认创建的最大线程数可能是Integer.MAX_VALUE，而创建这么多线程，必然就有可能导致OOM。\n反例：\n\n```\n ExecutorService executor = Executors.newFixedThreadPool(15);//不要这样做\n```\n正例\n```\nExecutorService executor = new ThreadPoolExecutor(\n10, 10,60L, TimeUnit.SECONDS,new ArrayBlockingQueue(10));\n```\n\n\n\n# 线程池类的社会关系\n## 关系\n`ThreadPoolExecutor——>AbstractExecutorService——>ExecutorService——>Executor`\n线程池类ThreadPoolExecutor在包java.util.concurrent下， 继承了AbstractExecutorService 抽象类，该抽象类实现了ExecutorService接口，而该接口继承了Executor接口\n\n## 分析\nExecutor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；\nExecutorService接口声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；\n抽象类AbstractExecutorService基本实现了ExecutorService中声明的所有方法；\n在ThreadPoolExecutor类中有几个非常重要的方法：\n\n* execute()\n* submit()\n* shutdown()\n* shutdownNow()\n\nexecute()可以向线程池提交一个任务。\nsubmit()也是用来向线程池提交任务的，但是它和execute()方法不的是能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果。\nshutdown()和shutdownNow()是用来关闭线程池的。\n\n# 线程池的状态（5种）\n其中AtomicInteger变量ctl的功能非常强大：利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态：\n1、**RUNNING**：-1 << COUNT_BITS，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；\n2、**SHUTDOWN**： 0 << COUNT_BITS，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；\n3、**STOP** ： 1 << COUNT_BITS，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；\n4、**TIDYING** ： 2 << COUNT_BITS，即高3位为010，该状态表示线程池对线程进行整理优化；\n5、**TERMINATED**： 3 << COUNT_BITS，即高3位为011，该状态表示线程池停止工作；\n\n\n# 实现原理\n线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；\n如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果阻塞队列满了，那就创建新的线程执行当前任务；\n直到线程池中的线程数达到maxPoolSize,这时再有任务来，只能执行reject()处理该任务。\n\n\n# 如何合理配置线程池的大小？\n根据《Java并发编程实战》对于计算密集型的任务，在拥有N个处理器的系统上，当线程池的大小为N+1时，通常能实现最优的效率。(即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费。)\n\n如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 **NCPU+1**\n如果是IO密集型任务（比如数据库数据交互、文件上传下载、网络数据传输等等），参考值可以设置为**2*NCPU**\n*tips：这行代码可以查看Ncpu\n`System.out.println(Runtime.getRuntime().availableProcessors());//输出运行时可用处理器\n`*\n\n>参考博文\n>[这篇比较详细，还有源码解读](https://www.cnblogs.com/dolphin0520/p/3932921.html)\n>[关于ThreadFactory与BlockingQueue](https://www.cnblogs.com/leipDao/p/8436380.html)\n\n\n","slug":"线程池详解","published":1,"updated":"2022-02-08T07:09:41.229Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qkq001rw9rpkl6hrj4w","content":"<h1 id=\"使用线程池的好处\"><a href=\"#使用线程池的好处\" class=\"headerlink\" title=\"使用线程池的好处\"></a>使用线程池的好处</h1><ol>\n<li><strong>降低资源销毁</strong>。不用频繁的创建销毁线程，线程可以循环重复使用。</li>\n<li><strong>提高响应速度</strong>。每当任务到达时，无需创建新线程。</li>\n<li><strong>提高线程的可管理性</strong>。线程池可以统一分配、调优和监控。可以根据系统的承受能力，调整线程的数量，防止因为消耗过多内存导致服务器崩溃。</li>\n</ol>\n<h1 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h1><p>创建线程池有两种方法。一、构造方法创建。二、通过Executor框架的工具类Executors实现。</p>\n<h2 id=\"一、构造方法创建\"><a href=\"#一、构造方法创建\" class=\"headerlink\" title=\"一、构造方法创建\"></a>一、构造方法创建</h2><p>在ThreadPoolExecutor类中提供了四个构造方法。</p>\n<blockquote>\n<p>public ThreadPoolExecutor(<strong>int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<runnable> workQueue</runnable></strong>);</p>\n<p>   public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<runnable> workQueue,<strong>ThreadFactory threadFactory</strong>);</runnable></p>\n<p>   public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<runnable> workQueue,<strong>RejectedExecutionHandler handler)</strong>;</runnable></p>\n<p>   public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<runnable> workQueue,<strong>ThreadFactory threadFactory,RejectedExecutionHandler handler</strong>);</runnable></p>\n</blockquote>\n<h3 id=\"参数介绍\"><a href=\"#参数介绍\" class=\"headerlink\" title=\"参数介绍\"></a>参数介绍</h3><p>这里使用了上面构造方法的第一种进行创建一个线程池<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor threadPool= new ThreadPoolExecutor(</span><br><span class=\"line\">        10, 15, 60, TimeUnit.SECONDS,new LinkedBlockingQueue&lt;Runnable&gt;(1024));</span><br></pre></td></tr></table></figure></p>\n<p>第一个参数corePoolSize=10 表示这个线程池初始化了10个线程在里面工作<br>第二个参数maximumPoolSize=15 表示如果10个线程不够用了，就会自动增加到最多15个线程<br>第三个参数keepAliveTime=60 结合第四个参数TimeUnit.SECONDS，表示经过60秒，多出来的线程还没有接到活儿，就会回收，最后保持池子里就10个<br>第四个参数TimeUnit.SECONDS 第三参数的单位为秒，有7种静态属性。<br>第五个参数 new LinkedBlockingQueue() 用来放任务的集合。有三个选择   </p>\n<ul>\n<li>ArrayBlockingQueue;</li>\n<li>LinkedBlockingQueue;</li>\n<li>SynchronousQueue;</li>\n</ul>\n<h3 id=\"拒绝策略\"><a href=\"#拒绝策略\" class=\"headerlink\" title=\"拒绝策略\"></a>拒绝策略</h3><p>handler：表示当处理任务时的四种拒绝策略：</p>\n<ul>\n<li>ThreadPoolExecutor.AbortPolicy:丢弃任务并<strong>抛出RejectedExecutionException异常</strong>。</li>\n<li>ThreadPoolExecutor.DiscardPolicy：丢弃任务（<strong>当前将要加入队列的任务</strong>），但是不抛出异常。</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列<strong>最老的任务</strong>，然后重新尝试执行任务，即重复此过程。</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy：<strong>由调用线程处理该任务</strong></li>\n</ul>\n<h2 id=\"二、通过Executor框架的工具类Executors实现\"><a href=\"#二、通过Executor框架的工具类Executors实现\" class=\"headerlink\" title=\"二、通过Executor框架的工具类Executors实现\"></a>二、通过Executor框架的工具类Executors实现</h2><ul>\n<li>newCachedThreadPool创建一个<strong>可缓存线程池</strong>，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。适合处理短时间工作任务。</li>\n<li>newFixedThreadPool 创建一个<strong>定长线程池</strong>，可控制线程最大并发数，超出的线程会在队列中等待。</li>\n<li>newScheduledThreadPool 创建一个<strong>定长线程池</strong>，支持<strong>定时或者周期性</strong>任务执行。</li>\n<li>newSingleThreadExecutor 创建一个<strong>单线程化</strong>的线程池，它只会用唯一的工作线程来执行任务，如何有异常结束，会有另一个线程去取代它。保证所有任务<strong>按照指定顺序</strong>(FIFO, LIFO, 优先级)执行。</li>\n<li>newWorkStealingPool:1.8版本出现，利用working-stealing算法，<strong>可窃取任务，并行处理</strong>，需要穿一个并行级别的参数，如果不传，则被设定为默认的CPU数量。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService c= Executors.newCachedThreadPool();</span><br><span class=\"line\">ExecutorService f= Executors.newFixedThreadPool(3);</span><br><span class=\"line\">ScheduledExecutorService s= Executors.newScheduledThreadPool(5);</span><br><span class=\"line\">ExecutorService sin= Executors.newSingleThreadExecutor(); </span><br><span class=\"line\">// 设置并行级别为2，即默认每时每刻只有2个线程同时执行</span><br><span class=\"line\">ExecutorService m = Executors.newWorkStealingPool(2);</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、不要使用Executors默认创建线程池的方式\"><a href=\"#三、不要使用Executors默认创建线程池的方式\" class=\"headerlink\" title=\"三、不要使用Executors默认创建线程池的方式\"></a>三、不要使用Executors默认创建线程池的方式</h2><p>另外注意：不要使用Executors<strong>默认</strong>创建线程池的方式，这可能会导致OOM，因为LinkedBlockingQueue时未指定容量，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导致内存溢出问题。<br>上面提到的问题主要体现在newFixedThreadPool和newSingleThreadExecutor两个工厂方法上，并不是说newCachedThreadPool和newScheduledThreadPool这两个方法就安全了，这两种方式默认创建的最大线程数可能是Integer.MAX_VALUE，而创建这么多线程，必然就有可能导致OOM。<br>反例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ExecutorService executor = Executors.newFixedThreadPool(15);//不要这样做</span><br></pre></td></tr></table></figure>\n<p>正例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService executor = new ThreadPoolExecutor(</span><br><span class=\"line\">10, 10,60L, TimeUnit.SECONDS,new ArrayBlockingQueue(10));</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"线程池类的社会关系\"><a href=\"#线程池类的社会关系\" class=\"headerlink\" title=\"线程池类的社会关系\"></a>线程池类的社会关系</h1><h2 id=\"关系\"><a href=\"#关系\" class=\"headerlink\" title=\"关系\"></a>关系</h2><p><code>ThreadPoolExecutor——&gt;AbstractExecutorService——&gt;ExecutorService——&gt;Executor</code><br>线程池类ThreadPoolExecutor在包java.util.concurrent下， 继承了AbstractExecutorService 抽象类，该抽象类实现了ExecutorService接口，而该接口继承了Executor接口</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；<br>ExecutorService接口声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；<br>抽象类AbstractExecutorService基本实现了ExecutorService中声明的所有方法；<br>在ThreadPoolExecutor类中有几个非常重要的方法：</p>\n<ul>\n<li>execute()</li>\n<li>submit()</li>\n<li>shutdown()</li>\n<li>shutdownNow()</li>\n</ul>\n<p>execute()可以向线程池提交一个任务。<br>submit()也是用来向线程池提交任务的，但是它和execute()方法不的是能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果。<br>shutdown()和shutdownNow()是用来关闭线程池的。</p>\n<h1 id=\"线程池的状态（5种）\"><a href=\"#线程池的状态（5种）\" class=\"headerlink\" title=\"线程池的状态（5种）\"></a>线程池的状态（5种）</h1><p>其中AtomicInteger变量ctl的功能非常强大：利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态：<br>1、<strong>RUNNING</strong>：-1 &lt;&lt; COUNT_BITS，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；<br>2、<strong>SHUTDOWN</strong>： 0 &lt;&lt; COUNT_BITS，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；<br>3、<strong>STOP</strong> ： 1 &lt;&lt; COUNT_BITS，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；<br>4、<strong>TIDYING</strong> ： 2 &lt;&lt; COUNT_BITS，即高3位为010，该状态表示线程池对线程进行整理优化；<br>5、<strong>TERMINATED</strong>： 3 &lt;&lt; COUNT_BITS，即高3位为011，该状态表示线程池停止工作；</p>\n<h1 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h1><p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；<br>如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果阻塞队列满了，那就创建新的线程执行当前任务；<br>直到线程池中的线程数达到maxPoolSize,这时再有任务来，只能执行reject()处理该任务。</p>\n<h1 id=\"如何合理配置线程池的大小？\"><a href=\"#如何合理配置线程池的大小？\" class=\"headerlink\" title=\"如何合理配置线程池的大小？\"></a>如何合理配置线程池的大小？</h1><p>根据《Java并发编程实战》对于计算密集型的任务，在拥有N个处理器的系统上，当线程池的大小为N+1时，通常能实现最优的效率。(即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费。)</p>\n<p>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 <strong>NCPU+1</strong><br>如果是IO密集型任务（比如数据库数据交互、文件上传下载、网络数据传输等等），参考值可以设置为<strong>2*NCPU</strong><br><em>tips：这行代码可以查看Ncpu<br><code>System.out.println(Runtime.getRuntime().availableProcessors());//输出运行时可用处理器</code></em></p>\n<blockquote>\n<p>参考博文<br><a href=\"https://www.cnblogs.com/dolphin0520/p/3932921.html\" target=\"_blank\" rel=\"noopener\">这篇比较详细，还有源码解读</a><br><a href=\"https://www.cnblogs.com/leipDao/p/8436380.html\" target=\"_blank\" rel=\"noopener\">关于ThreadFactory与BlockingQueue</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用线程池的好处\"><a href=\"#使用线程池的好处\" class=\"headerlink\" title=\"使用线程池的好处\"></a>使用线程池的好处</h1><ol>\n<li><strong>降低资源销毁</strong>。不用频繁的创建销毁线程，线程可以循环重复使用。</li>\n<li><strong>提高响应速度</strong>。每当任务到达时，无需创建新线程。</li>\n<li><strong>提高线程的可管理性</strong>。线程池可以统一分配、调优和监控。可以根据系统的承受能力，调整线程的数量，防止因为消耗过多内存导致服务器崩溃。</li>\n</ol>\n<h1 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h1><p>创建线程池有两种方法。一、构造方法创建。二、通过Executor框架的工具类Executors实现。</p>\n<h2 id=\"一、构造方法创建\"><a href=\"#一、构造方法创建\" class=\"headerlink\" title=\"一、构造方法创建\"></a>一、构造方法创建</h2><p>在ThreadPoolExecutor类中提供了四个构造方法。</p>\n<blockquote>\n<p>public ThreadPoolExecutor(<strong>int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<runnable> workQueue</runnable></strong>);</p>\n<p>   public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<runnable> workQueue,<strong>ThreadFactory threadFactory</strong>);</runnable></p>\n<p>   public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<runnable> workQueue,<strong>RejectedExecutionHandler handler)</strong>;</runnable></p>\n<p>   public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<runnable> workQueue,<strong>ThreadFactory threadFactory,RejectedExecutionHandler handler</strong>);</runnable></p>\n</blockquote>\n<h3 id=\"参数介绍\"><a href=\"#参数介绍\" class=\"headerlink\" title=\"参数介绍\"></a>参数介绍</h3><p>这里使用了上面构造方法的第一种进行创建一个线程池<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor threadPool= new ThreadPoolExecutor(</span><br><span class=\"line\">        10, 15, 60, TimeUnit.SECONDS,new LinkedBlockingQueue&lt;Runnable&gt;(1024));</span><br></pre></td></tr></table></figure></p>\n<p>第一个参数corePoolSize=10 表示这个线程池初始化了10个线程在里面工作<br>第二个参数maximumPoolSize=15 表示如果10个线程不够用了，就会自动增加到最多15个线程<br>第三个参数keepAliveTime=60 结合第四个参数TimeUnit.SECONDS，表示经过60秒，多出来的线程还没有接到活儿，就会回收，最后保持池子里就10个<br>第四个参数TimeUnit.SECONDS 第三参数的单位为秒，有7种静态属性。<br>第五个参数 new LinkedBlockingQueue() 用来放任务的集合。有三个选择   </p>\n<ul>\n<li>ArrayBlockingQueue;</li>\n<li>LinkedBlockingQueue;</li>\n<li>SynchronousQueue;</li>\n</ul>\n<h3 id=\"拒绝策略\"><a href=\"#拒绝策略\" class=\"headerlink\" title=\"拒绝策略\"></a>拒绝策略</h3><p>handler：表示当处理任务时的四种拒绝策略：</p>\n<ul>\n<li>ThreadPoolExecutor.AbortPolicy:丢弃任务并<strong>抛出RejectedExecutionException异常</strong>。</li>\n<li>ThreadPoolExecutor.DiscardPolicy：丢弃任务（<strong>当前将要加入队列的任务</strong>），但是不抛出异常。</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列<strong>最老的任务</strong>，然后重新尝试执行任务，即重复此过程。</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy：<strong>由调用线程处理该任务</strong></li>\n</ul>\n<h2 id=\"二、通过Executor框架的工具类Executors实现\"><a href=\"#二、通过Executor框架的工具类Executors实现\" class=\"headerlink\" title=\"二、通过Executor框架的工具类Executors实现\"></a>二、通过Executor框架的工具类Executors实现</h2><ul>\n<li>newCachedThreadPool创建一个<strong>可缓存线程池</strong>，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。适合处理短时间工作任务。</li>\n<li>newFixedThreadPool 创建一个<strong>定长线程池</strong>，可控制线程最大并发数，超出的线程会在队列中等待。</li>\n<li>newScheduledThreadPool 创建一个<strong>定长线程池</strong>，支持<strong>定时或者周期性</strong>任务执行。</li>\n<li>newSingleThreadExecutor 创建一个<strong>单线程化</strong>的线程池，它只会用唯一的工作线程来执行任务，如何有异常结束，会有另一个线程去取代它。保证所有任务<strong>按照指定顺序</strong>(FIFO, LIFO, 优先级)执行。</li>\n<li>newWorkStealingPool:1.8版本出现，利用working-stealing算法，<strong>可窃取任务，并行处理</strong>，需要穿一个并行级别的参数，如果不传，则被设定为默认的CPU数量。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService c= Executors.newCachedThreadPool();</span><br><span class=\"line\">ExecutorService f= Executors.newFixedThreadPool(3);</span><br><span class=\"line\">ScheduledExecutorService s= Executors.newScheduledThreadPool(5);</span><br><span class=\"line\">ExecutorService sin= Executors.newSingleThreadExecutor(); </span><br><span class=\"line\">// 设置并行级别为2，即默认每时每刻只有2个线程同时执行</span><br><span class=\"line\">ExecutorService m = Executors.newWorkStealingPool(2);</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、不要使用Executors默认创建线程池的方式\"><a href=\"#三、不要使用Executors默认创建线程池的方式\" class=\"headerlink\" title=\"三、不要使用Executors默认创建线程池的方式\"></a>三、不要使用Executors默认创建线程池的方式</h2><p>另外注意：不要使用Executors<strong>默认</strong>创建线程池的方式，这可能会导致OOM，因为LinkedBlockingQueue时未指定容量，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导致内存溢出问题。<br>上面提到的问题主要体现在newFixedThreadPool和newSingleThreadExecutor两个工厂方法上，并不是说newCachedThreadPool和newScheduledThreadPool这两个方法就安全了，这两种方式默认创建的最大线程数可能是Integer.MAX_VALUE，而创建这么多线程，必然就有可能导致OOM。<br>反例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ExecutorService executor = Executors.newFixedThreadPool(15);//不要这样做</span><br></pre></td></tr></table></figure>\n<p>正例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService executor = new ThreadPoolExecutor(</span><br><span class=\"line\">10, 10,60L, TimeUnit.SECONDS,new ArrayBlockingQueue(10));</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"线程池类的社会关系\"><a href=\"#线程池类的社会关系\" class=\"headerlink\" title=\"线程池类的社会关系\"></a>线程池类的社会关系</h1><h2 id=\"关系\"><a href=\"#关系\" class=\"headerlink\" title=\"关系\"></a>关系</h2><p><code>ThreadPoolExecutor——&gt;AbstractExecutorService——&gt;ExecutorService——&gt;Executor</code><br>线程池类ThreadPoolExecutor在包java.util.concurrent下， 继承了AbstractExecutorService 抽象类，该抽象类实现了ExecutorService接口，而该接口继承了Executor接口</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；<br>ExecutorService接口声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；<br>抽象类AbstractExecutorService基本实现了ExecutorService中声明的所有方法；<br>在ThreadPoolExecutor类中有几个非常重要的方法：</p>\n<ul>\n<li>execute()</li>\n<li>submit()</li>\n<li>shutdown()</li>\n<li>shutdownNow()</li>\n</ul>\n<p>execute()可以向线程池提交一个任务。<br>submit()也是用来向线程池提交任务的，但是它和execute()方法不的是能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果。<br>shutdown()和shutdownNow()是用来关闭线程池的。</p>\n<h1 id=\"线程池的状态（5种）\"><a href=\"#线程池的状态（5种）\" class=\"headerlink\" title=\"线程池的状态（5种）\"></a>线程池的状态（5种）</h1><p>其中AtomicInteger变量ctl的功能非常强大：利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态：<br>1、<strong>RUNNING</strong>：-1 &lt;&lt; COUNT_BITS，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；<br>2、<strong>SHUTDOWN</strong>： 0 &lt;&lt; COUNT_BITS，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；<br>3、<strong>STOP</strong> ： 1 &lt;&lt; COUNT_BITS，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；<br>4、<strong>TIDYING</strong> ： 2 &lt;&lt; COUNT_BITS，即高3位为010，该状态表示线程池对线程进行整理优化；<br>5、<strong>TERMINATED</strong>： 3 &lt;&lt; COUNT_BITS，即高3位为011，该状态表示线程池停止工作；</p>\n<h1 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h1><p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；<br>如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果阻塞队列满了，那就创建新的线程执行当前任务；<br>直到线程池中的线程数达到maxPoolSize,这时再有任务来，只能执行reject()处理该任务。</p>\n<h1 id=\"如何合理配置线程池的大小？\"><a href=\"#如何合理配置线程池的大小？\" class=\"headerlink\" title=\"如何合理配置线程池的大小？\"></a>如何合理配置线程池的大小？</h1><p>根据《Java并发编程实战》对于计算密集型的任务，在拥有N个处理器的系统上，当线程池的大小为N+1时，通常能实现最优的效率。(即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费。)</p>\n<p>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 <strong>NCPU+1</strong><br>如果是IO密集型任务（比如数据库数据交互、文件上传下载、网络数据传输等等），参考值可以设置为<strong>2*NCPU</strong><br><em>tips：这行代码可以查看Ncpu<br><code>System.out.println(Runtime.getRuntime().availableProcessors());//输出运行时可用处理器</code></em></p>\n<blockquote>\n<p>参考博文<br><a href=\"https://www.cnblogs.com/dolphin0520/p/3932921.html\" target=\"_blank\" rel=\"noopener\">这篇比较详细，还有源码解读</a><br><a href=\"https://www.cnblogs.com/leipDao/p/8436380.html\" target=\"_blank\" rel=\"noopener\">关于ThreadFactory与BlockingQueue</a></p>\n</blockquote>\n"},{"title":"读源码后把自实现的线程池改成了这样","date":"2019-07-01T14:24:50.000Z","description":"简单实现->读源码->再实现","_content":"\n\n这个标题我取得一股营销号味道hhh，很早之前学习多线程的时候有自己写过一个简易的线程池，最近读了源码发现自己以前写的代码有很多可以改进的地方。我尤其喜欢用迭代的方式去学习——先实现，然后深入学习，最后改进之前实现的，完成一个迭代。因为这种方式更能看到自己的思路的过程，更明白所以然。好了，闲话不多说。开撸。\n\n本文分为三个部分：\n一、如何实现一个简单的线程池？\n二、jdk线程池源码分析\n三、改进自实现的线程池\n\n\n# 一、如何实现一个简单的线程池？\n\n思路分析：线程池其实就是一个生产者消费者模型。\n\n首先我们需要一个**队列**作为任务容器作为存放任务， 还需要**多个线程**去执行任务，** 消费者线程**不断查询任务队列是否有任务，如果没有该线程等待，如果有任务，取出一个任务，唤醒所有在等待获取队列的线程，释放掉锁。执行任务线程的run方法。\n\n分析完毕，在开始写代码之前想想具体做法。\n\n- 任务容器，用LinkedList实现。\n- add方法，用于把任务线程放入任务容器。\n- 构造函数，一次性启动3个 消费者线程。\n- 任务：一个有run方法的线程。\n\n```java\npublic class ThreadPool {\n    // 线程池大小\n    private int corePoolSize;\n    // 任务容器\n    private LinkedList<Runnable> workQueue = new LinkedList<Runnable>();\n    private volatile boolean RUNNING =true;\n    public ThreadPool(int corePoolSize) {\n        //创建时候初始化线程\n        this.corePoolSize = corePoolSize;\n        synchronized (workQueue) {\n            for (int i = 0; i < corePoolSize; i++) {\n                new Worker(\"线程\" + i).start();\n            }\n        }\n    }\n    //将任务线程放入线程池\n    public void execute(Runnable r) {\n        synchronized (workQueue) {\n            workQueue.addLast(r);\n            //放入后唤醒所有wait线程\n            workQueue.notifyAll();\n        }\n    }\n    \n    class Worker extends Thread {\n        Runnable task;\n        public Worker(String name) {\n            super(name);\n        }\n        @Override\n        public void run() {\n            //锁住任务队列，试图取任务，失败则该线程wait\n            while (RUNNING) {\n                synchronized (workQueue) {\n                    while (workQueue.isEmpty()) {\n                        try {\n                            workQueue.wait();\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    task = workQueue.removeLast();\n                    workQueue.notifyAll();\n                }\n                //取到线程即可释放锁\n                System.out.println(this.getName() + \"获得到并且开始执行任务\");\n                task.run();\n            }\n        }\n    }\n}\n```\n\n\n\n```java\npublic class TestThreadPool {\n    public static void main(String[] args) throws InterruptedException {\n        //线程池大小初始化为3\n        ThreadPool threadPool=new ThreadPool(3);\n        //生成10个任务放入线程池\n        for (int i = 0; i < 10; i++) {\n          Runnable task=  new Runnable(){\n                @Override\n                public void run() {\n                    System.out.println(\"做任务中。。。\");\n                }\n            };\n          threadPool.add(task);\n          Thread.sleep(1000);\n        }\n    }\n}\n```\n\n启动TestThreadPool，输出\n\n大功告成。\n\n## 注意\n\nConsumerThread类中这段代码：\n\n```\nsynchronized (tasks) {\n  //试图取任务。。。\n}\n//取到线程即可释放锁\ntask.run();\n\n```\n\n从任务中取任务时候是获取任务队列锁的，但执行任务的时候要先释放锁。如果不释放就去执行，那它执行的过程中其他线程都得等着，**相当于一次只能有一个线程进行任务**。\n\n*2019年06月13号注：最近读书《java开发手册》OOP规约第11条：构造方法里禁止加入任何业务逻辑，如果有初始化逻辑，请放在init中。上面代码违背了这个规约。我这里也不改了，做个反例。再接下来的代码中改进*\n\n\n\n# 二、jdk线程池源码分析\n\n\n\n\n\n## 线程池的重要方法\n\n### execute()接受任务\n\n```java\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n    // 表示 “线程池状态” 和 “线程数” 的整数\n    int c = ctl.get();\n     //分为3种情况\n    // 情况1：如果当前线程数少于corePoolSize，直接新创建一个 worker 线程，并把当前 command 作为这个线程firstTask\n    if (workerCountOf(c) < corePoolSize) {\n        if (addWorker(command, true))\n            // 添加任务成功\n            return;\n          // 返回 false 代表线程池不允许提交任务\n        c = ctl.get();\n    }\n    // 情况2：要么当前线程数大于等于corePoolSize，要么刚刚 addWorker 失败了\n    // 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        //下面这个分支的意图是：担心任务提交到队列中了，但是线程都关闭了\n        // 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略\n        if (! isRunning(recheck) && remove(command))\n            reject(command);\n        // 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程\n        else if (workerCountOf(recheck) == 0)\n            addWorker(null, false);\n    }\n    // 情况3:如果 workQueue 队列满了，以 maximumPoolSize 为界创建新的 worker，\n    else if (!addWorker(command, false))\n         // 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略\n        reject(command);\n}\n```\n\n\n\n解释一下这行代码，  这个方法会返回一个表示 “线程池状态” 和 “线程数” 的整数。\n\n\n\n```java\n//一开始的状态是ctlOf(RUNNING, 0)\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n\n//  COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\n\n// 000 11111111111111111111111111111\n// 这里得到的是 29 个 1，也就是说线程池的最大线程数是 2^29-1=536870911\nprivate static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n// 运算结果为 111跟29个0：111 00000000000000000000000000000\nprivate static final int RUNNING    = -1 << COUNT_BITS;\n// 000 00000000000000000000000000000\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\n// 001 00000000000000000000000000000\nprivate static final int STOP       =  1 << COUNT_BITS;\n// 010 00000000000000000000000000000\nprivate static final int TIDYING    =  2 << COUNT_BITS;\n// 011 00000000000000000000000000000\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n\n// 将整数 c 的低 29 位修改为 0，就得到了线程池的状态\nprivate static int runStateOf(int c)     { return c & ~CAPACITY; }\n// 将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数\nprivate static int workerCountOf(int c)  { return c & CAPACITY; }\n```\n\n线程池的状态\n\n- RUNNING：接受新的任务，处理等待队列中的任务\n- SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务\n- STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程\n- TIDYING：所有的任务都销毁了，workCount 为 0。线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()\n- TERMINATED：terminated() 方法结束后，线程池的状态就会变成这个\n\n重点区分SHUTDOWN和STOP。\n\n在提一下关闭线程池的方法。\n\nshutdown()：设置 线程池的状态 为 SHUTDOWN，然后中断所有没有正在执行任务的线程\n\nshutdownNow()：设置 线程池的状态 为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表\n***使用建议：一般调用shutdown（）关闭线程池；若任务不一定要执行完，则调用shutdownNow（）***\n\n### addWorker()方法：增加工作线程\n\n```java\n// 参数一：第一个任务。参数二：是否使用核心线程数 corePoolSize 作为创建线程的界限\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    //打破多重循环的关键字retry\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        //下面代码的意图：担心创建线程的时候，线程池已经关闭了\n        // 如满足以下条件之一，那么不创建新的 worker：\n        // 1. 线程池状态大于 SHUTDOWN，其实也就是 STOP, TIDYING, 或 TERMINATED\n        // 2. firstTask != null\n        // 3. workQueue.isEmpty()\n        //  SHUTDOWN 的语义：不允许提交新的任务，但是要把已经进入到 workQueue 的任务执行完，所以在满足条件的基础上，是允许创建新的 Worker 的\n        if (rs >= SHUTDOWN &&\n            ! (rs == SHUTDOWN &&\n               firstTask == null &&\n               ! workQueue.isEmpty()))\n            return false;\n\n        for (;;) {\n            int wc = workerCountOf(c);\n            if (wc >= CAPACITY ||\n                wc >= (core ? corePoolSize : maximumPoolSize))\n                return false;\n            // 如果成功，那么就是所有创建线程前的条件校验都满足了，准备创建线程执行任务了\n            // 这里失败的话，说明有其他线程也在尝试往线程池中创建线程\n            if (compareAndIncrementWorkerCount(c))\n                //跳出多重循环\n                break retry;\n            // 由于有并发，重新再读取一下 ctl\n            c = ctl.get();\n            // 正常如果是 CAS 失败的话，进到下一个里层的for循环就可以了\n            // 可是如果是因为其他线程导致线程池的状态发生了变更，比如有其他线程关闭了这个线程池\n            // 那么需要回到外层的for循环\n            if (runStateOf(c) != rs)\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n\n    /*\n     * 啊终于可以开始创建线程了\n     */\n\n    // worker 是否已经启动\n    boolean workerStarted = false;\n    // 是否已将这个 worker 添加到 workers 这个 HashSet 中\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        final ReentrantLock mainLock = this.mainLock;\n        // 把 firstTask 传给 worker 的构造方法\n        w = new Worker(firstTask);\n        // 取 worker 中的线程对象，Worker的构造方法会调用 ThreadFactory 来创建一个新的线程\n        final Thread t = w.thread;\n        if (t != null) {\n            // 这个是整个线程池的全局锁，持有这个锁才能让下面的操作“顺理成章”，\n            // 因为关闭一个线程池需要这个锁，至少我持有锁的期间，线程池不会被关闭\n            mainLock.lock();\n            try {\n\n                int c = ctl.get();\n                int rs = runStateOf(c);\n\n                // 小于 SHUTTDOWN 那就是 RUNNING\n                // 如果等于 SHUTDOWN，不接受新的任务，但是会继续执行等待队列中的任务\n                if (rs < SHUTDOWN ||\n                    (rs == SHUTDOWN && firstTask == null)) {\n                    // worker 里面的 thread 可不能是已经启动的\n                    if (t.isAlive())\n                        throw new IllegalThreadStateException();\n                    // 加到 workers 这个 HashSet 中\n                    workers.add(w);\n                    int s = workers.size();\n                    // largestPoolSize 用于记录 workers 中的个数的最大值\n                    // 因为 workers 是不断增加减少的，通过这个值可以知道线程池的大小曾经达到的最大值\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            // 添加成功的话，启动这个线程\n            if (workerAdded) {\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        // 如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    // 返回线程是否启动成功\n    return workerStarted;\n}\n```\n\n## 总结\n\n### 线程池的线程创建时机\n\n- 线程池是**懒加载**的，声明的时候并不会创建好线程等待任务，而是当提交第一个任务时才去新建线程；\n- 当提交一个任务时，如果当前线程数**小于corePoolSize**，就直接创建一个新线程执行任务；\n- 如果当前线程数**大于corePoolSize**，继续提交的任务被保存到**阻塞队列中**，等待被执行；\n- 如果阻塞队列满了，并且当前线程数**小于maxPoolSize**，那就创建新的线程执行当前任务；\n- 如果池里的线程数**大于maxPoolSize**,这时再有任务来，只能调用**拒绝策略**。\n\n### 工厂模式\n\n从线程池的创建讲起，线程池有两种创建方式。\n\n一是`ThreadPoolExecutor threadPool= new ThreadPoolExecutor(10, 15, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());`\n\n二是`executorService= Executors.newFixedThreadPool(3);`\n\n第二钟方式用到了**工厂模式**，点进方法newFixedThreadPool(3)去看是返回一个定义好初始化的参数线程池实例，代码如下：\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n  return new ThreadPoolExecutor(nThreads, nThreads,0L,\n            TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());}\n\n```\n\n第二种方法最终还是会导向方法一ThreadPoolExecutor的构造方法ThreadPoolExecutor\n\n```java\n   public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n       ...\n    }\n```\n\n 工厂模式的好处是：\n\n- 用户只要知道名字就行了，比如我想创建一个固定长度的线程池，只需要调用newFixedThreadPool（）方法，而不需要在了解ThreadPoolExecutor构造函数之后自己new一个配置一堆参数。**不需要关注太多细节。**\n- 用工厂模式可以**消除循环依赖**，如果一个类构造函数的参数变了，所有实例化这个类的代码都得改。\n\n\n\n### 阻塞队列\n\n上一篇我是用synchronized锁住任务队列，工作线程wait和notify去实现线程阻塞去任务队列去任务，jdk是用**LinkedBlockingQueue的put和take**方法来实现。如果put或者take操作无法立即执行，这两个方法调用将会发生**阻塞**，直到能够执行。\n\n|          | *抛出异常*  | *特殊值*   | *阻塞*   |         *超时*         |\n| -------- | ----------- | ---------- | -------- | :--------------------: |\n| **插入** | `add(e)`    | `offer(e)` | `put(e)` | `offer(e, time, unit)` |\n| **移除** | `remove()`  | `poll()`   | `take()` |   `poll(time, unit)`   |\n| **检查** | `element()` | `peek()`   | *不可用* |        *不可用*        |\n\n\n\n\n\n### 延迟加载Lazy_load\n\n线程池是**懒加载**的，声明的时候并不会创建好线程等待任务，而是当提交第一个任务时才去新建线程；\n\n# 三、改进自实现的线程池\n\n改进\n\n1.实现延迟加载。我们是在构造函数创建线程，而java线程池只有当提交一个任务时，线程池才会创建一个新线程执行任务，直到当前线程数等于corePoolSize。这样会更节约资源。\n\n2.这里我们用LinkedList加线程wait（）notify（）来实现，也可以像java线程池一样用阻塞链表LinkedBlockingQueue来实现。\n\n```java\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\npublic class ThreadPool {\n    //工作线程数\n    private int workerCount;\n    // 线程池大小\n    private int corePoolSize;\n    // 任务容器\n    private BlockingQueue<Runnable> workQueue;\n    //工作线程容器\n    private Set<Worker> workers;\n    // 任务容器\n\n    private static ThreadPool threadPool;\n\n    public static ThreadPool newThreadPool() {\n        threadPool = new ThreadPool(3);\n        return threadPool;\n    }\n\n    private ThreadPool(int corePoolSize) {\n        this.corePoolSize = corePoolSize;\n        //LinkedBlockingQueue的默认容量是Integer.MAX_VALUE，一直加任务线程可能会造成OOM内存溢出\n        workQueue = new LinkedBlockingQueue<>(1024);//这里指定大小\n        workers = new HashSet<>();\n    }\n\n    public void execute(Runnable r) {\n        if (workerCount < corePoolSize) {\n            addWorker(r);\n        } else {\n            try {\n                workQueue.put(r);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void addWorker(Runnable r) {\n        workerCount++;\n        Worker worker = new Worker(r);\n        Thread t = worker.thread;\n        workers.add(worker);\n        t.start();\n    }\n\n    class Worker implements Runnable {\n        Runnable task;\n        Thread thread;\n\n        public Worker(Runnable task) {\n            this.task = task;\n            this.thread = new Thread(this);\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                Runnable task = this.task;\n                // 执行当前的任务，所以把这个任务置空，以免造成死循环\n                this.task = null;\n                if (task != null || (task = getTask()) != null) {\n                    task.run();\n                }\n            }\n        }\n    }\n\n    private Runnable getTask() {\n        Runnable r = null;\n        try {\n            r = workQueue.take();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return r;\n    }\n}\n```\n\n```java\npublic class TestThreadPool {\n    public static void main(String[] args) throws InterruptedException {\n\n        ThreadPool threadPool=ThreadPool.newThreadPool();\n        //生成10个任务放入线程池\n        for (int i = 0; i < 10; i++) {\n            Runnable task=  new Runnable(){\n                @Override\n                public void run() {\n                    System.out.println(\"做任务中。。。\");\n                }\n            };\n            threadPool.execute(task);\n            Thread.sleep(1000);\n        }\n    }\n}\n```\n\n\n\n参考\n\n> [模式方面菜鸟教程写的不错](https://www.runoob.com/design-pattern/factory-pattern.html)\n>\n> [Java高并发之BlockingQueue](https://blog.csdn.net/qq_42135428/article/details/80285737)\n>\n> https://blog.csdn.net/GitHub_boy/article/details/51046574","source":"_posts/自实现线程池（下）.md","raw":"---\ntitle: 读源码后把自实现的线程池改成了这样\ndate: 2019-07-01 22:24:50\ncategories: 并发\ndescription: 简单实现->读源码->再实现\n---\n\n\n这个标题我取得一股营销号味道hhh，很早之前学习多线程的时候有自己写过一个简易的线程池，最近读了源码发现自己以前写的代码有很多可以改进的地方。我尤其喜欢用迭代的方式去学习——先实现，然后深入学习，最后改进之前实现的，完成一个迭代。因为这种方式更能看到自己的思路的过程，更明白所以然。好了，闲话不多说。开撸。\n\n本文分为三个部分：\n一、如何实现一个简单的线程池？\n二、jdk线程池源码分析\n三、改进自实现的线程池\n\n\n# 一、如何实现一个简单的线程池？\n\n思路分析：线程池其实就是一个生产者消费者模型。\n\n首先我们需要一个**队列**作为任务容器作为存放任务， 还需要**多个线程**去执行任务，** 消费者线程**不断查询任务队列是否有任务，如果没有该线程等待，如果有任务，取出一个任务，唤醒所有在等待获取队列的线程，释放掉锁。执行任务线程的run方法。\n\n分析完毕，在开始写代码之前想想具体做法。\n\n- 任务容器，用LinkedList实现。\n- add方法，用于把任务线程放入任务容器。\n- 构造函数，一次性启动3个 消费者线程。\n- 任务：一个有run方法的线程。\n\n```java\npublic class ThreadPool {\n    // 线程池大小\n    private int corePoolSize;\n    // 任务容器\n    private LinkedList<Runnable> workQueue = new LinkedList<Runnable>();\n    private volatile boolean RUNNING =true;\n    public ThreadPool(int corePoolSize) {\n        //创建时候初始化线程\n        this.corePoolSize = corePoolSize;\n        synchronized (workQueue) {\n            for (int i = 0; i < corePoolSize; i++) {\n                new Worker(\"线程\" + i).start();\n            }\n        }\n    }\n    //将任务线程放入线程池\n    public void execute(Runnable r) {\n        synchronized (workQueue) {\n            workQueue.addLast(r);\n            //放入后唤醒所有wait线程\n            workQueue.notifyAll();\n        }\n    }\n    \n    class Worker extends Thread {\n        Runnable task;\n        public Worker(String name) {\n            super(name);\n        }\n        @Override\n        public void run() {\n            //锁住任务队列，试图取任务，失败则该线程wait\n            while (RUNNING) {\n                synchronized (workQueue) {\n                    while (workQueue.isEmpty()) {\n                        try {\n                            workQueue.wait();\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    task = workQueue.removeLast();\n                    workQueue.notifyAll();\n                }\n                //取到线程即可释放锁\n                System.out.println(this.getName() + \"获得到并且开始执行任务\");\n                task.run();\n            }\n        }\n    }\n}\n```\n\n\n\n```java\npublic class TestThreadPool {\n    public static void main(String[] args) throws InterruptedException {\n        //线程池大小初始化为3\n        ThreadPool threadPool=new ThreadPool(3);\n        //生成10个任务放入线程池\n        for (int i = 0; i < 10; i++) {\n          Runnable task=  new Runnable(){\n                @Override\n                public void run() {\n                    System.out.println(\"做任务中。。。\");\n                }\n            };\n          threadPool.add(task);\n          Thread.sleep(1000);\n        }\n    }\n}\n```\n\n启动TestThreadPool，输出\n\n大功告成。\n\n## 注意\n\nConsumerThread类中这段代码：\n\n```\nsynchronized (tasks) {\n  //试图取任务。。。\n}\n//取到线程即可释放锁\ntask.run();\n\n```\n\n从任务中取任务时候是获取任务队列锁的，但执行任务的时候要先释放锁。如果不释放就去执行，那它执行的过程中其他线程都得等着，**相当于一次只能有一个线程进行任务**。\n\n*2019年06月13号注：最近读书《java开发手册》OOP规约第11条：构造方法里禁止加入任何业务逻辑，如果有初始化逻辑，请放在init中。上面代码违背了这个规约。我这里也不改了，做个反例。再接下来的代码中改进*\n\n\n\n# 二、jdk线程池源码分析\n\n\n\n\n\n## 线程池的重要方法\n\n### execute()接受任务\n\n```java\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n    // 表示 “线程池状态” 和 “线程数” 的整数\n    int c = ctl.get();\n     //分为3种情况\n    // 情况1：如果当前线程数少于corePoolSize，直接新创建一个 worker 线程，并把当前 command 作为这个线程firstTask\n    if (workerCountOf(c) < corePoolSize) {\n        if (addWorker(command, true))\n            // 添加任务成功\n            return;\n          // 返回 false 代表线程池不允许提交任务\n        c = ctl.get();\n    }\n    // 情况2：要么当前线程数大于等于corePoolSize，要么刚刚 addWorker 失败了\n    // 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        //下面这个分支的意图是：担心任务提交到队列中了，但是线程都关闭了\n        // 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略\n        if (! isRunning(recheck) && remove(command))\n            reject(command);\n        // 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程\n        else if (workerCountOf(recheck) == 0)\n            addWorker(null, false);\n    }\n    // 情况3:如果 workQueue 队列满了，以 maximumPoolSize 为界创建新的 worker，\n    else if (!addWorker(command, false))\n         // 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略\n        reject(command);\n}\n```\n\n\n\n解释一下这行代码，  这个方法会返回一个表示 “线程池状态” 和 “线程数” 的整数。\n\n\n\n```java\n//一开始的状态是ctlOf(RUNNING, 0)\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n\n//  COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\n\n// 000 11111111111111111111111111111\n// 这里得到的是 29 个 1，也就是说线程池的最大线程数是 2^29-1=536870911\nprivate static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n// 运算结果为 111跟29个0：111 00000000000000000000000000000\nprivate static final int RUNNING    = -1 << COUNT_BITS;\n// 000 00000000000000000000000000000\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\n// 001 00000000000000000000000000000\nprivate static final int STOP       =  1 << COUNT_BITS;\n// 010 00000000000000000000000000000\nprivate static final int TIDYING    =  2 << COUNT_BITS;\n// 011 00000000000000000000000000000\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n\n// 将整数 c 的低 29 位修改为 0，就得到了线程池的状态\nprivate static int runStateOf(int c)     { return c & ~CAPACITY; }\n// 将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数\nprivate static int workerCountOf(int c)  { return c & CAPACITY; }\n```\n\n线程池的状态\n\n- RUNNING：接受新的任务，处理等待队列中的任务\n- SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务\n- STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程\n- TIDYING：所有的任务都销毁了，workCount 为 0。线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()\n- TERMINATED：terminated() 方法结束后，线程池的状态就会变成这个\n\n重点区分SHUTDOWN和STOP。\n\n在提一下关闭线程池的方法。\n\nshutdown()：设置 线程池的状态 为 SHUTDOWN，然后中断所有没有正在执行任务的线程\n\nshutdownNow()：设置 线程池的状态 为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表\n***使用建议：一般调用shutdown（）关闭线程池；若任务不一定要执行完，则调用shutdownNow（）***\n\n### addWorker()方法：增加工作线程\n\n```java\n// 参数一：第一个任务。参数二：是否使用核心线程数 corePoolSize 作为创建线程的界限\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    //打破多重循环的关键字retry\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        //下面代码的意图：担心创建线程的时候，线程池已经关闭了\n        // 如满足以下条件之一，那么不创建新的 worker：\n        // 1. 线程池状态大于 SHUTDOWN，其实也就是 STOP, TIDYING, 或 TERMINATED\n        // 2. firstTask != null\n        // 3. workQueue.isEmpty()\n        //  SHUTDOWN 的语义：不允许提交新的任务，但是要把已经进入到 workQueue 的任务执行完，所以在满足条件的基础上，是允许创建新的 Worker 的\n        if (rs >= SHUTDOWN &&\n            ! (rs == SHUTDOWN &&\n               firstTask == null &&\n               ! workQueue.isEmpty()))\n            return false;\n\n        for (;;) {\n            int wc = workerCountOf(c);\n            if (wc >= CAPACITY ||\n                wc >= (core ? corePoolSize : maximumPoolSize))\n                return false;\n            // 如果成功，那么就是所有创建线程前的条件校验都满足了，准备创建线程执行任务了\n            // 这里失败的话，说明有其他线程也在尝试往线程池中创建线程\n            if (compareAndIncrementWorkerCount(c))\n                //跳出多重循环\n                break retry;\n            // 由于有并发，重新再读取一下 ctl\n            c = ctl.get();\n            // 正常如果是 CAS 失败的话，进到下一个里层的for循环就可以了\n            // 可是如果是因为其他线程导致线程池的状态发生了变更，比如有其他线程关闭了这个线程池\n            // 那么需要回到外层的for循环\n            if (runStateOf(c) != rs)\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n\n    /*\n     * 啊终于可以开始创建线程了\n     */\n\n    // worker 是否已经启动\n    boolean workerStarted = false;\n    // 是否已将这个 worker 添加到 workers 这个 HashSet 中\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        final ReentrantLock mainLock = this.mainLock;\n        // 把 firstTask 传给 worker 的构造方法\n        w = new Worker(firstTask);\n        // 取 worker 中的线程对象，Worker的构造方法会调用 ThreadFactory 来创建一个新的线程\n        final Thread t = w.thread;\n        if (t != null) {\n            // 这个是整个线程池的全局锁，持有这个锁才能让下面的操作“顺理成章”，\n            // 因为关闭一个线程池需要这个锁，至少我持有锁的期间，线程池不会被关闭\n            mainLock.lock();\n            try {\n\n                int c = ctl.get();\n                int rs = runStateOf(c);\n\n                // 小于 SHUTTDOWN 那就是 RUNNING\n                // 如果等于 SHUTDOWN，不接受新的任务，但是会继续执行等待队列中的任务\n                if (rs < SHUTDOWN ||\n                    (rs == SHUTDOWN && firstTask == null)) {\n                    // worker 里面的 thread 可不能是已经启动的\n                    if (t.isAlive())\n                        throw new IllegalThreadStateException();\n                    // 加到 workers 这个 HashSet 中\n                    workers.add(w);\n                    int s = workers.size();\n                    // largestPoolSize 用于记录 workers 中的个数的最大值\n                    // 因为 workers 是不断增加减少的，通过这个值可以知道线程池的大小曾经达到的最大值\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            // 添加成功的话，启动这个线程\n            if (workerAdded) {\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        // 如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    // 返回线程是否启动成功\n    return workerStarted;\n}\n```\n\n## 总结\n\n### 线程池的线程创建时机\n\n- 线程池是**懒加载**的，声明的时候并不会创建好线程等待任务，而是当提交第一个任务时才去新建线程；\n- 当提交一个任务时，如果当前线程数**小于corePoolSize**，就直接创建一个新线程执行任务；\n- 如果当前线程数**大于corePoolSize**，继续提交的任务被保存到**阻塞队列中**，等待被执行；\n- 如果阻塞队列满了，并且当前线程数**小于maxPoolSize**，那就创建新的线程执行当前任务；\n- 如果池里的线程数**大于maxPoolSize**,这时再有任务来，只能调用**拒绝策略**。\n\n### 工厂模式\n\n从线程池的创建讲起，线程池有两种创建方式。\n\n一是`ThreadPoolExecutor threadPool= new ThreadPoolExecutor(10, 15, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());`\n\n二是`executorService= Executors.newFixedThreadPool(3);`\n\n第二钟方式用到了**工厂模式**，点进方法newFixedThreadPool(3)去看是返回一个定义好初始化的参数线程池实例，代码如下：\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n  return new ThreadPoolExecutor(nThreads, nThreads,0L,\n            TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());}\n\n```\n\n第二种方法最终还是会导向方法一ThreadPoolExecutor的构造方法ThreadPoolExecutor\n\n```java\n   public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n       ...\n    }\n```\n\n 工厂模式的好处是：\n\n- 用户只要知道名字就行了，比如我想创建一个固定长度的线程池，只需要调用newFixedThreadPool（）方法，而不需要在了解ThreadPoolExecutor构造函数之后自己new一个配置一堆参数。**不需要关注太多细节。**\n- 用工厂模式可以**消除循环依赖**，如果一个类构造函数的参数变了，所有实例化这个类的代码都得改。\n\n\n\n### 阻塞队列\n\n上一篇我是用synchronized锁住任务队列，工作线程wait和notify去实现线程阻塞去任务队列去任务，jdk是用**LinkedBlockingQueue的put和take**方法来实现。如果put或者take操作无法立即执行，这两个方法调用将会发生**阻塞**，直到能够执行。\n\n|          | *抛出异常*  | *特殊值*   | *阻塞*   |         *超时*         |\n| -------- | ----------- | ---------- | -------- | :--------------------: |\n| **插入** | `add(e)`    | `offer(e)` | `put(e)` | `offer(e, time, unit)` |\n| **移除** | `remove()`  | `poll()`   | `take()` |   `poll(time, unit)`   |\n| **检查** | `element()` | `peek()`   | *不可用* |        *不可用*        |\n\n\n\n\n\n### 延迟加载Lazy_load\n\n线程池是**懒加载**的，声明的时候并不会创建好线程等待任务，而是当提交第一个任务时才去新建线程；\n\n# 三、改进自实现的线程池\n\n改进\n\n1.实现延迟加载。我们是在构造函数创建线程，而java线程池只有当提交一个任务时，线程池才会创建一个新线程执行任务，直到当前线程数等于corePoolSize。这样会更节约资源。\n\n2.这里我们用LinkedList加线程wait（）notify（）来实现，也可以像java线程池一样用阻塞链表LinkedBlockingQueue来实现。\n\n```java\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\npublic class ThreadPool {\n    //工作线程数\n    private int workerCount;\n    // 线程池大小\n    private int corePoolSize;\n    // 任务容器\n    private BlockingQueue<Runnable> workQueue;\n    //工作线程容器\n    private Set<Worker> workers;\n    // 任务容器\n\n    private static ThreadPool threadPool;\n\n    public static ThreadPool newThreadPool() {\n        threadPool = new ThreadPool(3);\n        return threadPool;\n    }\n\n    private ThreadPool(int corePoolSize) {\n        this.corePoolSize = corePoolSize;\n        //LinkedBlockingQueue的默认容量是Integer.MAX_VALUE，一直加任务线程可能会造成OOM内存溢出\n        workQueue = new LinkedBlockingQueue<>(1024);//这里指定大小\n        workers = new HashSet<>();\n    }\n\n    public void execute(Runnable r) {\n        if (workerCount < corePoolSize) {\n            addWorker(r);\n        } else {\n            try {\n                workQueue.put(r);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void addWorker(Runnable r) {\n        workerCount++;\n        Worker worker = new Worker(r);\n        Thread t = worker.thread;\n        workers.add(worker);\n        t.start();\n    }\n\n    class Worker implements Runnable {\n        Runnable task;\n        Thread thread;\n\n        public Worker(Runnable task) {\n            this.task = task;\n            this.thread = new Thread(this);\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                Runnable task = this.task;\n                // 执行当前的任务，所以把这个任务置空，以免造成死循环\n                this.task = null;\n                if (task != null || (task = getTask()) != null) {\n                    task.run();\n                }\n            }\n        }\n    }\n\n    private Runnable getTask() {\n        Runnable r = null;\n        try {\n            r = workQueue.take();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return r;\n    }\n}\n```\n\n```java\npublic class TestThreadPool {\n    public static void main(String[] args) throws InterruptedException {\n\n        ThreadPool threadPool=ThreadPool.newThreadPool();\n        //生成10个任务放入线程池\n        for (int i = 0; i < 10; i++) {\n            Runnable task=  new Runnable(){\n                @Override\n                public void run() {\n                    System.out.println(\"做任务中。。。\");\n                }\n            };\n            threadPool.execute(task);\n            Thread.sleep(1000);\n        }\n    }\n}\n```\n\n\n\n参考\n\n> [模式方面菜鸟教程写的不错](https://www.runoob.com/design-pattern/factory-pattern.html)\n>\n> [Java高并发之BlockingQueue](https://blog.csdn.net/qq_42135428/article/details/80285737)\n>\n> https://blog.csdn.net/GitHub_boy/article/details/51046574","slug":"自实现线程池（下）","published":1,"updated":"2022-02-08T07:09:41.229Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qkr001tw9rpwnoo8eiw","content":"<p>这个标题我取得一股营销号味道hhh，很早之前学习多线程的时候有自己写过一个简易的线程池，最近读了源码发现自己以前写的代码有很多可以改进的地方。我尤其喜欢用迭代的方式去学习——先实现，然后深入学习，最后改进之前实现的，完成一个迭代。因为这种方式更能看到自己的思路的过程，更明白所以然。好了，闲话不多说。开撸。</p>\n<p>本文分为三个部分：<br>一、如何实现一个简单的线程池？<br>二、jdk线程池源码分析<br>三、改进自实现的线程池</p>\n<h1 id=\"一、如何实现一个简单的线程池？\"><a href=\"#一、如何实现一个简单的线程池？\" class=\"headerlink\" title=\"一、如何实现一个简单的线程池？\"></a>一、如何实现一个简单的线程池？</h1><p>思路分析：线程池其实就是一个生产者消费者模型。</p>\n<p>首先我们需要一个<strong>队列</strong>作为任务容器作为存放任务， 还需要<strong>多个线程</strong>去执行任务，<strong> 消费者线程</strong>不断查询任务队列是否有任务，如果没有该线程等待，如果有任务，取出一个任务，唤醒所有在等待获取队列的线程，释放掉锁。执行任务线程的run方法。</p>\n<p>分析完毕，在开始写代码之前想想具体做法。</p>\n<ul>\n<li>任务容器，用LinkedList实现。</li>\n<li>add方法，用于把任务线程放入任务容器。</li>\n<li>构造函数，一次性启动3个 消费者线程。</li>\n<li>任务：一个有run方法的线程。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadPool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 线程池大小</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> corePoolSize;</span><br><span class=\"line\">    <span class=\"comment\">// 任务容器</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedList&lt;Runnable&gt; workQueue = <span class=\"keyword\">new</span> LinkedList&lt;Runnable&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> RUNNING =<span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建时候初始化线程</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (workQueue) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; corePoolSize; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">new</span> Worker(<span class=\"string\">\"线程\"</span> + i).start();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将任务线程放入线程池</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (workQueue) &#123;</span><br><span class=\"line\">            workQueue.addLast(r);</span><br><span class=\"line\">            <span class=\"comment\">//放入后唤醒所有wait线程</span></span><br><span class=\"line\">            workQueue.notifyAll();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        Runnable task;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Worker</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//锁住任务队列，试图取任务，失败则该线程wait</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (RUNNING) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (workQueue) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (workQueue.isEmpty()) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            workQueue.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    task = workQueue.removeLast();</span><br><span class=\"line\">                    workQueue.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//取到线程即可释放锁</span></span><br><span class=\"line\">                System.out.println(<span class=\"keyword\">this</span>.getName() + <span class=\"string\">\"获得到并且开始执行任务\"</span>);</span><br><span class=\"line\">                task.run();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestThreadPool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//线程池大小初始化为3</span></span><br><span class=\"line\">        ThreadPool threadPool=<span class=\"keyword\">new</span> ThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"comment\">//生成10个任务放入线程池</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">          Runnable task=  <span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"做任务中。。。\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">          threadPool.add(task);</span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动TestThreadPool，输出</p>\n<p>大功告成。</p>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><p>ConsumerThread类中这段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized (tasks) &#123;</span><br><span class=\"line\">  //试图取任务。。。</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//取到线程即可释放锁</span><br><span class=\"line\">task.run();</span><br></pre></td></tr></table></figure>\n<p>从任务中取任务时候是获取任务队列锁的，但执行任务的时候要先释放锁。如果不释放就去执行，那它执行的过程中其他线程都得等着，<strong>相当于一次只能有一个线程进行任务</strong>。</p>\n<p><em>2019年06月13号注：最近读书《java开发手册》OOP规约第11条：构造方法里禁止加入任何业务逻辑，如果有初始化逻辑，请放在init中。上面代码违背了这个规约。我这里也不改了，做个反例。再接下来的代码中改进</em></p>\n<h1 id=\"二、jdk线程池源码分析\"><a href=\"#二、jdk线程池源码分析\" class=\"headerlink\" title=\"二、jdk线程池源码分析\"></a>二、jdk线程池源码分析</h1><h2 id=\"线程池的重要方法\"><a href=\"#线程池的重要方法\" class=\"headerlink\" title=\"线程池的重要方法\"></a>线程池的重要方法</h2><h3 id=\"execute-接受任务\"><a href=\"#execute-接受任务\" class=\"headerlink\" title=\"execute()接受任务\"></a>execute()接受任务</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"comment\">// 表示 “线程池状态” 和 “线程数” 的整数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">     <span class=\"comment\">//分为3种情况</span></span><br><span class=\"line\">    <span class=\"comment\">// 情况1：如果当前线程数少于corePoolSize，直接新创建一个 worker 线程，并把当前 command 作为这个线程firstTask</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">            <span class=\"comment\">// 添加任务成功</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">          <span class=\"comment\">// 返回 false 代表线程池不允许提交任务</span></span><br><span class=\"line\">        c = ctl.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 情况2：要么当前线程数大于等于corePoolSize，要么刚刚 addWorker 失败了</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">        <span class=\"comment\">//下面这个分支的意图是：担心任务提交到队列中了，但是线程都关闭了</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">            reject(command);</span><br><span class=\"line\">        <span class=\"comment\">// 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 情况3:如果 workQueue 队列满了，以 maximumPoolSize 为界创建新的 worker，</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">         <span class=\"comment\">// 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span></span><br><span class=\"line\">        reject(command);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释一下这行代码，  这个方法会返回一个表示 “线程池状态” 和 “线程数” 的整数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//一开始的状态是ctlOf(RUNNING, 0)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger ctl = <span class=\"keyword\">new</span> AtomicInteger(ctlOf(RUNNING, <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> COUNT_BITS = Integer.SIZE - <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 000 11111111111111111111111111111</span></span><br><span class=\"line\"><span class=\"comment\">// 这里得到的是 29 个 1，也就是说线程池的最大线程数是 2^29-1=536870911</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CAPACITY   = (<span class=\"number\">1</span> &lt;&lt; COUNT_BITS) - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运算结果为 111跟29个0：111 00000000000000000000000000000</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RUNNING    = -<span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"comment\">// 000 00000000000000000000000000000</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHUTDOWN   =  <span class=\"number\">0</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"comment\">// 001 00000000000000000000000000000</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> STOP       =  <span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"comment\">// 010 00000000000000000000000000000</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TIDYING    =  <span class=\"number\">2</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"comment\">// 011 00000000000000000000000000000</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TERMINATED =  <span class=\"number\">3</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将整数 c 的低 29 位修改为 0，就得到了线程池的状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">runStateOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>     </span>&#123; <span class=\"keyword\">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class=\"line\"><span class=\"comment\">// 将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">workerCountOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>  </span>&#123; <span class=\"keyword\">return</span> c &amp; CAPACITY; &#125;</span><br></pre></td></tr></table></figure>\n<p>线程池的状态</p>\n<ul>\n<li>RUNNING：接受新的任务，处理等待队列中的任务</li>\n<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务</li>\n<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</li>\n<li>TIDYING：所有的任务都销毁了，workCount 为 0。线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()</li>\n<li>TERMINATED：terminated() 方法结束后，线程池的状态就会变成这个</li>\n</ul>\n<p>重点区分SHUTDOWN和STOP。</p>\n<p>在提一下关闭线程池的方法。</p>\n<p>shutdown()：设置 线程池的状态 为 SHUTDOWN，然后中断所有没有正在执行任务的线程</p>\n<p>shutdownNow()：设置 线程池的状态 为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表<br><strong><em>使用建议：一般调用shutdown（）关闭线程池；若任务不一定要执行完，则调用shutdownNow（）</em></strong></p>\n<h3 id=\"addWorker-方法：增加工作线程\"><a href=\"#addWorker-方法：增加工作线程\" class=\"headerlink\" title=\"addWorker()方法：增加工作线程\"></a>addWorker()方法：增加工作线程</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参数一：第一个任务。参数二：是否使用核心线程数 corePoolSize 作为创建线程的界限</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//打破多重循环的关键字retry</span></span><br><span class=\"line\">    retry:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//下面代码的意图：担心创建线程的时候，线程池已经关闭了</span></span><br><span class=\"line\">        <span class=\"comment\">// 如满足以下条件之一，那么不创建新的 worker：</span></span><br><span class=\"line\">        <span class=\"comment\">// 1. 线程池状态大于 SHUTDOWN，其实也就是 STOP, TIDYING, 或 TERMINATED</span></span><br><span class=\"line\">        <span class=\"comment\">// 2. firstTask != null</span></span><br><span class=\"line\">        <span class=\"comment\">// 3. workQueue.isEmpty()</span></span><br><span class=\"line\">        <span class=\"comment\">//  SHUTDOWN 的语义：不允许提交新的任务，但是要把已经进入到 workQueue 的任务执行完，所以在满足条件的基础上，是允许创建新的 Worker 的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class=\"line\">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class=\"line\">               firstTask == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">               ! workQueue.isEmpty()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</span><br><span class=\"line\">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 如果成功，那么就是所有创建线程前的条件校验都满足了，准备创建线程执行任务了</span></span><br><span class=\"line\">            <span class=\"comment\">// 这里失败的话，说明有其他线程也在尝试往线程池中创建线程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"comment\">//跳出多重循环</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">            <span class=\"comment\">// 由于有并发，重新再读取一下 ctl</span></span><br><span class=\"line\">            c = ctl.get();</span><br><span class=\"line\">            <span class=\"comment\">// 正常如果是 CAS 失败的话，进到下一个里层的for循环就可以了</span></span><br><span class=\"line\">            <span class=\"comment\">// 可是如果是因为其他线程导致线程池的状态发生了变更，比如有其他线程关闭了这个线程池</span></span><br><span class=\"line\">            <span class=\"comment\">// 那么需要回到外层的for循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">            <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 啊终于可以开始创建线程了</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// worker 是否已经启动</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 是否已将这个 worker 添加到 workers 这个 HashSet 中</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">        <span class=\"comment\">// 把 firstTask 传给 worker 的构造方法</span></span><br><span class=\"line\">        w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">        <span class=\"comment\">// 取 worker 中的线程对象，Worker的构造方法会调用 ThreadFactory 来创建一个新的线程</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这个是整个线程池的全局锁，持有这个锁才能让下面的操作“顺理成章”，</span></span><br><span class=\"line\">            <span class=\"comment\">// 因为关闭一个线程池需要这个锁，至少我持有锁的期间，线程池不会被关闭</span></span><br><span class=\"line\">            mainLock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">                <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 小于 SHUTTDOWN 那就是 RUNNING</span></span><br><span class=\"line\">                <span class=\"comment\">// 如果等于 SHUTDOWN，不接受新的任务，但是会继续执行等待队列中的任务</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||</span><br><span class=\"line\">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// worker 里面的 thread 可不能是已经启动的</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t.isAlive())</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                    <span class=\"comment\">// 加到 workers 这个 HashSet 中</span></span><br><span class=\"line\">                    workers.add(w);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                    <span class=\"comment\">// largestPoolSize 用于记录 workers 中的个数的最大值</span></span><br><span class=\"line\">                    <span class=\"comment\">// 因为 workers 是不断增加减少的，通过这个值可以知道线程池的大小曾经达到的最大值</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                        largestPoolSize = s;</span><br><span class=\"line\">                    workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                mainLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 添加成功的话，启动这个线程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">                t.start();</span><br><span class=\"line\">                workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">            addWorkerFailed(w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回线程是否启动成功</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"线程池的线程创建时机\"><a href=\"#线程池的线程创建时机\" class=\"headerlink\" title=\"线程池的线程创建时机\"></a>线程池的线程创建时机</h3><ul>\n<li>线程池是<strong>懒加载</strong>的，声明的时候并不会创建好线程等待任务，而是当提交第一个任务时才去新建线程；</li>\n<li>当提交一个任务时，如果当前线程数<strong>小于corePoolSize</strong>，就直接创建一个新线程执行任务；</li>\n<li>如果当前线程数<strong>大于corePoolSize</strong>，继续提交的任务被保存到<strong>阻塞队列中</strong>，等待被执行；</li>\n<li>如果阻塞队列满了，并且当前线程数<strong>小于maxPoolSize</strong>，那就创建新的线程执行当前任务；</li>\n<li>如果池里的线程数<strong>大于maxPoolSize</strong>,这时再有任务来，只能调用<strong>拒绝策略</strong>。</li>\n</ul>\n<h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><p>从线程池的创建讲起，线程池有两种创建方式。</p>\n<p>一是<code>ThreadPoolExecutor threadPool= new ThreadPoolExecutor(10, 15, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());</code></p>\n<p>二是<code>executorService= Executors.newFixedThreadPool(3);</code></p>\n<p>第二钟方式用到了<strong>工厂模式</strong>，点进方法newFixedThreadPool(3)去看是返回一个定义好初始化的参数线程池实例，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads,<span class=\"number\">0L</span>,</span><br><span class=\"line\">            TimeUnit.MILLISECONDS,<span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;());&#125;</span><br></pre></td></tr></table></figure>\n<p>第二种方法最终还是会导向方法一ThreadPoolExecutor的构造方法ThreadPoolExecutor</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p> 工厂模式的好处是：</p>\n<ul>\n<li>用户只要知道名字就行了，比如我想创建一个固定长度的线程池，只需要调用newFixedThreadPool（）方法，而不需要在了解ThreadPoolExecutor构造函数之后自己new一个配置一堆参数。<strong>不需要关注太多细节。</strong></li>\n<li>用工厂模式可以<strong>消除循环依赖</strong>，如果一个类构造函数的参数变了，所有实例化这个类的代码都得改。</li>\n</ul>\n<h3 id=\"阻塞队列\"><a href=\"#阻塞队列\" class=\"headerlink\" title=\"阻塞队列\"></a>阻塞队列</h3><p>上一篇我是用synchronized锁住任务队列，工作线程wait和notify去实现线程阻塞去任务队列去任务，jdk是用<strong>LinkedBlockingQueue的put和take</strong>方法来实现。如果put或者take操作无法立即执行，这两个方法调用将会发生<strong>阻塞</strong>，直到能够执行。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th><em>抛出异常</em></th>\n<th><em>特殊值</em></th>\n<th><em>阻塞</em></th>\n<th style=\"text-align:center\"><em>超时</em></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>插入</strong></td>\n<td><code>add(e)</code></td>\n<td><code>offer(e)</code></td>\n<td><code>put(e)</code></td>\n<td style=\"text-align:center\"><code>offer(e, time, unit)</code></td>\n</tr>\n<tr>\n<td><strong>移除</strong></td>\n<td><code>remove()</code></td>\n<td><code>poll()</code></td>\n<td><code>take()</code></td>\n<td style=\"text-align:center\"><code>poll(time, unit)</code></td>\n</tr>\n<tr>\n<td><strong>检查</strong></td>\n<td><code>element()</code></td>\n<td><code>peek()</code></td>\n<td><em>不可用</em></td>\n<td style=\"text-align:center\"><em>不可用</em></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"延迟加载Lazy-load\"><a href=\"#延迟加载Lazy-load\" class=\"headerlink\" title=\"延迟加载Lazy_load\"></a>延迟加载Lazy_load</h3><p>线程池是<strong>懒加载</strong>的，声明的时候并不会创建好线程等待任务，而是当提交第一个任务时才去新建线程；</p>\n<h1 id=\"三、改进自实现的线程池\"><a href=\"#三、改进自实现的线程池\" class=\"headerlink\" title=\"三、改进自实现的线程池\"></a>三、改进自实现的线程池</h1><p>改进</p>\n<p>1.实现延迟加载。我们是在构造函数创建线程，而java线程池只有当提交一个任务时，线程池才会创建一个新线程执行任务，直到当前线程数等于corePoolSize。这样会更节约资源。</p>\n<p>2.这里我们用LinkedList加线程wait（）notify（）来实现，也可以像java线程池一样用阻塞链表LinkedBlockingQueue来实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.BlockingQueue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadPool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//工作线程数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> workerCount;</span><br><span class=\"line\">    <span class=\"comment\">// 线程池大小</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> corePoolSize;</span><br><span class=\"line\">    <span class=\"comment\">// 任务容器</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class=\"line\">    <span class=\"comment\">//工作线程容器</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Set&lt;Worker&gt; workers;</span><br><span class=\"line\">    <span class=\"comment\">// 任务容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadPool threadPool;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ThreadPool <span class=\"title\">newThreadPool</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        threadPool = <span class=\"keyword\">new</span> ThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> threadPool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">ThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">        <span class=\"comment\">//LinkedBlockingQueue的默认容量是Integer.MAX_VALUE，一直加任务线程可能会造成OOM内存溢出</span></span><br><span class=\"line\">        workQueue = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;(<span class=\"number\">1024</span>);<span class=\"comment\">//这里指定大小</span></span><br><span class=\"line\">        workers = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (workerCount &lt; corePoolSize) &#123;</span><br><span class=\"line\">            addWorker(r);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                workQueue.put(r);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">        workerCount++;</span><br><span class=\"line\">        Worker worker = <span class=\"keyword\">new</span> Worker(r);</span><br><span class=\"line\">        Thread t = worker.thread;</span><br><span class=\"line\">        workers.add(worker);</span><br><span class=\"line\">        t.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        Runnable task;</span><br><span class=\"line\">        Thread thread;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Worker</span><span class=\"params\">(Runnable task)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.task = task;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.thread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                Runnable task = <span class=\"keyword\">this</span>.task;</span><br><span class=\"line\">                <span class=\"comment\">// 执行当前的任务，所以把这个任务置空，以免造成死循环</span></span><br><span class=\"line\">                <span class=\"keyword\">this</span>.task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Runnable r = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            r = workQueue.take();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestThreadPool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ThreadPool threadPool=ThreadPool.newThreadPool();</span><br><span class=\"line\">        <span class=\"comment\">//生成10个任务放入线程池</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            Runnable task=  <span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"做任务中。。。\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            threadPool.execute(task);</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参考</p>\n<blockquote>\n<p><a href=\"https://www.runoob.com/design-pattern/factory-pattern.html\" target=\"_blank\" rel=\"noopener\">模式方面菜鸟教程写的不错</a></p>\n<p><a href=\"https://blog.csdn.net/qq_42135428/article/details/80285737\" target=\"_blank\" rel=\"noopener\">Java高并发之BlockingQueue</a></p>\n<p><a href=\"https://blog.csdn.net/GitHub_boy/article/details/51046574\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/GitHub_boy/article/details/51046574</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>这个标题我取得一股营销号味道hhh，很早之前学习多线程的时候有自己写过一个简易的线程池，最近读了源码发现自己以前写的代码有很多可以改进的地方。我尤其喜欢用迭代的方式去学习——先实现，然后深入学习，最后改进之前实现的，完成一个迭代。因为这种方式更能看到自己的思路的过程，更明白所以然。好了，闲话不多说。开撸。</p>\n<p>本文分为三个部分：<br>一、如何实现一个简单的线程池？<br>二、jdk线程池源码分析<br>三、改进自实现的线程池</p>\n<h1 id=\"一、如何实现一个简单的线程池？\"><a href=\"#一、如何实现一个简单的线程池？\" class=\"headerlink\" title=\"一、如何实现一个简单的线程池？\"></a>一、如何实现一个简单的线程池？</h1><p>思路分析：线程池其实就是一个生产者消费者模型。</p>\n<p>首先我们需要一个<strong>队列</strong>作为任务容器作为存放任务， 还需要<strong>多个线程</strong>去执行任务，<strong> 消费者线程</strong>不断查询任务队列是否有任务，如果没有该线程等待，如果有任务，取出一个任务，唤醒所有在等待获取队列的线程，释放掉锁。执行任务线程的run方法。</p>\n<p>分析完毕，在开始写代码之前想想具体做法。</p>\n<ul>\n<li>任务容器，用LinkedList实现。</li>\n<li>add方法，用于把任务线程放入任务容器。</li>\n<li>构造函数，一次性启动3个 消费者线程。</li>\n<li>任务：一个有run方法的线程。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadPool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 线程池大小</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> corePoolSize;</span><br><span class=\"line\">    <span class=\"comment\">// 任务容器</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedList&lt;Runnable&gt; workQueue = <span class=\"keyword\">new</span> LinkedList&lt;Runnable&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> RUNNING =<span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建时候初始化线程</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (workQueue) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; corePoolSize; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">new</span> Worker(<span class=\"string\">\"线程\"</span> + i).start();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将任务线程放入线程池</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (workQueue) &#123;</span><br><span class=\"line\">            workQueue.addLast(r);</span><br><span class=\"line\">            <span class=\"comment\">//放入后唤醒所有wait线程</span></span><br><span class=\"line\">            workQueue.notifyAll();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        Runnable task;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Worker</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//锁住任务队列，试图取任务，失败则该线程wait</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (RUNNING) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (workQueue) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (workQueue.isEmpty()) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            workQueue.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    task = workQueue.removeLast();</span><br><span class=\"line\">                    workQueue.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//取到线程即可释放锁</span></span><br><span class=\"line\">                System.out.println(<span class=\"keyword\">this</span>.getName() + <span class=\"string\">\"获得到并且开始执行任务\"</span>);</span><br><span class=\"line\">                task.run();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestThreadPool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//线程池大小初始化为3</span></span><br><span class=\"line\">        ThreadPool threadPool=<span class=\"keyword\">new</span> ThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"comment\">//生成10个任务放入线程池</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">          Runnable task=  <span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"做任务中。。。\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">          threadPool.add(task);</span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动TestThreadPool，输出</p>\n<p>大功告成。</p>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><p>ConsumerThread类中这段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized (tasks) &#123;</span><br><span class=\"line\">  //试图取任务。。。</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//取到线程即可释放锁</span><br><span class=\"line\">task.run();</span><br></pre></td></tr></table></figure>\n<p>从任务中取任务时候是获取任务队列锁的，但执行任务的时候要先释放锁。如果不释放就去执行，那它执行的过程中其他线程都得等着，<strong>相当于一次只能有一个线程进行任务</strong>。</p>\n<p><em>2019年06月13号注：最近读书《java开发手册》OOP规约第11条：构造方法里禁止加入任何业务逻辑，如果有初始化逻辑，请放在init中。上面代码违背了这个规约。我这里也不改了，做个反例。再接下来的代码中改进</em></p>\n<h1 id=\"二、jdk线程池源码分析\"><a href=\"#二、jdk线程池源码分析\" class=\"headerlink\" title=\"二、jdk线程池源码分析\"></a>二、jdk线程池源码分析</h1><h2 id=\"线程池的重要方法\"><a href=\"#线程池的重要方法\" class=\"headerlink\" title=\"线程池的重要方法\"></a>线程池的重要方法</h2><h3 id=\"execute-接受任务\"><a href=\"#execute-接受任务\" class=\"headerlink\" title=\"execute()接受任务\"></a>execute()接受任务</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"comment\">// 表示 “线程池状态” 和 “线程数” 的整数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">     <span class=\"comment\">//分为3种情况</span></span><br><span class=\"line\">    <span class=\"comment\">// 情况1：如果当前线程数少于corePoolSize，直接新创建一个 worker 线程，并把当前 command 作为这个线程firstTask</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">            <span class=\"comment\">// 添加任务成功</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">          <span class=\"comment\">// 返回 false 代表线程池不允许提交任务</span></span><br><span class=\"line\">        c = ctl.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 情况2：要么当前线程数大于等于corePoolSize，要么刚刚 addWorker 失败了</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">        <span class=\"comment\">//下面这个分支的意图是：担心任务提交到队列中了，但是线程都关闭了</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">            reject(command);</span><br><span class=\"line\">        <span class=\"comment\">// 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 情况3:如果 workQueue 队列满了，以 maximumPoolSize 为界创建新的 worker，</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">         <span class=\"comment\">// 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span></span><br><span class=\"line\">        reject(command);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释一下这行代码，  这个方法会返回一个表示 “线程池状态” 和 “线程数” 的整数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//一开始的状态是ctlOf(RUNNING, 0)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger ctl = <span class=\"keyword\">new</span> AtomicInteger(ctlOf(RUNNING, <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> COUNT_BITS = Integer.SIZE - <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 000 11111111111111111111111111111</span></span><br><span class=\"line\"><span class=\"comment\">// 这里得到的是 29 个 1，也就是说线程池的最大线程数是 2^29-1=536870911</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CAPACITY   = (<span class=\"number\">1</span> &lt;&lt; COUNT_BITS) - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运算结果为 111跟29个0：111 00000000000000000000000000000</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RUNNING    = -<span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"comment\">// 000 00000000000000000000000000000</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHUTDOWN   =  <span class=\"number\">0</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"comment\">// 001 00000000000000000000000000000</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> STOP       =  <span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"comment\">// 010 00000000000000000000000000000</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TIDYING    =  <span class=\"number\">2</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"comment\">// 011 00000000000000000000000000000</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TERMINATED =  <span class=\"number\">3</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将整数 c 的低 29 位修改为 0，就得到了线程池的状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">runStateOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>     </span>&#123; <span class=\"keyword\">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class=\"line\"><span class=\"comment\">// 将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">workerCountOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>  </span>&#123; <span class=\"keyword\">return</span> c &amp; CAPACITY; &#125;</span><br></pre></td></tr></table></figure>\n<p>线程池的状态</p>\n<ul>\n<li>RUNNING：接受新的任务，处理等待队列中的任务</li>\n<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务</li>\n<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</li>\n<li>TIDYING：所有的任务都销毁了，workCount 为 0。线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()</li>\n<li>TERMINATED：terminated() 方法结束后，线程池的状态就会变成这个</li>\n</ul>\n<p>重点区分SHUTDOWN和STOP。</p>\n<p>在提一下关闭线程池的方法。</p>\n<p>shutdown()：设置 线程池的状态 为 SHUTDOWN，然后中断所有没有正在执行任务的线程</p>\n<p>shutdownNow()：设置 线程池的状态 为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表<br><strong><em>使用建议：一般调用shutdown（）关闭线程池；若任务不一定要执行完，则调用shutdownNow（）</em></strong></p>\n<h3 id=\"addWorker-方法：增加工作线程\"><a href=\"#addWorker-方法：增加工作线程\" class=\"headerlink\" title=\"addWorker()方法：增加工作线程\"></a>addWorker()方法：增加工作线程</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参数一：第一个任务。参数二：是否使用核心线程数 corePoolSize 作为创建线程的界限</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//打破多重循环的关键字retry</span></span><br><span class=\"line\">    retry:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//下面代码的意图：担心创建线程的时候，线程池已经关闭了</span></span><br><span class=\"line\">        <span class=\"comment\">// 如满足以下条件之一，那么不创建新的 worker：</span></span><br><span class=\"line\">        <span class=\"comment\">// 1. 线程池状态大于 SHUTDOWN，其实也就是 STOP, TIDYING, 或 TERMINATED</span></span><br><span class=\"line\">        <span class=\"comment\">// 2. firstTask != null</span></span><br><span class=\"line\">        <span class=\"comment\">// 3. workQueue.isEmpty()</span></span><br><span class=\"line\">        <span class=\"comment\">//  SHUTDOWN 的语义：不允许提交新的任务，但是要把已经进入到 workQueue 的任务执行完，所以在满足条件的基础上，是允许创建新的 Worker 的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class=\"line\">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class=\"line\">               firstTask == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">               ! workQueue.isEmpty()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</span><br><span class=\"line\">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 如果成功，那么就是所有创建线程前的条件校验都满足了，准备创建线程执行任务了</span></span><br><span class=\"line\">            <span class=\"comment\">// 这里失败的话，说明有其他线程也在尝试往线程池中创建线程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"comment\">//跳出多重循环</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">            <span class=\"comment\">// 由于有并发，重新再读取一下 ctl</span></span><br><span class=\"line\">            c = ctl.get();</span><br><span class=\"line\">            <span class=\"comment\">// 正常如果是 CAS 失败的话，进到下一个里层的for循环就可以了</span></span><br><span class=\"line\">            <span class=\"comment\">// 可是如果是因为其他线程导致线程池的状态发生了变更，比如有其他线程关闭了这个线程池</span></span><br><span class=\"line\">            <span class=\"comment\">// 那么需要回到外层的for循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">            <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 啊终于可以开始创建线程了</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// worker 是否已经启动</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 是否已将这个 worker 添加到 workers 这个 HashSet 中</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">        <span class=\"comment\">// 把 firstTask 传给 worker 的构造方法</span></span><br><span class=\"line\">        w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">        <span class=\"comment\">// 取 worker 中的线程对象，Worker的构造方法会调用 ThreadFactory 来创建一个新的线程</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这个是整个线程池的全局锁，持有这个锁才能让下面的操作“顺理成章”，</span></span><br><span class=\"line\">            <span class=\"comment\">// 因为关闭一个线程池需要这个锁，至少我持有锁的期间，线程池不会被关闭</span></span><br><span class=\"line\">            mainLock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">                <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 小于 SHUTTDOWN 那就是 RUNNING</span></span><br><span class=\"line\">                <span class=\"comment\">// 如果等于 SHUTDOWN，不接受新的任务，但是会继续执行等待队列中的任务</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||</span><br><span class=\"line\">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// worker 里面的 thread 可不能是已经启动的</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t.isAlive())</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                    <span class=\"comment\">// 加到 workers 这个 HashSet 中</span></span><br><span class=\"line\">                    workers.add(w);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                    <span class=\"comment\">// largestPoolSize 用于记录 workers 中的个数的最大值</span></span><br><span class=\"line\">                    <span class=\"comment\">// 因为 workers 是不断增加减少的，通过这个值可以知道线程池的大小曾经达到的最大值</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                        largestPoolSize = s;</span><br><span class=\"line\">                    workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                mainLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 添加成功的话，启动这个线程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">                t.start();</span><br><span class=\"line\">                workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">            addWorkerFailed(w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回线程是否启动成功</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"线程池的线程创建时机\"><a href=\"#线程池的线程创建时机\" class=\"headerlink\" title=\"线程池的线程创建时机\"></a>线程池的线程创建时机</h3><ul>\n<li>线程池是<strong>懒加载</strong>的，声明的时候并不会创建好线程等待任务，而是当提交第一个任务时才去新建线程；</li>\n<li>当提交一个任务时，如果当前线程数<strong>小于corePoolSize</strong>，就直接创建一个新线程执行任务；</li>\n<li>如果当前线程数<strong>大于corePoolSize</strong>，继续提交的任务被保存到<strong>阻塞队列中</strong>，等待被执行；</li>\n<li>如果阻塞队列满了，并且当前线程数<strong>小于maxPoolSize</strong>，那就创建新的线程执行当前任务；</li>\n<li>如果池里的线程数<strong>大于maxPoolSize</strong>,这时再有任务来，只能调用<strong>拒绝策略</strong>。</li>\n</ul>\n<h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><p>从线程池的创建讲起，线程池有两种创建方式。</p>\n<p>一是<code>ThreadPoolExecutor threadPool= new ThreadPoolExecutor(10, 15, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());</code></p>\n<p>二是<code>executorService= Executors.newFixedThreadPool(3);</code></p>\n<p>第二钟方式用到了<strong>工厂模式</strong>，点进方法newFixedThreadPool(3)去看是返回一个定义好初始化的参数线程池实例，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads,<span class=\"number\">0L</span>,</span><br><span class=\"line\">            TimeUnit.MILLISECONDS,<span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;());&#125;</span><br></pre></td></tr></table></figure>\n<p>第二种方法最终还是会导向方法一ThreadPoolExecutor的构造方法ThreadPoolExecutor</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p> 工厂模式的好处是：</p>\n<ul>\n<li>用户只要知道名字就行了，比如我想创建一个固定长度的线程池，只需要调用newFixedThreadPool（）方法，而不需要在了解ThreadPoolExecutor构造函数之后自己new一个配置一堆参数。<strong>不需要关注太多细节。</strong></li>\n<li>用工厂模式可以<strong>消除循环依赖</strong>，如果一个类构造函数的参数变了，所有实例化这个类的代码都得改。</li>\n</ul>\n<h3 id=\"阻塞队列\"><a href=\"#阻塞队列\" class=\"headerlink\" title=\"阻塞队列\"></a>阻塞队列</h3><p>上一篇我是用synchronized锁住任务队列，工作线程wait和notify去实现线程阻塞去任务队列去任务，jdk是用<strong>LinkedBlockingQueue的put和take</strong>方法来实现。如果put或者take操作无法立即执行，这两个方法调用将会发生<strong>阻塞</strong>，直到能够执行。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th><em>抛出异常</em></th>\n<th><em>特殊值</em></th>\n<th><em>阻塞</em></th>\n<th style=\"text-align:center\"><em>超时</em></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>插入</strong></td>\n<td><code>add(e)</code></td>\n<td><code>offer(e)</code></td>\n<td><code>put(e)</code></td>\n<td style=\"text-align:center\"><code>offer(e, time, unit)</code></td>\n</tr>\n<tr>\n<td><strong>移除</strong></td>\n<td><code>remove()</code></td>\n<td><code>poll()</code></td>\n<td><code>take()</code></td>\n<td style=\"text-align:center\"><code>poll(time, unit)</code></td>\n</tr>\n<tr>\n<td><strong>检查</strong></td>\n<td><code>element()</code></td>\n<td><code>peek()</code></td>\n<td><em>不可用</em></td>\n<td style=\"text-align:center\"><em>不可用</em></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"延迟加载Lazy-load\"><a href=\"#延迟加载Lazy-load\" class=\"headerlink\" title=\"延迟加载Lazy_load\"></a>延迟加载Lazy_load</h3><p>线程池是<strong>懒加载</strong>的，声明的时候并不会创建好线程等待任务，而是当提交第一个任务时才去新建线程；</p>\n<h1 id=\"三、改进自实现的线程池\"><a href=\"#三、改进自实现的线程池\" class=\"headerlink\" title=\"三、改进自实现的线程池\"></a>三、改进自实现的线程池</h1><p>改进</p>\n<p>1.实现延迟加载。我们是在构造函数创建线程，而java线程池只有当提交一个任务时，线程池才会创建一个新线程执行任务，直到当前线程数等于corePoolSize。这样会更节约资源。</p>\n<p>2.这里我们用LinkedList加线程wait（）notify（）来实现，也可以像java线程池一样用阻塞链表LinkedBlockingQueue来实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.BlockingQueue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadPool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//工作线程数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> workerCount;</span><br><span class=\"line\">    <span class=\"comment\">// 线程池大小</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> corePoolSize;</span><br><span class=\"line\">    <span class=\"comment\">// 任务容器</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class=\"line\">    <span class=\"comment\">//工作线程容器</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Set&lt;Worker&gt; workers;</span><br><span class=\"line\">    <span class=\"comment\">// 任务容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadPool threadPool;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ThreadPool <span class=\"title\">newThreadPool</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        threadPool = <span class=\"keyword\">new</span> ThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> threadPool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">ThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">        <span class=\"comment\">//LinkedBlockingQueue的默认容量是Integer.MAX_VALUE，一直加任务线程可能会造成OOM内存溢出</span></span><br><span class=\"line\">        workQueue = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;(<span class=\"number\">1024</span>);<span class=\"comment\">//这里指定大小</span></span><br><span class=\"line\">        workers = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (workerCount &lt; corePoolSize) &#123;</span><br><span class=\"line\">            addWorker(r);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                workQueue.put(r);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">        workerCount++;</span><br><span class=\"line\">        Worker worker = <span class=\"keyword\">new</span> Worker(r);</span><br><span class=\"line\">        Thread t = worker.thread;</span><br><span class=\"line\">        workers.add(worker);</span><br><span class=\"line\">        t.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        Runnable task;</span><br><span class=\"line\">        Thread thread;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Worker</span><span class=\"params\">(Runnable task)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.task = task;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.thread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                Runnable task = <span class=\"keyword\">this</span>.task;</span><br><span class=\"line\">                <span class=\"comment\">// 执行当前的任务，所以把这个任务置空，以免造成死循环</span></span><br><span class=\"line\">                <span class=\"keyword\">this</span>.task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Runnable r = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            r = workQueue.take();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestThreadPool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ThreadPool threadPool=ThreadPool.newThreadPool();</span><br><span class=\"line\">        <span class=\"comment\">//生成10个任务放入线程池</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            Runnable task=  <span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"做任务中。。。\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            threadPool.execute(task);</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参考</p>\n<blockquote>\n<p><a href=\"https://www.runoob.com/design-pattern/factory-pattern.html\" target=\"_blank\" rel=\"noopener\">模式方面菜鸟教程写的不错</a></p>\n<p><a href=\"https://blog.csdn.net/qq_42135428/article/details/80285737\" target=\"_blank\" rel=\"noopener\">Java高并发之BlockingQueue</a></p>\n<p><a href=\"https://blog.csdn.net/GitHub_boy/article/details/51046574\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/GitHub_boy/article/details/51046574</a></p>\n</blockquote>\n"},{"title":"What interesting things can zset for redis do?","date":"2022-07-25T16:24:50.000Z","description":"Multidimensional leaderboard and rate Limiting.","_content":"\n\n\n\n\n## Foreword\n\n\n\nI have always had the habit of doing work summaries, and I will occasionally carry out an extended study of the technologies I use in my work, but the summary notes are written for myself. some. I happened to be learning English recently, so I thought I might as well organize my notes in English. This is the first work note I have compiled in English。\n\n I recently developed a timed spike function using redis' zset. The specific implementation is to use the seckill time as the score of the zset, use the product ID as the value, the key is the name of the seckill product set, and use a timed task to scan the zset at the second level, start is a very early time, and end is the current timestamp , use the method zrangeByScore to get the commodities of this period. If the seckill time of a commodity falls within this range, it will execute the opening seconds. After this function is completed, I want to summarize zset, which can achieve many interesting functions, so I have this article. \n\n\n\n## What interesting things can zset do? \n\n\n\n### Multidimensional leaderboard \n\nThe most common usage is to implement a leaderboard, such as a list of winning countries based on the number of Olympic medals. Here I would like to introduce a more interesting implementation - multi-dimensional leaderboard. The multi-dimensional ranking means that the rankings are ranked according to multiple different dimensions. For example, for example, in the medal rankings of Olympic countries, the participants are ranked from the dimensions of gold, silver and bronze medals, and the number of gold medals is first sorted. ; If the number of gold medals is the same, then sort by the number of silver medals.\n\nIsn't it easy to think of piecing together two numbers as a fraction? But this simple way of putting together is problematic. For example, if country A has won 5 gold medals and 15 silver medals, the combination is 515; another country B has won 50 gold medals and only 1 silver medal. , which when pieced together is 501, yields a higher score for the A country, when the opposite is true. \n\nThere are two ways to implement multidimensional indexing：\n\n#### Binary segmentation\n\nThe reason for the failure of direct piecing is essentially because the low-order bits grabbed the high-order bits, so we can distinguish the low-order bits from the high-order bits, and fill in zeros in front of the high-order bits that are not filled. Fractions of different dimensions can be stored in different binary digits of a variable. This kind of binary segmented storage design idea is very common in Java source code. For example, in the design of thread state in Java's thread pool, the thread state is stored in AtomicInteger. This AtomicInteger traverses the lower 29 bits to indicate the number of threads in the thread pool. , through the upper 3 bits to indicate the running status of the thread pool. \n\n#### Split into decimals \n\nOr we can directly split into decimals in multiple dimensions. For example, the gold medal is an integer, and the silver medal is placed in a decimal place. If country A has 5 gold medals and 15 silver medals, the combination is 5.15; another country B has 50 gold medals and only 1 silver medal, and the combination is 50.1. \n\n### Rate Limiting\n\n#### counter \n\nIf you want to use redis to implement a current limit, first of all think that you can implement counter current limit based on Redis's setnx. For each request, use the unique identifier of the requested resource as the key. If the key already exists, it will be incremented by 1. If the initialization counter is not created, it will be 1. According to the size of the counter, it is judged whether the current limit threshold is exceeded, and if it exceeds, it will return to trigger the current limit. \n\nSimple counter current limiting has a fatal flaw, the criticality problem. For example, in a scenario where the total number of requests is limited to 100 in 1 minute, 100 requests came in the first minute until the end of the minute, and 100 requests came immediately at the beginning of the next minute. Because it is in two different one-minute intervals, the counter current limit will be released, but in fact, 200 requests came in less than one minute, violating the current limit rules. Therefore, the counter current limit is generally not used by anyone. \n\n#### sliding window \n\nSliding window current limiting can solve this critical problem. To implement sliding window, we have to use zset. The principle is similar to that of a timed spike. The timestamp is used as a score, and zset can be used to obtain the corresponding value according to the range of the score. The specific implementation is as follows：\n\nWhen the request comes, the unique identifier of the requested resource is used as the key. When each request comes in, the score of the zset is the current timestamp, and the value of the zset remains unique and can be generated by UUID; \n\nThe beginning of the sliding window: the current time - the time period of the current limit, the beginning of the sliding window: the current time. \n\nUse zset's zrangebyscore to get how many requests are in the sliding window. If the size of the threshold has been exceeded, the current limit is triggered. Otherwise, add a new piece of data in zset. \n\nIn order to avoid the infinite increase of zset, regularly use zremrangebyscore to delete data smaller than the end of the sliding window, because the data beyond the window does not care. \n\nNote: The difference between zrange and zrangebyscore, zrange divides the interval according to the index, and zrangebyscore is according to the score.\n\nA simple code example is as follows：\n\n```java\npublic class RedisSlidingWindowRateLimit {\n  \n    private static final int LIMIT = 100;\n  \n    private static final int PERIOD = 60;\n    @Resource\n    private RedisService redisService;\n\n    public boolean triggerLimit(String requestPath) {\n        long now = System.currentTimeMillis();\n        Set<String> range = redisService.opsForZSet().rangeByScore(requestPath, now - PERIOD * 1000, now);\n        if (range.size() > LIMIT) {\n            return true;\n        } else {\n            redisService.opsForZSet().add(requestPath, UUID.randomUUID().toString(), now);\n            return false;\n        }\n    }\n}\n```\n\n\n\n\n","source":"_posts/自英-redis的zset可以做哪些有趣的事？.md","raw":"---\ntitle: What interesting things can zset for redis do?\ndate: 2022-07-26 00:24:50\ncategories: redis\ndescription: Multidimensional leaderboard and rate Limiting.\n\n---\n\n\n\n\n\n## Foreword\n\n\n\nI have always had the habit of doing work summaries, and I will occasionally carry out an extended study of the technologies I use in my work, but the summary notes are written for myself. some. I happened to be learning English recently, so I thought I might as well organize my notes in English. This is the first work note I have compiled in English。\n\n I recently developed a timed spike function using redis' zset. The specific implementation is to use the seckill time as the score of the zset, use the product ID as the value, the key is the name of the seckill product set, and use a timed task to scan the zset at the second level, start is a very early time, and end is the current timestamp , use the method zrangeByScore to get the commodities of this period. If the seckill time of a commodity falls within this range, it will execute the opening seconds. After this function is completed, I want to summarize zset, which can achieve many interesting functions, so I have this article. \n\n\n\n## What interesting things can zset do? \n\n\n\n### Multidimensional leaderboard \n\nThe most common usage is to implement a leaderboard, such as a list of winning countries based on the number of Olympic medals. Here I would like to introduce a more interesting implementation - multi-dimensional leaderboard. The multi-dimensional ranking means that the rankings are ranked according to multiple different dimensions. For example, for example, in the medal rankings of Olympic countries, the participants are ranked from the dimensions of gold, silver and bronze medals, and the number of gold medals is first sorted. ; If the number of gold medals is the same, then sort by the number of silver medals.\n\nIsn't it easy to think of piecing together two numbers as a fraction? But this simple way of putting together is problematic. For example, if country A has won 5 gold medals and 15 silver medals, the combination is 515; another country B has won 50 gold medals and only 1 silver medal. , which when pieced together is 501, yields a higher score for the A country, when the opposite is true. \n\nThere are two ways to implement multidimensional indexing：\n\n#### Binary segmentation\n\nThe reason for the failure of direct piecing is essentially because the low-order bits grabbed the high-order bits, so we can distinguish the low-order bits from the high-order bits, and fill in zeros in front of the high-order bits that are not filled. Fractions of different dimensions can be stored in different binary digits of a variable. This kind of binary segmented storage design idea is very common in Java source code. For example, in the design of thread state in Java's thread pool, the thread state is stored in AtomicInteger. This AtomicInteger traverses the lower 29 bits to indicate the number of threads in the thread pool. , through the upper 3 bits to indicate the running status of the thread pool. \n\n#### Split into decimals \n\nOr we can directly split into decimals in multiple dimensions. For example, the gold medal is an integer, and the silver medal is placed in a decimal place. If country A has 5 gold medals and 15 silver medals, the combination is 5.15; another country B has 50 gold medals and only 1 silver medal, and the combination is 50.1. \n\n### Rate Limiting\n\n#### counter \n\nIf you want to use redis to implement a current limit, first of all think that you can implement counter current limit based on Redis's setnx. For each request, use the unique identifier of the requested resource as the key. If the key already exists, it will be incremented by 1. If the initialization counter is not created, it will be 1. According to the size of the counter, it is judged whether the current limit threshold is exceeded, and if it exceeds, it will return to trigger the current limit. \n\nSimple counter current limiting has a fatal flaw, the criticality problem. For example, in a scenario where the total number of requests is limited to 100 in 1 minute, 100 requests came in the first minute until the end of the minute, and 100 requests came immediately at the beginning of the next minute. Because it is in two different one-minute intervals, the counter current limit will be released, but in fact, 200 requests came in less than one minute, violating the current limit rules. Therefore, the counter current limit is generally not used by anyone. \n\n#### sliding window \n\nSliding window current limiting can solve this critical problem. To implement sliding window, we have to use zset. The principle is similar to that of a timed spike. The timestamp is used as a score, and zset can be used to obtain the corresponding value according to the range of the score. The specific implementation is as follows：\n\nWhen the request comes, the unique identifier of the requested resource is used as the key. When each request comes in, the score of the zset is the current timestamp, and the value of the zset remains unique and can be generated by UUID; \n\nThe beginning of the sliding window: the current time - the time period of the current limit, the beginning of the sliding window: the current time. \n\nUse zset's zrangebyscore to get how many requests are in the sliding window. If the size of the threshold has been exceeded, the current limit is triggered. Otherwise, add a new piece of data in zset. \n\nIn order to avoid the infinite increase of zset, regularly use zremrangebyscore to delete data smaller than the end of the sliding window, because the data beyond the window does not care. \n\nNote: The difference between zrange and zrangebyscore, zrange divides the interval according to the index, and zrangebyscore is according to the score.\n\nA simple code example is as follows：\n\n```java\npublic class RedisSlidingWindowRateLimit {\n  \n    private static final int LIMIT = 100;\n  \n    private static final int PERIOD = 60;\n    @Resource\n    private RedisService redisService;\n\n    public boolean triggerLimit(String requestPath) {\n        long now = System.currentTimeMillis();\n        Set<String> range = redisService.opsForZSet().rangeByScore(requestPath, now - PERIOD * 1000, now);\n        if (range.size() > LIMIT) {\n            return true;\n        } else {\n            redisService.opsForZSet().add(requestPath, UUID.randomUUID().toString(), now);\n            return false;\n        }\n    }\n}\n```\n\n\n\n\n","slug":"自英-redis的zset可以做哪些有趣的事？","published":1,"updated":"2022-07-25T16:18:49.725Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qks001ww9rpn3txfler","content":"<h2 id=\"Foreword\"><a href=\"#Foreword\" class=\"headerlink\" title=\"Foreword\"></a>Foreword</h2><p>I have always had the habit of doing work summaries, and I will occasionally carry out an extended study of the technologies I use in my work, but the summary notes are written for myself. some. I happened to be learning English recently, so I thought I might as well organize my notes in English. This is the first work note I have compiled in English。</p>\n<p> I recently developed a timed spike function using redis’ zset. The specific implementation is to use the seckill time as the score of the zset, use the product ID as the value, the key is the name of the seckill product set, and use a timed task to scan the zset at the second level, start is a very early time, and end is the current timestamp , use the method zrangeByScore to get the commodities of this period. If the seckill time of a commodity falls within this range, it will execute the opening seconds. After this function is completed, I want to summarize zset, which can achieve many interesting functions, so I have this article. </p>\n<h2 id=\"What-interesting-things-can-zset-do\"><a href=\"#What-interesting-things-can-zset-do\" class=\"headerlink\" title=\"What interesting things can zset do?\"></a>What interesting things can zset do?</h2><h3 id=\"Multidimensional-leaderboard\"><a href=\"#Multidimensional-leaderboard\" class=\"headerlink\" title=\"Multidimensional leaderboard\"></a>Multidimensional leaderboard</h3><p>The most common usage is to implement a leaderboard, such as a list of winning countries based on the number of Olympic medals. Here I would like to introduce a more interesting implementation - multi-dimensional leaderboard. The multi-dimensional ranking means that the rankings are ranked according to multiple different dimensions. For example, for example, in the medal rankings of Olympic countries, the participants are ranked from the dimensions of gold, silver and bronze medals, and the number of gold medals is first sorted. ; If the number of gold medals is the same, then sort by the number of silver medals.</p>\n<p>Isn’t it easy to think of piecing together two numbers as a fraction? But this simple way of putting together is problematic. For example, if country A has won 5 gold medals and 15 silver medals, the combination is 515; another country B has won 50 gold medals and only 1 silver medal. , which when pieced together is 501, yields a higher score for the A country, when the opposite is true. </p>\n<p>There are two ways to implement multidimensional indexing：</p>\n<h4 id=\"Binary-segmentation\"><a href=\"#Binary-segmentation\" class=\"headerlink\" title=\"Binary segmentation\"></a>Binary segmentation</h4><p>The reason for the failure of direct piecing is essentially because the low-order bits grabbed the high-order bits, so we can distinguish the low-order bits from the high-order bits, and fill in zeros in front of the high-order bits that are not filled. Fractions of different dimensions can be stored in different binary digits of a variable. This kind of binary segmented storage design idea is very common in Java source code. For example, in the design of thread state in Java’s thread pool, the thread state is stored in AtomicInteger. This AtomicInteger traverses the lower 29 bits to indicate the number of threads in the thread pool. , through the upper 3 bits to indicate the running status of the thread pool. </p>\n<h4 id=\"Split-into-decimals\"><a href=\"#Split-into-decimals\" class=\"headerlink\" title=\"Split into decimals\"></a>Split into decimals</h4><p>Or we can directly split into decimals in multiple dimensions. For example, the gold medal is an integer, and the silver medal is placed in a decimal place. If country A has 5 gold medals and 15 silver medals, the combination is 5.15; another country B has 50 gold medals and only 1 silver medal, and the combination is 50.1. </p>\n<h3 id=\"Rate-Limiting\"><a href=\"#Rate-Limiting\" class=\"headerlink\" title=\"Rate Limiting\"></a>Rate Limiting</h3><h4 id=\"counter\"><a href=\"#counter\" class=\"headerlink\" title=\"counter\"></a>counter</h4><p>If you want to use redis to implement a current limit, first of all think that you can implement counter current limit based on Redis’s setnx. For each request, use the unique identifier of the requested resource as the key. If the key already exists, it will be incremented by 1. If the initialization counter is not created, it will be 1. According to the size of the counter, it is judged whether the current limit threshold is exceeded, and if it exceeds, it will return to trigger the current limit. </p>\n<p>Simple counter current limiting has a fatal flaw, the criticality problem. For example, in a scenario where the total number of requests is limited to 100 in 1 minute, 100 requests came in the first minute until the end of the minute, and 100 requests came immediately at the beginning of the next minute. Because it is in two different one-minute intervals, the counter current limit will be released, but in fact, 200 requests came in less than one minute, violating the current limit rules. Therefore, the counter current limit is generally not used by anyone. </p>\n<h4 id=\"sliding-window\"><a href=\"#sliding-window\" class=\"headerlink\" title=\"sliding window\"></a>sliding window</h4><p>Sliding window current limiting can solve this critical problem. To implement sliding window, we have to use zset. The principle is similar to that of a timed spike. The timestamp is used as a score, and zset can be used to obtain the corresponding value according to the range of the score. The specific implementation is as follows：</p>\n<p>When the request comes, the unique identifier of the requested resource is used as the key. When each request comes in, the score of the zset is the current timestamp, and the value of the zset remains unique and can be generated by UUID; </p>\n<p>The beginning of the sliding window: the current time - the time period of the current limit, the beginning of the sliding window: the current time. </p>\n<p>Use zset’s zrangebyscore to get how many requests are in the sliding window. If the size of the threshold has been exceeded, the current limit is triggered. Otherwise, add a new piece of data in zset. </p>\n<p>In order to avoid the infinite increase of zset, regularly use zremrangebyscore to delete data smaller than the end of the sliding window, because the data beyond the window does not care. </p>\n<p>Note: The difference between zrange and zrangebyscore, zrange divides the interval according to the index, and zrangebyscore is according to the score.</p>\n<p>A simple code example is as follows：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisSlidingWindowRateLimit</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> LIMIT = <span class=\"number\">100</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PERIOD = <span class=\"number\">60</span>;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisService redisService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">triggerLimit</span><span class=\"params\">(String requestPath)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">        Set&lt;String&gt; range = redisService.opsForZSet().rangeByScore(requestPath, now - PERIOD * <span class=\"number\">1000</span>, now);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (range.size() &gt; LIMIT) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            redisService.opsForZSet().add(requestPath, UUID.randomUUID().toString(), now);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Foreword\"><a href=\"#Foreword\" class=\"headerlink\" title=\"Foreword\"></a>Foreword</h2><p>I have always had the habit of doing work summaries, and I will occasionally carry out an extended study of the technologies I use in my work, but the summary notes are written for myself. some. I happened to be learning English recently, so I thought I might as well organize my notes in English. This is the first work note I have compiled in English。</p>\n<p> I recently developed a timed spike function using redis’ zset. The specific implementation is to use the seckill time as the score of the zset, use the product ID as the value, the key is the name of the seckill product set, and use a timed task to scan the zset at the second level, start is a very early time, and end is the current timestamp , use the method zrangeByScore to get the commodities of this period. If the seckill time of a commodity falls within this range, it will execute the opening seconds. After this function is completed, I want to summarize zset, which can achieve many interesting functions, so I have this article. </p>\n<h2 id=\"What-interesting-things-can-zset-do\"><a href=\"#What-interesting-things-can-zset-do\" class=\"headerlink\" title=\"What interesting things can zset do?\"></a>What interesting things can zset do?</h2><h3 id=\"Multidimensional-leaderboard\"><a href=\"#Multidimensional-leaderboard\" class=\"headerlink\" title=\"Multidimensional leaderboard\"></a>Multidimensional leaderboard</h3><p>The most common usage is to implement a leaderboard, such as a list of winning countries based on the number of Olympic medals. Here I would like to introduce a more interesting implementation - multi-dimensional leaderboard. The multi-dimensional ranking means that the rankings are ranked according to multiple different dimensions. For example, for example, in the medal rankings of Olympic countries, the participants are ranked from the dimensions of gold, silver and bronze medals, and the number of gold medals is first sorted. ; If the number of gold medals is the same, then sort by the number of silver medals.</p>\n<p>Isn’t it easy to think of piecing together two numbers as a fraction? But this simple way of putting together is problematic. For example, if country A has won 5 gold medals and 15 silver medals, the combination is 515; another country B has won 50 gold medals and only 1 silver medal. , which when pieced together is 501, yields a higher score for the A country, when the opposite is true. </p>\n<p>There are two ways to implement multidimensional indexing：</p>\n<h4 id=\"Binary-segmentation\"><a href=\"#Binary-segmentation\" class=\"headerlink\" title=\"Binary segmentation\"></a>Binary segmentation</h4><p>The reason for the failure of direct piecing is essentially because the low-order bits grabbed the high-order bits, so we can distinguish the low-order bits from the high-order bits, and fill in zeros in front of the high-order bits that are not filled. Fractions of different dimensions can be stored in different binary digits of a variable. This kind of binary segmented storage design idea is very common in Java source code. For example, in the design of thread state in Java’s thread pool, the thread state is stored in AtomicInteger. This AtomicInteger traverses the lower 29 bits to indicate the number of threads in the thread pool. , through the upper 3 bits to indicate the running status of the thread pool. </p>\n<h4 id=\"Split-into-decimals\"><a href=\"#Split-into-decimals\" class=\"headerlink\" title=\"Split into decimals\"></a>Split into decimals</h4><p>Or we can directly split into decimals in multiple dimensions. For example, the gold medal is an integer, and the silver medal is placed in a decimal place. If country A has 5 gold medals and 15 silver medals, the combination is 5.15; another country B has 50 gold medals and only 1 silver medal, and the combination is 50.1. </p>\n<h3 id=\"Rate-Limiting\"><a href=\"#Rate-Limiting\" class=\"headerlink\" title=\"Rate Limiting\"></a>Rate Limiting</h3><h4 id=\"counter\"><a href=\"#counter\" class=\"headerlink\" title=\"counter\"></a>counter</h4><p>If you want to use redis to implement a current limit, first of all think that you can implement counter current limit based on Redis’s setnx. For each request, use the unique identifier of the requested resource as the key. If the key already exists, it will be incremented by 1. If the initialization counter is not created, it will be 1. According to the size of the counter, it is judged whether the current limit threshold is exceeded, and if it exceeds, it will return to trigger the current limit. </p>\n<p>Simple counter current limiting has a fatal flaw, the criticality problem. For example, in a scenario where the total number of requests is limited to 100 in 1 minute, 100 requests came in the first minute until the end of the minute, and 100 requests came immediately at the beginning of the next minute. Because it is in two different one-minute intervals, the counter current limit will be released, but in fact, 200 requests came in less than one minute, violating the current limit rules. Therefore, the counter current limit is generally not used by anyone. </p>\n<h4 id=\"sliding-window\"><a href=\"#sliding-window\" class=\"headerlink\" title=\"sliding window\"></a>sliding window</h4><p>Sliding window current limiting can solve this critical problem. To implement sliding window, we have to use zset. The principle is similar to that of a timed spike. The timestamp is used as a score, and zset can be used to obtain the corresponding value according to the range of the score. The specific implementation is as follows：</p>\n<p>When the request comes, the unique identifier of the requested resource is used as the key. When each request comes in, the score of the zset is the current timestamp, and the value of the zset remains unique and can be generated by UUID; </p>\n<p>The beginning of the sliding window: the current time - the time period of the current limit, the beginning of the sliding window: the current time. </p>\n<p>Use zset’s zrangebyscore to get how many requests are in the sliding window. If the size of the threshold has been exceeded, the current limit is triggered. Otherwise, add a new piece of data in zset. </p>\n<p>In order to avoid the infinite increase of zset, regularly use zremrangebyscore to delete data smaller than the end of the sliding window, because the data beyond the window does not care. </p>\n<p>Note: The difference between zrange and zrangebyscore, zrange divides the interval according to the index, and zrangebyscore is according to the score.</p>\n<p>A simple code example is as follows：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisSlidingWindowRateLimit</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> LIMIT = <span class=\"number\">100</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PERIOD = <span class=\"number\">60</span>;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisService redisService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">triggerLimit</span><span class=\"params\">(String requestPath)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">        Set&lt;String&gt; range = redisService.opsForZSet().rangeByScore(requestPath, now - PERIOD * <span class=\"number\">1000</span>, now);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (range.size() &gt; LIMIT) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            redisService.opsForZSet().add(requestPath, UUID.randomUUID().toString(), now);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"我的编程之路（一）","date":"2020-06-04T00:52:50.000Z","description":"初出茅庐","_content":"\n## 大学\n\n大一随着课程学习前端,第一学期的课程设计，我用纯HTML+CSS实现了一个学院网站的静态页面，这个网站我的主要精力花在设计上，每一个框框的px我一点点调，设成不同颜色，看如何能更漂亮；在第二学期，我发现了BootStrap这个前端框架，原来只需要简单引用组件，就能达到我上一学期花很多时间效果。\n\n大二，学院开始教后端的内容，比如Java语法基础，网络、数据库。当时Java老师上课讲教科书让我昏昏欲睡，但是我察觉这只是老师的问题，并不是后端的问题。比起前端。后端才是我想要真正学习的编程。因为我想要掌握的编程不仅是想要样式，更希望编程能够做一些更有用的事情，比如通信，对现实生活映射。于是我开始自学后端。\n\n入门后端比较印象深刻的事是：\n\n- 在图书馆借了这本书《Data Structures and Other Objects Using Java》它让我完全理解了栈和队列等数据结构以及其作用。顺便提一句，书中有一个用树实现的小程序，叫猜动物。我特别喜欢这个程序，因为这个简单程序能够“自学”。每一次玩游戏后，程序都会更聪明一点。\n- 跟着网上的资料，照猫画虎写了一个聊天室，用到了socket网络通信，https://github.com/wangxuanni/MyChat\n- 发现了这个网站，开始接触一些流行的互联网技术，比如SSM、Redis https://how2j.cn/\n- 数据库这门课我学的挺好的，期末只扣了几分。当时想着不如去考一个证，于是准备了两个月，拿下了软考中级——数据库系统工程师。\n\n大三，随着学习深入，职业专业方向变得清楚：服务端+互联网。\n\n- 写了一个HTTP服务器，参考《tomcat是怎么运行的》\n- 认真的写了一个贴吧项目，用SSM+mysql+redis，。后来这个项目作为我的毕业设计，后来还拿到了年级的优秀毕业设计。\n- 报名蓝桥杯比赛，想着以考代学，让对算法一无所知的我，有一个驱动力去啃算法。刷题了两个星期，拿了省三安慰奖。之后囫囵吞枣刷过一遍剑指offer，leetcode70题左右。\n\n大三下学期，去了广州的一家软件公司实习了2个月，发现学到的东西和工资一样少的可怜，就辞职了，准备好好参加秋招。\n当时因为很穷，租到房子通勤需要一小时。广州早上8点的5号线，人多到工作人员拉九曲围栏，让人们排队等待限流进闸门。这种通勤体验令人难受的不仅仅浪费时间和挤来挤去，还有在背着电脑的人群中排队缓缓前进的时候，会忍不住觉得自己好渺小，像自己这样的打工人有那么多个，我和别人又有什么不同呢。\n\n19年9月，参加秋招，这期间我学了这些：\n\n- java并发包的源码看了一遍，如HashMap、CurrentHashMap，syn，volatile。\n- 看了十本左右书和数不尽在闲鱼淘的视频。\n- 租了个云服务器，自己实践了一遍redis的容灾全过程，当我把master节点kill掉后，从redis的日志能看到，哨兵会进行哨兵选举，选举出来的哨兵进行主从复制。这次实践给我留下来很深刻的印象，而且这之后我完全理解了raft协议。\n- 还尝试写一个RPC框架，但后面精力放在面试了，没有写完。\n\n秋招最后收获三个Offer，蘑菇街、老虎证券、growingIO，接受了蘑菇街的。\n\n\n\n\n\n## 实习\n其实秋招offer是可以不用来实习的，但我想提前看看工作环境，没想到这一来，就呆了5个月。\n\n我所在直播的稳定性小组，简单来说就是在业务部门做中间层相关的事。在实习的前四个月我没有做过业务需求，都在跟着我学长了解稳定性的方方面面，比如用flink监控直播流、把直播界面模块抽象成插件化、直播拉流的容灾切换。\n\n工作和自己学的东西非常不一样，在来实习之前，我全凭自己的兴趣学，对分布式有兴趣就自己租服务器实践，对并发有兴趣就一边看源码一边看博客。工作后，我学到了身为工程师的基本素养。举一个方面，学生的时候我的写代码，最在乎的是能不能跑起来，谁要跟我说你这程序如果突然有大流量会不会崩溃；如果功能变了，你的改动成本是多大。我会觉得他没事找事，但是对于一个工程师，这些考虑都是最最基本的，和能不能跑起来一样基本。此外因为是在团队里，会更加注意代码规范。\n\n当时一人来到了杭州，当时在杭州谁也不认识，在租房等房东来签协议。突然觉得特别孤独。当时认真的把社交写进了待办事件，后来在杭州认识的朋友，比我大学都多。\n\n大三认识了一群五湖四海的同届朋友们，我们有一个技术小群，群里技术氛围浓厚，每周都会有技术讨论会。后来在秋招的时候，大家互相内推，每周分享技术，群里讨论问题，复盘面试。秋招大家也都去到了理想的公司，至今我们仍然每天聊天。\n\n值得一提的是，群里有个小哥哥叫糖糖，当时我两都在杭州实习，面基后还蛮聊得来的。赞同他说过一句话\"人总是会高估每天能做的事情，却一直低估一年能做的事情\"。他秋招被毁约之后（这时秋招已经结束了）虽然很气，但是甚至没有告诉我们，因为他知道我们肯定会为他打抱不平。当时他最重要的不是闹事，而是最后的补招，后来他拿到了更理想的offer。运气不好遇到这种仍然能沉得住气，知道自己想要什么，我很佩服。\n\n在我实习期间，20年3月爆发疫情，导致回家之路九九八十一难，因为疫情航班被取消了两次，要走的那天6点起来把床收了，结果一看手机航班又取消了 - -，只能放弃直达，从杭州飞广州，再从广州做汽车。接下来还遇到如下困难：迟到了改签+行李很多+汽车晚点车站人很多+下雨+新修的陌生汽车站。\n\n实习结束，是我最后也是最长的一个暑假，把朋友的ps4和碟片借来了。天昏地暗的玩游戏。刺客信条、底特律变人、美国末日、风之旅人、最后的守护者、鬼泣5。追星看小说，在我的最后一个暑假，干一些毫无意义但非常快乐的事。\n\n\n\n","source":"_posts/我的编程之路1.md","raw":"---\ntitle: 我的编程之路（一）\ndate: 2020-06-04 08:52:50\ncategories: 生活\ndescription: 初出茅庐\n---\n\n## 大学\n\n大一随着课程学习前端,第一学期的课程设计，我用纯HTML+CSS实现了一个学院网站的静态页面，这个网站我的主要精力花在设计上，每一个框框的px我一点点调，设成不同颜色，看如何能更漂亮；在第二学期，我发现了BootStrap这个前端框架，原来只需要简单引用组件，就能达到我上一学期花很多时间效果。\n\n大二，学院开始教后端的内容，比如Java语法基础，网络、数据库。当时Java老师上课讲教科书让我昏昏欲睡，但是我察觉这只是老师的问题，并不是后端的问题。比起前端。后端才是我想要真正学习的编程。因为我想要掌握的编程不仅是想要样式，更希望编程能够做一些更有用的事情，比如通信，对现实生活映射。于是我开始自学后端。\n\n入门后端比较印象深刻的事是：\n\n- 在图书馆借了这本书《Data Structures and Other Objects Using Java》它让我完全理解了栈和队列等数据结构以及其作用。顺便提一句，书中有一个用树实现的小程序，叫猜动物。我特别喜欢这个程序，因为这个简单程序能够“自学”。每一次玩游戏后，程序都会更聪明一点。\n- 跟着网上的资料，照猫画虎写了一个聊天室，用到了socket网络通信，https://github.com/wangxuanni/MyChat\n- 发现了这个网站，开始接触一些流行的互联网技术，比如SSM、Redis https://how2j.cn/\n- 数据库这门课我学的挺好的，期末只扣了几分。当时想着不如去考一个证，于是准备了两个月，拿下了软考中级——数据库系统工程师。\n\n大三，随着学习深入，职业专业方向变得清楚：服务端+互联网。\n\n- 写了一个HTTP服务器，参考《tomcat是怎么运行的》\n- 认真的写了一个贴吧项目，用SSM+mysql+redis，。后来这个项目作为我的毕业设计，后来还拿到了年级的优秀毕业设计。\n- 报名蓝桥杯比赛，想着以考代学，让对算法一无所知的我，有一个驱动力去啃算法。刷题了两个星期，拿了省三安慰奖。之后囫囵吞枣刷过一遍剑指offer，leetcode70题左右。\n\n大三下学期，去了广州的一家软件公司实习了2个月，发现学到的东西和工资一样少的可怜，就辞职了，准备好好参加秋招。\n当时因为很穷，租到房子通勤需要一小时。广州早上8点的5号线，人多到工作人员拉九曲围栏，让人们排队等待限流进闸门。这种通勤体验令人难受的不仅仅浪费时间和挤来挤去，还有在背着电脑的人群中排队缓缓前进的时候，会忍不住觉得自己好渺小，像自己这样的打工人有那么多个，我和别人又有什么不同呢。\n\n19年9月，参加秋招，这期间我学了这些：\n\n- java并发包的源码看了一遍，如HashMap、CurrentHashMap，syn，volatile。\n- 看了十本左右书和数不尽在闲鱼淘的视频。\n- 租了个云服务器，自己实践了一遍redis的容灾全过程，当我把master节点kill掉后，从redis的日志能看到，哨兵会进行哨兵选举，选举出来的哨兵进行主从复制。这次实践给我留下来很深刻的印象，而且这之后我完全理解了raft协议。\n- 还尝试写一个RPC框架，但后面精力放在面试了，没有写完。\n\n秋招最后收获三个Offer，蘑菇街、老虎证券、growingIO，接受了蘑菇街的。\n\n\n\n\n\n## 实习\n其实秋招offer是可以不用来实习的，但我想提前看看工作环境，没想到这一来，就呆了5个月。\n\n我所在直播的稳定性小组，简单来说就是在业务部门做中间层相关的事。在实习的前四个月我没有做过业务需求，都在跟着我学长了解稳定性的方方面面，比如用flink监控直播流、把直播界面模块抽象成插件化、直播拉流的容灾切换。\n\n工作和自己学的东西非常不一样，在来实习之前，我全凭自己的兴趣学，对分布式有兴趣就自己租服务器实践，对并发有兴趣就一边看源码一边看博客。工作后，我学到了身为工程师的基本素养。举一个方面，学生的时候我的写代码，最在乎的是能不能跑起来，谁要跟我说你这程序如果突然有大流量会不会崩溃；如果功能变了，你的改动成本是多大。我会觉得他没事找事，但是对于一个工程师，这些考虑都是最最基本的，和能不能跑起来一样基本。此外因为是在团队里，会更加注意代码规范。\n\n当时一人来到了杭州，当时在杭州谁也不认识，在租房等房东来签协议。突然觉得特别孤独。当时认真的把社交写进了待办事件，后来在杭州认识的朋友，比我大学都多。\n\n大三认识了一群五湖四海的同届朋友们，我们有一个技术小群，群里技术氛围浓厚，每周都会有技术讨论会。后来在秋招的时候，大家互相内推，每周分享技术，群里讨论问题，复盘面试。秋招大家也都去到了理想的公司，至今我们仍然每天聊天。\n\n值得一提的是，群里有个小哥哥叫糖糖，当时我两都在杭州实习，面基后还蛮聊得来的。赞同他说过一句话\"人总是会高估每天能做的事情，却一直低估一年能做的事情\"。他秋招被毁约之后（这时秋招已经结束了）虽然很气，但是甚至没有告诉我们，因为他知道我们肯定会为他打抱不平。当时他最重要的不是闹事，而是最后的补招，后来他拿到了更理想的offer。运气不好遇到这种仍然能沉得住气，知道自己想要什么，我很佩服。\n\n在我实习期间，20年3月爆发疫情，导致回家之路九九八十一难，因为疫情航班被取消了两次，要走的那天6点起来把床收了，结果一看手机航班又取消了 - -，只能放弃直达，从杭州飞广州，再从广州做汽车。接下来还遇到如下困难：迟到了改签+行李很多+汽车晚点车站人很多+下雨+新修的陌生汽车站。\n\n实习结束，是我最后也是最长的一个暑假，把朋友的ps4和碟片借来了。天昏地暗的玩游戏。刺客信条、底特律变人、美国末日、风之旅人、最后的守护者、鬼泣5。追星看小说，在我的最后一个暑假，干一些毫无意义但非常快乐的事。\n\n\n\n","slug":"我的编程之路1","published":1,"updated":"2022-08-30T09:31:31.807Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qpy0029w9rpruh7g9rc","content":"<h2 id=\"大学\"><a href=\"#大学\" class=\"headerlink\" title=\"大学\"></a>大学</h2><p>大一随着课程学习前端,第一学期的课程设计，我用纯HTML+CSS实现了一个学院网站的静态页面，这个网站我的主要精力花在设计上，每一个框框的px我一点点调，设成不同颜色，看如何能更漂亮；在第二学期，我发现了BootStrap这个前端框架，原来只需要简单引用组件，就能达到我上一学期花很多时间效果。</p>\n<p>大二，学院开始教后端的内容，比如Java语法基础，网络、数据库。当时Java老师上课讲教科书让我昏昏欲睡，但是我察觉这只是老师的问题，并不是后端的问题。比起前端。后端才是我想要真正学习的编程。因为我想要掌握的编程不仅是想要样式，更希望编程能够做一些更有用的事情，比如通信，对现实生活映射。于是我开始自学后端。</p>\n<p>入门后端比较印象深刻的事是：</p>\n<ul>\n<li>在图书馆借了这本书《Data Structures and Other Objects Using Java》它让我完全理解了栈和队列等数据结构以及其作用。顺便提一句，书中有一个用树实现的小程序，叫猜动物。我特别喜欢这个程序，因为这个简单程序能够“自学”。每一次玩游戏后，程序都会更聪明一点。</li>\n<li>跟着网上的资料，照猫画虎写了一个聊天室，用到了socket网络通信，<a href=\"https://github.com/wangxuanni/MyChat\" target=\"_blank\" rel=\"noopener\">https://github.com/wangxuanni/MyChat</a></li>\n<li>发现了这个网站，开始接触一些流行的互联网技术，比如SSM、Redis <a href=\"https://how2j.cn/\" target=\"_blank\" rel=\"noopener\">https://how2j.cn/</a></li>\n<li>数据库这门课我学的挺好的，期末只扣了几分。当时想着不如去考一个证，于是准备了两个月，拿下了软考中级——数据库系统工程师。</li>\n</ul>\n<p>大三，随着学习深入，职业专业方向变得清楚：服务端+互联网。</p>\n<ul>\n<li>写了一个HTTP服务器，参考《tomcat是怎么运行的》</li>\n<li>认真的写了一个贴吧项目，用SSM+mysql+redis，。后来这个项目作为我的毕业设计，后来还拿到了年级的优秀毕业设计。</li>\n<li>报名蓝桥杯比赛，想着以考代学，让对算法一无所知的我，有一个驱动力去啃算法。刷题了两个星期，拿了省三安慰奖。之后囫囵吞枣刷过一遍剑指offer，leetcode70题左右。</li>\n</ul>\n<p>大三下学期，去了广州的一家软件公司实习了2个月，发现学到的东西和工资一样少的可怜，就辞职了，准备好好参加秋招。<br>当时因为很穷，租到房子通勤需要一小时。广州早上8点的5号线，人多到工作人员拉九曲围栏，让人们排队等待限流进闸门。这种通勤体验令人难受的不仅仅浪费时间和挤来挤去，还有在背着电脑的人群中排队缓缓前进的时候，会忍不住觉得自己好渺小，像自己这样的打工人有那么多个，我和别人又有什么不同呢。</p>\n<p>19年9月，参加秋招，这期间我学了这些：</p>\n<ul>\n<li>java并发包的源码看了一遍，如HashMap、CurrentHashMap，syn，volatile。</li>\n<li>看了十本左右书和数不尽在闲鱼淘的视频。</li>\n<li>租了个云服务器，自己实践了一遍redis的容灾全过程，当我把master节点kill掉后，从redis的日志能看到，哨兵会进行哨兵选举，选举出来的哨兵进行主从复制。这次实践给我留下来很深刻的印象，而且这之后我完全理解了raft协议。</li>\n<li>还尝试写一个RPC框架，但后面精力放在面试了，没有写完。</li>\n</ul>\n<p>秋招最后收获三个Offer，蘑菇街、老虎证券、growingIO，接受了蘑菇街的。</p>\n<h2 id=\"实习\"><a href=\"#实习\" class=\"headerlink\" title=\"实习\"></a>实习</h2><p>其实秋招offer是可以不用来实习的，但我想提前看看工作环境，没想到这一来，就呆了5个月。</p>\n<p>我所在直播的稳定性小组，简单来说就是在业务部门做中间层相关的事。在实习的前四个月我没有做过业务需求，都在跟着我学长了解稳定性的方方面面，比如用flink监控直播流、把直播界面模块抽象成插件化、直播拉流的容灾切换。</p>\n<p>工作和自己学的东西非常不一样，在来实习之前，我全凭自己的兴趣学，对分布式有兴趣就自己租服务器实践，对并发有兴趣就一边看源码一边看博客。工作后，我学到了身为工程师的基本素养。举一个方面，学生的时候我的写代码，最在乎的是能不能跑起来，谁要跟我说你这程序如果突然有大流量会不会崩溃；如果功能变了，你的改动成本是多大。我会觉得他没事找事，但是对于一个工程师，这些考虑都是最最基本的，和能不能跑起来一样基本。此外因为是在团队里，会更加注意代码规范。</p>\n<p>当时一人来到了杭州，当时在杭州谁也不认识，在租房等房东来签协议。突然觉得特别孤独。当时认真的把社交写进了待办事件，后来在杭州认识的朋友，比我大学都多。</p>\n<p>大三认识了一群五湖四海的同届朋友们，我们有一个技术小群，群里技术氛围浓厚，每周都会有技术讨论会。后来在秋招的时候，大家互相内推，每周分享技术，群里讨论问题，复盘面试。秋招大家也都去到了理想的公司，至今我们仍然每天聊天。</p>\n<p>值得一提的是，群里有个小哥哥叫糖糖，当时我两都在杭州实习，面基后还蛮聊得来的。赞同他说过一句话”人总是会高估每天能做的事情，却一直低估一年能做的事情”。他秋招被毁约之后（这时秋招已经结束了）虽然很气，但是甚至没有告诉我们，因为他知道我们肯定会为他打抱不平。当时他最重要的不是闹事，而是最后的补招，后来他拿到了更理想的offer。运气不好遇到这种仍然能沉得住气，知道自己想要什么，我很佩服。</p>\n<p>在我实习期间，20年3月爆发疫情，导致回家之路九九八十一难，因为疫情航班被取消了两次，要走的那天6点起来把床收了，结果一看手机航班又取消了 - -，只能放弃直达，从杭州飞广州，再从广州做汽车。接下来还遇到如下困难：迟到了改签+行李很多+汽车晚点车站人很多+下雨+新修的陌生汽车站。</p>\n<p>实习结束，是我最后也是最长的一个暑假，把朋友的ps4和碟片借来了。天昏地暗的玩游戏。刺客信条、底特律变人、美国末日、风之旅人、最后的守护者、鬼泣5。追星看小说，在我的最后一个暑假，干一些毫无意义但非常快乐的事。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"大学\"><a href=\"#大学\" class=\"headerlink\" title=\"大学\"></a>大学</h2><p>大一随着课程学习前端,第一学期的课程设计，我用纯HTML+CSS实现了一个学院网站的静态页面，这个网站我的主要精力花在设计上，每一个框框的px我一点点调，设成不同颜色，看如何能更漂亮；在第二学期，我发现了BootStrap这个前端框架，原来只需要简单引用组件，就能达到我上一学期花很多时间效果。</p>\n<p>大二，学院开始教后端的内容，比如Java语法基础，网络、数据库。当时Java老师上课讲教科书让我昏昏欲睡，但是我察觉这只是老师的问题，并不是后端的问题。比起前端。后端才是我想要真正学习的编程。因为我想要掌握的编程不仅是想要样式，更希望编程能够做一些更有用的事情，比如通信，对现实生活映射。于是我开始自学后端。</p>\n<p>入门后端比较印象深刻的事是：</p>\n<ul>\n<li>在图书馆借了这本书《Data Structures and Other Objects Using Java》它让我完全理解了栈和队列等数据结构以及其作用。顺便提一句，书中有一个用树实现的小程序，叫猜动物。我特别喜欢这个程序，因为这个简单程序能够“自学”。每一次玩游戏后，程序都会更聪明一点。</li>\n<li>跟着网上的资料，照猫画虎写了一个聊天室，用到了socket网络通信，<a href=\"https://github.com/wangxuanni/MyChat\" target=\"_blank\" rel=\"noopener\">https://github.com/wangxuanni/MyChat</a></li>\n<li>发现了这个网站，开始接触一些流行的互联网技术，比如SSM、Redis <a href=\"https://how2j.cn/\" target=\"_blank\" rel=\"noopener\">https://how2j.cn/</a></li>\n<li>数据库这门课我学的挺好的，期末只扣了几分。当时想着不如去考一个证，于是准备了两个月，拿下了软考中级——数据库系统工程师。</li>\n</ul>\n<p>大三，随着学习深入，职业专业方向变得清楚：服务端+互联网。</p>\n<ul>\n<li>写了一个HTTP服务器，参考《tomcat是怎么运行的》</li>\n<li>认真的写了一个贴吧项目，用SSM+mysql+redis，。后来这个项目作为我的毕业设计，后来还拿到了年级的优秀毕业设计。</li>\n<li>报名蓝桥杯比赛，想着以考代学，让对算法一无所知的我，有一个驱动力去啃算法。刷题了两个星期，拿了省三安慰奖。之后囫囵吞枣刷过一遍剑指offer，leetcode70题左右。</li>\n</ul>\n<p>大三下学期，去了广州的一家软件公司实习了2个月，发现学到的东西和工资一样少的可怜，就辞职了，准备好好参加秋招。<br>当时因为很穷，租到房子通勤需要一小时。广州早上8点的5号线，人多到工作人员拉九曲围栏，让人们排队等待限流进闸门。这种通勤体验令人难受的不仅仅浪费时间和挤来挤去，还有在背着电脑的人群中排队缓缓前进的时候，会忍不住觉得自己好渺小，像自己这样的打工人有那么多个，我和别人又有什么不同呢。</p>\n<p>19年9月，参加秋招，这期间我学了这些：</p>\n<ul>\n<li>java并发包的源码看了一遍，如HashMap、CurrentHashMap，syn，volatile。</li>\n<li>看了十本左右书和数不尽在闲鱼淘的视频。</li>\n<li>租了个云服务器，自己实践了一遍redis的容灾全过程，当我把master节点kill掉后，从redis的日志能看到，哨兵会进行哨兵选举，选举出来的哨兵进行主从复制。这次实践给我留下来很深刻的印象，而且这之后我完全理解了raft协议。</li>\n<li>还尝试写一个RPC框架，但后面精力放在面试了，没有写完。</li>\n</ul>\n<p>秋招最后收获三个Offer，蘑菇街、老虎证券、growingIO，接受了蘑菇街的。</p>\n<h2 id=\"实习\"><a href=\"#实习\" class=\"headerlink\" title=\"实习\"></a>实习</h2><p>其实秋招offer是可以不用来实习的，但我想提前看看工作环境，没想到这一来，就呆了5个月。</p>\n<p>我所在直播的稳定性小组，简单来说就是在业务部门做中间层相关的事。在实习的前四个月我没有做过业务需求，都在跟着我学长了解稳定性的方方面面，比如用flink监控直播流、把直播界面模块抽象成插件化、直播拉流的容灾切换。</p>\n<p>工作和自己学的东西非常不一样，在来实习之前，我全凭自己的兴趣学，对分布式有兴趣就自己租服务器实践，对并发有兴趣就一边看源码一边看博客。工作后，我学到了身为工程师的基本素养。举一个方面，学生的时候我的写代码，最在乎的是能不能跑起来，谁要跟我说你这程序如果突然有大流量会不会崩溃；如果功能变了，你的改动成本是多大。我会觉得他没事找事，但是对于一个工程师，这些考虑都是最最基本的，和能不能跑起来一样基本。此外因为是在团队里，会更加注意代码规范。</p>\n<p>当时一人来到了杭州，当时在杭州谁也不认识，在租房等房东来签协议。突然觉得特别孤独。当时认真的把社交写进了待办事件，后来在杭州认识的朋友，比我大学都多。</p>\n<p>大三认识了一群五湖四海的同届朋友们，我们有一个技术小群，群里技术氛围浓厚，每周都会有技术讨论会。后来在秋招的时候，大家互相内推，每周分享技术，群里讨论问题，复盘面试。秋招大家也都去到了理想的公司，至今我们仍然每天聊天。</p>\n<p>值得一提的是，群里有个小哥哥叫糖糖，当时我两都在杭州实习，面基后还蛮聊得来的。赞同他说过一句话”人总是会高估每天能做的事情，却一直低估一年能做的事情”。他秋招被毁约之后（这时秋招已经结束了）虽然很气，但是甚至没有告诉我们，因为他知道我们肯定会为他打抱不平。当时他最重要的不是闹事，而是最后的补招，后来他拿到了更理想的offer。运气不好遇到这种仍然能沉得住气，知道自己想要什么，我很佩服。</p>\n<p>在我实习期间，20年3月爆发疫情，导致回家之路九九八十一难，因为疫情航班被取消了两次，要走的那天6点起来把床收了，结果一看手机航班又取消了 - -，只能放弃直达，从杭州飞广州，再从广州做汽车。接下来还遇到如下困难：迟到了改签+行李很多+汽车晚点车站人很多+下雨+新修的陌生汽车站。</p>\n<p>实习结束，是我最后也是最长的一个暑假，把朋友的ps4和碟片借来了。天昏地暗的玩游戏。刺客信条、底特律变人、美国末日、风之旅人、最后的守护者、鬼泣5。追星看小说，在我的最后一个暑假，干一些毫无意义但非常快乐的事。</p>\n"},{"title":"《Data Structures and Other Objects Using Java》读书笔记","date":"2018-09-08T06:00:50.000Z","_content":"书是从学校图书馆借的，豆瓣评分寥寥，但真的是一本好书。\n<!-- more -->\n\n*段落根据我认为重要程度排名。*\n\n- p84\n为什么要给自己给一个类写clone的方法？而不是直接调用父类的复制方法。\n举个栗子，把数组a拷贝到副本b。如果直接去调用父类的复制方法。它会做什么呢？它会把b的引用都指向数组a，也就是说它并没有真正意义上的复制，而是偷懒把新引用指向原本的数组。\n这样做有什么问题呢？问题在于对a数组修改都会影响到拷贝的副本b。显然这不是我们想要的。\n所以我们得自己写一个clone类，循环遍历数组，挨个复制。\n笔记：大家都知道集合有length（）方法，不需要知道怎么实现，只要能用就行了。但当我们自己去写一个集合类的时候，写这个方法就必须要考虑到方方面面了。这本书重点不在于告诉人java有多少个API，而是这些类、方法的实现原理。只有当我们去重写的时候才会深度去思考程序的设计的原理。\n比如得知数组的长度，那么写属性size就行了，因为数组是固定长度的。\n但是要得知集合的长度，需要写一个方法遍历得知，因为集合是自动增长的。\n\n- p8\nfinal变量即这个变量是最终版本，不可变更，不能被继承。另外final变量的名称全部大写 。\n比如一个常量-273。如果把它写成final变量,则是final MINMUM_CELSIUS=-273。\n什么时候用常量？如果直接写c<-273，那么阅读程序的人会在这里停住，直到想起-273是最小摄氏度为止。\n当然了，有些众所周知的公式，其原始形式更易识别。\n\n- 用static修饰的话，即使没有生成该对象的实例，也可使用该方法。毕竟如果只是想使用该方法，也没有必要生成一个实例。\n比如java自带Math类，没有生成实例也可以直接用它生成random随机数的方法 。(Math.random() * 100)。这条语句是意思是生成一个一百以内的随机数。\n如果没有用static修饰，绝对不能激活空引用的方法。绝不能访问null引用的实例变量。两种情况下都会引发nullpointerexception异常。\n\n- 变量分引用变量和普通变量。\n除了八种基本类型之一的任何变量，其余都是引向某一对象的引用变量。\n引用变量：\n有些为了省事的程序员用“油门对象t正在工作”，而不使用，“t引用的油门对象正在工作”\n笔记：t不是这个油门对象的命名而是这个油门对象的引用。\n\n- p49\n关于取名。名字最好是描述性的词\n存取方法：比如“toString”；get+，比如\"getFlow\"\n修改方法：动词\n有返回值的静态方法：名词\n\n- 如果方法需要返回多个信息，那么返回数组是一个有效的手段。\n\n- 集合类不用定义容量，每当包要满时，方法就会实现，使得容量翻倍。\nm*2+1。加1是为了使得即使容量为零，这一动作仍能起作用。\n\n- 如果没有指定修饰符，则为默认访问，也叫包访问。可以访问同一个一个包的类。\n\n- 递归不只是尾递归。\n\n- java的易移植性：程序变成字节码，这些字节码由jar运行时环境编译，jar可以免费获得，所以程序可以在不同的机器间进行移植。\n\n- 每一个方法有参数，前置条件，返回值。前置条件比如参数c>-273。\n\n- 接口代码单词一般以-able为后缀。\n\n\n\n\n\n","source":"_posts/数据结构读书笔记.md","raw":"---\ntitle: 《Data Structures and Other Objects Using Java》读书笔记\ndate: 2018-09-08 14:00:50\ncategories: 读书笔记\n---\n书是从学校图书馆借的，豆瓣评分寥寥，但真的是一本好书。\n<!-- more -->\n\n*段落根据我认为重要程度排名。*\n\n- p84\n为什么要给自己给一个类写clone的方法？而不是直接调用父类的复制方法。\n举个栗子，把数组a拷贝到副本b。如果直接去调用父类的复制方法。它会做什么呢？它会把b的引用都指向数组a，也就是说它并没有真正意义上的复制，而是偷懒把新引用指向原本的数组。\n这样做有什么问题呢？问题在于对a数组修改都会影响到拷贝的副本b。显然这不是我们想要的。\n所以我们得自己写一个clone类，循环遍历数组，挨个复制。\n笔记：大家都知道集合有length（）方法，不需要知道怎么实现，只要能用就行了。但当我们自己去写一个集合类的时候，写这个方法就必须要考虑到方方面面了。这本书重点不在于告诉人java有多少个API，而是这些类、方法的实现原理。只有当我们去重写的时候才会深度去思考程序的设计的原理。\n比如得知数组的长度，那么写属性size就行了，因为数组是固定长度的。\n但是要得知集合的长度，需要写一个方法遍历得知，因为集合是自动增长的。\n\n- p8\nfinal变量即这个变量是最终版本，不可变更，不能被继承。另外final变量的名称全部大写 。\n比如一个常量-273。如果把它写成final变量,则是final MINMUM_CELSIUS=-273。\n什么时候用常量？如果直接写c<-273，那么阅读程序的人会在这里停住，直到想起-273是最小摄氏度为止。\n当然了，有些众所周知的公式，其原始形式更易识别。\n\n- 用static修饰的话，即使没有生成该对象的实例，也可使用该方法。毕竟如果只是想使用该方法，也没有必要生成一个实例。\n比如java自带Math类，没有生成实例也可以直接用它生成random随机数的方法 。(Math.random() * 100)。这条语句是意思是生成一个一百以内的随机数。\n如果没有用static修饰，绝对不能激活空引用的方法。绝不能访问null引用的实例变量。两种情况下都会引发nullpointerexception异常。\n\n- 变量分引用变量和普通变量。\n除了八种基本类型之一的任何变量，其余都是引向某一对象的引用变量。\n引用变量：\n有些为了省事的程序员用“油门对象t正在工作”，而不使用，“t引用的油门对象正在工作”\n笔记：t不是这个油门对象的命名而是这个油门对象的引用。\n\n- p49\n关于取名。名字最好是描述性的词\n存取方法：比如“toString”；get+，比如\"getFlow\"\n修改方法：动词\n有返回值的静态方法：名词\n\n- 如果方法需要返回多个信息，那么返回数组是一个有效的手段。\n\n- 集合类不用定义容量，每当包要满时，方法就会实现，使得容量翻倍。\nm*2+1。加1是为了使得即使容量为零，这一动作仍能起作用。\n\n- 如果没有指定修饰符，则为默认访问，也叫包访问。可以访问同一个一个包的类。\n\n- 递归不只是尾递归。\n\n- java的易移植性：程序变成字节码，这些字节码由jar运行时环境编译，jar可以免费获得，所以程序可以在不同的机器间进行移植。\n\n- 每一个方法有参数，前置条件，返回值。前置条件比如参数c>-273。\n\n- 接口代码单词一般以-able为后缀。\n\n\n\n\n\n","slug":"数据结构读书笔记","published":1,"updated":"2022-04-02T07:59:53.724Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qq4002bw9rp2y7g8aa2","content":"<p>书是从学校图书馆借的，豆瓣评分寥寥，但真的是一本好书。<br><a id=\"more\"></a></p>\n<p><em>段落根据我认为重要程度排名。</em></p>\n<ul>\n<li><p>p84<br>为什么要给自己给一个类写clone的方法？而不是直接调用父类的复制方法。<br>举个栗子，把数组a拷贝到副本b。如果直接去调用父类的复制方法。它会做什么呢？它会把b的引用都指向数组a，也就是说它并没有真正意义上的复制，而是偷懒把新引用指向原本的数组。<br>这样做有什么问题呢？问题在于对a数组修改都会影响到拷贝的副本b。显然这不是我们想要的。<br>所以我们得自己写一个clone类，循环遍历数组，挨个复制。<br>笔记：大家都知道集合有length（）方法，不需要知道怎么实现，只要能用就行了。但当我们自己去写一个集合类的时候，写这个方法就必须要考虑到方方面面了。这本书重点不在于告诉人java有多少个API，而是这些类、方法的实现原理。只有当我们去重写的时候才会深度去思考程序的设计的原理。<br>比如得知数组的长度，那么写属性size就行了，因为数组是固定长度的。<br>但是要得知集合的长度，需要写一个方法遍历得知，因为集合是自动增长的。</p>\n</li>\n<li><p>p8<br>final变量即这个变量是最终版本，不可变更，不能被继承。另外final变量的名称全部大写 。<br>比如一个常量-273。如果把它写成final变量,则是final MINMUM_CELSIUS=-273。<br>什么时候用常量？如果直接写c&lt;-273，那么阅读程序的人会在这里停住，直到想起-273是最小摄氏度为止。<br>当然了，有些众所周知的公式，其原始形式更易识别。</p>\n</li>\n<li><p>用static修饰的话，即使没有生成该对象的实例，也可使用该方法。毕竟如果只是想使用该方法，也没有必要生成一个实例。<br>比如java自带Math类，没有生成实例也可以直接用它生成random随机数的方法 。(Math.random() * 100)。这条语句是意思是生成一个一百以内的随机数。<br>如果没有用static修饰，绝对不能激活空引用的方法。绝不能访问null引用的实例变量。两种情况下都会引发nullpointerexception异常。</p>\n</li>\n<li><p>变量分引用变量和普通变量。<br>除了八种基本类型之一的任何变量，其余都是引向某一对象的引用变量。<br>引用变量：<br>有些为了省事的程序员用“油门对象t正在工作”，而不使用，“t引用的油门对象正在工作”<br>笔记：t不是这个油门对象的命名而是这个油门对象的引用。</p>\n</li>\n<li><p>p49<br>关于取名。名字最好是描述性的词<br>存取方法：比如“toString”；get+，比如”getFlow”<br>修改方法：动词<br>有返回值的静态方法：名词</p>\n</li>\n<li><p>如果方法需要返回多个信息，那么返回数组是一个有效的手段。</p>\n</li>\n<li><p>集合类不用定义容量，每当包要满时，方法就会实现，使得容量翻倍。<br>m*2+1。加1是为了使得即使容量为零，这一动作仍能起作用。</p>\n</li>\n<li><p>如果没有指定修饰符，则为默认访问，也叫包访问。可以访问同一个一个包的类。</p>\n</li>\n<li><p>递归不只是尾递归。</p>\n</li>\n<li><p>java的易移植性：程序变成字节码，这些字节码由jar运行时环境编译，jar可以免费获得，所以程序可以在不同的机器间进行移植。</p>\n</li>\n<li><p>每一个方法有参数，前置条件，返回值。前置条件比如参数c&gt;-273。</p>\n</li>\n<li><p>接口代码单词一般以-able为后缀。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>书是从学校图书馆借的，豆瓣评分寥寥，但真的是一本好书。<br>","more":"</p>\n<p><em>段落根据我认为重要程度排名。</em></p>\n<ul>\n<li><p>p84<br>为什么要给自己给一个类写clone的方法？而不是直接调用父类的复制方法。<br>举个栗子，把数组a拷贝到副本b。如果直接去调用父类的复制方法。它会做什么呢？它会把b的引用都指向数组a，也就是说它并没有真正意义上的复制，而是偷懒把新引用指向原本的数组。<br>这样做有什么问题呢？问题在于对a数组修改都会影响到拷贝的副本b。显然这不是我们想要的。<br>所以我们得自己写一个clone类，循环遍历数组，挨个复制。<br>笔记：大家都知道集合有length（）方法，不需要知道怎么实现，只要能用就行了。但当我们自己去写一个集合类的时候，写这个方法就必须要考虑到方方面面了。这本书重点不在于告诉人java有多少个API，而是这些类、方法的实现原理。只有当我们去重写的时候才会深度去思考程序的设计的原理。<br>比如得知数组的长度，那么写属性size就行了，因为数组是固定长度的。<br>但是要得知集合的长度，需要写一个方法遍历得知，因为集合是自动增长的。</p>\n</li>\n<li><p>p8<br>final变量即这个变量是最终版本，不可变更，不能被继承。另外final变量的名称全部大写 。<br>比如一个常量-273。如果把它写成final变量,则是final MINMUM_CELSIUS=-273。<br>什么时候用常量？如果直接写c&lt;-273，那么阅读程序的人会在这里停住，直到想起-273是最小摄氏度为止。<br>当然了，有些众所周知的公式，其原始形式更易识别。</p>\n</li>\n<li><p>用static修饰的话，即使没有生成该对象的实例，也可使用该方法。毕竟如果只是想使用该方法，也没有必要生成一个实例。<br>比如java自带Math类，没有生成实例也可以直接用它生成random随机数的方法 。(Math.random() * 100)。这条语句是意思是生成一个一百以内的随机数。<br>如果没有用static修饰，绝对不能激活空引用的方法。绝不能访问null引用的实例变量。两种情况下都会引发nullpointerexception异常。</p>\n</li>\n<li><p>变量分引用变量和普通变量。<br>除了八种基本类型之一的任何变量，其余都是引向某一对象的引用变量。<br>引用变量：<br>有些为了省事的程序员用“油门对象t正在工作”，而不使用，“t引用的油门对象正在工作”<br>笔记：t不是这个油门对象的命名而是这个油门对象的引用。</p>\n</li>\n<li><p>p49<br>关于取名。名字最好是描述性的词<br>存取方法：比如“toString”；get+，比如”getFlow”<br>修改方法：动词<br>有返回值的静态方法：名词</p>\n</li>\n<li><p>如果方法需要返回多个信息，那么返回数组是一个有效的手段。</p>\n</li>\n<li><p>集合类不用定义容量，每当包要满时，方法就会实现，使得容量翻倍。<br>m*2+1。加1是为了使得即使容量为零，这一动作仍能起作用。</p>\n</li>\n<li><p>如果没有指定修饰符，则为默认访问，也叫包访问。可以访问同一个一个包的类。</p>\n</li>\n<li><p>递归不只是尾递归。</p>\n</li>\n<li><p>java的易移植性：程序变成字节码，这些字节码由jar运行时环境编译，jar可以免费获得，所以程序可以在不同的机器间进行移植。</p>\n</li>\n<li><p>每一个方法有参数，前置条件，返回值。前置条件比如参数c&gt;-273。</p>\n</li>\n<li><p>接口代码单词一般以-able为后缀。</p>\n</li>\n</ul>"},{"title":"What interesting things can zset for redis do?","date":"2022-07-25T16:24:50.000Z","description":"Multidimensional leaderboard and rate Limiting.","_content":"\n\n\n\n\n## Foreword\n\n\n\nI have always had the habit of doing work summaries, and I will occasionally carry out an extended study of the technologies I use in my work, but the summary notes are written for myself. some. I happened to be learning English recently, so I thought I might as well organize my notes in English. This is the first work note I have compiled in English。\n\n I recently developed a timed spike function using redis' zset. The specific implementation is to use the seckill time as the score of the zset, use the product ID as the value, the key is the name of the seckill product set, and use a timed task to scan the zset at the second level, start is a very early time, and end is the current timestamp , use the method zrangeByScore to get the commodities of this period. If the seckill time of a commodity falls within this range, it will execute the opening seconds. After this function is completed, I want to summarize zset, which can achieve many interesting functions, so I have this article. \n\n\n\n## What interesting things can zset do? \n\n\n\n### Multidimensional leaderboard \n\nThe most common usage is to implement a leaderboard, such as a list of winning countries based on the number of Olympic medals. Here I would like to introduce a more interesting implementation - multi-dimensional leaderboard. The multi-dimensional ranking means that the rankings are ranked according to multiple different dimensions. For example, for example, in the medal rankings of Olympic countries, the participants are ranked from the dimensions of gold, silver and bronze medals, and the number of gold medals is first sorted. ; If the number of gold medals is the same, then sort by the number of silver medals.\n\nIsn't it easy to think of piecing together two numbers as a fraction? But this simple way of putting together is problematic. For example, if country A has won 5 gold medals and 15 silver medals, the combination is 515; another country B has won 50 gold medals and only 1 silver medal. , which when pieced together is 501, yields a higher score for the A country, when the opposite is true. \n\nThere are two ways to implement multidimensional indexing：\n\n#### Binary segmentation\n\nThe reason for the failure of direct piecing is essentially because the low-order bits grabbed the high-order bits, so we can distinguish the low-order bits from the high-order bits, and fill in zeros in front of the high-order bits that are not filled. Fractions of different dimensions can be stored in different binary digits of a variable. This kind of binary segmented storage design idea is very common in Java source code. For example, in the design of thread state in Java's thread pool, the thread state is stored in AtomicInteger. This AtomicInteger traverses the lower 29 bits to indicate the number of threads in the thread pool. , through the upper 3 bits to indicate the running status of the thread pool. \n\n#### Split into decimals \n\nOr we can directly split into decimals in multiple dimensions. For example, the gold medal is an integer, and the silver medal is placed in a decimal place. If country A has 5 gold medals and 15 silver medals, the combination is 5.15; another country B has 50 gold medals and only 1 silver medal, and the combination is 50.1. \n\n### Rate Limiting\n\n#### counter \n\nIf you want to use redis to implement a current limit, first of all think that you can implement counter current limit based on Redis's setnx. For each request, use the unique identifier of the requested resource as the key. If the key already exists, it will be incremented by 1. If the initialization counter is not created, it will be 1. According to the size of the counter, it is judged whether the current limit threshold is exceeded, and if it exceeds, it will return to trigger the current limit. \n\nSimple counter current limiting has a fatal flaw, the criticality problem. For example, in a scenario where the total number of requests is limited to 100 in 1 minute, 100 requests came in the first minute until the end of the minute, and 100 requests came immediately at the beginning of the next minute. Because it is in two different one-minute intervals, the counter current limit will be released, but in fact, 200 requests came in less than one minute, violating the current limit rules. Therefore, the counter current limit is generally not used by anyone. \n\n#### sliding window \n\nSliding window current limiting can solve this critical problem. To implement sliding window, we have to use zset. The principle is similar to that of a timed spike. The timestamp is used as a score, and zset can be used to obtain the corresponding value according to the range of the score. The specific implementation is as follows：\n\nWhen the request comes, the unique identifier of the requested resource is used as the key. When each request comes in, the score of the zset is the current timestamp, and the value of the zset remains unique and can be generated by UUID; \n\nThe beginning of the sliding window: the current time - the time period of the current limit, the beginning of the sliding window: the current time. \n\nUse zset's zrangebyscore to get how many requests are in the sliding window. If the size of the threshold has been exceeded, the current limit is triggered. Otherwise, add a new piece of data in zset. \n\nIn order to avoid the infinite increase of zset, regularly use zremrangebyscore to delete data smaller than the end of the sliding window, because the data beyond the window does not care. \n\nNote: The difference between zrange and zrangebyscore, zrange divides the interval according to the index, and zrangebyscore is according to the score.\n\nA simple code example is as follows：\n\n```java\npublic class RedisSlidingWindowRateLimit {\n  \n    private static final int LIMIT = 100;\n  \n    private static final int PERIOD = 60;\n    @Resource\n    private RedisService redisService;\n\n    public boolean triggerLimit(String requestPath) {\n        long now = System.currentTimeMillis();\n        Set<String> range = redisService.opsForZSet().rangeByScore(requestPath, now - PERIOD * 1000, now);\n        if (range.size() > LIMIT) {\n            return true;\n        } else {\n            redisService.opsForZSet().add(requestPath, UUID.randomUUID().toString(), now);\n            return false;\n        }\n    }\n}\n```\n\n\n\n\n","source":"_posts/英文-redis的zset可以做哪些有趣的事？.md","raw":"---\ntitle: What interesting things can zset for redis do?\ndate: 2022-07-26 00:24:50\ncategories: redis\ndescription: Multidimensional leaderboard and rate Limiting.\n\n---\n\n\n\n\n\n## Foreword\n\n\n\nI have always had the habit of doing work summaries, and I will occasionally carry out an extended study of the technologies I use in my work, but the summary notes are written for myself. some. I happened to be learning English recently, so I thought I might as well organize my notes in English. This is the first work note I have compiled in English。\n\n I recently developed a timed spike function using redis' zset. The specific implementation is to use the seckill time as the score of the zset, use the product ID as the value, the key is the name of the seckill product set, and use a timed task to scan the zset at the second level, start is a very early time, and end is the current timestamp , use the method zrangeByScore to get the commodities of this period. If the seckill time of a commodity falls within this range, it will execute the opening seconds. After this function is completed, I want to summarize zset, which can achieve many interesting functions, so I have this article. \n\n\n\n## What interesting things can zset do? \n\n\n\n### Multidimensional leaderboard \n\nThe most common usage is to implement a leaderboard, such as a list of winning countries based on the number of Olympic medals. Here I would like to introduce a more interesting implementation - multi-dimensional leaderboard. The multi-dimensional ranking means that the rankings are ranked according to multiple different dimensions. For example, for example, in the medal rankings of Olympic countries, the participants are ranked from the dimensions of gold, silver and bronze medals, and the number of gold medals is first sorted. ; If the number of gold medals is the same, then sort by the number of silver medals.\n\nIsn't it easy to think of piecing together two numbers as a fraction? But this simple way of putting together is problematic. For example, if country A has won 5 gold medals and 15 silver medals, the combination is 515; another country B has won 50 gold medals and only 1 silver medal. , which when pieced together is 501, yields a higher score for the A country, when the opposite is true. \n\nThere are two ways to implement multidimensional indexing：\n\n#### Binary segmentation\n\nThe reason for the failure of direct piecing is essentially because the low-order bits grabbed the high-order bits, so we can distinguish the low-order bits from the high-order bits, and fill in zeros in front of the high-order bits that are not filled. Fractions of different dimensions can be stored in different binary digits of a variable. This kind of binary segmented storage design idea is very common in Java source code. For example, in the design of thread state in Java's thread pool, the thread state is stored in AtomicInteger. This AtomicInteger traverses the lower 29 bits to indicate the number of threads in the thread pool. , through the upper 3 bits to indicate the running status of the thread pool. \n\n#### Split into decimals \n\nOr we can directly split into decimals in multiple dimensions. For example, the gold medal is an integer, and the silver medal is placed in a decimal place. If country A has 5 gold medals and 15 silver medals, the combination is 5.15; another country B has 50 gold medals and only 1 silver medal, and the combination is 50.1. \n\n### Rate Limiting\n\n#### counter \n\nIf you want to use redis to implement a current limit, first of all think that you can implement counter current limit based on Redis's setnx. For each request, use the unique identifier of the requested resource as the key. If the key already exists, it will be incremented by 1. If the initialization counter is not created, it will be 1. According to the size of the counter, it is judged whether the current limit threshold is exceeded, and if it exceeds, it will return to trigger the current limit. \n\nSimple counter current limiting has a fatal flaw, the criticality problem. For example, in a scenario where the total number of requests is limited to 100 in 1 minute, 100 requests came in the first minute until the end of the minute, and 100 requests came immediately at the beginning of the next minute. Because it is in two different one-minute intervals, the counter current limit will be released, but in fact, 200 requests came in less than one minute, violating the current limit rules. Therefore, the counter current limit is generally not used by anyone. \n\n#### sliding window \n\nSliding window current limiting can solve this critical problem. To implement sliding window, we have to use zset. The principle is similar to that of a timed spike. The timestamp is used as a score, and zset can be used to obtain the corresponding value according to the range of the score. The specific implementation is as follows：\n\nWhen the request comes, the unique identifier of the requested resource is used as the key. When each request comes in, the score of the zset is the current timestamp, and the value of the zset remains unique and can be generated by UUID; \n\nThe beginning of the sliding window: the current time - the time period of the current limit, the beginning of the sliding window: the current time. \n\nUse zset's zrangebyscore to get how many requests are in the sliding window. If the size of the threshold has been exceeded, the current limit is triggered. Otherwise, add a new piece of data in zset. \n\nIn order to avoid the infinite increase of zset, regularly use zremrangebyscore to delete data smaller than the end of the sliding window, because the data beyond the window does not care. \n\nNote: The difference between zrange and zrangebyscore, zrange divides the interval according to the index, and zrangebyscore is according to the score.\n\nA simple code example is as follows：\n\n```java\npublic class RedisSlidingWindowRateLimit {\n  \n    private static final int LIMIT = 100;\n  \n    private static final int PERIOD = 60;\n    @Resource\n    private RedisService redisService;\n\n    public boolean triggerLimit(String requestPath) {\n        long now = System.currentTimeMillis();\n        Set<String> range = redisService.opsForZSet().rangeByScore(requestPath, now - PERIOD * 1000, now);\n        if (range.size() > LIMIT) {\n            return true;\n        } else {\n            redisService.opsForZSet().add(requestPath, UUID.randomUUID().toString(), now);\n            return false;\n        }\n    }\n}\n```\n\n\n\n\n","slug":"英文-redis的zset可以做哪些有趣的事？","published":1,"updated":"2023-08-09T11:54:47.731Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qq8002dw9rp5dgzb369","content":"<h2 id=\"Foreword\"><a href=\"#Foreword\" class=\"headerlink\" title=\"Foreword\"></a>Foreword</h2><p>I have always had the habit of doing work summaries, and I will occasionally carry out an extended study of the technologies I use in my work, but the summary notes are written for myself. some. I happened to be learning English recently, so I thought I might as well organize my notes in English. This is the first work note I have compiled in English。</p>\n<p> I recently developed a timed spike function using redis’ zset. The specific implementation is to use the seckill time as the score of the zset, use the product ID as the value, the key is the name of the seckill product set, and use a timed task to scan the zset at the second level, start is a very early time, and end is the current timestamp , use the method zrangeByScore to get the commodities of this period. If the seckill time of a commodity falls within this range, it will execute the opening seconds. After this function is completed, I want to summarize zset, which can achieve many interesting functions, so I have this article. </p>\n<h2 id=\"What-interesting-things-can-zset-do\"><a href=\"#What-interesting-things-can-zset-do\" class=\"headerlink\" title=\"What interesting things can zset do?\"></a>What interesting things can zset do?</h2><h3 id=\"Multidimensional-leaderboard\"><a href=\"#Multidimensional-leaderboard\" class=\"headerlink\" title=\"Multidimensional leaderboard\"></a>Multidimensional leaderboard</h3><p>The most common usage is to implement a leaderboard, such as a list of winning countries based on the number of Olympic medals. Here I would like to introduce a more interesting implementation - multi-dimensional leaderboard. The multi-dimensional ranking means that the rankings are ranked according to multiple different dimensions. For example, for example, in the medal rankings of Olympic countries, the participants are ranked from the dimensions of gold, silver and bronze medals, and the number of gold medals is first sorted. ; If the number of gold medals is the same, then sort by the number of silver medals.</p>\n<p>Isn’t it easy to think of piecing together two numbers as a fraction? But this simple way of putting together is problematic. For example, if country A has won 5 gold medals and 15 silver medals, the combination is 515; another country B has won 50 gold medals and only 1 silver medal. , which when pieced together is 501, yields a higher score for the A country, when the opposite is true. </p>\n<p>There are two ways to implement multidimensional indexing：</p>\n<h4 id=\"Binary-segmentation\"><a href=\"#Binary-segmentation\" class=\"headerlink\" title=\"Binary segmentation\"></a>Binary segmentation</h4><p>The reason for the failure of direct piecing is essentially because the low-order bits grabbed the high-order bits, so we can distinguish the low-order bits from the high-order bits, and fill in zeros in front of the high-order bits that are not filled. Fractions of different dimensions can be stored in different binary digits of a variable. This kind of binary segmented storage design idea is very common in Java source code. For example, in the design of thread state in Java’s thread pool, the thread state is stored in AtomicInteger. This AtomicInteger traverses the lower 29 bits to indicate the number of threads in the thread pool. , through the upper 3 bits to indicate the running status of the thread pool. </p>\n<h4 id=\"Split-into-decimals\"><a href=\"#Split-into-decimals\" class=\"headerlink\" title=\"Split into decimals\"></a>Split into decimals</h4><p>Or we can directly split into decimals in multiple dimensions. For example, the gold medal is an integer, and the silver medal is placed in a decimal place. If country A has 5 gold medals and 15 silver medals, the combination is 5.15; another country B has 50 gold medals and only 1 silver medal, and the combination is 50.1. </p>\n<h3 id=\"Rate-Limiting\"><a href=\"#Rate-Limiting\" class=\"headerlink\" title=\"Rate Limiting\"></a>Rate Limiting</h3><h4 id=\"counter\"><a href=\"#counter\" class=\"headerlink\" title=\"counter\"></a>counter</h4><p>If you want to use redis to implement a current limit, first of all think that you can implement counter current limit based on Redis’s setnx. For each request, use the unique identifier of the requested resource as the key. If the key already exists, it will be incremented by 1. If the initialization counter is not created, it will be 1. According to the size of the counter, it is judged whether the current limit threshold is exceeded, and if it exceeds, it will return to trigger the current limit. </p>\n<p>Simple counter current limiting has a fatal flaw, the criticality problem. For example, in a scenario where the total number of requests is limited to 100 in 1 minute, 100 requests came in the first minute until the end of the minute, and 100 requests came immediately at the beginning of the next minute. Because it is in two different one-minute intervals, the counter current limit will be released, but in fact, 200 requests came in less than one minute, violating the current limit rules. Therefore, the counter current limit is generally not used by anyone. </p>\n<h4 id=\"sliding-window\"><a href=\"#sliding-window\" class=\"headerlink\" title=\"sliding window\"></a>sliding window</h4><p>Sliding window current limiting can solve this critical problem. To implement sliding window, we have to use zset. The principle is similar to that of a timed spike. The timestamp is used as a score, and zset can be used to obtain the corresponding value according to the range of the score. The specific implementation is as follows：</p>\n<p>When the request comes, the unique identifier of the requested resource is used as the key. When each request comes in, the score of the zset is the current timestamp, and the value of the zset remains unique and can be generated by UUID; </p>\n<p>The beginning of the sliding window: the current time - the time period of the current limit, the beginning of the sliding window: the current time. </p>\n<p>Use zset’s zrangebyscore to get how many requests are in the sliding window. If the size of the threshold has been exceeded, the current limit is triggered. Otherwise, add a new piece of data in zset. </p>\n<p>In order to avoid the infinite increase of zset, regularly use zremrangebyscore to delete data smaller than the end of the sliding window, because the data beyond the window does not care. </p>\n<p>Note: The difference between zrange and zrangebyscore, zrange divides the interval according to the index, and zrangebyscore is according to the score.</p>\n<p>A simple code example is as follows：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisSlidingWindowRateLimit</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> LIMIT = <span class=\"number\">100</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PERIOD = <span class=\"number\">60</span>;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisService redisService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">triggerLimit</span><span class=\"params\">(String requestPath)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">        Set&lt;String&gt; range = redisService.opsForZSet().rangeByScore(requestPath, now - PERIOD * <span class=\"number\">1000</span>, now);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (range.size() &gt; LIMIT) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            redisService.opsForZSet().add(requestPath, UUID.randomUUID().toString(), now);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Foreword\"><a href=\"#Foreword\" class=\"headerlink\" title=\"Foreword\"></a>Foreword</h2><p>I have always had the habit of doing work summaries, and I will occasionally carry out an extended study of the technologies I use in my work, but the summary notes are written for myself. some. I happened to be learning English recently, so I thought I might as well organize my notes in English. This is the first work note I have compiled in English。</p>\n<p> I recently developed a timed spike function using redis’ zset. The specific implementation is to use the seckill time as the score of the zset, use the product ID as the value, the key is the name of the seckill product set, and use a timed task to scan the zset at the second level, start is a very early time, and end is the current timestamp , use the method zrangeByScore to get the commodities of this period. If the seckill time of a commodity falls within this range, it will execute the opening seconds. After this function is completed, I want to summarize zset, which can achieve many interesting functions, so I have this article. </p>\n<h2 id=\"What-interesting-things-can-zset-do\"><a href=\"#What-interesting-things-can-zset-do\" class=\"headerlink\" title=\"What interesting things can zset do?\"></a>What interesting things can zset do?</h2><h3 id=\"Multidimensional-leaderboard\"><a href=\"#Multidimensional-leaderboard\" class=\"headerlink\" title=\"Multidimensional leaderboard\"></a>Multidimensional leaderboard</h3><p>The most common usage is to implement a leaderboard, such as a list of winning countries based on the number of Olympic medals. Here I would like to introduce a more interesting implementation - multi-dimensional leaderboard. The multi-dimensional ranking means that the rankings are ranked according to multiple different dimensions. For example, for example, in the medal rankings of Olympic countries, the participants are ranked from the dimensions of gold, silver and bronze medals, and the number of gold medals is first sorted. ; If the number of gold medals is the same, then sort by the number of silver medals.</p>\n<p>Isn’t it easy to think of piecing together two numbers as a fraction? But this simple way of putting together is problematic. For example, if country A has won 5 gold medals and 15 silver medals, the combination is 515; another country B has won 50 gold medals and only 1 silver medal. , which when pieced together is 501, yields a higher score for the A country, when the opposite is true. </p>\n<p>There are two ways to implement multidimensional indexing：</p>\n<h4 id=\"Binary-segmentation\"><a href=\"#Binary-segmentation\" class=\"headerlink\" title=\"Binary segmentation\"></a>Binary segmentation</h4><p>The reason for the failure of direct piecing is essentially because the low-order bits grabbed the high-order bits, so we can distinguish the low-order bits from the high-order bits, and fill in zeros in front of the high-order bits that are not filled. Fractions of different dimensions can be stored in different binary digits of a variable. This kind of binary segmented storage design idea is very common in Java source code. For example, in the design of thread state in Java’s thread pool, the thread state is stored in AtomicInteger. This AtomicInteger traverses the lower 29 bits to indicate the number of threads in the thread pool. , through the upper 3 bits to indicate the running status of the thread pool. </p>\n<h4 id=\"Split-into-decimals\"><a href=\"#Split-into-decimals\" class=\"headerlink\" title=\"Split into decimals\"></a>Split into decimals</h4><p>Or we can directly split into decimals in multiple dimensions. For example, the gold medal is an integer, and the silver medal is placed in a decimal place. If country A has 5 gold medals and 15 silver medals, the combination is 5.15; another country B has 50 gold medals and only 1 silver medal, and the combination is 50.1. </p>\n<h3 id=\"Rate-Limiting\"><a href=\"#Rate-Limiting\" class=\"headerlink\" title=\"Rate Limiting\"></a>Rate Limiting</h3><h4 id=\"counter\"><a href=\"#counter\" class=\"headerlink\" title=\"counter\"></a>counter</h4><p>If you want to use redis to implement a current limit, first of all think that you can implement counter current limit based on Redis’s setnx. For each request, use the unique identifier of the requested resource as the key. If the key already exists, it will be incremented by 1. If the initialization counter is not created, it will be 1. According to the size of the counter, it is judged whether the current limit threshold is exceeded, and if it exceeds, it will return to trigger the current limit. </p>\n<p>Simple counter current limiting has a fatal flaw, the criticality problem. For example, in a scenario where the total number of requests is limited to 100 in 1 minute, 100 requests came in the first minute until the end of the minute, and 100 requests came immediately at the beginning of the next minute. Because it is in two different one-minute intervals, the counter current limit will be released, but in fact, 200 requests came in less than one minute, violating the current limit rules. Therefore, the counter current limit is generally not used by anyone. </p>\n<h4 id=\"sliding-window\"><a href=\"#sliding-window\" class=\"headerlink\" title=\"sliding window\"></a>sliding window</h4><p>Sliding window current limiting can solve this critical problem. To implement sliding window, we have to use zset. The principle is similar to that of a timed spike. The timestamp is used as a score, and zset can be used to obtain the corresponding value according to the range of the score. The specific implementation is as follows：</p>\n<p>When the request comes, the unique identifier of the requested resource is used as the key. When each request comes in, the score of the zset is the current timestamp, and the value of the zset remains unique and can be generated by UUID; </p>\n<p>The beginning of the sliding window: the current time - the time period of the current limit, the beginning of the sliding window: the current time. </p>\n<p>Use zset’s zrangebyscore to get how many requests are in the sliding window. If the size of the threshold has been exceeded, the current limit is triggered. Otherwise, add a new piece of data in zset. </p>\n<p>In order to avoid the infinite increase of zset, regularly use zremrangebyscore to delete data smaller than the end of the sliding window, because the data beyond the window does not care. </p>\n<p>Note: The difference between zrange and zrangebyscore, zrange divides the interval according to the index, and zrangebyscore is according to the score.</p>\n<p>A simple code example is as follows：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisSlidingWindowRateLimit</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> LIMIT = <span class=\"number\">100</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PERIOD = <span class=\"number\">60</span>;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisService redisService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">triggerLimit</span><span class=\"params\">(String requestPath)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">        Set&lt;String&gt; range = redisService.opsForZSet().rangeByScore(requestPath, now - PERIOD * <span class=\"number\">1000</span>, now);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (range.size() &gt; LIMIT) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            redisService.opsForZSet().add(requestPath, UUID.randomUUID().toString(), now);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"逃逸分析","date":"2019-08-12T12:24:50.000Z","description":"深入理解Java中的逃逸分析","_content":"\n\n\n本文转自掘金**HollisChuang**，[原地址](https://mp.weixin.qq.com/s/HWIuXNWjyfV-5UVoQG3vSQ)。\n写的非常好，忍不住转载了。在文章最后写了自己的笔记。\n\n\n[TOC]\n\n## 我的笔记\n\n###  JIT 技术（即时编译）\n\nJava需要经过两段编译，第一段是把.java文件转换成.class文件。第二段编译是把.class转换成机器指令的过程。显然，其执行速度必然会比可执行的二进制字节码程序慢很多。为了优化效率，引入了 JIT 。\n\n当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。\n\nJIT优化中最重要的一个就是逃逸分析。\n\n### 逃逸分析\n\n逃逸分析即**分析对象动态作用域**。如果一个对象只在方法内使用，我们就可以做一些**优化**。\n\n1. 栈上分配：如果对象没有发生逃逸，就可以栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。\n2. 同步消除：如果对象没有发生逃逸，那么这个对象只能够被一个线程访问（因为虚拟机栈是线程私有的），JIT会取消对这部分代码的同步。\n3. 标量替换，把对象拆分成几个被方法代替的成员变量。\n\n### JVM参数\n\n- `-XX:+DoEscapeAnalysis` ： 表示开启逃逸分析\n- `-XX:-DoEscapeAnalysis` ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis\n\n看完这篇，就可以回答，是不是所有的对象和数组都会在堆内存分配空间？\n\n不一定，如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。但是这也并不是绝对的。\n\n\n\n\n\n## 原文：深入理解Java中的逃逸分析\n\n在Java的编译体系中，一个Java的源代码文件变成计算机可执行的机器指令的过程中，需要经过两段编译，第一段是把.java文件转换成.class文件。第二段编译是把.class转换成机器指令的过程。\n\n第一段编译就是`javac`命令。\n\n在第二编译阶段，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。这就是传统的JVM的解释器（Interpreter）的功能。为了解决这种效率问题，引入了 JIT（即时编译） 技术。\n\n引入了 JIT 技术后，Java程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。\n\n由于关于JIT编译和热点检测的内容，我在[深入分析Java的编译原理](https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2322)中已经介绍过了，这里就不在赘述，本文主要来介绍下JIT中的优化。JIT优化中最重要的一个就是逃逸分析。\n\n### 逃逸分析\n\n关于逃逸分析的概念，可以参考[对象和数组并不是都在堆上分配内存的。](https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2398)一文，这里简单回顾一下：\n\n逃逸分析的基本行为就是**分析对象动态作用域**：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。\n\n例如以下代码：\n\n```\npublic static StringBuffer craeteStringBuffer(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb;\n}\n\npublic static String createStringBuffer(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb.toString();\n}\n复制代码\n```\n\n第一段代码中的`sb`就逃逸了，而第二段代码中的`sb`就没有逃逸。\n\n使用逃逸分析，编译器可以对代码做如下优化：\n\n一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。\n\n二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。\n\n三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。\n\n在Java代码运行时，通过JVM参数可指定是否开启逃逸分析，\n\n`-XX:+DoEscapeAnalysis` ： 表示开启逃逸分析\n\n`-XX:-DoEscapeAnalysis` ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis\n\n### 同步省略\n\n在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。\n\n如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这个取消同步的过程就叫同步省略，也叫[锁消除](https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2344)。\n\n如以下代码：\n\n```\npublic void f() {\n    Object hollis = new Object();\n    synchronized(hollis) {\n        System.out.println(hollis);\n    }\n}\n复制代码\n```\n\n代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。优化成：\n\n```\npublic void f() {\n    Object hollis = new Object();\n    System.out.println(hollis);\n}\n复制代码\n```\n\n所以，在使用synchronized的时候，如果JIT经过逃逸分析之后发现并无线程安全问题的话，就会做锁消除。\n\n### 标量替换\n\n标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。\n\n在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。\n\n```\npublic static void main(String[] args) {\n   alloc();\n}\n\nprivate static void alloc() {\n   Point point = new Point（1,2）;\n   System.out.println(\"point.x=\"+point.x+\"; point.y=\"+point.y);\n}\nclass Point{\n    private int x;\n    private int y;\n}\n复制代码\n```\n\n以上代码中，point对象并没有逃逸出`alloc`方法，并且point对象是可以拆解成标量的。那么，JIT就会不会直接创建Point对象，而是直接使用两个标量int x ，int y来替代Point对象。\n\n以上代码，经过标量替换后，就会变成：\n\n```\nprivate static void alloc() {\n   int x = 1;\n   int y = 2;\n   System.out.println(\"point.x=\"+x+\"; point.y=\"+y);\n}\n复制代码\n```\n\n可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。\n\n标量替换为栈上分配提供了很好的基础。\n\n### 栈上分配\n\n在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。\n\n关于栈上分配的详细介绍，可以参考[对象和数组并不是都在堆上分配内存的。](https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2398)。\n\n这里，还是要简单说一下，其实在现有的虚拟机中，并没有真正的实现栈上分配，在[对象和数组并不是都在堆上分配内存的。](https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2398)中我们的例子中，对象没有在堆上分配，其实是标量替换实现的。\n\n### 逃逸分析并不成熟\n\n关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。\n\n其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。\n\n一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。\n\n虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。\n\n","source":"_posts/逃逸分析.md","raw":"---\ntitle: 逃逸分析\ndate: 2019-08-12 20:24:50\ncategories: jvm\ndescription: 深入理解Java中的逃逸分析\n---\n\n\n\n本文转自掘金**HollisChuang**，[原地址](https://mp.weixin.qq.com/s/HWIuXNWjyfV-5UVoQG3vSQ)。\n写的非常好，忍不住转载了。在文章最后写了自己的笔记。\n\n\n[TOC]\n\n## 我的笔记\n\n###  JIT 技术（即时编译）\n\nJava需要经过两段编译，第一段是把.java文件转换成.class文件。第二段编译是把.class转换成机器指令的过程。显然，其执行速度必然会比可执行的二进制字节码程序慢很多。为了优化效率，引入了 JIT 。\n\n当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。\n\nJIT优化中最重要的一个就是逃逸分析。\n\n### 逃逸分析\n\n逃逸分析即**分析对象动态作用域**。如果一个对象只在方法内使用，我们就可以做一些**优化**。\n\n1. 栈上分配：如果对象没有发生逃逸，就可以栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。\n2. 同步消除：如果对象没有发生逃逸，那么这个对象只能够被一个线程访问（因为虚拟机栈是线程私有的），JIT会取消对这部分代码的同步。\n3. 标量替换，把对象拆分成几个被方法代替的成员变量。\n\n### JVM参数\n\n- `-XX:+DoEscapeAnalysis` ： 表示开启逃逸分析\n- `-XX:-DoEscapeAnalysis` ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis\n\n看完这篇，就可以回答，是不是所有的对象和数组都会在堆内存分配空间？\n\n不一定，如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。但是这也并不是绝对的。\n\n\n\n\n\n## 原文：深入理解Java中的逃逸分析\n\n在Java的编译体系中，一个Java的源代码文件变成计算机可执行的机器指令的过程中，需要经过两段编译，第一段是把.java文件转换成.class文件。第二段编译是把.class转换成机器指令的过程。\n\n第一段编译就是`javac`命令。\n\n在第二编译阶段，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。这就是传统的JVM的解释器（Interpreter）的功能。为了解决这种效率问题，引入了 JIT（即时编译） 技术。\n\n引入了 JIT 技术后，Java程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。\n\n由于关于JIT编译和热点检测的内容，我在[深入分析Java的编译原理](https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2322)中已经介绍过了，这里就不在赘述，本文主要来介绍下JIT中的优化。JIT优化中最重要的一个就是逃逸分析。\n\n### 逃逸分析\n\n关于逃逸分析的概念，可以参考[对象和数组并不是都在堆上分配内存的。](https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2398)一文，这里简单回顾一下：\n\n逃逸分析的基本行为就是**分析对象动态作用域**：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。\n\n例如以下代码：\n\n```\npublic static StringBuffer craeteStringBuffer(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb;\n}\n\npublic static String createStringBuffer(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb.toString();\n}\n复制代码\n```\n\n第一段代码中的`sb`就逃逸了，而第二段代码中的`sb`就没有逃逸。\n\n使用逃逸分析，编译器可以对代码做如下优化：\n\n一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。\n\n二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。\n\n三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。\n\n在Java代码运行时，通过JVM参数可指定是否开启逃逸分析，\n\n`-XX:+DoEscapeAnalysis` ： 表示开启逃逸分析\n\n`-XX:-DoEscapeAnalysis` ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis\n\n### 同步省略\n\n在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。\n\n如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这个取消同步的过程就叫同步省略，也叫[锁消除](https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2344)。\n\n如以下代码：\n\n```\npublic void f() {\n    Object hollis = new Object();\n    synchronized(hollis) {\n        System.out.println(hollis);\n    }\n}\n复制代码\n```\n\n代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。优化成：\n\n```\npublic void f() {\n    Object hollis = new Object();\n    System.out.println(hollis);\n}\n复制代码\n```\n\n所以，在使用synchronized的时候，如果JIT经过逃逸分析之后发现并无线程安全问题的话，就会做锁消除。\n\n### 标量替换\n\n标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。\n\n在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。\n\n```\npublic static void main(String[] args) {\n   alloc();\n}\n\nprivate static void alloc() {\n   Point point = new Point（1,2）;\n   System.out.println(\"point.x=\"+point.x+\"; point.y=\"+point.y);\n}\nclass Point{\n    private int x;\n    private int y;\n}\n复制代码\n```\n\n以上代码中，point对象并没有逃逸出`alloc`方法，并且point对象是可以拆解成标量的。那么，JIT就会不会直接创建Point对象，而是直接使用两个标量int x ，int y来替代Point对象。\n\n以上代码，经过标量替换后，就会变成：\n\n```\nprivate static void alloc() {\n   int x = 1;\n   int y = 2;\n   System.out.println(\"point.x=\"+x+\"; point.y=\"+y);\n}\n复制代码\n```\n\n可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。\n\n标量替换为栈上分配提供了很好的基础。\n\n### 栈上分配\n\n在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。\n\n关于栈上分配的详细介绍，可以参考[对象和数组并不是都在堆上分配内存的。](https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2398)。\n\n这里，还是要简单说一下，其实在现有的虚拟机中，并没有真正的实现栈上分配，在[对象和数组并不是都在堆上分配内存的。](https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2398)中我们的例子中，对象没有在堆上分配，其实是标量替换实现的。\n\n### 逃逸分析并不成熟\n\n关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。\n\n其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。\n\n一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。\n\n虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。\n\n","slug":"逃逸分析","published":1,"updated":"2022-02-08T07:09:41.229Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3p2qqa002ew9rpia2zkbcl","content":"<p>本文转自掘金<strong>HollisChuang</strong>，<a href=\"https://mp.weixin.qq.com/s/HWIuXNWjyfV-5UVoQG3vSQ\" target=\"_blank\" rel=\"noopener\">原地址</a>。<br>写的非常好，忍不住转载了。在文章最后写了自己的笔记。</p>\n<p>[TOC]</p>\n<h2 id=\"我的笔记\"><a href=\"#我的笔记\" class=\"headerlink\" title=\"我的笔记\"></a>我的笔记</h2><h3 id=\"JIT-技术（即时编译）\"><a href=\"#JIT-技术（即时编译）\" class=\"headerlink\" title=\"JIT 技术（即时编译）\"></a>JIT 技术（即时编译）</h3><p>Java需要经过两段编译，第一段是把.java文件转换成.class文件。第二段编译是把.class转换成机器指令的过程。显然，其执行速度必然会比可执行的二进制字节码程序慢很多。为了优化效率，引入了 JIT 。</p>\n<p>当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。</p>\n<p>JIT优化中最重要的一个就是逃逸分析。</p>\n<h3 id=\"逃逸分析\"><a href=\"#逃逸分析\" class=\"headerlink\" title=\"逃逸分析\"></a>逃逸分析</h3><p>逃逸分析即<strong>分析对象动态作用域</strong>。如果一个对象只在方法内使用，我们就可以做一些<strong>优化</strong>。</p>\n<ol>\n<li>栈上分配：如果对象没有发生逃逸，就可以栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。</li>\n<li>同步消除：如果对象没有发生逃逸，那么这个对象只能够被一个线程访问（因为虚拟机栈是线程私有的），JIT会取消对这部分代码的同步。</li>\n<li>标量替换，把对象拆分成几个被方法代替的成员变量。</li>\n</ol>\n<h3 id=\"JVM参数\"><a href=\"#JVM参数\" class=\"headerlink\" title=\"JVM参数\"></a>JVM参数</h3><ul>\n<li><code>-XX:+DoEscapeAnalysis</code> ： 表示开启逃逸分析</li>\n<li><code>-XX:-DoEscapeAnalysis</code> ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis</li>\n</ul>\n<p>看完这篇，就可以回答，是不是所有的对象和数组都会在堆内存分配空间？</p>\n<p>不一定，如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。但是这也并不是绝对的。</p>\n<h2 id=\"原文：深入理解Java中的逃逸分析\"><a href=\"#原文：深入理解Java中的逃逸分析\" class=\"headerlink\" title=\"原文：深入理解Java中的逃逸分析\"></a>原文：深入理解Java中的逃逸分析</h2><p>在Java的编译体系中，一个Java的源代码文件变成计算机可执行的机器指令的过程中，需要经过两段编译，第一段是把.java文件转换成.class文件。第二段编译是把.class转换成机器指令的过程。</p>\n<p>第一段编译就是<code>javac</code>命令。</p>\n<p>在第二编译阶段，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。这就是传统的JVM的解释器（Interpreter）的功能。为了解决这种效率问题，引入了 JIT（即时编译） 技术。</p>\n<p>引入了 JIT 技术后，Java程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。</p>\n<p>由于关于JIT编译和热点检测的内容，我在<a href=\"https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2322\" target=\"_blank\" rel=\"noopener\">深入分析Java的编译原理</a>中已经介绍过了，这里就不在赘述，本文主要来介绍下JIT中的优化。JIT优化中最重要的一个就是逃逸分析。</p>\n<h3 id=\"逃逸分析-1\"><a href=\"#逃逸分析-1\" class=\"headerlink\" title=\"逃逸分析\"></a>逃逸分析</h3><p>关于逃逸分析的概念，可以参考<a href=\"https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2398\" target=\"_blank\" rel=\"noopener\">对象和数组并不是都在堆上分配内存的。</a>一文，这里简单回顾一下：</p>\n<p>逃逸分析的基本行为就是<strong>分析对象动态作用域</strong>：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</p>\n<p>例如以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static StringBuffer craeteStringBuffer(String s1, String s2) &#123;</span><br><span class=\"line\">    StringBuffer sb = new StringBuffer();</span><br><span class=\"line\">    sb.append(s1);</span><br><span class=\"line\">    sb.append(s2);</span><br><span class=\"line\">    return sb;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static String createStringBuffer(String s1, String s2) &#123;</span><br><span class=\"line\">    StringBuffer sb = new StringBuffer();</span><br><span class=\"line\">    sb.append(s1);</span><br><span class=\"line\">    sb.append(s2);</span><br><span class=\"line\">    return sb.toString();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>第一段代码中的<code>sb</code>就逃逸了，而第二段代码中的<code>sb</code>就没有逃逸。</p>\n<p>使用逃逸分析，编译器可以对代码做如下优化：</p>\n<p>一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>\n<p>二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p>\n<p>三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p>\n<p>在Java代码运行时，通过JVM参数可指定是否开启逃逸分析，</p>\n<p><code>-XX:+DoEscapeAnalysis</code> ： 表示开启逃逸分析</p>\n<p><code>-XX:-DoEscapeAnalysis</code> ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis</p>\n<h3 id=\"同步省略\"><a href=\"#同步省略\" class=\"headerlink\" title=\"同步省略\"></a>同步省略</h3><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</p>\n<p>如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这个取消同步的过程就叫同步省略，也叫<a href=\"https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2344\" target=\"_blank\" rel=\"noopener\">锁消除</a>。</p>\n<p>如以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void f() &#123;</span><br><span class=\"line\">    Object hollis = new Object();</span><br><span class=\"line\">    synchronized(hollis) &#123;</span><br><span class=\"line\">        System.out.println(hollis);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。优化成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void f() &#123;</span><br><span class=\"line\">    Object hollis = new Object();</span><br><span class=\"line\">    System.out.println(hollis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>所以，在使用synchronized的时候，如果JIT经过逃逸分析之后发现并无线程安全问题的话，就会做锁消除。</p>\n<h3 id=\"标量替换\"><a href=\"#标量替换\" class=\"headerlink\" title=\"标量替换\"></a>标量替换</h3><p>标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>\n<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">   alloc();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static void alloc() &#123;</span><br><span class=\"line\">   Point point = new Point（1,2）;</span><br><span class=\"line\">   System.out.println(&quot;point.x=&quot;+point.x+&quot;; point.y=&quot;+point.y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Point&#123;</span><br><span class=\"line\">    private int x;</span><br><span class=\"line\">    private int y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>以上代码中，point对象并没有逃逸出<code>alloc</code>方法，并且point对象是可以拆解成标量的。那么，JIT就会不会直接创建Point对象，而是直接使用两个标量int x ，int y来替代Point对象。</p>\n<p>以上代码，经过标量替换后，就会变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static void alloc() &#123;</span><br><span class=\"line\">   int x = 1;</span><br><span class=\"line\">   int y = 2;</span><br><span class=\"line\">   System.out.println(&quot;point.x=&quot;+x+&quot;; point.y=&quot;+y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</p>\n<p>标量替换为栈上分配提供了很好的基础。</p>\n<h3 id=\"栈上分配\"><a href=\"#栈上分配\" class=\"headerlink\" title=\"栈上分配\"></a>栈上分配</h3><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。</p>\n<p>关于栈上分配的详细介绍，可以参考<a href=\"https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2398\" target=\"_blank\" rel=\"noopener\">对象和数组并不是都在堆上分配内存的。</a>。</p>\n<p>这里，还是要简单说一下，其实在现有的虚拟机中，并没有真正的实现栈上分配，在<a href=\"https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2398\" target=\"_blank\" rel=\"noopener\">对象和数组并不是都在堆上分配内存的。</a>中我们的例子中，对象没有在堆上分配，其实是标量替换实现的。</p>\n<h3 id=\"逃逸分析并不成熟\"><a href=\"#逃逸分析并不成熟\" class=\"headerlink\" title=\"逃逸分析并不成熟\"></a>逃逸分析并不成熟</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p>\n<p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</p>\n<p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>\n<p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文转自掘金<strong>HollisChuang</strong>，<a href=\"https://mp.weixin.qq.com/s/HWIuXNWjyfV-5UVoQG3vSQ\" target=\"_blank\" rel=\"noopener\">原地址</a>。<br>写的非常好，忍不住转载了。在文章最后写了自己的笔记。</p>\n<p>[TOC]</p>\n<h2 id=\"我的笔记\"><a href=\"#我的笔记\" class=\"headerlink\" title=\"我的笔记\"></a>我的笔记</h2><h3 id=\"JIT-技术（即时编译）\"><a href=\"#JIT-技术（即时编译）\" class=\"headerlink\" title=\"JIT 技术（即时编译）\"></a>JIT 技术（即时编译）</h3><p>Java需要经过两段编译，第一段是把.java文件转换成.class文件。第二段编译是把.class转换成机器指令的过程。显然，其执行速度必然会比可执行的二进制字节码程序慢很多。为了优化效率，引入了 JIT 。</p>\n<p>当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。</p>\n<p>JIT优化中最重要的一个就是逃逸分析。</p>\n<h3 id=\"逃逸分析\"><a href=\"#逃逸分析\" class=\"headerlink\" title=\"逃逸分析\"></a>逃逸分析</h3><p>逃逸分析即<strong>分析对象动态作用域</strong>。如果一个对象只在方法内使用，我们就可以做一些<strong>优化</strong>。</p>\n<ol>\n<li>栈上分配：如果对象没有发生逃逸，就可以栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。</li>\n<li>同步消除：如果对象没有发生逃逸，那么这个对象只能够被一个线程访问（因为虚拟机栈是线程私有的），JIT会取消对这部分代码的同步。</li>\n<li>标量替换，把对象拆分成几个被方法代替的成员变量。</li>\n</ol>\n<h3 id=\"JVM参数\"><a href=\"#JVM参数\" class=\"headerlink\" title=\"JVM参数\"></a>JVM参数</h3><ul>\n<li><code>-XX:+DoEscapeAnalysis</code> ： 表示开启逃逸分析</li>\n<li><code>-XX:-DoEscapeAnalysis</code> ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis</li>\n</ul>\n<p>看完这篇，就可以回答，是不是所有的对象和数组都会在堆内存分配空间？</p>\n<p>不一定，如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。但是这也并不是绝对的。</p>\n<h2 id=\"原文：深入理解Java中的逃逸分析\"><a href=\"#原文：深入理解Java中的逃逸分析\" class=\"headerlink\" title=\"原文：深入理解Java中的逃逸分析\"></a>原文：深入理解Java中的逃逸分析</h2><p>在Java的编译体系中，一个Java的源代码文件变成计算机可执行的机器指令的过程中，需要经过两段编译，第一段是把.java文件转换成.class文件。第二段编译是把.class转换成机器指令的过程。</p>\n<p>第一段编译就是<code>javac</code>命令。</p>\n<p>在第二编译阶段，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。这就是传统的JVM的解释器（Interpreter）的功能。为了解决这种效率问题，引入了 JIT（即时编译） 技术。</p>\n<p>引入了 JIT 技术后，Java程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。</p>\n<p>由于关于JIT编译和热点检测的内容，我在<a href=\"https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2322\" target=\"_blank\" rel=\"noopener\">深入分析Java的编译原理</a>中已经介绍过了，这里就不在赘述，本文主要来介绍下JIT中的优化。JIT优化中最重要的一个就是逃逸分析。</p>\n<h3 id=\"逃逸分析-1\"><a href=\"#逃逸分析-1\" class=\"headerlink\" title=\"逃逸分析\"></a>逃逸分析</h3><p>关于逃逸分析的概念，可以参考<a href=\"https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2398\" target=\"_blank\" rel=\"noopener\">对象和数组并不是都在堆上分配内存的。</a>一文，这里简单回顾一下：</p>\n<p>逃逸分析的基本行为就是<strong>分析对象动态作用域</strong>：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</p>\n<p>例如以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static StringBuffer craeteStringBuffer(String s1, String s2) &#123;</span><br><span class=\"line\">    StringBuffer sb = new StringBuffer();</span><br><span class=\"line\">    sb.append(s1);</span><br><span class=\"line\">    sb.append(s2);</span><br><span class=\"line\">    return sb;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static String createStringBuffer(String s1, String s2) &#123;</span><br><span class=\"line\">    StringBuffer sb = new StringBuffer();</span><br><span class=\"line\">    sb.append(s1);</span><br><span class=\"line\">    sb.append(s2);</span><br><span class=\"line\">    return sb.toString();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>第一段代码中的<code>sb</code>就逃逸了，而第二段代码中的<code>sb</code>就没有逃逸。</p>\n<p>使用逃逸分析，编译器可以对代码做如下优化：</p>\n<p>一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>\n<p>二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p>\n<p>三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p>\n<p>在Java代码运行时，通过JVM参数可指定是否开启逃逸分析，</p>\n<p><code>-XX:+DoEscapeAnalysis</code> ： 表示开启逃逸分析</p>\n<p><code>-XX:-DoEscapeAnalysis</code> ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis</p>\n<h3 id=\"同步省略\"><a href=\"#同步省略\" class=\"headerlink\" title=\"同步省略\"></a>同步省略</h3><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</p>\n<p>如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这个取消同步的过程就叫同步省略，也叫<a href=\"https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2344\" target=\"_blank\" rel=\"noopener\">锁消除</a>。</p>\n<p>如以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void f() &#123;</span><br><span class=\"line\">    Object hollis = new Object();</span><br><span class=\"line\">    synchronized(hollis) &#123;</span><br><span class=\"line\">        System.out.println(hollis);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。优化成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void f() &#123;</span><br><span class=\"line\">    Object hollis = new Object();</span><br><span class=\"line\">    System.out.println(hollis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>所以，在使用synchronized的时候，如果JIT经过逃逸分析之后发现并无线程安全问题的话，就会做锁消除。</p>\n<h3 id=\"标量替换\"><a href=\"#标量替换\" class=\"headerlink\" title=\"标量替换\"></a>标量替换</h3><p>标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>\n<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">   alloc();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static void alloc() &#123;</span><br><span class=\"line\">   Point point = new Point（1,2）;</span><br><span class=\"line\">   System.out.println(&quot;point.x=&quot;+point.x+&quot;; point.y=&quot;+point.y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Point&#123;</span><br><span class=\"line\">    private int x;</span><br><span class=\"line\">    private int y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>以上代码中，point对象并没有逃逸出<code>alloc</code>方法，并且point对象是可以拆解成标量的。那么，JIT就会不会直接创建Point对象，而是直接使用两个标量int x ，int y来替代Point对象。</p>\n<p>以上代码，经过标量替换后，就会变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static void alloc() &#123;</span><br><span class=\"line\">   int x = 1;</span><br><span class=\"line\">   int y = 2;</span><br><span class=\"line\">   System.out.println(&quot;point.x=&quot;+x+&quot;; point.y=&quot;+y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</p>\n<p>标量替换为栈上分配提供了很好的基础。</p>\n<h3 id=\"栈上分配\"><a href=\"#栈上分配\" class=\"headerlink\" title=\"栈上分配\"></a>栈上分配</h3><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。</p>\n<p>关于栈上分配的详细介绍，可以参考<a href=\"https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2398\" target=\"_blank\" rel=\"noopener\">对象和数组并不是都在堆上分配内存的。</a>。</p>\n<p>这里，还是要简单说一下，其实在现有的虚拟机中，并没有真正的实现栈上分配，在<a href=\"https://link.juejin.im/?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2398\" target=\"_blank\" rel=\"noopener\">对象和数组并不是都在堆上分配内存的。</a>中我们的例子中，对象没有在堆上分配，其实是标量替换实现的。</p>\n<h3 id=\"逃逸分析并不成熟\"><a href=\"#逃逸分析并不成熟\" class=\"headerlink\" title=\"逃逸分析并不成熟\"></a>逃逸分析并不成熟</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p>\n<p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</p>\n<p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>\n<p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cll3p2qjj0000w9rpzl518f67","category_id":"cll3p2qjr0002w9rpr0fhp1j3","_id":"cll3p2qjz000aw9rps1dvhtqa"},{"post_id":"cll3p2qjp0001w9rpuwhq8iaf","category_id":"cll3p2qjr0002w9rpr0fhp1j3","_id":"cll3p2qk2000dw9rppw0rwrxa"},{"post_id":"cll3p2qjy0008w9rp04b8a9l1","category_id":"cll3p2qjr0002w9rpr0fhp1j3","_id":"cll3p2qk4000gw9rpa1nxh35s"},{"post_id":"cll3p2qk0000bw9rptkz2xomj","category_id":"cll3p2qjr0002w9rpr0fhp1j3","_id":"cll3p2qk6000iw9rp0zhmmbt9"},{"post_id":"cll3p2qjs0003w9rpt5kzsujp","category_id":"cll3p2qjz0009w9rpy6th2hqf","_id":"cll3p2qk7000lw9rpsf6kwt9g"},{"post_id":"cll3p2qk3000fw9rp7tqrnly8","category_id":"cll3p2qjz0009w9rpy6th2hqf","_id":"cll3p2qk8000nw9rpbkdlf89u"},{"post_id":"cll3p2qjt0004w9rp2dmg6d2x","category_id":"cll3p2qjz0009w9rpy6th2hqf","_id":"cll3p2qka000qw9rpim4atezp"},{"post_id":"cll3p2qju0005w9rprwnfxb8t","category_id":"cll3p2qjz0009w9rpy6th2hqf","_id":"cll3p2qkc000sw9rp6ajgrl72"},{"post_id":"cll3p2qk8000mw9rp3v0vnd49","category_id":"cll3p2qjz0009w9rpy6th2hqf","_id":"cll3p2qke000vw9rpnvjpc89i"},{"post_id":"cll3p2qk9000pw9rp3rzfs10w","category_id":"cll3p2qjz0009w9rpy6th2hqf","_id":"cll3p2qkh000xw9rpop7z0649"},{"post_id":"cll3p2qjx0007w9rp2u9nw9ia","category_id":"cll3p2qk8000ow9rpfmxl4xt4","_id":"cll3p2qki0010w9rp0b0c437p"},{"post_id":"cll3p2qkd000uw9rpyzys1laa","category_id":"cll3p2qjr0002w9rpr0fhp1j3","_id":"cll3p2qki0012w9rps3ggftae"},{"post_id":"cll3p2qk1000cw9rpsbu5ep9a","category_id":"cll3p2qkd000tw9rpol9uuqtn","_id":"cll3p2qkj0015w9rpcht3xx2w"},{"post_id":"cll3p2qki0011w9rp5p1omh9g","category_id":"cll3p2qkh000yw9rp2t27v8fn","_id":"cll3p2qkk0018w9rpldr8vj38"},{"post_id":"cll3p2qk5000hw9rp4ppa1jdu","category_id":"cll3p2qkh000yw9rp2t27v8fn","_id":"cll3p2qkl001bw9rpkgmlfvke"},{"post_id":"cll3p2qki0013w9rpvbbj0o9z","category_id":"cll3p2qkh000yw9rp2t27v8fn","_id":"cll3p2qkl001dw9rpb89gcwrv"},{"post_id":"cll3p2qkj0016w9rpberid1tg","category_id":"cll3p2qkj0014w9rp8pjkqjty","_id":"cll3p2qkm001gw9rp07l4u7v5"},{"post_id":"cll3p2qk7000kw9rpa0m0l2bi","category_id":"cll3p2qkj0014w9rp8pjkqjty","_id":"cll3p2qkm001iw9rpvath51fq"},{"post_id":"cll3p2qkk0017w9rpwhdwxa0k","category_id":"cll3p2qkj0014w9rp8pjkqjty","_id":"cll3p2qkn001lw9rpmnwg2kbw"},{"post_id":"cll3p2qkc000rw9rps9wgvbs7","category_id":"cll3p2qkk0019w9rp8pfmd1dr","_id":"cll3p2qkq001nw9rpkxpsif62"},{"post_id":"cll3p2qkl001cw9rpec87kaq1","category_id":"cll3p2qk8000ow9rpfmxl4xt4","_id":"cll3p2qkq001pw9rp6oxf6noh"},{"post_id":"cll3p2qkf000ww9rpz8bkpm6f","category_id":"cll3p2qkl001ew9rpgjrzq8nv","_id":"cll3p2qkr001sw9rpitb2cvfb"},{"post_id":"cll3p2qkh000zw9rps1o3mcvt","category_id":"cll3p2qkm001jw9rpyfe5pd9g","_id":"cll3p2qkr001uw9rpgrwg4kne"},{"post_id":"cll3p2qkq001rw9rpkl6hrj4w","category_id":"cll3p2qjr0002w9rpr0fhp1j3","_id":"cll3p2qks001xw9rposky5dxw"},{"post_id":"cll3p2qkk001aw9rpos5j07h3","category_id":"cll3p2qkq001qw9rpl348pyss","_id":"cll3p2qks001zw9rpzs5efyjc"},{"post_id":"cll3p2qkr001tw9rpwnoo8eiw","category_id":"cll3p2qjr0002w9rpr0fhp1j3","_id":"cll3p2qks0020w9rpnr1hw7ju"},{"post_id":"cll3p2qkl001fw9rpt44lzmh2","category_id":"cll3p2qkr001vw9rpv10tbnbg","_id":"cll3p2qks0022w9rpqg6t753i"},{"post_id":"cll3p2qkn001kw9rppmxdfoxp","category_id":"cll3p2qks001yw9rphhz79am3","_id":"cll3p2qkt0023w9rpxegx1w5n"},{"post_id":"cll3p2qkp001mw9rpmn46o4w7","category_id":"cll3p2qks0021w9rphckzsyj8","_id":"cll3p2qkt0025w9rpkfbtetj4"},{"post_id":"cll3p2qkq001ow9rp02ogomb5","category_id":"cll3p2qkt0024w9rp1k516199","_id":"cll3p2qkt0027w9rp4ebrwo4x"},{"post_id":"cll3p2qks001ww9rpn3txfler","category_id":"cll3p2qkt0026w9rpc9iuxhe3","_id":"cll3p2qkt0028w9rpbsadkbg9"},{"post_id":"cll3p2qpy0029w9rpruh7g9rc","category_id":"cll3p2qkm001jw9rpyfe5pd9g","_id":"cll3p2qqb002fw9rppveacj9t"},{"post_id":"cll3p2qq4002bw9rp2y7g8aa2","category_id":"cll3p2qkl001ew9rpgjrzq8nv","_id":"cll3p2qqc002gw9rp45rnraog"},{"post_id":"cll3p2qq8002dw9rp5dgzb369","category_id":"cll3p2qkt0026w9rpc9iuxhe3","_id":"cll3p2qqc002iw9rpikgjm0ww"},{"post_id":"cll3p2qqa002ew9rpia2zkbcl","category_id":"cll3p2qqc002hw9rpao3ca1lq","_id":"cll3p2qqc002jw9rpgppwsz05"}],"PostTag":[],"Tag":[]}}